import {
  __async,
  __spreadValues
} from "./chunk-XWLXMCJQ.js";

// node_modules/gojs/release/go-debug.mjs
(function() {
  const root = typeof globalThis == "object" && globalThis || typeof global == "object" && global.global === global && global || typeof self == "object" && self.self === self && self || {};
  root.requestAnimationFrame === void 0 && (root.setImmediate === void 0 ? root.requestAnimationFrame = (w) => root.setTimeout(w, 0) : root.requestAnimationFrame = root.setImmediate);
  const Debug = { boundsInfoEnabled: false, drawLocationsEnabled: false, drawClipEnabled: false, drawLinkpointsEnabled: false, nodeInspector: false, handleMessages: false, drawFrames: false, defaultDiagram: null, trace: function(w) {
    root.console && root.console.log(w);
  }, drawDiagramBounds(w, t, i, e) {
    w.strokeStyle = "red", w.fillStyle = "red", w.font = "8px sans-serif", w.beginPath(), w.moveTo(-10, 0), w.lineTo(10, 0), w.moveTo(0, -10), w.lineTo(0, 10), w.stroke(), w.setTransform(1, 0, 0, 1, 0, 0), w.scale(i, i), w.transform(t.m11, t.m12, t.m21, t.m22, t.dx, t.dy), w.lineWidth = 2, w.beginPath(), w.moveTo(e.left, e.top + 20), w.lineTo(e.left, e.top), w.lineTo(e.left + 20, e.top), w.moveTo(e.right, e.bottom - 20), w.lineTo(e.right, e.bottom), w.lineTo(e.right - 20, e.bottom), w.stroke(), w.fillText("DB: " + Math.round(e.x) + ", " + Math.round(e.y) + ", " + Math.round(e.width) + ", " + Math.round(e.height), e.left, e.top - 5);
  }, attachReadonlyWarnings: function(w) {
    for (const t in w) {
      if (t === "licenseKey") continue;
      const i = w[t];
      if (i.prototype === void 0) continue;
      const e = Object.getOwnPropertyNames(i.prototype);
      for (let s = 0; s < e.length; s++) {
        const n = Object.getOwnPropertyDescriptor(i.prototype, e[s]);
        n && n.get !== void 0 && n.set === void 0 && Object.defineProperty(i.prototype, e[s], { set: function(o) {
          U.n("Property " + e[s] + " of " + t + " is read-only.");
        } });
      }
    }
  } };
  class U {
    static wr = root.navigator !== void 0 && root.navigator.platform !== void 0 && root.navigator.platform.match(/(iPhone|iPod|iPad|Mac)/i) !== null;
    static Rk(t, i, e) {
      let s = -1;
      return function() {
        const n = this, o = arguments;
        s !== -1 && U.Nf(s), s = U.yn(() => {
          s = -1, e || t.apply(n, o);
        }, i), e && !s && t.apply(n, o);
      };
    }
    static yn(t, i) {
      return root.setTimeout(t, i);
    }
    static Nf(t) {
      root.clearTimeout(t);
    }
    static Le(t) {
      return root.document.createElement(t);
    }
    static n(t) {
      throw new Error(t);
    }
    static D(t, i) {
      let e = "The object is frozen, so its properties cannot be set: " + t.toString();
      i !== void 0 && (e += "  to value: " + i), U.n(e);
    }
    static s(t, i, e, s) {
      if (!(t instanceof i)) {
        let n = U.Cf(e);
        s !== void 0 && (n += "." + s), U.Ti(t, i, n);
      }
    }
    static i(t, i, e, s) {
      if (typeof t !== i) {
        let n = U.Cf(e);
        s !== void 0 && (n += "." + s), U.Ti(t, i, n);
      }
    }
    static r(t, i, e) {
      if (typeof t != "number" || !isFinite(t)) {
        let s = U.Cf(i);
        e !== void 0 && (s += "." + e), U.n(s + " must be a real number type, and not NaN or Infinity: " + t);
      }
    }
    static Oo(t, i, e) {
      if (t === null || typeof t != "object") {
        let s = U.Cf(i);
        e !== void 0 && (s += "." + e), U.Ti(t, "object", s);
      }
    }
    static C(t, i, e) {
      U.i(t, "function", i, e);
    }
    static W(t, i, e) {
      t in i || U.n(`${t} is not a valid value in enumeration: ${e}`);
    }
    static Ti(t, i, e, s) {
      const n = " value is not an instance of " + U.Cf(i) + ": ";
      let o = U.Cf(e);
      s !== void 0 && (o += "." + s), typeof t == "string" && (t = '"' + t + '"'), U.n(o + n + t);
    }
    static G(t, i, e, s) {
      let n = U.Cf(e);
      s !== void 0 && (n += "." + s), U.n(n + " is not in the range " + i + ": " + t);
    }
    static ve(t) {
      U.n("Collection was modified during iteration: " + t.toString() + `
  Perhaps you should iterate over a copy of the collection,
  or you could collect items to be removed from the collection after the iteration.`);
    }
    static xr(t, i) {
      U.n("No property to set for this enum value: " + i + " on " + t.toString());
    }
    static ot(t) {
      root.console && root.console.log(t);
    }
    static it(t) {
      return t !== null && typeof t == "object";
    }
    static at(t) {
      return typeof t == "function";
    }
    static Ok = [];
    static ft() {
      const t = U.Ok.pop();
      return t === void 0 ? [] : t;
    }
    static et(t) {
      t.length = 0, U.Ok.push(t);
    }
    static FB = Object.freeze([]);
    static Cf(t) {
      return t === null ? "*" : typeof t == "string" ? t : U.at(t) ? t.name : "";
    }
    static $n(t) {
      return U.at(t) ? t.className ? t.className : t.name : U.it(t) && t.constructor ? U.$n(t.constructor) : typeof t;
    }
    static ta(t, i) {
      return i == null || i === "" ? null : U.it(t) && i in t || t[i] ? t[i] : null;
    }
    static toString(t) {
      let i = t;
      return U.it(t) && (t.text ? i = t.text : t.name ? i = t.name : t.key !== void 0 ? i = t.key : t.id !== void 0 ? i = t.id : t.constructor === Object && (t.Text ? i = t.Text : t.Name ? i = t.Name : t.Key !== void 0 ? i = t.Key : t.Id !== void 0 ? i = t.Id : t.ID !== void 0 && (i = t.ID))), i === void 0 ? "undefined" : i === null ? "null" : i.toString();
    }
    static $w(t, i) {
      if (t.hasOwnProperty(i)) return true;
      let e = Object.getPrototypeOf(t);
      for (; e && e !== Function; ) {
        if (e.hasOwnProperty(i)) return true;
        const s = e.IB;
        if (s && s[i]) return true;
        e = Object.getPrototypeOf(e);
      }
      return false;
    }
    static WI(t) {
      const i = [];
      let e = 0;
      for (e = 0; e < 256; e++) i[e] = e;
      let s = 0, n = 0;
      for (e = 0; e < 256; e++) s = (s + i[e] + 119) % 256, n = i[e], i[e] = i[s], i[s] = n;
      e = 0, s = 0;
      let o = "";
      for (let r = 0; r < t.length; r++) e = (e + 1) % 256, s = (s + i[e]) % 256, n = i[e], i[e] = i[s], i[s] = n, o += String.fromCharCode(t.charCodeAt(r) ^ i[(i[e] + i[s]) % 256]);
      return o;
    }
    static jI(t) {
      const i = "0123456789abcdef", e = [];
      for (let r = 0; r < 256; r++) e[i.charAt(r >> 4) + i.charAt(r & 15)] = String.fromCharCode(r);
      t.length % 2 && (t = "0" + t);
      const s = [];
      let n = 0;
      for (let r = 0; r < t.length; r += 2) s[n++] = e[t.substring(r, r + 2)];
      const o = s.join("");
      return o === "" ? "0" : o;
    }
    static Qi(t) {
      return U.WI(U.jI(t));
    }
    static color1 = "@COLOR1";
    static color2 = "@COLOR2";
    static Zw = "32ab5ff3b26f42dc0ed90f21412913b5";
  }
  U.vfo = "29e647fdb3";
  class StringBuilder {
    Ek;
    constructor() {
      this.Ek = [];
    }
    toString() {
      return this.Ek.join("");
    }
    add(t) {
      t !== "" && this.Ek.push(t);
    }
  }
  class PropertyCollection {
  }
  class EmptyIterator {
    w;
    constructor() {
      this.w = [];
    }
    [Symbol.iterator]() {
      return this.w.values();
    }
    key;
    value;
    get iterator() {
      return this;
    }
    reset() {
    }
    next() {
      return false;
    }
    hasNext() {
      return false;
    }
    first() {
      return null;
    }
    any() {
      return false;
    }
    all() {
      return true;
    }
    each() {
      return this;
    }
    map(t) {
      return this;
    }
    filter() {
      return this;
    }
    get count() {
      return 0;
    }
    Tl() {
    }
    toString() {
      return "EmptyIterator";
    }
    static instance = new EmptyIterator();
  }
  class SingletonIterator {
    constructor(t) {
      this.key = -1, this.value = t;
    }
    [Symbol.iterator]() {
      return [this.value].values();
    }
    key;
    value;
    get iterator() {
      return this;
    }
    reset() {
      this.key = -1;
    }
    next() {
      return this.key === -1 ? (this.key = 0, true) : false;
    }
    hasNext() {
      return this.next();
    }
    first() {
      return this.key = 0, this.value;
    }
    any(t) {
      return this.key = -1, t(this.value);
    }
    all(t) {
      return this.key = -1, t(this.value);
    }
    each(t) {
      return this.key = -1, t(this.value), this;
    }
    map(t) {
      return new SingletonIterator(t(this.value));
    }
    filter(t) {
      return t(this.value) ? new SingletonIterator(this.value) : EmptyIterator.instance;
    }
    get count() {
      return 1;
    }
    Tl() {
      this.value = null;
    }
    toString() {
      return "SingletonIterator(" + this.value + ")";
    }
  }
  class ListIterator {
    Zt;
    Hs;
    Wt;
    Et;
    constructor(t) {
      this.Zt = t, this.Hs = null, t.br = null, this.Wt = t.ut, this.Et = -1;
    }
    [Symbol.iterator]() {
      return this.Hs === null ? this.Zt.h.values() : this.Zt.h.filter(this.Hs).values();
    }
    key;
    value;
    get iterator() {
      return this;
    }
    get predicate() {
      return this.Hs;
    }
    set predicate(t) {
      this.Hs = t;
    }
    reset() {
      const t = this.Zt;
      t.br = null, this.Wt = t.ut, this.Et = -1;
    }
    next() {
      const t = this.Zt;
      if (t.ut !== this.Wt) {
        if (this.key < 0) return false;
        U.ve(t);
      }
      const i = t.h, e = i.length;
      let s = ++this.Et;
      const n = this.Hs;
      if (n !== null) for (; s < e; ) {
        const o = i[s];
        if (n(o)) return this.Et = s, this.key = s, this.value = o, true;
        s++;
      }
      else {
        if (s < e) return this.key = s, this.value = i[s], true;
        this.Tl();
      }
      return false;
    }
    hasNext() {
      return this.next();
    }
    first() {
      const t = this.Zt;
      this.Wt = t.ut, this.Et = 0;
      const i = t.h, e = i.length, s = this.Hs;
      if (s !== null) {
        let n = 0;
        for (; n < e; ) {
          const o = i[n];
          if (s(o)) return this.Et = n, this.key = n, this.value = o, o;
          n++;
        }
        return null;
      } else if (e > 0) {
        const n = i[0];
        return this.key = 0, this.value = n, n;
      } else return null;
    }
    any(t) {
      const i = this.Zt;
      i.br = null;
      const e = i.ut;
      this.Et = -1;
      const s = i.h, n = s.length, o = this.Hs;
      for (let r = 0; r < n; r++) {
        const l = s[r];
        if (!(o !== null && !o(l))) {
          if (t(l)) return true;
          i.ut !== e && U.ve(i);
        }
      }
      return false;
    }
    all(t) {
      const i = this.Zt;
      i.br = null;
      const e = i.ut;
      this.Et = -1;
      const s = i.h, n = s.length, o = this.Hs;
      for (let r = 0; r < n; r++) {
        const l = s[r];
        if (!(o !== null && !o(l))) {
          if (!t(l)) return false;
          i.ut !== e && U.ve(i);
        }
      }
      return true;
    }
    each(t) {
      const i = this.Zt;
      i.br = null;
      const e = i.ut;
      this.Et = -1;
      const s = i.h, n = s.length, o = this.Hs;
      for (let r = 0; r < n; r++) {
        const l = s[r];
        o !== null && !o(l) || (t(l), i.ut !== e && U.ve(i));
      }
      return this;
    }
    map(t) {
      const i = this.Zt;
      i.br = null;
      const e = i.ut;
      this.Et = -1;
      const s = [], n = i.h, o = n.length, r = this.Hs;
      for (let h = 0; h < o; h++) {
        const f = n[h];
        r !== null && !r(f) || (s.push(t(f)), i.ut !== e && U.ve(i));
      }
      const l = new List2();
      return l.h = s, l.We(), l.iterator;
    }
    filter(t) {
      const i = this.Zt;
      i.br = null;
      const e = i.ut;
      this.Et = -1;
      const s = [], n = i.h, o = n.length, r = this.Hs;
      for (let h = 0; h < o; h++) {
        const f = n[h];
        r !== null && !r(f) || (t(f) && s.push(f), i.ut !== e && U.ve(i));
      }
      const l = new List2();
      return l.h = s, l.We(), l.iterator;
    }
    get count() {
      const t = this.Hs;
      if (t !== null) {
        let i = 0;
        const e = this.Zt.h, s = e.length;
        for (let n = 0; n < s; n++) t(e[n]) && i++;
        return i;
      } else return this.Zt.h.length;
    }
    Tl() {
      this.key = -1, this.value = null, this.Wt = -1, this.Hs = null, this.Zt.br = this;
    }
    toString() {
      return "ListIterator@" + this.Et + "/" + this.Zt.count;
    }
  }
  class ListIteratorBackwards {
    Zt;
    Wt;
    Et;
    constructor(t) {
      this.Zt = t, t.Sr = null, this.Wt = t.ut, this.Et = t.h.length;
    }
    [Symbol.iterator]() {
      return this.Zt.h.reverse().values();
    }
    key;
    value;
    get iterator() {
      return this;
    }
    reset() {
      const t = this.Zt;
      t.Sr = null, this.Wt = t.ut, this.Et = t.h.length;
    }
    next() {
      const t = this.Zt;
      if (t.ut !== this.Wt) {
        if (this.key < 0) return false;
        U.ve(t);
      }
      const i = --this.Et;
      return i >= 0 ? (this.key = i, this.value = t.h[i], true) : (this.Tl(), false);
    }
    hasNext() {
      return this.next();
    }
    first() {
      const t = this.Zt;
      this.Wt = t.ut;
      const i = t.h, e = i.length - 1;
      if (this.Et = e, e >= 0) {
        const s = i[e];
        return this.key = e, this.value = s, s;
      } else return null;
    }
    any(t) {
      const i = this.Zt;
      i.Sr = null;
      const e = i.ut, s = i.h, n = s.length;
      this.Et = n;
      for (let o = n - 1; o >= 0; o--) {
        const r = s[o];
        if (t(r)) return true;
        i.ut !== e && U.ve(i);
      }
      return false;
    }
    all(t) {
      const i = this.Zt;
      i.Sr = null;
      const e = i.ut, s = i.h, n = s.length;
      this.Et = n;
      for (let o = n - 1; o >= 0; o--) {
        const r = s[o];
        if (!t(r)) return false;
        i.ut !== e && U.ve(i);
      }
      return true;
    }
    each(t) {
      const i = this.Zt;
      i.Sr = null;
      const e = i.ut, s = i.h, n = s.length;
      this.Et = n;
      for (let o = n - 1; o >= 0; o--) {
        const r = s[o];
        t(r), i.ut !== e && U.ve(i);
      }
      return this;
    }
    map(t) {
      const i = this.Zt;
      i.Sr = null;
      const e = i.ut, s = [], n = i.h, o = n.length;
      this.Et = o;
      for (let l = o - 1; l >= 0; l--) {
        const h = n[l];
        s.push(t(h)), i.ut !== e && U.ve(i);
      }
      const r = new List2();
      return r.h = s, r.We(), r.iterator;
    }
    filter(t) {
      const i = this.Zt;
      i.Sr = null;
      const e = i.ut, s = [], n = i.h, o = n.length;
      this.Et = o;
      for (let l = o - 1; l >= 0; l--) {
        const h = n[l];
        t(h) && s.push(h), i.ut !== e && U.ve(i);
      }
      const r = new List2();
      return r.h = s, r.We(), r.iterator;
    }
    get count() {
      return this.Zt.h.length;
    }
    Tl() {
      this.key = -1, this.value = null, this.Wt = -1, this.Zt.Sr = this;
    }
    toString() {
      return "ListIteratorBackwards(" + this.Et + "/" + this.Zt.count + ")";
    }
  }
  class List2 {
    u;
    h;
    ut;
    br;
    Sr;
    constructor(t) {
      GSet2._i(this), this.u = false, this.h = [], this.ut = 0, this.br = null, this.Sr = null, t !== void 0 && this.addAll(t);
    }
    [Symbol.iterator]() {
      return this.h.values();
    }
    We() {
      let t = this.ut;
      t++, t > 999999999 && (t = 0), this.ut = t;
    }
    S() {
      return this.u = true, this;
    }
    di() {
      return this.u = false, this;
    }
    toString() {
      return "List()#" + GSet2.Ps(this);
    }
    add(t) {
      return this.u && U.D(this, t), this.h.push(t), this.We(), this;
    }
    push(t) {
      this.add(t);
    }
    addAll(t) {
      if (t === null) return this;
      this.u && U.D(this);
      const i = this.h;
      if (t.first) {
        const e = t.iterator;
        for (; e.next(); ) i.push(e.value);
      } else for (const e of t) i.push(e);
      return this.We(), this;
    }
    clear() {
      this.u && U.D(this), this.h.length = 0, this.We();
    }
    contains(t) {
      return this.has(t);
    }
    has(t) {
      return t === null ? false : this.h.indexOf(t) !== -1;
    }
    indexOf(t) {
      return t === null ? -1 : this.h.indexOf(t);
    }
    elt(t) {
      Debug && U.r(t, List2, "elt:i");
      const i = this.h;
      return (t < 0 || t >= i.length) && U.G(t, "0 <= i < length", List2, "elt:i"), i[t];
    }
    get(t) {
      return this.elt(t);
    }
    setElt(t, i) {
      Debug && U.r(t, List2, "setElt:i");
      const e = this.h;
      (t < 0 || t >= e.length) && U.G(t, "0 <= i < length", List2, "setElt:i"), this.u && U.D(this, t), e[t] = i;
    }
    set(t, i) {
      this.setElt(t, i);
    }
    first() {
      const t = this.h;
      return t.length === 0 ? null : t[0];
    }
    last() {
      const t = this.h, i = t.length;
      return i > 0 ? t[i - 1] : null;
    }
    pop() {
      this.u && U.D(this);
      const t = this.h;
      if (t.length > 0) {
        const i = t.pop();
        return i === void 0 ? null : i;
      }
      return null;
    }
    any(t) {
      const i = this.h, e = this.ut, s = i.length;
      for (let n = 0; n < s; n++) {
        if (t(i[n])) return true;
        this.ut !== e && U.ve(this);
      }
      return false;
    }
    all(t) {
      const i = this.h, e = this.ut, s = i.length;
      for (let n = 0; n < s; n++) {
        if (!t(i[n])) return false;
        this.ut !== e && U.ve(this);
      }
      return true;
    }
    each(t) {
      const i = this.h, e = this.ut, s = i.length;
      for (let n = 0; n < s; n++) t(i[n]), this.ut !== e && U.ve(this);
      return this;
    }
    map(t) {
      const i = new List2(), e = [], s = this.h, n = this.ut, o = s.length;
      for (let r = 0; r < o; r++) e.push(t(s[r])), this.ut !== n && U.ve(this);
      return i.h = e, i.We(), i;
    }
    filter(t) {
      const i = new List2(), e = [], s = this.h, n = this.ut, o = s.length;
      for (let r = 0; r < o; r++) {
        const l = s[r];
        t(l) && e.push(l), this.ut !== n && U.ve(this);
      }
      return i.h = e, i.We(), i;
    }
    insertAt(t, i) {
      Debug && U.r(t, List2, "insertAt:i"), t < 0 && U.G(t, ">= 0", List2, "insertAt:i"), this.u && U.D(this, t);
      const e = this.h;
      t >= e.length ? e.push(i) : e.splice(t, 0, i), this.We();
    }
    remove(t) {
      return this.delete(t);
    }
    delete(t) {
      if (t === null) return false;
      this.u && U.D(this, t);
      const i = this.h, e = i.indexOf(t);
      return e === -1 ? false : (e === i.length - 1 ? i.pop() : i.splice(e, 1), this.We(), true);
    }
    removeAt(t) {
      Debug && U.r(t, List2, "removeAt:i");
      const i = this.h;
      (t < 0 || t >= i.length) && U.G(t, "0 <= i < length", List2, "removeAt:i"), this.u && U.D(this, t), t === i.length - 1 ? i.pop() : i.splice(t, 1), this.We();
    }
    removeRange(t, i) {
      Debug && (U.r(t, List2, "removeRange:from"), U.r(i, List2, "removeRange:to"));
      const e = this.h, s = e.length;
      if (t < 0) t = 0;
      else if (t >= s) return this;
      if (i < 0) return this;
      if (i >= s && (i = s - 1), t > i) return this;
      this.u && U.D(this);
      let n = t, o = i + 1;
      for (; o < s; ) e[n++] = e[o++];
      return e.length = s - (i - t + 1), this.We(), this;
    }
    copy() {
      const t = new List2(), i = this.h;
      return i.length > 0 && (t.h = Array.prototype.slice.call(i)), t;
    }
    toArray() {
      const t = this.h, i = this.count, e = new Array(i);
      for (let s = 0; s < i; s++) e[s] = t[s];
      return e;
    }
    get IA() {
      return this.h;
    }
    toSet() {
      const t = new GSet2(), i = this.h, e = this.count;
      for (let s = 0; s < e; s++) t.add(i[s]);
      return t;
    }
    sort(t) {
      return Debug && U.C(t, List2, "sort:sortfunc"), this.u && U.D(this), this.h.sort(t), this.We(), this;
    }
    sortRange(t, i, e) {
      const s = this.h, n = s.length;
      i === void 0 && (i = 0), e === void 0 && (e = n), Debug && (U.C(t, List2, "sortRange:sortfunc"), U.r(i, List2, "sortRange:from"), U.r(e, List2, "sortRange:to")), this.u && U.D(this);
      const o = e - i;
      if (o <= 1) return this;
      if ((i < 0 || i >= n - 1) && U.G(i, "0 <= from < length", List2, "sortRange:from"), o === 2) {
        const r = s[i], l = s[i + 1];
        return t(r, l) > 0 && (s[i] = l, s[i + 1] = r, this.We()), this;
      }
      if (i === 0) if (e >= n) s.sort(t);
      else {
        const r = s.slice(0, e);
        r.sort(t);
        for (let l = 0; l < e; l++) s[l] = r[l];
      }
      else if (e >= n) {
        const r = s.slice(i);
        r.sort(t);
        for (let l = i; l < n; l++) s[l] = r[l - i];
      } else {
        const r = s.slice(i, e);
        r.sort(t);
        for (let l = i; l < e; l++) s[l] = r[l - i];
      }
      return this.We(), this;
    }
    reverse() {
      return this.u && U.D(this), this.h.reverse(), this.We(), this;
    }
    get count() {
      return this.h.length;
    }
    get size() {
      return this.h.length;
    }
    get length() {
      return this.h.length;
    }
    get iterator() {
      if (this.h.length <= 0) return EmptyIterator.instance;
      const t = this.br;
      return t !== null ? (t.reset(), t) : new ListIterator(this);
    }
    get iteratorBackwards() {
      if (this.h.length <= 0) return EmptyIterator.instance;
      const t = this.Sr;
      return t !== null ? (t.reset(), t) : new ListIteratorBackwards(this);
    }
  }
  class SetIterator {
    Eo;
    hi;
    constructor(t) {
      this.Eo = t, this.hi = t.w.values();
    }
    [Symbol.iterator]() {
      return this.Eo.w.values();
    }
    key;
    value;
    get iterator() {
      return this;
    }
    reset() {
      const t = this.Eo;
      this.hi = t.w.values();
    }
    next() {
      const t = this.hi.next();
      return this.value = t.value, this.key = t.value, !t.done;
    }
    hasNext() {
      return this.next();
    }
    first() {
      return this.Eo.w.size === 0 ? null : (this.hi = this.Eo.w.values(), this.hi.next().value);
    }
    any(t) {
      return this.Eo.any(t);
    }
    all(t) {
      return this.Eo.all(t);
    }
    each(t) {
      return this.Eo.each(t), this;
    }
    map(t) {
      const i = new List2();
      return this.Eo.w.forEach((e) => i.add(t(e))), i.iterator;
    }
    filter(t) {
      const i = new List2();
      return this.Eo.w.forEach((e) => {
        t(e) && i.add(e);
      }), i.iterator;
    }
    get count() {
      return this.Eo.count;
    }
    Tl() {
      this.key = null, this.value = null, this.hi = null;
    }
    toString() {
      return "SetIterator";
    }
  }
  class GSet2 {
    u;
    w;
    constructor(t) {
      this.u = false, this.w = /* @__PURE__ */ new Set(), t !== void 0 && this.addAll(t);
    }
    [Symbol.iterator]() {
      return this.w.values();
    }
    values() {
      return this.w.values();
    }
    S() {
      return this.u = true, this;
    }
    di() {
      return this.u = false, this;
    }
    toString() {
      return "Set()#" + GSet2.Ps(this);
    }
    add(t) {
      return t === null ? this : (this.w.add(t), this);
    }
    addAll(t) {
      if (t === null) return this;
      if (this.u && U.D(this), t.first) {
        const i = t.iterator;
        for (; i.next(); ) this.w.add(i.value);
      } else for (const i of t) this.w.add(i);
      return this;
    }
    has(t) {
      return this.w.has(t);
    }
    contains(t) {
      return this.has(t);
    }
    containsAll(t) {
      if (t === null) return true;
      if (t.first) {
        const i = t.iterator;
        for (; i.next(); ) if (!this.has(i.value)) return false;
      } else for (const i of t) if (!this.has(i)) return false;
      return true;
    }
    containsAny(t) {
      if (t === null) return true;
      if (t.first) {
        const i = t.iterator;
        for (; i.next(); ) if (this.has(i.value)) return true;
      } else for (const i of t) if (this.has(i)) return true;
      return false;
    }
    first() {
      return this.w.size === 0 ? null : this.w.values().next().value;
    }
    any(t) {
      for (const i of this.w) if (t(i)) return true;
      return false;
    }
    all(t) {
      for (const i of this.w) if (!t(i)) return false;
      return true;
    }
    each(t) {
      for (const i of this.w) t(i);
      return this;
    }
    map(t) {
      const i = new GSet2();
      for (const e of this.w) i.add(t(e));
      return i;
    }
    filter(t) {
      const i = new GSet2();
      for (const e of this.w) t(e) && i.add(e);
      return i;
    }
    delete(t) {
      return this.u && U.D(this), this.w.delete(t);
    }
    remove(t) {
      return this.delete(t);
    }
    removeAll(t) {
      if (t === null) return this;
      if (this.u && U.D(this), t.first) {
        const i = t.iterator;
        for (; i.next(); ) this.delete(i.value);
      } else for (const i of t) this.delete(i);
      return this;
    }
    retainAll(t) {
      if (t === null) return this;
      if (this.count === 0) return this;
      this.u && U.D(this);
      const i = new GSet2();
      i.addAll(t);
      const e = [];
      if (t.first) {
        const s = t.iterator;
        for (; s.next(); ) {
          const n = s.value;
          i.has(n) || e.push(n);
        }
      } else for (const s of t) i.has(s) || e.push(s);
      return this.removeAll(e), this;
    }
    clear() {
      this.u && U.D(this), this.w.clear();
    }
    copy() {
      const t = new GSet2();
      return this.w.forEach((i) => t.add(i)), t;
    }
    toArray() {
      return Array.from(this.w);
    }
    toList() {
      const t = new List2();
      return this.w.forEach((i) => t.add(i)), t;
    }
    get count() {
      return this.w.size;
    }
    get size() {
      return this.w.size;
    }
    get iterator() {
      return this.w.size <= 0 ? EmptyIterator.instance : new SetIterator(this);
    }
    entries() {
      return this.w.entries();
    }
    keys() {
      return this.w.keys();
    }
    forEach(t, i) {
      return this.w.forEach(t, i);
    }
    static Qw = 1;
    static _i(t) {
      t.__gohashid = GSet2.Qw++;
    }
    static Ps(t) {
      return t.__gohashid;
    }
  }
  class MapKeySetIterator {
    Z;
    hi;
    constructor(t) {
      this.Z = t, this.hi = t.w.keys();
    }
    [Symbol.iterator]() {
      return this.Z.w.keys();
    }
    key;
    value;
    get iterator() {
      return this;
    }
    reset() {
      const t = this.Z;
      this.hi = t.w.keys();
    }
    next() {
      const t = this.hi.next();
      return this.value = t.value, this.key = t.value, !t.done;
    }
    hasNext() {
      return this.next();
    }
    first() {
      return this.Z.w.size === 0 ? null : (this.hi = this.Z.w.keys(), this.hi.next().value);
    }
    any(t) {
      for (const i of this.Z.w) if (t(i[0])) return true;
      return false;
    }
    all(t) {
      for (const i of this.Z.w) if (!t(i[0])) return false;
      return true;
    }
    each(t) {
      for (const i of this.Z.w) t(i[0]);
      return this;
    }
    map(t) {
      const i = this.Z, e = new List2();
      for (const s of i.w) e.add(t(s[0]));
      return e.iterator;
    }
    filter(t) {
      const i = this.Z, e = new List2();
      for (const s of i.w) {
        const n = s[0];
        t(n) && e.add(n);
      }
      return e.iterator;
    }
    get count() {
      return this.Z.size;
    }
    Tl() {
      this.key = null, this.value = null, this.hi = null;
    }
    toString() {
      return "MapKeySetIterator";
    }
  }
  class MapKeySet extends GSet2 {
    Z;
    constructor(t) {
      super(), GSet2._i(this), this.u = true, this.Z = t;
    }
    [Symbol.iterator]() {
      return this.w.keys();
    }
    values() {
      return this.w.keys();
    }
    S() {
      return this;
    }
    di() {
      return this;
    }
    toString() {
      return "MapKeySet(" + this.Z.toString() + ")";
    }
    add(t) {
      U.n("This Set is read-only: " + this.toString());
    }
    has(t) {
      return this.Z.has(t);
    }
    contains(t) {
      return this.has(t);
    }
    delete(t) {
      U.n("This Set is read-only: " + this.toString());
    }
    remove(t) {
      return this.delete(t);
    }
    clear() {
      U.n("This Set is read-only: " + this.toString());
    }
    first() {
      return this.Z.w.size === 0 ? null : this.Z.w.keys().next().value;
    }
    any(t) {
      for (const i of this.Z.w) if (t(i[0])) return true;
      return false;
    }
    all(t) {
      for (const i of this.Z.w) if (!t(i[0])) return false;
      return true;
    }
    each(t) {
      for (const i of this.Z.w) t(i[0]);
      return this;
    }
    map(t) {
      const i = new GSet2();
      for (const e of this.Z.w) i.add(t(e[0]));
      return i;
    }
    filter(t) {
      const i = new GSet2();
      for (const e of this.Z.w) {
        const s = e[0];
        t(s) && i.add(s);
      }
      return i;
    }
    copy() {
      return new MapKeySet(this.Z);
    }
    toSet() {
      const t = new GSet2(), i = this.Z.w;
      for (const e of i) t.add(e[0]);
      return t;
    }
    toArray() {
      const t = this.Z.w, i = new Array(t.size);
      let e = 0;
      for (const s of t) i[e] = s[0], e++;
      return i;
    }
    toList() {
      const t = new List2(), i = this.Z.w;
      for (const e of i) t.add(e[0]);
      return t;
    }
    get count() {
      return this.Z.size;
    }
    get size() {
      return this.Z.size;
    }
    get iterator() {
      return this.Z.size <= 0 ? EmptyIterator.instance : new MapKeySetIterator(this.Z);
    }
  }
  class MapValueSetIterator {
    Z;
    hi;
    constructor(t) {
      this.Z = t, this.hi = t.w.values();
    }
    [Symbol.iterator]() {
      return this.Z.w.values();
    }
    key;
    value;
    get iterator() {
      return this;
    }
    reset() {
      const t = this.Z;
      this.hi = t.w.values();
    }
    next() {
      const t = this.hi.next();
      return this.value = t.value, this.key = t.value, !t.done;
    }
    hasNext() {
      return this.next();
    }
    first() {
      return this.Z.w.size === 0 ? null : (this.hi = this.Z.w.values(), this.hi.next().value);
    }
    any(t) {
      for (const i of this.Z.w) if (t(i[1])) return true;
      return false;
    }
    all(t) {
      for (const i of this.Z.w) if (!t(i[1])) return false;
      return true;
    }
    each(t) {
      for (const i of this.Z.w) t(i[1]);
      return this;
    }
    map(t) {
      const i = this.Z, e = new List2();
      for (const s of i.w) e.add(t(s[1]));
      return e.iterator;
    }
    filter(t) {
      const i = this.Z, e = new List2();
      for (const s of i.w) {
        const n = s[1];
        t(n) && e.add(n);
      }
      return e.iterator;
    }
    get count() {
      return this.Z.size;
    }
    Tl() {
      this.key = null, this.value = null, this.hi = null;
    }
    toString() {
      return "MapValueSetIterator";
    }
  }
  class KeyValuePair {
    constructor(t, i) {
      this.key = t, this.value = i;
    }
    toString() {
      return "{" + this.key + ":" + this.value + "}";
    }
    key;
    value;
  }
  class MapIterator {
    Z;
    hi;
    constructor(t) {
      this.Z = t, this.hi = t.w.entries();
    }
    [Symbol.iterator]() {
      return this.Z.w.entries();
    }
    key;
    value;
    get iterator() {
      return this;
    }
    reset() {
      const t = this.Z;
      this.hi = t.w.entries();
    }
    next() {
      const t = this.hi.next();
      return t.done ? (this.key = null, this.value = null, false) : (this.key = t.value[0], this.value = t.value[1], true);
    }
    hasNext() {
      return this.next();
    }
    first() {
      if (this.Z.w.size === 0) return null;
      this.hi = this.Z.w.entries();
      const t = this.hi.next().value;
      return this.key = t[0], this.value = t[1], new KeyValuePair(t[0], t[1]);
    }
    any(t) {
      return this.Z.any(t);
    }
    all(t) {
      return this.Z.all(t);
    }
    each(t) {
      return this.Z.each(t), this;
    }
    map(t) {
      const i = new List2();
      let e = null;
      return this.Z.w.forEach((s, n) => {
        e === null ? e = new KeyValuePair(n, s) : (e.key = n, e.value = s), i.add(t(e));
      }), i.iterator;
    }
    filter(t) {
      const i = new List2();
      let e = null;
      return this.Z.w.forEach((s, n) => {
        e === null ? e = new KeyValuePair(n, s) : (e.key = n, e.value = s), t(e) && (i.add(e), e = null);
      }), i.iterator;
    }
    get count() {
      return this.Z.size;
    }
    Tl() {
      this.key = null, this.value = null, this.hi = null;
    }
    toString() {
      return "MapIterator";
    }
  }
  class GMap2 {
    u;
    w;
    constructor(t) {
      GSet2._i(this), this.u = false, this.w = /* @__PURE__ */ new Map(), t !== void 0 && this.addAll(t);
    }
    [Symbol.iterator]() {
      return this.w.entries();
    }
    entries() {
      return this.w.entries();
    }
    S() {
      return this.u = true, this;
    }
    di() {
      return this.u = false, this;
    }
    toString() {
      return "Map()#" + GSet2.Ps(this);
    }
    set(t, i) {
      return this.u && U.D(this, t), this.w.set(t, i), this;
    }
    add(t, i) {
      return this.set(t, i);
    }
    addAll(t) {
      if (t === null) return this;
      if (this.u && U.D(this), t instanceof GMap2) {
        const i = t.iterator;
        for (; i.next(); ) this.w.set(i.key, i.value);
      } else if (t.first) {
        const i = t.iterator;
        for (; i.next(); ) {
          const e = i.value;
          this.w.set(e.key, e.value);
        }
      } else for (const i of t) {
        const e = i;
        Array.isArray(e) ? this.w.set(e[0], e[1]) : this.w.set(e.key, e.value);
      }
      return this;
    }
    first() {
      if (this.w.size === 0) return null;
      const t = this.w.entries().next().value;
      return t ? new KeyValuePair(t[0], t[1]) : null;
    }
    any(t) {
      let i = null;
      for (const [e, s] of this.w) if (i === null ? i = new KeyValuePair(e, s) : (i.key = e, i.value = s), t(i)) return true;
      return false;
    }
    all(t) {
      let i = null;
      for (const [e, s] of this.w) if (i === null ? i = new KeyValuePair(e, s) : (i.key = e, i.value = s), !t(i)) return false;
      return true;
    }
    each(t) {
      let i = null;
      for (const [e, s] of this.w) i === null ? i = new KeyValuePair(e, s) : (i.key = e, i.value = s), t(i);
      return this;
    }
    map(t) {
      const i = new GMap2();
      let e = null;
      for (const [s, n] of this.w) e === null ? e = new KeyValuePair(s, n) : (e.key = s, e.value = n), i.set(s, t(e));
      return i;
    }
    filter(t) {
      const i = new GMap2();
      let e = null;
      for (const [s, n] of this.w) e === null ? e = new KeyValuePair(s, n) : (e.key = s, e.value = n), t(e) && i.set(s, n);
      return i;
    }
    has(t) {
      return this.w.has(t);
    }
    contains(t) {
      return this.has(t);
    }
    get(t) {
      const i = this.w.get(t);
      return i === void 0 ? null : i;
    }
    getValue(t) {
      return this.get(t);
    }
    delete(t) {
      return t === null ? false : (this.u && U.D(this, t), this.w.delete(t));
    }
    remove(t) {
      return this.delete(t);
    }
    clear() {
      this.u && U.D(this), this.w.clear();
    }
    copy() {
      const t = new GMap2();
      return t.w = new Map(this.w), t;
    }
    toArray() {
      const t = this.w, i = new Array(t.size);
      let e = 0;
      for (const s of t) i[e] = new KeyValuePair(s[0], s[1]), e++;
      return i;
    }
    toKeySet() {
      return new MapKeySet(this);
    }
    get count() {
      return this.w.size;
    }
    get size() {
      return this.w.size;
    }
    get iterator() {
      return this.w.size <= 0 ? EmptyIterator.instance : new MapIterator(this);
    }
    get iteratorKeys() {
      return this.count <= 0 ? EmptyIterator.instance : new MapKeySetIterator(this);
    }
    keys() {
      return this.w.keys();
    }
    get iteratorValues() {
      return this.count <= 0 ? EmptyIterator.instance : new MapValueSetIterator(this);
    }
    values() {
      return this.w.values();
    }
    forEach(t, i) {
      return this.w.forEach(t, i);
    }
  }
  class Point2 {
    px;
    py;
    u;
    constructor(t, i) {
      t === void 0 ? (this.px = 0, this.py = 0) : typeof t == "number" && typeof i == "number" ? (this.px = t, this.py = i) : U.n("Invalid arguments to Point constructor: " + t + ", " + i), this.u = false;
    }
    c(t) {
      return this.px = t.px, this.py = t.py, this;
    }
    e(t, i) {
      return this.px = t, this.py = i, this;
    }
    setTo(t, i) {
      return Debug && (U.i(t, "number", Point2, "setTo:x"), U.i(i, "number", Point2, "setTo:y"), this._()), this.px = t, this.py = i, this;
    }
    set(t) {
      return Debug && (U.s(t, Point2, Point2, "set:p"), this._()), this.px = t.px, this.py = t.py, this;
    }
    copy() {
      const t = new Point2();
      return t.px = this.px, t.py = this.py, t;
    }
    Ct() {
      return this.u = true, Object.freeze(this), this;
    }
    T() {
      return this.u || Object.isFrozen(this) ? this : this.copy().S();
    }
    S() {
      return this.u || (this.u = true), this;
    }
    _(t) {
      if (Debug && this.u) {
        let i = "The Point is frozen, so its properties cannot be set: " + this.toString();
        t !== void 0 && (i += "  to value: " + t), U.n(i);
      }
    }
    static parse(t) {
      if (typeof t == "string") {
        const i = t.split(" ");
        let e = 0, s = 0;
        for (; i[e] === ""; ) e++;
        let n = i[e++];
        n && (s = parseFloat(n));
        let o = 0;
        for (; i[e] === ""; ) e++;
        return n = i[e++], n && (o = parseFloat(n)), new Point2(s, o);
      } else return new Point2();
    }
    static stringify(t) {
      return Debug && U.s(t, Point2), t.x.toString() + " " + t.y.toString();
    }
    static stringifyFixed(t) {
      return U.i(t, "number", Point2, "stringifyFixed:digits"), (i) => i.x.toFixed(t) + " " + i.y.toFixed(t);
    }
    toString() {
      return "Point(" + this.x + "," + this.y + ")";
    }
    equals(t) {
      return t instanceof Point2 ? this.px === t.x && this.py === t.y : false;
    }
    equalTo(t, i) {
      return this.px === t && this.py === i;
    }
    equalsApprox(t) {
      return G.p(this.px, t.x) && G.p(this.py, t.y);
    }
    add(t) {
      return Debug && (U.s(t, Point2, Point2, "add:p"), this._()), this.px += t.x, this.py += t.y, this;
    }
    subtract(t) {
      return Debug && (U.s(t, Point2, Point2, "subtract:p"), this._()), this.px -= t.x, this.py -= t.y, this;
    }
    offset(t, i) {
      return Debug && (U.r(t, Point2, "offset:dx"), U.r(i, Point2, "offset:dy"), this._()), this.px += t, this.py += i, this;
    }
    rotate(t) {
      if (Debug && (U.r(t, Point2, "rotate:angle"), this._()), t === 0) return this;
      const i = this.px, e = this.py;
      if (i === 0 && e === 0) return this;
      let s = 0, n = 0;
      if (t = G.Yi(t), t === 90) s = 0, n = 1;
      else if (t === 180) s = -1, n = 0;
      else if (t === 270) s = 0, n = -1;
      else {
        const o = t * Math.PI / 180;
        s = Math.cos(o), n = Math.sin(o);
      }
      return this.px = s * i - n * e, this.py = n * i + s * e, this;
    }
    scale(t, i) {
      return Debug && (U.r(t, Point2, "scale:sx"), U.r(i, Point2, "scale:sy"), this._()), this.px *= t, this.py *= i, this;
    }
    distanceSquaredPoint(t) {
      Debug && U.s(t, Point2, Point2, "distanceSquaredPoint:p");
      const i = t.x - this.px, e = t.y - this.py;
      return i * i + e * e;
    }
    distanceSquared(t, i) {
      Debug && (U.r(t, Point2, "distanceSquared:px"), U.r(i, Point2, "distanceSquared:py"));
      const e = t - this.px, s = i - this.py;
      return e * e + s * s;
    }
    normalize() {
      Debug && this._();
      const t = this.px, i = this.py, e = Math.sqrt(t * t + i * i);
      return e > 0 && (this.px = t / e, this.py = i / e), this;
    }
    directionPoint(t) {
      return Debug && U.s(t, Point2, Point2, "directionPoint:p"), this.RA(t.x - this.px, t.y - this.py);
    }
    direction(t, i) {
      return Debug && (U.r(t, Point2, "direction:px"), U.r(i, Point2, "direction:py")), this.RA(t - this.px, i - this.py);
    }
    RA(t, i) {
      if (t === 0) return i > 0 ? 90 : i < 0 ? 270 : 0;
      if (i === 0) return t > 0 ? 0 : 180;
      {
        if (isNaN(t) || isNaN(i)) return 0;
        let e = Math.atan(Math.abs(i / t)) * 180 / Math.PI;
        return t < 0 ? i < 0 ? e += 180 : e = 180 - e : i < 0 && (e = 360 - e), e;
      }
    }
    static compareWithLineSegment(t, i, e, s, n, o) {
      return Debug && (U.r(t, Point2, "compareWithLineSegment:a1x"), U.r(i, Point2, "compareWithLineSegment:a1y"), U.r(e, Point2, "compareWithLineSegment:a2x"), U.r(s, Point2, "compareWithLineSegment:a2y"), U.r(n, Point2, "compareWithLineSegment:b1x"), U.r(o, Point2, "compareWithLineSegment:b1y")), G.Cu(t, i, e, s, n, o);
    }
    compareWithLineSegmentPoint(t, i) {
      return Debug && (U.s(t, Point2, Point2, "compareWithLineSegmentPoint:p"), U.s(i, Point2, Point2, "compareWithLineSegmentPoint:q")), G.Cu(t.x, t.y, i.x, i.y, this.x, this.y);
    }
    static intersectingLineSegments(t, i, e, s, n, o, r, l) {
      return Debug && (U.r(t, Point2, "intersectingLineSegments:a1x"), U.r(i, Point2, "intersectingLineSegments:a1y"), U.r(e, Point2, "intersectingLineSegments:a2x"), U.r(s, Point2, "intersectingLineSegments:a2y"), U.r(n, Point2, "intersectingLineSegments:b1x"), U.r(o, Point2, "intersectingLineSegments:b1y"), U.r(r, Point2, "intersectingLineSegments:b2x"), U.r(l, Point2, "intersectingLineSegments:b2y")), G.Au(t, i, e, s, n, o, r, l);
    }
    projectOntoLineSegment(t, i, e, s) {
      return Debug && (U.r(t, Point2, "projectOntoLineSegment:px"), U.r(i, Point2, "projectOntoLineSegment:py"), U.r(e, Point2, "projectOntoLineSegment:qx"), U.r(s, Point2, "projectOntoLineSegment:qy")), G.Ll(t, i, e, s, this.px, this.py, this), this;
    }
    projectOntoLineSegmentPoint(t, i) {
      return Debug && (U.s(t, Point2, Point2, "projectOntoLineSegmentPoint:p"), U.s(i, Point2, Point2, "projectOntoLineSegmentPoint:q")), G.Ll(t.x, t.y, i.x, i.y, this.px, this.py, this), this;
    }
    snapToGrid(t, i, e, s) {
      return Debug && (U.r(t, Point2, "snapToGrid:originx"), U.r(i, Point2, "snapToGrid:originy"), U.r(e, Point2, "snapToGrid:cellwidth"), U.r(s, Point2, "snapToGrid:cellheight")), G.om(this.px, this.py, t, i, e, s, this), this;
    }
    snapToGridPoint(t, i) {
      return Debug && (U.s(t, Point2, Point2, "snapToGridPoint:p"), U.s(i, Size2, Point2, "snapToGridPoint:q")), G.om(this.px, this.py, t.x, t.y, i.width, i.height, this), this;
    }
    setRectSpot(t, i) {
      return Debug && (U.s(t, Rect2, Point2, "setRectSpot:r"), U.s(i, Spot2, Point2, "setRectSpot:spot"), this._()), this.px = t.x + i.x * t.width + i.offsetX, this.py = t.y + i.y * t.height + i.offsetY, this;
    }
    setSpot(t, i, e, s, n) {
      return Debug && (U.r(t, Point2, "setSpot:x"), U.r(i, Point2, "setSpot:y"), U.r(e, Point2, "setSpot:w"), U.r(s, Point2, "setSpot:h"), (e < 0 || s < 0) && U.n("Point.setSpot:Width and height cannot be negative"), U.s(n, Spot2, Point2, "setSpot:spot"), this._()), this.px = t + n.x * e + n.offsetX, this.py = i + n.y * s + n.offsetY, this;
    }
    E(t) {
      return t.St(this), this;
    }
    je(t) {
      return t.De(this), this;
    }
    static distanceLineSegmentSquared(t, i, e, s, n, o) {
      Debug && (U.r(t, Point2, "distanceLineSegmentSquared:px"), U.r(i, Point2, "distanceLineSegmentSquared:py"), U.r(e, Point2, "distanceLineSegmentSquared:ax"), U.r(s, Point2, "distanceLineSegmentSquared:ay"), U.r(n, Point2, "distanceLineSegmentSquared:bx"), U.r(o, Point2, "distanceLineSegmentSquared:by"));
      let r = n - e, l = o - s;
      const h = r * r + l * l, f = e - t, a = s - i, c = -f * r - a * l;
      if (c <= 0 || c >= h) return r = n - t, l = o - i, Math.min(f * f + a * a, r * r + l * l);
      {
        const u = r * a - l * f;
        return u * u / h;
      }
    }
    static distanceSquared(t, i, e, s) {
      Debug && (U.r(t, Point2, "distanceSquared:px"), U.r(i, Point2, "distanceSquared:py"), U.r(e, Point2, "distanceSquared:qx"), U.r(s, Point2, "distanceSquared:qy"));
      const n = e - t, o = s - i;
      return n * n + o * o;
    }
    static direction(t, i, e, s) {
      Debug && (U.r(t, Point2, "direction:px"), U.r(i, Point2, "direction:py"), U.r(e, Point2, "direction:qx"), U.r(s, Point2, "direction:qy"));
      const n = e - t, o = s - i;
      if (n === 0) return o > 0 ? 90 : o < 0 ? 270 : 0;
      if (o === 0) return n > 0 ? 0 : 180;
      {
        if (isNaN(n) || isNaN(o)) return 0;
        let r = Math.atan(Math.abs(o / n)) * 180 / Math.PI;
        return n < 0 ? o < 0 ? r += 180 : r = 180 - r : o < 0 && (r = 360 - r), r;
      }
    }
    get x() {
      return this.px;
    }
    set x(t) {
      Debug && (U.i(t, "number", Point2, "x"), this._(t)), this.px = t;
    }
    get y() {
      return this.py;
    }
    set y(t) {
      Debug && (U.i(t, "number", Point2, "y"), this._(t)), this.py = t;
    }
    isReal() {
      return isFinite(this.x) && isFinite(this.y);
    }
    static wn = new Point2(0, 0).Ct();
    static OA = new Point2(-1 / 0, -1 / 0).Ct();
    static EA = new Point2(1 / 0, 1 / 0).Ct();
    static BA = new Point2(6, 6).Ct();
    static xn = new Point2(NaN, NaN).Ct();
    static _w = [];
    static a() {
      const t = Point2._w.pop();
      return t === void 0 ? new Point2() : t;
    }
    static Ms(t) {
      const i = Point2._w.pop();
      return i === void 0 ? t.copy() : i.c(t);
    }
    static U(t, i) {
      const e = Point2._w.pop();
      return e === void 0 ? new Point2(t, i) : (e.x = t, e.y = i, e);
    }
    static o(t) {
      Point2._w.push(t);
    }
  }
  class Size2 {
    sw;
    sh;
    u;
    constructor(t, i) {
      t === void 0 ? (this.sw = 0, this.sh = 0) : typeof t == "number" && (t >= 0 || isNaN(t)) && typeof i == "number" && (i >= 0 || isNaN(i)) ? (this.sw = t, this.sh = i) : U.n("Invalid arguments to Size constructor: " + t + ", " + i), this.u = false;
    }
    c(t) {
      return this.sw = t.sw, this.sh = t.sh, this;
    }
    e(t, i) {
      return this.sw = t, this.sh = i, this;
    }
    setTo(t, i) {
      return Debug && (U.i(t, "number", Size2, "setTo:w"), U.i(i, "number", Size2, "setTo:h"), t < 0 && U.G(t, ">= 0", Size2, "setTo:w"), i < 0 && U.G(i, ">= 0", Size2, "setTo:h"), this._()), this.sw = t, this.sh = i, this;
    }
    set(t) {
      return Debug && (U.s(t, Size2, Size2, "set:s"), this._()), this.sw = t.sw, this.sh = t.sh, this;
    }
    copy() {
      const t = new Size2();
      return t.sw = this.sw, t.sh = this.sh, t;
    }
    Ct() {
      return this.u = true, Object.freeze(this), this;
    }
    T() {
      return this.u || Object.isFrozen(this) ? this : this.copy().S();
    }
    S() {
      return this.u || (this.u = true), this;
    }
    _(t) {
      if (Debug && this.u) {
        let i = "The Size is frozen, so its properties cannot be set: " + this.toString();
        t !== void 0 && (i += "  to value: " + t), U.n(i);
      }
    }
    static parse(t) {
      if (typeof t == "string") {
        const i = t.split(" ");
        let e = 0, s = 0;
        for (; i[e] === ""; ) e++;
        let n = i[e++];
        n && (s = parseFloat(n));
        let o = 0;
        for (; i[e] === ""; ) e++;
        return n = i[e++], n && (o = parseFloat(n)), new Size2(s, o);
      } else return new Size2();
    }
    static stringify(t) {
      return Debug && U.s(t, Size2), t.width.toString() + " " + t.height.toString();
    }
    static stringifyFixed(t) {
      return U.i(t, "number", Size2, "stringifyFixed:digits"), (i) => i.width.toFixed(t) + " " + i.height.toFixed(t);
    }
    toString() {
      return "Size(" + this.width + "," + this.height + ")";
    }
    equals(t) {
      return t instanceof Size2 ? this.sw === t.width && this.sh === t.height : false;
    }
    equalTo(t, i) {
      return this.sw === t && this.sh === i;
    }
    equalsApprox(t) {
      return G.p(this.sw, t.width) && G.p(this.sh, t.height);
    }
    inflate(t, i) {
      Debug && (U.r(t, Size2, "inflate:w"), U.r(i, Size2, "inflate:h"));
      const e = this.width + t;
      this.sw = e >= 0 ? e : 0;
      const s = this.height + i;
      return this.sh = s >= 0 ? s : 0, this;
    }
    get width() {
      return this.sw;
    }
    set width(t) {
      Debug && (U.i(t, "number", Size2, "width"), this._(t)), t < 0 && U.G(t, ">= 0", Size2, "width"), this.sw = t;
    }
    get height() {
      return this.sh;
    }
    set height(t) {
      Debug && (U.i(t, "number", Size2, "height"), this._(t)), t < 0 && U.G(t, ">= 0", Size2, "height"), this.sh = t;
    }
    isReal() {
      return isFinite(this.width) && isFinite(this.height);
    }
    static ia = new Size2(0, 0).Ct();
    static Bk = new Size2(1, 1).Ct();
    static VA = new Size2(6, 6).Ct();
    static Tu = new Size2(8, 8).Ct();
    static zA = new Size2(10, 10).Ct();
    static tx = new Size2(1 / 0, 1 / 0).Ct();
    static ix = new Size2(NaN, NaN).Ct();
    static XA = [];
    static a() {
      const t = Size2.XA.pop();
      return t === void 0 ? new Size2() : t;
    }
    static o(t) {
      Size2.XA.push(t);
    }
  }
  class Rect2 {
    rx;
    ry;
    rw;
    rh;
    u;
    constructor(t, i, e, s) {
      if (t === void 0) this.rx = 0, this.ry = 0, this.rw = 0, this.rh = 0;
      else if (typeof t == "number" && typeof i == "number" && typeof e == "number" && (e >= 0 || isNaN(e)) && typeof s == "number" && (s >= 0 || isNaN(s))) this.rx = t, this.ry = i, this.rw = e, this.rh = s;
      else if (t instanceof Point2) {
        const n = t.x, o = t.y;
        if (i instanceof Point2) {
          const r = i.x, l = i.y;
          this.rx = Math.min(n, r), this.ry = Math.min(o, l), this.rw = Math.abs(n - r), this.rh = Math.abs(o - l);
        } else i instanceof Size2 ? (this.rx = n, this.ry = o, this.rw = i.width, this.rh = i.height) : U.n("Incorrect second argument supplied to Rect constructor " + i);
      } else U.n("Invalid arguments to Rect constructor: " + t + ", " + i + ", " + e + ", " + s);
      this.u = false;
    }
    c(t) {
      return this.rx = t.rx, this.ry = t.ry, this.rw = t.rw, this.rh = t.rh, this;
    }
    e(t, i, e, s) {
      return this.rx = t, this.ry = i, this.rw = e, this.rh = s, this;
    }
    Zn(t, i) {
      return this.rw = t, this.rh = i, this;
    }
    setTo(t, i, e, s) {
      return Debug && (U.i(t, "number", Rect2, "setTo:x"), U.i(i, "number", Rect2, "setTo:y"), U.i(e, "number", Rect2, "setTo:w"), U.i(s, "number", Rect2, "setTo:h"), e < 0 && U.G(e, ">= 0", Rect2, "setTo:w"), s < 0 && U.G(s, ">= 0", Rect2, "setTo:h"), this._()), this.rx = t, this.ry = i, this.rw = e, this.rh = s, this;
    }
    set(t) {
      return Debug && (U.s(t, Rect2, Rect2, "set:r"), this._()), this.rx = t.rx, this.ry = t.ry, this.rw = t.rw, this.rh = t.rh, this;
    }
    setPoint(t) {
      return Debug && (U.s(t, Point2, Rect2, "setPoint:p"), this._()), this.rx = t.x, this.ry = t.y, this;
    }
    setSize(t) {
      return Debug && (U.s(t, Size2, Rect2, "setSize:s"), this._()), this.rw = t.width, this.rh = t.height, this;
    }
    copy() {
      const t = new Rect2();
      return t.rx = this.rx, t.ry = this.ry, t.rw = this.rw, t.rh = this.rh, t;
    }
    Ct() {
      return this.u = true, Object.freeze(this), this;
    }
    T() {
      return this.u || Object.isFrozen(this) ? this : this.copy().S();
    }
    S() {
      return this.u || (this.u = true), this;
    }
    di() {
      return this.u && (Object.isFrozen(this) && U.n("cannot thaw constant: " + this), this.u = false), this;
    }
    _(t) {
      if (Debug && this.u) {
        let i = "The Rect is frozen, so its properties cannot be set: " + this.toString();
        t !== void 0 && (i += "  to value: " + t), U.n(i);
      }
    }
    static parse(t) {
      if (typeof t == "string") {
        const i = t.split(" ");
        let e = 0, s = 0;
        for (; i[e] === ""; ) e++;
        let n = i[e++];
        n && (s = parseFloat(n));
        let o = 0;
        for (; i[e] === ""; ) e++;
        n = i[e++], n && (o = parseFloat(n));
        let r = 0;
        for (; i[e] === ""; ) e++;
        n = i[e++], n && (r = parseFloat(n));
        let l = 0;
        for (; i[e] === ""; ) e++;
        return n = i[e++], n && (l = parseFloat(n)), new Rect2(s, o, r, l);
      } else return new Rect2();
    }
    static stringify(t) {
      return Debug && U.s(t, Rect2), t.x.toString() + " " + t.y.toString() + " " + t.width.toString() + " " + t.height.toString();
    }
    static stringifyFixed(t) {
      return U.i(t, "number", Rect2, "stringifyFixed:digits"), (i) => i.x.toFixed(t) + " " + i.y.toFixed(t) + " " + i.width.toFixed(t) + " " + i.height.toFixed(t);
    }
    toString() {
      return "Rect(" + this.x + "," + this.y + "," + this.width + "," + this.height + ")";
    }
    equals(t) {
      return t instanceof Rect2 ? this.rx === t.x && this.ry === t.y && this.rw === t.width && this.rh === t.height : false;
    }
    equalTo(t, i, e, s) {
      return this.rx === t && this.ry === i && this.rw === e && this.rh === s;
    }
    equalsApprox(t) {
      return G.p(this.rx, t.x) && G.p(this.ry, t.y) && G.p(this.rw, t.width) && G.p(this.rh, t.height);
    }
    equalsApproxTo(t, i, e, s) {
      return G.p(this.rx, t) && G.p(this.ry, i) && G.p(this.rw, e) && G.p(this.rh, s);
    }
    equalsApproxClose(t) {
      return G.q(this.rx, t.x) && G.q(this.ry, t.y) && G.q(this.rw, t.width) && G.q(this.rh, t.height);
    }
    containsPoint(t) {
      return Debug && U.s(t, Point2, Rect2, "containsPoint:p"), this.rx <= t.x && this.rx + this.rw >= t.x && this.ry <= t.y && this.ry + this.rh >= t.y;
    }
    containsRect(t) {
      return Debug && U.s(t, Rect2, Rect2, "containsRect:r"), this.rx <= t.x && t.x + t.width <= this.rx + this.rw && this.ry <= t.y && t.y + t.height <= this.ry + this.rh;
    }
    contains(t, i, e, s) {
      return Debug ? (U.r(t, Rect2, "contains:x"), U.r(i, Rect2, "contains:y"), e === void 0 ? e = 0 : U.r(e, Rect2, "contains:w"), s === void 0 ? s = 0 : U.r(s, Rect2, "contains:h"), (e < 0 || s < 0) && U.n("Rect.contains:Width and height cannot be negative")) : (e === void 0 && (e = 0), s === void 0 && (s = 0)), this.rx <= t && t + e <= this.rx + this.rw && this.ry <= i && i + s <= this.ry + this.rh;
    }
    offset(t, i) {
      return Debug && (U.r(t, Rect2, "offset:dx"), U.r(i, Rect2, "offset:dy"), this._()), this.rx += t, this.ry += i, this;
    }
    inflate(t, i) {
      return Debug && (U.r(t, Rect2, "inflate:w"), U.r(i, Rect2, "inflate:h")), this.ex(i, t, i, t);
    }
    addMargin(t) {
      return Debug && U.s(t, Margin2, Rect2, "addMargin:m"), this.ex(t.top, t.right, t.bottom, t.left);
    }
    subtractMargin(t) {
      return Debug && U.s(t, Margin2, Rect2, "subtractMargin:m"), this.ex(-t.top, -t.right, -t.bottom, -t.left);
    }
    grow(t, i, e, s) {
      return Debug && (U.r(t, Rect2, "grow:t"), U.r(i, Rect2, "grow:r"), U.r(e, Rect2, "grow:b"), U.r(s, Rect2, "grow:l")), this.ex(t, i, e, s);
    }
    ex(t, i, e, s) {
      Debug && this._();
      const n = this.rw;
      i + s <= -n ? (this.rx += n / 2, this.rw = 0) : (this.rx -= s, this.rw += i + s);
      const o = this.rh;
      return t + e <= -o ? (this.ry += o / 2, this.rh = 0) : (this.ry -= t, this.rh += t + e), this;
    }
    intersectRect(t) {
      return Debug && U.s(t, Rect2, Rect2, "intersectRect:r"), this.YA(t.x, t.y, t.width, t.height);
    }
    intersect(t, i, e, s) {
      return Debug && (U.r(t, Rect2, "intersect:x"), U.r(i, Rect2, "intersect:y"), U.r(e, Rect2, "intersect:w"), U.r(s, Rect2, "intersect:h"), (e < 0 || s < 0) && U.n("Rect.intersect:Width and height cannot be negative")), this.YA(t, i, e, s);
    }
    YA(t, i, e, s) {
      Debug && this._();
      const n = Math.max(this.rx, t), o = Math.max(this.ry, i), r = Math.min(this.rx + this.rw, t + e), l = Math.min(this.ry + this.rh, i + s);
      return this.rx = n, this.ry = o, this.rw = Math.max(0, r - n), this.rh = Math.max(0, l - o), this;
    }
    intersectsRect(t) {
      return Debug && U.s(t, Rect2, Rect2, "intersectsRect:r"), this.intersects(t.x, t.y, t.width, t.height);
    }
    intersects(t, i, e, s) {
      Debug && (U.r(t, Rect2, "intersects:x"), U.r(i, Rect2, "intersects:y"), U.r(t, Rect2, "intersects:w"), U.r(i, Rect2, "intersects:h"), (e < 0 || s < 0) && U.n("Rect.intersects:Width and height cannot be negative"));
      let n = this.rw;
      const o = this.rx;
      if (n !== 1 / 0 && e !== 1 / 0 && (n += o, e += t, isNaN(e) || isNaN(n) || o > e || t > n)) return false;
      let r = this.rh;
      const l = this.ry;
      return !(r !== 1 / 0 && s !== 1 / 0 && (r += l, s += i, isNaN(s) || isNaN(r) || l > s || i > r));
    }
    KA(t, i) {
      let e = this.rw, s = t.width + i + i;
      const n = this.rx, o = t.x - i;
      if (e += n, s += o, n > s || o > e) return false;
      let r = this.rh, l = t.height + i + i;
      const h = this.ry, f = t.y - i;
      return r += h, l += f, !(h > l || f > r);
    }
    unionPoint(t) {
      return Debug && U.s(t, Point2, Rect2, "unionPoint:p"), this.ai(t.x, t.y, 0, 0);
    }
    unionRect(t) {
      return Debug && U.s(t, Rect2, Rect2, "unionRect:r"), this.ai(t.rx, t.ry, t.rw, t.rh);
    }
    union(t, i, e, s) {
      return Debug ? (U.r(t, Rect2, "union:x"), U.r(i, Rect2, "union:y"), e === void 0 ? e = 0 : U.r(e, Rect2, "union:w"), s === void 0 ? s = 0 : U.r(s, Rect2, "union:h"), (e < 0 || s < 0) && U.n("Rect.union:Width and height cannot be negative"), this._()) : (e === void 0 && (e = 0), s === void 0 && (s = 0)), this.ai(t, i, e, s);
    }
    ai(t, i, e, s) {
      const n = Math.min(this.rx, t), o = Math.min(this.ry, i), r = Math.max(this.rx + this.rw, t + e), l = Math.max(this.ry + this.rh, i + s);
      return this.rx = n, this.ry = o, this.rw = r - n, this.rh = l - o, this;
    }
    setSpot(t, i, e) {
      return Debug && (U.r(t, Rect2, "setSpot:x"), U.r(i, Rect2, "setSpot:y"), U.s(e, Spot2, Rect2, "setSpot:spot"), this._()), this.rx = t - e.offsetX - e.x * this.rw, this.ry = i - e.offsetY - e.y * this.rh, this;
    }
    nearestSideDirection(t, i) {
      return Debug && (U.r(t, Rect2, "nearestSideDirection:x"), U.r(i, Rect2, "nearestSideDirection:y")), G.nx(this, t, i, true);
    }
    nearestSideDirectionPoint(t) {
      return Debug && U.s(t, Point2, Rect2, "unionPoint:p"), G.nx(this, t.x, t.y, true);
    }
    static contains(t, i, e, s, n, o, r, l) {
      return Debug ? (U.r(t, Rect2, "contains:rx"), U.r(i, Rect2, "contains:ry"), U.r(e, Rect2, "contains:rw"), U.r(s, Rect2, "contains:rh"), U.r(n, Rect2, "contains:x"), U.r(o, Rect2, "contains:y"), r === void 0 ? r = 0 : U.r(r, Rect2, "contains:w"), l === void 0 ? l = 0 : U.r(l, Rect2, "contains:h"), (e < 0 || s < 0 || r < 0 || l < 0) && U.n("Rect.contains:Width and height cannot be negative")) : (r === void 0 && (r = 0), l === void 0 && (l = 0)), t <= n && n + r <= t + e && i <= o && o + l <= i + s;
    }
    static intersects(t, i, e, s, n, o, r, l) {
      Debug && (U.r(t, Rect2, "intersects:rx"), U.r(i, Rect2, "intersects:ry"), U.r(e, Rect2, "intersects:rw"), U.r(s, Rect2, "intersects:rh"), U.r(n, Rect2, "intersects:x"), U.r(o, Rect2, "intersects:y"), U.r(r, Rect2, "intersects:w"), U.r(l, Rect2, "intersects:h"), (e < 0 || s < 0 || r < 0 || l < 0) && U.n("Rect.intersects:Width and height cannot be negative"));
      let h = e, f = r;
      const a = t, c = n;
      if (h += a, f += c, a > f || c > h) return false;
      let u = s, d = l;
      const m = i, g = o;
      return u += m, d += g, !(m > d || g > u);
    }
    static intersectsLineSegment(t, i, e, s, n, o, r, l) {
      return Debug && (U.r(t, Rect2, "intersectsLineSegment:x"), U.r(i, Rect2, "intersectsLineSegment:y"), U.r(e, Rect2, "intersectsLineSegment:w"), U.r(s, Rect2, "intersectsLineSegment:h"), U.r(n, Rect2, "intersectsLineSegment:p1x"), U.r(o, Rect2, "intersectsLineSegment:p1y"), U.r(r, Rect2, "intersectsLineSegment:p2x"), U.r(l, Rect2, "intersectsLineSegment:p2y"), (e < 0 || s < 0) && U.n("Rect.intersectsLineSegment: width and height cannot be negative")), G.UA(t, i, e, s, n, o, r, l);
    }
    get x() {
      return this.rx;
    }
    set x(t) {
      Debug && (U.i(t, "number", Rect2, "x"), this._(t)), this.rx = t;
    }
    get y() {
      return this.ry;
    }
    set y(t) {
      Debug && (U.i(t, "number", Rect2, "y"), this._(t)), this.ry = t;
    }
    get width() {
      return this.rw;
    }
    set width(t) {
      Debug && (U.i(t, "number", Rect2, "width"), this._(t)), t < 0 && U.G(t, ">= 0", Rect2, "width"), this.rw = t;
    }
    get height() {
      return this.rh;
    }
    set height(t) {
      Debug && (U.i(t, "number", Rect2, "height"), this._(t)), t < 0 && U.G(t, ">= 0", Rect2, "height"), this.rh = t;
    }
    get left() {
      return this.rx;
    }
    set left(t) {
      Debug && (U.i(t, "number", Rect2, "left"), this._(t)), this.rx = t;
    }
    get top() {
      return this.ry;
    }
    set top(t) {
      Debug && (U.i(t, "number", Rect2, "top"), this._(t)), this.ry = t;
    }
    get right() {
      return this.rx + this.rw;
    }
    set right(t) {
      Debug && (U.r(t, Rect2, "right"), this._(t)), this.rx += t - (this.rx + this.rw);
    }
    get bottom() {
      return this.ry + this.rh;
    }
    set bottom(t) {
      Debug && (U.r(t, Rect2, "top"), this._(t)), this.ry += t - (this.ry + this.rh);
    }
    get position() {
      return new Point2(this.rx, this.ry);
    }
    set position(t) {
      Debug && (U.s(t, Point2, Rect2, "position"), this._(t)), this.rx = t.x, this.ry = t.y;
    }
    get size() {
      return new Size2(this.rw, this.rh);
    }
    set size(t) {
      Debug && (U.s(t, Size2, Rect2, "size"), this._(t)), this.rw = t.width, this.rh = t.height;
    }
    get center() {
      return new Point2(this.rx + this.rw / 2, this.ry + this.rh / 2);
    }
    set center(t) {
      Debug && (U.s(t, Point2, Rect2, "center"), this._(t)), this.rx = t.x - this.rw / 2, this.ry = t.y - this.rh / 2;
    }
    get centerX() {
      return this.rx + this.rw / 2;
    }
    set centerX(t) {
      Debug && (U.r(t, Rect2, "centerX"), this._(t)), this.rx = t - this.rw / 2;
    }
    get centerY() {
      return this.ry + this.rh / 2;
    }
    set centerY(t) {
      Debug && (U.r(t, Rect2, "centerY"), this._(t)), this.ry = t - this.rh / 2;
    }
    isReal() {
      return isFinite(this.x) && isFinite(this.y) && isFinite(this.width) && isFinite(this.height);
    }
    isEmpty() {
      return this.width === 0 && this.height === 0;
    }
    static rm = new Rect2(0, 0, 0, 0).Ct();
    static JI = new Rect2(NaN, NaN, NaN, NaN).Ct();
    static lx = [];
    static a() {
      const t = Rect2.lx.pop();
      return t === void 0 ? new Rect2() : t;
    }
    static Ms(t) {
      const i = Rect2.lx.pop();
      return i === void 0 ? t.copy() : i.c(t);
    }
    static U(t, i, e, s) {
      const n = Rect2.lx.pop();
      return n === void 0 ? new Rect2(t, i, e, s) : n.e(t, i, e, s);
    }
    static o(t) {
      Rect2.lx.push(t);
    }
  }
  class Margin2 {
    mt;
    mr;
    mb;
    ml;
    constructor(t, i, e, s) {
      t === void 0 ? (this.mt = 0, this.mr = 0, this.mb = 0, this.ml = 0) : i === void 0 ? (i = t, e = t, s = t, this.mt = t, this.mr = i, this.mb = e, this.ml = s) : e === void 0 ? (e = t, s = i, this.mt = t, this.mr = i, this.mb = e, this.ml = s) : s !== void 0 ? (this.mt = t, this.mr = i, this.mb = e, this.ml = s) : U.n("Invalid arguments to Margin constructor: " + t + ", " + i + ", " + e + ", " + s);
    }
    setTo(t, i, e, s) {
      return Debug && (U.i(t, "number", Margin2, "setTo:t"), U.i(i, "number", Margin2, "setTo:r"), U.i(e, "number", Margin2, "setTo:b"), U.i(s, "number", Margin2, "setTo:l"), this._()), this.mt = t, this.mr = i, this.mb = e, this.ml = s, this;
    }
    set(t) {
      return Debug && (U.s(t, Margin2, Margin2, "assign:m"), this._()), this.mt = t.mt, this.mr = t.mr, this.mb = t.mb, this.ml = t.ml, this;
    }
    copy() {
      const t = new Margin2();
      return t.mt = this.mt, t.mr = this.mr, t.mb = this.mb, t.ml = this.ml, t;
    }
    Ct() {
      return Object.freeze(this), this;
    }
    T() {
      return Object.isFrozen(this) ? this : this.copy().Ct();
    }
    _(t) {
      if (Debug && Object.isFrozen(this)) {
        let i = "The Margin is frozen, so its properties cannot be set: " + this.toString();
        t !== void 0 && (i += "  to value: " + t), U.n(i);
      }
    }
    static parse(t) {
      if (typeof t == "string") {
        const i = t.split(" ");
        let e = 0, s = NaN;
        for (; i[e] === ""; ) e++;
        let n = i[e++];
        if (n && (s = parseFloat(n)), isNaN(s)) return new Margin2();
        let o = NaN;
        for (; i[e] === ""; ) e++;
        if (n = i[e++], n && (o = parseFloat(n)), isNaN(o)) return new Margin2(s);
        let r = NaN;
        for (; i[e] === ""; ) e++;
        if (n = i[e++], n && (r = parseFloat(n)), isNaN(r)) return new Margin2(s, o);
        let l = NaN;
        for (; i[e] === ""; ) e++;
        return n = i[e++], n && (l = parseFloat(n)), isNaN(l) ? new Margin2(s, o) : new Margin2(s, o, r, l);
      } else return new Margin2();
    }
    static stringify(t) {
      return Debug && U.s(t, Margin2), t.top.toString() + " " + t.right.toString() + " " + t.bottom.toString() + " " + t.left.toString();
    }
    static stringifyFixed(t) {
      return U.i(t, "number", Margin2, "stringifyFixed:digits"), (i) => i.top.toFixed(t) + " " + i.right.toFixed(t) + " " + i.bottom.toFixed(t) + " " + i.left.toFixed(t);
    }
    toString() {
      return "Margin(" + this.top + "," + this.right + "," + this.bottom + "," + this.left + ")";
    }
    equals(t) {
      return t instanceof Margin2 ? this.mt === t.top && this.mr === t.right && this.mb === t.bottom && this.ml === t.left : false;
    }
    equalTo(t, i, e, s) {
      return this.mt === t && this.mr === i && this.mb === e && this.ml === s;
    }
    equalsApprox(t) {
      return G.p(this.mt, t.top) && G.p(this.mr, t.right) && G.p(this.mb, t.bottom) && G.p(this.ml, t.left);
    }
    get top() {
      return this.mt;
    }
    set top(t) {
      Debug && (U.r(t, Margin2, "top"), this._(t)), this.mt = t;
    }
    get right() {
      return this.mr;
    }
    set right(t) {
      Debug && (U.r(t, Margin2, "right"), this._(t)), this.mr = t;
    }
    get bottom() {
      return this.mb;
    }
    set bottom(t) {
      Debug && (U.r(t, Margin2, "bottom"), this._(t)), this.mb = t;
    }
    get left() {
      return this.ml;
    }
    set left(t) {
      Debug && (U.r(t, Margin2, "left"), this._(t)), this.ml = t;
    }
    isReal() {
      return isFinite(this.top) && isFinite(this.right) && isFinite(this.bottom) && isFinite(this.left);
    }
    static lm = new Margin2(0, 0, 0, 0).Ct();
    static GA = new Margin2(2, 2, 2, 2).Ct();
  }
  class Spot2 {
    sx;
    sy;
    ox;
    oy;
    constructor(t, i, e, s) {
      t === void 0 ? (this.sx = 0, this.sy = 0, this.ox = 0, this.oy = 0) : (i === void 0 && (i = 0), e === void 0 && (e = 0), s === void 0 && (s = 0), this.sx = t, this.sy = i, this.ox = e, this.oy = s);
    }
    setTo(t, i, e, s) {
      return Debug && (this.hx(t, "setTo:x"), this.hx(i, "setTo:y"), this.fx(e, "setTo:offx"), this.fx(s, "setTo:offy"), this._()), this.sx = t, this.sy = i, this.ox = e, this.oy = s, this;
    }
    set(t) {
      return Debug && (U.s(t, Spot2, Spot2, "set:s"), this._()), this.sx = t.sx, this.sy = t.sy, this.ox = t.ox, this.oy = t.oy, this;
    }
    copy() {
      const t = new Spot2();
      return t.sx = this.sx, t.sy = this.sy, t.ox = this.ox, t.oy = this.oy, t;
    }
    Ct() {
      return Object.freeze(this), this;
    }
    T() {
      return Object.isFrozen(this) ? this : this.copy().Ct();
    }
    _(t) {
      if (Debug && Object.isFrozen(this)) {
        let i = "The Spot is frozen, so its properties cannot be set: " + this.toString();
        t !== void 0 && (i += "  to value: " + t), U.n(i);
      }
    }
    Je(t) {
      return this.sx = NaN, this.sy = NaN, this.ox = t, this.Ct();
    }
    hx(t, i) {
      (isNaN(t) || t > 1 || t < 0) && U.G(t, "0 <= " + i + " <= 1", Spot2, i);
    }
    fx(t, i) {
      (isNaN(t) || t === 1 / 0 || t === -1 / 0) && U.G(t, "real number, not NaN or Infinity", Spot2, i);
    }
    static parse(t) {
      if (typeof t == "string") {
        if (t = t.trim(), t === "None") return Spot2.None;
        if (t === "TopLeft") return Spot2.TopLeft;
        if (t === "Top" || t === "TopCenter" || t === "MiddleTop") return Spot2.TopCenter;
        if (t === "TopRight") return Spot2.TopRight;
        if (t === "Left" || t === "LeftCenter" || t === "MiddleLeft") return Spot2.LeftCenter;
        if (t === "Center") return Spot2.Center;
        if (t === "Right" || t === "RightCenter" || t === "MiddleRight") return Spot2.RightCenter;
        if (t === "BottomLeft") return Spot2.BottomLeft;
        if (t === "Bottom" || t === "BottomCenter" || t === "MiddleBottom") return Spot2.BottomCenter;
        if (t === "BottomRight") return Spot2.BottomRight;
        if (t === "TopSide") return Spot2.TopSide;
        if (t === "LeftSide") return Spot2.LeftSide;
        if (t === "RightSide") return Spot2.RightSide;
        if (t === "BottomSide") return Spot2.BottomSide;
        if (t === "TopBottomSides") return Spot2.TopBottomSides;
        if (t === "LeftRightSides") return Spot2.LeftRightSides;
        if (t === "TopLeftSides") return Spot2.TopLeftSides;
        if (t === "TopRightSides") return Spot2.TopRightSides;
        if (t === "BottomLeftSides") return Spot2.BottomLeftSides;
        if (t === "BottomRightSides") return Spot2.BottomRightSides;
        if (t === "NotTopSide") return Spot2.NotTopSide;
        if (t === "NotLeftSide") return Spot2.NotLeftSide;
        if (t === "NotRightSide") return Spot2.NotRightSide;
        if (t === "NotBottomSide") return Spot2.NotBottomSide;
        if (t === "AllSides") return Spot2.AllSides;
        if (t === "Default") return Spot2.Default;
        const i = t.split(" ");
        let e = 0, s = 0;
        for (; i[e] === ""; ) e++;
        let n = i[e++];
        n !== void 0 && n.length > 0 && (s = parseFloat(n));
        let o = 0;
        for (; i[e] === ""; ) e++;
        n = i[e++], n !== void 0 && n.length > 0 && (o = parseFloat(n));
        let r = 0;
        for (; i[e] === ""; ) e++;
        n = i[e++], n !== void 0 && n.length > 0 && (r = parseFloat(n));
        let l = 0;
        for (; i[e] === ""; ) e++;
        return n = i[e++], n !== void 0 && n.length > 0 && (l = parseFloat(n)), new Spot2(s, o, r, l);
      } else return new Spot2();
    }
    static stringify(t) {
      return Debug && U.s(t, Spot2), t.isSpot() ? t.x.toString() + " " + t.y.toString() + " " + t.offsetX.toString() + " " + t.offsetY.toString() : t.toString();
    }
    static stringifyFixed(t) {
      return U.i(t, "number", Spot2, "stringifyFixed:digits"), (i) => i.x.toFixed(t) + " " + i.y.toFixed(t) + " " + i.offsetX.toFixed(t) + " " + i.offsetY.toFixed(t);
    }
    toString() {
      return this.isSpot() ? this.ox === 0 && this.oy === 0 ? "Spot(" + this.x + "," + this.y + ")" : "Spot(" + this.x + "," + this.y + "," + this.offsetX + "," + this.offsetY + ")" : this.equals(Spot2.None) ? "None" : this.equals(Spot2.TopLeft) ? "TopLeft" : this.equals(Spot2.TopCenter) ? "Top" : this.equals(Spot2.TopRight) ? "TopRight" : this.equals(Spot2.LeftCenter) ? "Left" : this.equals(Spot2.Center) ? "Center" : this.equals(Spot2.RightCenter) ? "Right" : this.equals(Spot2.BottomLeft) ? "BottomLeft" : this.equals(Spot2.BottomCenter) ? "Bottom" : this.equals(Spot2.BottomRight) ? "BottomRight" : this.equals(Spot2.TopSide) ? "TopSide" : this.equals(Spot2.LeftSide) ? "LeftSide" : this.equals(Spot2.RightSide) ? "RightSide" : this.equals(Spot2.BottomSide) ? "BottomSide" : this.equals(Spot2.TopBottomSides) ? "TopBottomSides" : this.equals(Spot2.LeftRightSides) ? "LeftRightSides" : this.equals(Spot2.TopLeftSides) ? "TopLeftSides" : this.equals(Spot2.TopRightSides) ? "TopRightSides" : this.equals(Spot2.BottomLeftSides) ? "BottomLeftSides" : this.equals(Spot2.BottomRightSides) ? "BottomRightSides" : this.equals(Spot2.NotTopSide) ? "NotTopSide" : this.equals(Spot2.NotLeftSide) ? "NotLeftSide" : this.equals(Spot2.NotRightSide) ? "NotRightSide" : this.equals(Spot2.NotBottomSide) ? "NotBottomSide" : this.equals(Spot2.AllSides) ? "AllSides" : this.equals(Spot2.Default) ? "Default" : "None";
    }
    equals(t) {
      return t instanceof Spot2 ? (this.sx === t.x || isNaN(this.sx) && isNaN(t.x)) && (this.sy === t.y || isNaN(this.sy) && isNaN(t.y)) && this.ox === t.offsetX && this.oy === t.offsetY : false;
    }
    opposite() {
      return new Spot2(0.5 - (this.sx - 0.5), 0.5 - (this.sy - 0.5), -this.ox, -this.oy);
    }
    includesSide(t) {
      if (!this.isSide()) return false;
      if (!t.isSide()) if (t.equals(Spot2.Left)) t = Spot2.LeftSide;
      else if (t.equals(Spot2.Right)) t = Spot2.RightSide;
      else if (t.equals(Spot2.Top)) t = Spot2.TopSide;
      else if (t.equals(Spot2.Bottom)) t = Spot2.BottomSide;
      else return false;
      const i = this.oy, e = t.offsetY;
      return (i & e) === e;
    }
    get x() {
      return this.sx;
    }
    set x(t) {
      Debug && (this.hx(t, "x"), this._(t)), this.sx = t;
    }
    get y() {
      return this.sy;
    }
    set y(t) {
      Debug && (this.hx(t, "y"), this._(t)), this.sy = t;
    }
    get offsetX() {
      return this.ox;
    }
    set offsetX(t) {
      Debug && (this.fx(t, "offsetX"), this._(t)), this.ox = t;
    }
    get offsetY() {
      return this.oy;
    }
    set offsetY(t) {
      Debug && (this.fx(t, "offsetY"), this._(t)), this.oy = t;
    }
    isSpot() {
      return !isNaN(this.x) && !isNaN(this.y);
    }
    isNoSpot() {
      return isNaN(this.x) || isNaN(this.y);
    }
    isSide() {
      return isNaN(this.x) && isNaN(this.y) && this.offsetX === 1 && this.offsetY !== 0;
    }
    isNone() {
      return isNaN(this.x) && isNaN(this.y) && this.offsetX === 0 && this.offsetY === 0;
    }
    isDefault() {
      return isNaN(this.x) && isNaN(this.y) && this.offsetX === -1 && this.offsetY === 0;
    }
    static None = new Spot2(0, 0, 0, 0).Je(0);
    static Default = new Spot2(0, 0, -1, 0).Je(-1);
    static TopLeft = new Spot2(0, 0, 0, 0).Ct();
    static TopCenter = new Spot2(0.5, 0, 0, 0).Ct();
    static TopRight = new Spot2(1, 0, 0, 0).Ct();
    static LeftCenter = new Spot2(0, 0.5, 0, 0).Ct();
    static Center = new Spot2(0.5, 0.5, 0, 0).Ct();
    static RightCenter = new Spot2(1, 0.5, 0, 0).Ct();
    static BottomLeft = new Spot2(0, 1, 0, 0).Ct();
    static BottomCenter = new Spot2(0.5, 1, 0, 0).Ct();
    static BottomRight = new Spot2(1, 1, 0, 0).Ct();
    static MiddleTop = Spot2.TopCenter;
    static MiddleLeft = Spot2.LeftCenter;
    static MiddleRight = Spot2.RightCenter;
    static MiddleBottom = Spot2.BottomCenter;
    static Top = Spot2.TopCenter;
    static Left = Spot2.LeftCenter;
    static Right = Spot2.RightCenter;
    static Bottom = Spot2.BottomCenter;
    static TopSide = new Spot2(0, 0, 1, 1).Je(1);
    static LeftSide = new Spot2(0, 0, 1, 2).Je(1);
    static RightSide = new Spot2(0, 0, 1, 4).Je(1);
    static BottomSide = new Spot2(0, 0, 1, 8).Je(1);
    static TopBottomSides = new Spot2(0, 0, 1, 9).Je(1);
    static LeftRightSides = new Spot2(0, 0, 1, 6).Je(1);
    static TopLeftSides = new Spot2(0, 0, 1, 3).Je(1);
    static TopRightSides = new Spot2(0, 0, 1, 5).Je(1);
    static BottomLeftSides = new Spot2(0, 0, 1, 10).Je(1);
    static BottomRightSides = new Spot2(0, 0, 1, 12).Je(1);
    static NotTopSide = new Spot2(0, 0, 1, 14).Je(1);
    static NotLeftSide = new Spot2(0, 0, 1, 13).Je(1);
    static NotRightSide = new Spot2(0, 0, 1, 11).Je(1);
    static NotBottomSide = new Spot2(0, 0, 1, 7).Je(1);
    static AllSides = new Spot2(0, 0, 1, 15).Je(1);
    static Vk = new Spot2(0.156, 0.156).Ct();
    static zk = new Spot2(0.844, 0.844).Ct();
  }
  class Transform {
    m11;
    m12;
    m21;
    m22;
    dx;
    dy;
    constructor() {
      this.m11 = 1, this.m12 = 0, this.m21 = 0, this.m22 = 1, this.dx = 0, this.dy = 0;
    }
    set(t) {
      return this.m11 = t.m11, this.m12 = t.m12, this.m21 = t.m21, this.m22 = t.m22, this.dx = t.dx, this.dy = t.dy, this;
    }
    setTo(t, i, e, s, n, o) {
      return this.m11 = t, this.m12 = i, this.m21 = e, this.m22 = s, this.dx = n, this.dy = o, this;
    }
    copy() {
      const t = new Transform();
      return t.m11 = this.m11, t.m12 = this.m12, t.m21 = this.m21, t.m22 = this.m22, t.dx = this.dx, t.dy = this.dy, t;
    }
    toString() {
      return "Transform(" + this.m11 + "," + this.m12 + "," + this.m21 + "," + this.m22 + "," + this.dx + "," + this.dy + ")";
    }
    equals(t) {
      return this.m11 === t.m11 && this.m12 === t.m12 && this.m21 === t.m21 && this.m22 === t.m22 && this.dx === t.dx && this.dy === t.dy;
    }
    Xk() {
      return this.dx === 0 && this.dy === 0 && this.m11 === 1 && this.m12 === 0 && this.m21 === 0 && this.m22 === 1;
    }
    Ki() {
      return this.m11 = 1, this.m12 = 0, this.m21 = 0, this.m22 = 1, this.dx = 0, this.dy = 0, this;
    }
    Af(t) {
      const i = this.m11 * t.m11 + this.m21 * t.m12, e = this.m12 * t.m11 + this.m22 * t.m12, s = this.m11 * t.m21 + this.m21 * t.m22, n = this.m12 * t.m21 + this.m22 * t.m22;
      return this.dx = this.m11 * t.dx + this.m21 * t.dy + this.dx, this.dy = this.m12 * t.dx + this.m22 * t.dy + this.dy, this.m11 = i, this.m12 = e, this.m21 = s, this.m22 = n, this;
    }
    qA(t) {
      const i = 1 / (t.m11 * t.m22 - t.m12 * t.m21), e = t.m22 * i, s = -t.m12 * i, n = -t.m21 * i, o = t.m11 * i, r = i * (t.m21 * t.dy - t.m22 * t.dx), l = i * (t.m12 * t.dx - t.m11 * t.dy), h = this.m11 * e + this.m21 * s, f = this.m12 * e + this.m22 * s, a = this.m11 * n + this.m21 * o, c = this.m12 * n + this.m22 * o;
      return this.dx = this.m11 * r + this.m21 * l + this.dx, this.dy = this.m12 * r + this.m22 * l + this.dy, this.m11 = h, this.m12 = f, this.m21 = a, this.m22 = c, this;
    }
    cx() {
      const t = 1 / (this.m11 * this.m22 - this.m12 * this.m21), i = this.m22 * t, e = -this.m12 * t, s = -this.m21 * t, n = this.m11 * t, o = t * (this.m21 * this.dy - this.m22 * this.dx), r = t * (this.m12 * this.dx - this.m11 * this.dy);
      return this.m11 = i, this.m12 = e, this.m21 = s, this.m22 = n, this.dx = o, this.dy = r, this;
    }
    Ns(t, i, e) {
      if (t = G.Yi(t), t === 0) return this;
      this.vs(i, e);
      let s = 0, n = 0;
      if (t === 90) s = 0, n = 1;
      else if (t === 180) s = -1, n = 0;
      else if (t === 270) s = 0, n = -1;
      else {
        const f = t * Math.PI / 180;
        s = Math.cos(f), n = Math.sin(f);
      }
      const o = this.m11 * s + this.m21 * n, r = this.m12 * s + this.m22 * n, l = this.m11 * -n + this.m21 * s, h = this.m12 * -n + this.m22 * s;
      return this.m11 = o, this.m12 = r, this.m21 = l, this.m22 = h, this.vs(-i, -e), this;
    }
    vs(t, i) {
      return this.dx += this.m11 * t + this.m21 * i, this.dy += this.m12 * t + this.m22 * i, this;
    }
    lt(t, i) {
      return i === void 0 && (i = t), this.m11 *= t, this.m12 *= t, this.m21 *= i, this.m22 *= i, this;
    }
    $I() {
      if (this.m11 === 1 && this.m12 === 0) return 0;
      let t = Math.atan2(this.m12, this.m11) * 180 / Math.PI;
      return t < 0 && (t += 360), t;
    }
    St(t) {
      const i = t.x, e = t.y;
      return t.e(i * this.m11 + e * this.m21 + this.dx, i * this.m12 + e * this.m22 + this.dy);
    }
    De(t) {
      const i = 1 / (this.m11 * this.m22 - this.m12 * this.m21), e = this.m22 * i, s = -this.m12 * i, n = -this.m21 * i, o = this.m11 * i, r = t.x - this.dx, l = t.y - this.dy;
      return t.e(r * e + l * n, r * s + l * o);
    }
    Lu(t) {
      const i = 1 / (this.m11 * this.m22 - this.m12 * this.m21), e = this.m22 * i, s = -this.m12 * i, n = -this.m21 * i, o = this.m11 * i, r = i * (this.m21 * this.dy - this.m22 * this.dx), l = i * (this.m12 * this.dx - this.m11 * this.dy), h = t.x * 1.25, f = t.y * 1.2;
      return t.e(h * e + f * n + r, h * s + f * o + l);
    }
    hm(t) {
      const i = t.x, e = t.y, s = i + t.width, n = e + t.height, o = this.m11, r = this.m12, l = this.m21, h = this.m22, f = this.dx, a = this.dy, c = i * o + e * l + f, u = i * r + e * h + a, d = s * o + e * l + f, m = s * r + e * h + a, g = i * o + n * l + f, p = i * r + n * h + a, y = s * o + n * l + f, x = s * r + n * h + a;
      let S = c, b = c, k = u, P = u;
      return S = Math.min(S, d), b = Math.max(b, d), k = Math.min(k, m), P = Math.max(P, m), S = Math.min(S, g), b = Math.max(b, g), k = Math.min(k, p), P = Math.max(P, p), S = Math.min(S, y), b = Math.max(b, y), k = Math.min(k, x), P = Math.max(P, x), t.e(S, k, b - S, P - k), t;
    }
    static HA = [];
    static a() {
      const t = Transform.HA.pop();
      return t === void 0 ? new Transform() : t;
    }
    static o(t) {
      Transform.HA.push(t);
    }
    static Yk = "54a702f3e53909c447824c6706603faf4c";
  }
  const G = { ZI: "7da71ca0ad381e90", Qn: 4 * ((Math.sqrt(2) - 1) / 3), vA: [], ux: (w) => {
    if (w <= 0) return 0;
    let t = G.vA;
    if (t === null) {
      t = [];
      for (let i = 0; i <= 2e3; i++) t[i] = Math.sqrt(i);
      G.vA = t;
    }
    if (w < 1) {
      const i = 1 / w;
      return i <= 2e3 ? 1 / t[i | 0] : Math.sqrt(w);
    } else return w <= 2e3 ? t[w | 0] : Math.sqrt(w);
  }, p: (w, t) => {
    const i = w - t;
    return i < 0.5 && i > -0.5;
  }, q: (w, t) => {
    const i = w - t;
    return i < 5e-8 && i > -5e-8;
  }, Ui: (w, t, i, e, s, n, o) => {
    s <= 0 && (s = 1e-6);
    let r = 0, l = 0, h = 0, f = 0;
    if (w < i ? (l = w, r = i) : (l = i, r = w), t < e ? (f = t, h = e) : (f = e, h = t), w === i) return f <= o && o <= h && w - s <= n && n <= w + s;
    if (t === e) return l <= n && n <= r && t - s <= o && o <= t + s;
    const a = r + s, c = l - s;
    if (c <= n && n <= a) {
      const u = h + s, d = f - s;
      if (d <= o && o <= u) if (a - c > u - d) if (w - i > s || i - w > s) {
        const g = (e - t) / (i - w) * (n - w) + t;
        if (g - s <= o && o <= g + s) return true;
      } else return true;
      else if (t - e > s || e - t > s) {
        const g = (i - w) / (e - t) * (o - t) + w;
        if (g - s <= n && n <= g + s) return true;
      } else return true;
    }
    return false;
  }, gx: (w, t, i, e, s, n, o, r, l, h, f, a) => {
    if (!G.Ui(w, t, o, r, a, i, e) || !G.Ui(w, t, o, r, a, s, n)) {
      const c = (w + i) / 2, u = (t + e) / 2, d = (i + s) / 2, m = (e + n) / 2, g = (s + o) / 2, p = (n + r) / 2, y = (c + d) / 2, x = (u + m) / 2, S = (d + g) / 2, b = (m + p) / 2, k = (y + S) / 2, P = (x + b) / 2;
      return G.gx(w, t, c, u, y, x, k, P, l, h, f, a) || G.gx(k, P, S, b, g, p, o, r, l, h, f, a);
    } else return G.Ui(w, t, o, r, a, h, f);
  }, WA: (w, t, i, e, s, n, o, r, l) => {
    const h = (w + i) / 2, f = (t + e) / 2, a = (i + s) / 2, c = (e + n) / 2, u = (s + o) / 2, d = (n + r) / 2, m = (h + a) / 2, g = (f + c) / 2, p = (a + u) / 2, y = (c + d) / 2;
    return l.e((m + p) / 2, (g + y) / 2), l;
  }, QI: (w, t, i, e, s, n, o, r) => {
    const l = (w + i) / 2, h = (t + e) / 2, f = (i + s) / 2, a = (e + n) / 2, c = (s + o) / 2, u = (n + r) / 2, d = (l + f) / 2, m = (h + a) / 2, g = (f + c) / 2, p = (a + u) / 2;
    return Point2.direction(d, m, g, p);
  }, Du: (w, t, i, e, s, n, o, r, l, h) => {
    if (!G.Ui(w, t, o, r, l, i, e) || !G.Ui(w, t, o, r, l, s, n)) {
      const f = (w + i) / 2, a = (t + e) / 2, c = (i + s) / 2, u = (e + n) / 2, d = (s + o) / 2, m = (n + r) / 2, g = (f + c) / 2, p = (a + u) / 2, y = (c + d) / 2, x = (u + m) / 2, S = (g + y) / 2, b = (p + x) / 2;
      G.Du(w, t, f, a, g, p, S, b, l, h), G.Du(S, b, y, x, d, m, o, r, l, h);
    } else h.ai(w, t, 0, 0), h.ai(o, r, 0, 0);
    return h;
  }, _n: (w, t, i, e, s, n, o, r, l, h) => {
    if (!G.Ui(w, t, o, r, l, i, e) || !G.Ui(w, t, o, r, l, s, n)) {
      const f = (w + i) / 2, a = (t + e) / 2, c = (i + s) / 2, u = (e + n) / 2, d = (s + o) / 2, m = (n + r) / 2, g = (f + c) / 2, p = (a + u) / 2, y = (c + d) / 2, x = (u + m) / 2, S = (g + y) / 2, b = (p + x) / 2;
      G._n(w, t, f, a, g, p, S, b, l, h), G._n(S, b, y, x, d, m, o, r, l, h);
    } else h.length === 0 && (h.push(w), h.push(t)), h.push(o), h.push(r);
    return h;
  }, Kk: (w, t, i, e, s, n, o, r, l, h) => {
    if (G.Ui(w, t, s, n, h, i, e)) return G.Ui(w, t, s, n, h, r, l);
    {
      const f = (w + i) / 2, a = (t + e) / 2, c = (i + s) / 2, u = (e + n) / 2, d = (f + c) / 2, m = (a + u) / 2;
      return G.Kk(w, t, f, a, d, m, o, r, l, h) || G.Kk(d, m, c, u, s, n, o, r, l, h);
    }
  }, Uk: (w, t, i, e, s, n, o, r) => {
    if (G.Ui(w, t, s, n, o, i, e)) r.ai(w, t, 0, 0), r.ai(s, n, 0, 0);
    else {
      const l = (w + i) / 2, h = (t + e) / 2, f = (i + s) / 2, a = (e + n) / 2, c = (l + f) / 2, u = (h + a) / 2;
      G.Uk(w, t, l, h, c, u, o, r), G.Uk(c, u, f, a, s, n, o, r);
    }
    return r;
  }, am: (w, t, i, e, s, n, o, r) => {
    if (G.Ui(w, t, s, n, o, i, e)) r.length === 0 && (r.push(w), r.push(t)), r.push(s), r.push(n);
    else {
      const l = (w + i) / 2, h = (t + e) / 2, f = (i + s) / 2, a = (e + n) / 2, c = (l + f) / 2, u = (h + a) / 2;
      G.am(w, t, l, h, c, u, o, r), G.am(c, u, f, a, s, n, o, r);
    }
    return r;
  }, fm: (w, t, i, e, s, n, o, r, l, h, f, a, c, u) => {
    if (!G.Ui(w, t, o, r, c, i, e) || !G.Ui(w, t, o, r, c, s, n)) {
      const d = (w + i) / 2, m = (t + e) / 2, g = (i + s) / 2, p = (e + n) / 2, y = (s + o) / 2, x = (n + r) / 2, S = (d + g) / 2, b = (m + p) / 2, k = (g + y) / 2, P = (p + x) / 2, A = (S + k) / 2, C = (b + P) / 2;
      let M = 1 / 0, N = false, L = 0, T = 0;
      if (G.fm(w, t, d, m, S, b, A, C, l, h, f, a, c, u)) {
        const D = (u.x - l) ** 2 + (u.y - h) ** 2;
        D < M && (M = D, N = true, L = u.x, T = u.y);
      }
      if (G.fm(A, C, k, P, y, x, o, r, l, h, f, a, c, u)) {
        const D = (u.x - l) ** 2 + (u.y - h) ** 2;
        D < M && (M = D, N = true, L = u.x, T = u.y);
      }
      return N && (u.x = L, u.y = T), N;
    } else {
      if (!G.Au(w, t, o, r, l, h, f, a)) return false;
      const d = (w - o) * (h - a) - (t - r) * (l - f);
      if (d === 0) return false;
      const m = ((w * r - t * o) * (l - f) - (w - o) * (l * a - h * f)) / d, g = ((w * r - t * o) * (h - a) - (t - r) * (l * a - h * f)) / d;
      return u.e(m, g), true;
    }
  }, cm: (w, t, i, e, s, n, o, r, l, h, f, a, c) => {
    let u = 0;
    if (!G.Ui(w, t, o, r, c, i, e) || !G.Ui(w, t, o, r, c, s, n)) {
      const d = (w + i) / 2, m = (t + e) / 2, g = (i + s) / 2, p = (e + n) / 2, y = (s + o) / 2, x = (n + r) / 2, S = (d + g) / 2, b = (m + p) / 2, k = (g + y) / 2, P = (p + x) / 2, A = (S + k) / 2, C = (b + P) / 2;
      u += G.cm(w, t, d, m, S, b, A, C, l, h, f, a, c), u += G.cm(A, C, k, P, y, x, o, r, l, h, f, a, c);
    } else {
      const d = (w - o) * (h - a) - (t - r) * (l - f);
      if (d === 0) return u;
      const m = ((w * r - t * o) * (l - f) - (w - o) * (l * a - h * f)) / d, g = ((w * r - t * o) * (h - a) - (t - r) * (l * a - h * f)) / d;
      if (m >= f) return u;
      let p = 0, y = 0;
      if ((l > f ? l - f : f - l) < (h > a ? h - a : a - h)) {
        if (t < r ? (p = t, y = r) : (p = r, y = t), g < p || g > y) return u;
      } else if (w < o ? (p = w, y = o) : (p = o, y = w), m < p || m > y) return u;
      d > 0 ? u++ : d < 0 && u--;
    }
    return u;
  }, Ll: (w, t, i, e, s, n, o) => {
    if (G.q(w, i)) {
      let r = 0, l = 0;
      t < e ? (r = t, l = e) : (r = e, l = t);
      const h = n;
      return h < r ? (o.e(w, r), false) : h > l ? (o.e(w, l), false) : (o.e(w, h), true);
    } else if (G.q(t, e)) {
      let r = 0, l = 0;
      w < i ? (r = w, l = i) : (r = i, l = w);
      const h = s;
      return h < r ? (o.e(r, t), false) : h > l ? (o.e(l, t), false) : (o.e(h, t), true);
    } else {
      const r = (i - w) ** 2 + (e - t) ** 2, l = ((w - s) * (w - i) + (t - n) * (t - e)) / r;
      if (l < -5e-6) return o.e(w, t), false;
      if (l > 1.000005) return o.e(i, e), false;
      {
        const h = w + l * (i - w), f = t + l * (e - t);
        return o.e(h, f), true;
      }
    }
  }, Bo: (w, t, i, e, s, n, o, r, l) => {
    if (G.p(w, i) && G.p(t, e)) return l.e(w, t), false;
    if (G.q(s, o)) {
      if (G.q(w, i)) return G.Ll(w, t, i, e, s, n, l), false;
      {
        const f = (e - t) / (i - w) * (s - w) + t;
        return G.Ll(w, t, i, e, s, f, l);
      }
    } else {
      const h = (r - n) / (o - s);
      if (G.q(w, i)) {
        const f = h * (w - s) + n;
        let a = 0, c = 0;
        return t < e ? (a = t, c = e) : (a = e, c = t), f < a ? (l.e(w, a), false) : f > c ? (l.e(w, c), false) : (l.e(w, f), true);
      } else {
        const f = (e - t) / (i - w);
        if (G.q(h, f)) return G.Ll(w, t, i, e, s, n, l), false;
        {
          const a = (f * w - h * s + n - t) / (f - h);
          if (G.q(f, 0)) {
            let c = 0, u = 0;
            return w < i ? (c = w, u = i) : (c = i, u = w), a < c ? (l.e(c, t), false) : a > u ? (l.e(u, t), false) : (l.e(a, t), true);
          } else {
            const c = f * (a - w) + t;
            return G.Ll(w, t, i, e, a, c, l);
          }
        }
      }
    }
  }, Dl: (w, t, i, e, s, n, o, r, l) => {
    let h = 1e21, f = w, a = t;
    if (G.Bo(w, t, w, e, s, n, o, r, l)) {
      const c = (l.x - s) ** 2 + (l.y - n) ** 2;
      c < h && (h = c, f = l.x, a = l.y);
    }
    if (G.Bo(i, t, i, e, s, n, o, r, l)) {
      const c = (l.x - s) ** 2 + (l.y - n) ** 2;
      c < h && (h = c, f = l.x, a = l.y);
    }
    if (G.Bo(w, t, i, t, s, n, o, r, l)) {
      const c = (l.x - s) ** 2 + (l.y - n) ** 2;
      c < h && (h = c, f = l.x, a = l.y);
    }
    if (G.Bo(w, e, i, e, s, n, o, r, l)) {
      const c = (l.x - s) ** 2 + (l.y - n) ** 2;
      c < h && (h = c, f = l.x, a = l.y);
    }
    return l.e(f, a), h < 1e21;
  }, mx: (w, t, i) => G.UA(w.x, w.y, w.width, w.height, t.x, t.y, i.x, i.y), UA: (w, t, i, e, s, n, o, r) => {
    const l = w, h = w + i, f = t, a = t + e;
    if (s === o) {
      let c = 0, u = 0;
      return n < r ? (c = n, u = r) : (c = r, u = n), l <= s && s <= h && c <= a && u >= f;
    }
    if (n === r) {
      let c = 0, u = 0;
      return s < o ? (c = s, u = o) : (c = o, u = s), f <= n && n <= a && c <= h && u >= l;
    }
    return !!(Rect2.contains(w, t, i, e, s, n) || Rect2.contains(w, t, i, e, o, r) || G.Au(l, f, h, f, s, n, o, r) || G.Au(h, f, h, a, s, n, o, r) || G.Au(h, a, l, a, s, n, o, r) || G.Au(l, a, l, f, s, n, o, r));
  }, Au: (w, t, i, e, s, n, o, r) => w === i && t === e && s === o && n === r ? w === s && t === n : G.Cu(w, t, i, e, s, n) * G.Cu(w, t, i, e, o, r) <= 0 && G.Cu(s, n, o, r, w, t) * G.Cu(s, n, o, r, i, e) <= 0, Cu: (w, t, i, e, s, n) => {
    const o = i - w, r = e - t;
    let l = s - w, h = n - t, f = l * r - h * o;
    return f === 0 && (f = l * o + h * r, f > 0 && (l -= o, h -= r, f = l * o + h * r, f < 0 && (f = 0))), f;
  }, nx(w, t, i, e) {
    e === void 0 && (e = false);
    let s = 0;
    const n = w === null ? t : (t - w.x) / (w.width > 0 ? w.width : 1), o = w === null ? i : (i - w.y) / (w.height > 0 ? w.height : 1);
    return n > o ? n > 1 - o || (e || n < 1 - o ? s = 270 : s = 315) : e || n < o ? n > 1 - o ? s = 90 : e || n < 1 - o ? s = 180 : s = 135 : n < 0.5 ? s = 225 : n > 0.5 && (s = 45), s;
  }, Yi: (w) => (w >= 360 ? w -= 360 : w < 0 && (w += 360), w), _I: (w, t) => w > t ? Math.min(w - t, Math.abs(w - 360 - t)) : t > w ? Math.min(t - w, Math.abs(w - (t - 360))) : 0, jA: (w, t, i, e, s, n) => {
    const o = Math.PI;
    n || (e = e * (o / 180), s = s * (o / 180));
    const r = e > s ? -1 : 1, l = 1e-5, h = o * 2, f = [], a = o / 2;
    let c = e, u = Math.min(h, Math.abs(s - e));
    if (u < l) {
      const d = c + r * Math.min(u, a), m = w + i * Math.cos(c), g = t + i * Math.sin(c), p = w + i * Math.cos(d), y = t + i * Math.sin(d), x = (m + p) / 2, S = (g + y) / 2;
      return f.push([m, g, x, S, x, S, p, y]), f;
    }
    for (; u > l; ) {
      const d = c + r * Math.min(u, a);
      f.push(G.tR(i, c, d, w, t)), u -= Math.abs(d - c), c = d;
    }
    return f;
  }, tR: (w, t, i, e, s) => {
    const n = (i - t) / 2, o = w * Math.cos(n), r = w * Math.sin(n), l = o, h = -r, f = l * l + h * h, a = f + l * o + h * r, c = 4 / 3 * (Math.sqrt(2 * f * a) - a) / (l * r - h * o), u = l - c * h, d = h + c * l, m = u, g = -d, p = n + t, y = Math.cos(p), x = Math.sin(p);
    return [e + w * Math.cos(t), s + w * Math.sin(t), e + u * y - d * x, s + u * x + d * y, e + m * y - g * x, s + m * x + g * y, e + w * Math.cos(i), s + w * Math.sin(i)];
  }, om: (w, t, i, e, s, n, o) => {
    const r = s, l = n, h = Math.floor((w - i) / r) * r + i, f = Math.floor((t - e) / l) * l + e;
    let a = h;
    h + r - w < r / 2 && (a = h + r);
    let c = f;
    return f + l - t < l / 2 && (c = f + l), o.e(a, c), o;
  }, JA: (w, t) => {
    let i = Math.max(w, t), e = Math.min(w, t), s = 1, n = 1;
    do
      s = i % e, n = e, i = e, e = s;
    while (s > 0);
    return n;
  }, iR: (w, t, i, e) => {
    const s = i < 0, n = e < 0;
    let o = 0, r = 0, l = 0;
    w < t ? (r = 1, l = 0) : (r = 0, l = 1);
    let h = 0, f = 0, a = 0, c = 0;
    return o = r, h = o === 0 ? w : t, a = o === 0 ? i : e, (o === 0 ? s : n) && (a = -a), o = l, f = o === 0 ? w : t, c = o === 0 ? i : e, (o === 0 ? s : n) && (c = -c), G.eR(h, f, a, c, 0, 0);
  }, eR: (w, t, i, e, s, n) => {
    let o = 0;
    if (e > 0) if (i > 0) {
      const r = w * w, l = t * t, h = w * i, f = t * e;
      let a = -l + f, c = -l + Math.sqrt(h * h + f * f), u = a;
      const d = 9999999999;
      for (let p = 0; p < d && (u = 0.5 * (a + c), !(u === a || u === c)); ++p) {
        const y = h / (u + r), x = f / (u + l), S = y * y + x * x - 1;
        if (S > 0) a = u;
        else if (S < 0) c = u;
        else break;
      }
      s = r * i / (u + r), n = l * e / (u + l);
      const m = s - i, g = n - e;
      o = Math.sqrt(m * m + g * g);
    } else s = 0, n = t, o = Math.abs(e - t);
    else {
      const r = w * w - t * t, l = w * i;
      if (l < r) {
        const h = l / r, f = h * h;
        s = w * h, n = t * Math.sqrt(Math.abs(1 - f));
        const a = s - i;
        o = Math.sqrt(a * a + n * n);
      } else s = w, n = 0, o = Math.abs(i - w);
    }
    return o;
  }, bn: {}, um: new PropertyCollection(), kr: new PropertyCollection(), Pr: 0, dm: 100 };
  G.za = G.ZI;
  var GeometryType2 = ((w) => (w[w.Line = 1] = "Line", w[w.Rectangle = 2] = "Rectangle", w[w.Ellipse = 3] = "Ellipse", w[w.Path = 4] = "Path", w))(GeometryType2 || {}), GeometryStretch2 = ((w) => (w[w.None = 0] = "None", w[w.Default = 1] = "Default", w[w.Fill = 2] = "Fill", w[w.Uniform = 6] = "Uniform", w))(GeometryStretch2 || {});
  class Geometry2 {
    l;
    gm;
    mm;
    Tf;
    Fu;
    Iu;
    to;
    io;
    eo;
    tt;
    Fe;
    Ie;
    le;
    he;
    Ws;
    Lf;
    Df;
    constructor(t, i) {
      Debug && arguments.length > 2 && U.n("Geometry constructor can take at most two optional arguments, the Geometry type and an initialization Object"), GSet2._i(this), this.l = 2, t === void 0 ? t = 4 : Debug && U.W(t, GeometryType2, "GeometryType"), this.tt = t, this.Fe = 0, this.Ie = 0, this.le = 0, this.he = 0, t === 4 ? this.Ws = new List2() : this.Ws = Geometry2.yx, this.gm = this.Ws.ut, this.mm = new Rect2(), this.Tf = null, this.Fu = null, this.Iu = NaN, this.to = Spot2.TopLeft, this.io = Spot2.BottomRight, this.Lf = NaN, this.Df = NaN, this.eo = 2, i && Object.assign(this, i);
    }
    copy() {
      const t = new Geometry2();
      if (t.l = this.l & -2, t.tt = this.tt, t.Fe = this.Fe, t.Ie = this.Ie, t.le = this.le, t.he = this.he, this.tt === 4) {
        const i = this.Ws.h, e = t.Ws;
        for (let s = 0; s < i.length; s++) {
          const n = i[s];
          e.add(n.copy());
        }
        t.Ws = e;
      } else t.Ws = this.Ws;
      return t.gm = this.gm, t.mm.c(this.mm), t.Tf = this.Tf, t.Fu = this.Fu, t.Iu = this.Iu, t.to = this.to.T(), t.io = this.io.T(), t.Lf = this.Lf, t.Df = this.Df, t.eo = this.eo, t;
    }
    static Line = 1;
    static Rectangle = 2;
    static Ellipse = 3;
    static Path = 4;
    static yx = new List2().S();
    get u() {
      return (this.l & 1) !== 0;
    }
    set u(t) {
      t ? this.l |= 1 : this.l &= -2;
    }
    get kt() {
      return (this.l & 2) !== 0;
    }
    set kt(t) {
      t ? this.l |= 2 : this.l &= -3;
    }
    S() {
      if (this.u = true, this.type !== 4) return this;
      const t = this.figures;
      t.S();
      for (const i of t) i.S();
      return this;
    }
    equalsApprox(t) {
      if (!(t instanceof Geometry2)) return false;
      if (this.type !== t.type) return this.type === 1 && t.type === 4 ? this.$A(t) : t.type === 1 && this.type === 4 ? t.$A(this) : false;
      if (this.type === 4) {
        const i = this.figures.h, e = t.figures.h, s = i.length;
        if (s !== e.length) return false;
        for (let n = 0; n < s; n++) {
          const o = i[n], r = e[n];
          if (!o.equalsApprox(r)) return false;
        }
        return true;
      } else return G.p(this.startX, t.startX) && G.p(this.startY, t.startY) && G.p(this.endX, t.endX) && G.p(this.endY, t.endY);
    }
    $A(t) {
      if (this.type !== 1 || t.type !== 4) return false;
      if (t.figures.count === 1) {
        const i = t.figures.elt(0);
        if (i.segments.count === 1 && G.p(this.startX, i.startX) && G.p(this.startY, i.startY)) {
          const e = i.segments.elt(0);
          if (e.type === 2 && G.p(this.endX, e.endX) && G.p(this.endY, e.endY)) return true;
        }
      }
      return false;
    }
    static stringify(t) {
      return t.toString();
    }
    static stringifyFixed(t) {
      return U.i(t, "number", Geometry2, "stringifyFixed:digits"), (i) => i.toString(t);
    }
    gi(t) {
      t in GeometryType2 ? this.type = t : U.xr(this, t);
    }
    toString(t) {
      t === void 0 && (t = -1);
      const i = (s) => s === 0 ? "0" : s.toFixed(t);
      let e;
      switch (this.type) {
        case 1:
          return t < 0 ? "M" + this.startX.toString() + " " + this.startY.toString() + "L" + this.endX.toString() + " " + this.endY.toString() : "M" + i(this.startX) + " " + i(this.startY) + "L" + i(this.endX) + " " + i(this.endY);
        case 2:
          return e = new Rect2(this.startX, this.startY, 0, 0), e.union(this.endX, this.endY, 0, 0), t < 0 ? "M" + e.x.toString() + " " + e.y.toString() + "H" + e.right.toString() + "V" + e.bottom.toString() + "H" + e.left.toString() + "z" : "M" + i(e.x) + " " + i(e.y) + "H" + i(e.right) + "V" + i(e.bottom) + "H" + i(e.left) + "z";
        case 3:
          if (e = new Rect2(this.startX, this.startY, 0, 0), e.union(this.endX, this.endY, 0, 0), t < 0) {
            const r = e.left.toString() + " " + (e.y + e.height / 2).toString(), l = e.right.toString() + " " + (e.y + e.height / 2).toString();
            return "M" + r + "A" + (e.width / 2).toString() + " " + (e.height / 2).toString() + " 0 0 1 " + l + "A" + (e.width / 2).toString() + " " + (e.height / 2).toString() + " 0 0 1 " + r;
          } else {
            const r = i(e.left) + " " + i(e.y + e.height / 2), l = i(e.right) + " " + i(e.y + e.height / 2);
            return "M" + r + "A" + i(e.width / 2) + " " + i(e.height / 2) + " 0 0 1 " + l + "A" + i(e.width / 2) + " " + i(e.height / 2) + " 0 0 1 " + r;
          }
        case 4:
          let s = "";
          const n = this.figures.h, o = n.length;
          for (let r = 0; r < o; r++) {
            const l = n[r];
            r > 0 && (s += " x "), l.isFilled && (s += "F "), s += l.toString(t);
          }
          return s;
        default:
          return GeometryType2[this.type];
      }
    }
    static fillPath(t) {
      typeof t != "string" && U.Ti(t, "string", Geometry2, "fillPath:str");
      const i = t.split(/[Xx]/), e = i.length;
      let s = "";
      for (let n = 0; n < e; n++) {
        const o = i[n];
        if (o.match(/[Ff]/) !== null) {
          n === 0 ? s += o : s += "X" + (o[0] === " " ? "" : " ") + o;
          continue;
        }
        s += (n === 0 ? "" : "X ") + "F" + (o[0] === " " ? "" : " ") + o;
      }
      return s;
    }
    static pm = "UuBbMmZzLlHhVvCcSsQqTtAaFfXx";
    static parse(t, i) {
      i === void 0 && (i = false), typeof t != "string" && U.Ti(t, "string", Geometry2, "parse:str");
      const e = new RegExp("([" + Geometry2.pm + "])([" + Geometry2.pm + "])", "gm"), s = new RegExp("([" + Geometry2.pm + "])([^s])", "gm"), n = new RegExp("([^s])([" + Geometry2.pm + "])", "gm");
      t = t.replace(/,/gm, " "), t = t.replace(e, "$1 $2"), t = t.replace(e, "$1 $2"), t = t.replace(s, "$1 $2"), t = t.replace(n, "$1 $2"), t = t.replace(/([0-9])([+\-])/gm, "$1 $2"), t = t.replace(/[\s\r\t\n]+/gm, " "), t = t.replace(/^\s+|\s+$/g, "");
      const o = t.split(" ");
      for (let L = 0; L < o.length; L++) {
        const T = o[L];
        if (T.match(/(\.[0-9]*)(\.)/gm) !== null) {
          const D = U.ft();
          let F = "", R = false;
          for (let I = 0; I < T.length; I++) {
            const O = T[I];
            O === "." && !R ? (R = true, F += O) : O === "." ? (D.push(F), F = ".") : F += O;
          }
          D.push(F), o.splice(L, 1);
          for (let I = 0; I < D.length; I++) o.splice(L + I, 0, D[I]);
          L += D.length - 1, U.et(D);
        }
      }
      let r = -1, l = "", h = "";
      const f = new Point2(0, 0), a = new Point2(0, 0), c = new Point2(0, 0);
      let u = true;
      function d() {
        return r >= S - 1 || o[r + 1].match(M) !== null ? true : (u = false, false);
      }
      function m() {
        return r++, o[r];
      }
      function g(L) {
        let T = parseFloat(m()), D = parseFloat(m());
        l === l.toLowerCase() && (T = c.x + T, D = c.y + D), L.e(T, D);
      }
      function p() {
        return g(c), c;
      }
      function y() {
        return g(a), a;
      }
      function x() {
        const L = h.toLowerCase();
        return L === "c" || L === "s" || L === "q" || L === "t" ? new Point2(2 * c.x - a.x, 2 * c.y - a.y) : new Point2(c.x, c.y);
      }
      const S = o.length, b = GeoStream.ZA(null);
      let k = false, P = false, A = false, C = true;
      const M = new RegExp("[" + Geometry2.pm + "]");
      for (; !(r >= S - 1); ) {
        if (h = l, l = m(), l === "") continue;
        u = true;
        let L = false;
        switch (l.toUpperCase()) {
          case "X":
            C = true, k = false, P = false;
            break;
          case "M":
            const T = p();
            for (b.Li === null || C === true ? (b.Ru(T.x, T.y, k, false, !P, A), C = false) : b.sR(T.x, T.y), f.c(c); !d(); ) {
              const D = p();
              b.js(D.x, D.y);
            }
            break;
          case "L":
            for (; !d(); ) {
              const D = p();
              b.js(D.x, D.y);
            }
            u && (L = true);
            break;
          case "H":
            for (; !d(); ) c.e((l === l.toLowerCase() ? c.x : 0) + parseFloat(m()), c.y), b.js(c.x, c.y);
            break;
          case "V":
            for (; !d(); ) c.e(c.x, (l === l.toLowerCase() ? c.y : 0) + parseFloat(m())), b.js(c.x, c.y);
            u && (L = true);
            break;
          case "C":
            for (; !d(); ) {
              const D = new Point2();
              g(D);
              const F = y(), R = p();
              b.Mr(D.x, D.y, F.x, F.y, R.x, R.y);
            }
            u && (L = true);
            break;
          case "S":
            for (; !d(); ) {
              const D = x(), F = y(), R = p();
              b.Mr(D.x, D.y, F.x, F.y, R.x, R.y);
            }
            u && (L = true);
            break;
          case "Q":
            for (; !d(); ) {
              const D = y(), F = p();
              b.Ou(D.x, D.y, F.x, F.y);
            }
            u && (L = true);
            break;
          case "T":
            for (; !d(); ) {
              const D = x();
              a.c(D);
              const F = p();
              b.Ou(D.x, D.y, F.x, F.y), a.c(F);
            }
            u && (L = true);
            break;
          case "B":
            for (; !d(); ) {
              const D = parseFloat(m()), F = parseFloat(m());
              let R = parseFloat(m()), I = parseFloat(m());
              const O = parseFloat(m());
              let X = O, K = false;
              d() || (X = parseFloat(m()), d() || (K = parseFloat(m()) !== 0)), l === l.toLowerCase() && (R += c.x, I += c.y), b.nR(D, F, R, I, O, X, K);
            }
            u && (L = true);
            break;
          case "A":
            for (; !d(); ) {
              const D = Math.abs(parseFloat(m())), F = Math.abs(parseFloat(m())), R = parseFloat(m());
              let I = false, O = false, X = 0, K = 0;
              const B = m();
              B.length === 1 ? (I = !!parseFloat(B), O = !!parseFloat(m()), X = parseFloat(m()), K = parseFloat(m())) : B.length === 2 ? (I = !!parseFloat(B[0]), O = !!parseFloat(B[1]), X = parseFloat(m()), K = parseFloat(m())) : (I = !!parseFloat(B[0]), O = !!parseFloat(B[1]), X = parseFloat(B.slice(2)), K = parseFloat(m())), l === l.toLowerCase() && (X = c.x + X, K = c.y + K), c.e(X, K), b.oR(D, F, R, I, O, X, K);
            }
            u && (L = true);
            break;
          case "Z":
            b.rR(), c.c(f);
            break;
          case "F": {
            let D = "", F = 1;
            for (; o[r + F]; ) {
              if (o[r + F] === "0") {
                A = true, F++;
                continue;
              }
              if (o[r + F].match(/[Uu]/) !== null) {
                F++;
                continue;
              }
              if (o[r + F].match(M) === null) {
                F++;
                continue;
              }
              D = o[r + F];
              break;
            }
            D.match(/[Mm]/) ? k = true : b.lR();
            break;
          }
          case "U": {
            let D = "", F = 1;
            for (; o[r + F]; ) {
              if (o[r + F].match(/[Ff]/) !== null) {
                F++;
                continue;
              }
              if (o[r + F].match(M) === null) {
                F++;
                continue;
              }
              D = o[r + F];
              break;
            }
            D.match(/[Mm]/) ? P = true : b.hR(false);
            break;
          }
          default:
            if (l === "0" || l === "1") break;
            U.ot("Unknown geometry command: " + l);
            break;
        }
        if (L) {
          U.ot(`Bad geometry command: ${l}, next token: ${m()},
string: ${t}`);
          break;
        }
      }
      const N = b.ym;
      if (GeoStream.QA(b), i) {
        const L = N.figures.iterator;
        for (; L.next(); ) {
          const T = L.value;
          T.isFilled = true;
        }
      }
      return N;
    }
    static _A(t, i) {
      const e = t.length, s = Point2.a();
      for (let n = 0; n < e; n++) {
        const o = t[n];
        s.x = o[0], s.y = o[1], i.St(s), o[0] = s.x, o[1] = s.y, s.x = o[2], s.y = o[3], i.St(s), o[2] = s.x, o[3] = s.y, s.x = o[4], s.y = o[5], i.St(s), o[4] = s.x, o[5] = s.y, s.x = o[6], s.y = o[7], i.St(s), o[6] = s.x, o[7] = s.y;
      }
      Point2.o(s);
    }
    Gk() {
      if (this.kt) return true;
      if (this.type === 4) {
        const t = this.figures;
        if (this.gm !== t.ut) return true;
        const i = this.figures.h, e = i.length;
        for (let s = 0; s < e; s++) if (i[s].Gk()) return true;
      }
      return false;
    }
    wx() {
      if (this.kt = false, this.Tf = null, this.Fu = null, this.Iu = NaN, this.type === 4) {
        const i = this.figures;
        this.gm = i.ut;
        const e = this.figures.h, s = e.length;
        for (let n = 0; n < s; n++) e[n].aR();
      }
      const t = this.mm;
      isNaN(this.Lf) || isNaN(this.Df) ? t.e(0, 0, 0, 0) : t.e(0, 0, this.Lf, this.Df), this.tT(t, false), t.ai(0, 0, 0, 0);
    }
    computeBoundsWithoutOrigin() {
      const t = new Rect2();
      return this.tT(t, true), t;
    }
    tT(t, i) {
      switch (this.type) {
        case 1:
        case 2:
        case 3:
          i ? t.e(this.Fe, this.Ie, 0, 0) : t.ai(this.Fe, this.Ie, 0, 0), t.ai(this.le, this.he, 0, 0);
          break;
        case 4:
          const e = this.figures, s = e.h, n = e.length;
          for (let o = 0; o < n; o++) {
            const r = s[o];
            i && o === 0 ? t.e(r.startX, r.startY, 0, 0) : t.ai(r.startX, r.startY, 0, 0);
            const h = r.segments.h, f = h.length;
            let a = r.startX, c = r.startY;
            for (let u = 0; u < f; u++) {
              const d = h[u];
              switch (d.type) {
                case 2:
                case 1:
                  a = d.endX, c = d.endY, t.ai(a, c, 0, 0);
                  break;
                case 3:
                  G.Du(a, c, d.point1X, d.point1Y, d.point2X, d.point2Y, d.endX, d.endY, 0.5, t), a = d.endX, c = d.endY;
                  break;
                case 4:
                  G.Uk(a, c, d.point1X, d.point1Y, d.endX, d.endY, 0.5, t), a = d.endX, c = d.endY;
                  break;
                case 5:
                case 6:
                  const m = d.type === 5 ? d.Vo(r) : d.ea(r, a, c), g = m.length;
                  if (g === 0) {
                    a = d.type === 5 ? d.centerX : d.endX, c = d.type === 5 ? d.centerY : d.endY, t.ai(a, c, 0, 0);
                    break;
                  }
                  let p = null;
                  for (let y = 0; y < g; y++) p = m[y], G.Du(p[0], p[1], p[2], p[3], p[4], p[5], p[6], p[7], 0.5, t);
                  p !== null && (a = p[6], c = p[7]);
                  break;
                default:
                  U.n("Unknown Segment type: " + d.type);
              }
            }
          }
          break;
        default:
          U.n("Unknown Geometry type: " + this.type);
      }
    }
    fR(t, i) {
      const e = this.bounds;
      let s = t / e.width, n = i / e.height;
      return isFinite(s) || (s = 1), isFinite(n) || (n = 1), s === 1 && n === 1 ? this : this.copy().scale(s, n);
    }
    normalize() {
      this.u && U.D(this);
      const t = this.computeBoundsWithoutOrigin();
      return this.offset(-t.x, -t.y), new Point2(-t.x, -t.y);
    }
    offset(t, i) {
      return this.u && U.D(this), Debug && (U.r(t, Geometry2, "offset"), U.r(i, Geometry2, "offset")), this.E(1, 0, 0, 1, t, i), this;
    }
    scale(t, i) {
      return this.u && U.D(this), Debug && (U.r(t, Geometry2, "scale:x"), U.r(i, Geometry2, "scale:y"), t === 0 && U.G(t, "scale must be non-zero", Geometry2, "scale:x"), i === 0 && U.G(i, "scale must be non-zero", Geometry2, "scale:y")), this.E(t, 0, 0, i, 0, 0), this;
    }
    rotate(t, i, e) {
      this.u && U.D(this), i === void 0 && (i = 0), e === void 0 && (e = 0), Debug && (U.r(t, Geometry2, "rotate:angle"), U.r(i, Geometry2, "rotate:x"), U.r(e, Geometry2, "rotate:y"));
      const s = Transform.a();
      return s.Ki(), s.Ns(t, i, e), this.E(s.m11, s.m12, s.m21, s.m22, s.dx, s.dy), Transform.o(s), this;
    }
    E(t, i, e, s, n, o) {
      let r = 0, l = 0;
      switch (this.type) {
        case 1:
        case 2:
        case 3:
          r = this.Fe, l = this.Ie, this.Fe = r * t + l * e + n, this.Ie = r * i + l * s + o, r = this.le, l = this.he, this.le = r * t + l * e + n, this.he = r * i + l * s + o;
          break;
        case 4:
          const f = this.figures.h, a = f.length;
          for (let c = 0; c < a; c++) {
            const u = f[c];
            r = u.startX, l = u.startY, u.startX = r * t + l * e + n, u.startY = r * i + l * s + o;
            const m = u.segments.h, g = m.length;
            for (let p = 0; p < g; p++) {
              const y = m[p];
              switch (y.type) {
                case 2:
                case 1:
                  r = y.endX, l = y.endY, y.endX = r * t + l * e + n, y.endY = r * i + l * s + o;
                  break;
                case 3:
                  r = y.point1X, l = y.point1Y, y.point1X = r * t + l * e + n, y.point1Y = r * i + l * s + o, r = y.point2X, l = y.point2Y, y.point2X = r * t + l * e + n, y.point2Y = r * i + l * s + o, r = y.endX, l = y.endY, y.endX = r * t + l * e + n, y.endY = r * i + l * s + o;
                  break;
                case 4:
                  r = y.point1X, l = y.point1Y, y.point1X = r * t + l * e + n, y.point1Y = r * i + l * s + o, r = y.endX, l = y.endY, y.endX = r * t + l * e + n, y.endY = r * i + l * s + o;
                  break;
                case 5:
                  if (r = y.centerX, l = y.centerY, y.centerX = r * t + l * e + n, y.centerY = r * i + l * s + o, i !== 0) {
                    let x = Math.atan2(i, t) * 180 / Math.PI;
                    x < 0 && (x += 360), y.startAngle += x;
                  }
                  t < 0 && (y.startAngle = 180 - y.startAngle, y.sweepAngle = -y.sweepAngle), s < 0 && (y.startAngle = -y.startAngle, y.sweepAngle = -y.sweepAngle), y.radiusX *= Math.sqrt(t * t + e * e), y.radiusY !== void 0 && (y.radiusY *= Math.sqrt(i * i + s * s));
                  break;
                case 6:
                  if (r = y.endX, l = y.endY, y.endX = r * t + l * e + n, y.endY = r * i + l * s + o, y.radiusX === 0 || y.radiusY === 0) break;
                  if (i !== 0) {
                    let x = Math.atan2(i, t) * 180 / Math.PI;
                    x < 0 && (x += 360), y.xAxisRotation += x;
                  }
                  t < 0 && (y.xAxisRotation = 180 - y.xAxisRotation, y.isClockwiseArc = !y.isClockwiseArc), s < 0 && (y.xAxisRotation = -y.xAxisRotation, y.isClockwiseArc = !y.isClockwiseArc), y.radiusX *= Math.sqrt(t * t + e * e), y.radiusY *= Math.sqrt(i * i + s * s);
                  break;
                default:
                  U.n("Unknown Segment type: " + y.type);
              }
            }
          }
          break;
      }
      return this.kt = true, this;
    }
    containsPoint(t, i) {
      i === void 0 && (i = 0);
      const e = this.Fe, s = this.Ie, n = this.le, o = this.he;
      switch (this.type) {
        case 1:
          return G.Ui(e, s, n, o, i, t.x, t.y);
        case 2: {
          const r = Math.min(e, n) - i, l = Math.min(s, o) - i, h = Math.abs(n - e) + i * 2, f = Math.abs(o - s) + i * 2, a = Rect2.U(r, l, h, f), c = a.containsPoint(t);
          return Rect2.o(a), c;
        }
        case 3: {
          let r = Math.min(e, n) - i, l = Math.min(s, o) - i;
          const h = Math.abs(n - e) + i * 2, f = Math.abs(o - s) + i * 2, a = h / 2, c = f / 2;
          return a <= 0 || c <= 0 ? false : (r = t.x - (r + a), l = t.y - (l + c), r * r / (a * a) + l * l / (c * c) <= 1);
        }
        case 4:
          return this.qk(t, i, true, false);
        default:
          return false;
      }
    }
    qk(t, i, e, s) {
      const n = t.x, o = t.y, r = this.bounds.x - 20, l = o;
      let h = 0, f = 0, a = 0, c = 0, u = 0, d = 0;
      const m = this.figures.h, g = m.length;
      for (let p = 0; p < g; p++) {
        const y = m[p], x = !y.isEvenOdd;
        if (y.isFilled) {
          if (e && y.Hk(n, o, i)) return true;
        } else {
          if (y.Hk(n, o, s ? i : i + 2)) return true;
          continue;
        }
        const S = y.segments;
        f = y.startX, a = y.startY;
        let b = f, k = a;
        const P = S.h;
        let A = P[0];
        for (let C = 0; C <= S.length; C++) {
          let M;
          switch (C !== S.length ? (A = P[C], M = A.type, u = A.endX, d = A.endY) : (M = 2, u = b, d = k), M) {
            case 1: {
              const N = this.xx(n, o, r, l, f, a, b, k);
              if (isNaN(N)) return true;
              h += N, b = u, k = d;
              break;
            }
            case 2: {
              const N = this.xx(n, o, r, l, f, a, u, d);
              if (isNaN(N)) return true;
              h += N;
              break;
            }
            case 3:
              c = G.cm(f, a, A.point1X, A.point1Y, A.point2X, A.point2Y, u, d, r, l, n, o, 0.5), h += c;
              break;
            case 4: {
              const N = (f + 2 * A.point1X) / 3, L = (a + 2 * A.point1Y) / 3, T = (A.point1X * 2 + u) / 3, D = (A.point1Y * 2 + d) / 3;
              c = G.cm(f, a, N, L, T, D, u, d, r, l, n, o, 0.5), h += c;
              break;
            }
            case 5:
            case 6: {
              const N = A.type === 5 ? A.Vo(y) : A.ea(y, f, a), L = N.length;
              if (L === 0) {
                const D = this.xx(n, o, r, l, f, a, A.type === 5 ? A.centerX : A.endX, A.type === 5 ? A.centerY : A.endY);
                if (isNaN(D)) return true;
                h += D;
                break;
              }
              let T = null;
              for (let D = 0; D < L; D++) {
                if (T = N[D], D === 0) {
                  const F = this.xx(n, o, r, l, f, a, T[0], T[1]);
                  if (isNaN(F)) return true;
                  h += F;
                }
                c = G.cm(T[0], T[1], T[2], T[3], T[4], T[5], T[6], T[7], r, l, n, o, 0.5), h += c;
              }
              T !== null && (u = T[6], d = T[7]);
              break;
            }
            default:
              U.n("Unknown Segment type: " + A.type);
          }
          f = u, a = d;
        }
        if (x) {
          if (h !== 0) return true;
        } else if (h % 2 !== 0) return true;
        h = 0;
      }
      return false;
    }
    xx(t, i, e, s, n, o, r, l) {
      if (G.Ui(n, o, r, l, 0.05, t, i)) return NaN;
      const h = (t - e) * (o - l);
      if (h === 0) return 0;
      const f = ((t * s - i * e) * (n - r) - (t - e) * (n * l - o * r)) / h, a = (t * s - i * e) * (o - l) / h;
      if (f >= t) return 0;
      if ((n > r ? n - r : r - n) < (o > l ? o - l : l - o)) {
        if (o < l) {
          if (a < o || a > l) return 0;
        } else if (a < l || a > o) return 0;
      } else if (n < r) {
        if (f < n || f > r) return 0;
      } else if (f < r || f > n) return 0;
      return h > 0 ? 1 : -1;
    }
    iT(t, i, e) {
      const s = this.figures.h, n = s.length;
      for (let o = 0; o < n; o++) if (s[o].Hk(t, i, e)) return true;
      return false;
    }
    getPointAlongPath(t, i) {
      if (t < 0 ? t = 0 : t > 1 && (t = 1), i === void 0 && (i = new Point2()), this.type === 1) return i.e(this.startX + t * (this.endX - this.startX), this.startY + t * (this.endY - this.startY)), i;
      const e = this.flattenedSegments, s = this.flattenedLengths, n = this.flattenedTotalLength, o = e.length, r = n * t;
      let l = 0;
      for (let h = 0; h < o; h++) {
        const f = s[h], a = f.length;
        for (let c = 0; c < a; c++) {
          const u = f[c];
          if (l + u >= r) {
            const d = r - l, m = u === 0 ? 0 : d / u, g = e[h], p = g[c * 2], y = g[c * 2 + 1], x = g[c * 2 + 2], S = g[c * 2 + 3];
            return i.e(p + (x - p) * m, y + (S - y) * m), i;
          }
          l += u;
        }
      }
      return i;
    }
    getAngleAlongPath(t) {
      if (t < 0 ? t = 0 : t > 1 && (t = 1), this.type === 1) return Math.atan2(this.endY - this.startY, this.endX - this.startX) * 180 / Math.PI;
      const i = this.flattenedSegments, e = this.flattenedLengths, s = this.flattenedTotalLength, n = i.length, o = s * t;
      let r = 0;
      for (let l = 0; l < n; l++) {
        const h = e[l], f = h.length;
        for (let a = 0; a < f; a++) {
          const c = h[a];
          if (r + c >= o) {
            const u = i[l], d = u[a * 2], m = u[a * 2 + 1], g = u[a * 2 + 2], p = u[a * 2 + 3];
            return Math.abs(g - d) < 1 && Math.abs(p - m) < 1 ? 0 : Math.abs(g - d) < 1 ? p - m >= 0 ? 90 : 270 : Math.abs(p - m) < 1 ? g - d >= 0 ? 0 : 180 : Math.atan2(p - m, g - d) * 180 / Math.PI;
          }
          r += c;
        }
      }
      return NaN;
    }
    getPointAndAngleAlongPath(t, i) {
      if (t < 0 ? t = 0 : t > 1 && (t = 1), i === void 0 && (i = []), i.length = 3, this.type === 1) return i[0] = this.startX + t * (this.endX - this.startX), i[1] = this.startY + t * (this.endY - this.startY), i[2] = Math.atan2(this.endY - this.startY, this.endX - this.startX) * 180 / Math.PI, i;
      const e = this.flattenedSegments, s = this.flattenedLengths, n = this.flattenedTotalLength, o = e.length, r = n * t;
      let l = 0;
      for (let h = 0; h < o; h++) {
        const f = s[h], a = f.length;
        for (let c = 0; c < a; c++) {
          const u = f[c];
          if (l + u >= r) {
            const d = r - l, m = u === 0 ? 0 : d / u, g = e[h], p = g[c * 2], y = g[c * 2 + 1], x = g[c * 2 + 2], S = g[c * 2 + 3];
            i[0] = p + (x - p) * m, i[1] = y + (S - y) * m;
            let b;
            return Math.abs(x - p) < 1 && Math.abs(S - y) < 1 ? b = 0 : Math.abs(x - p) < 1 ? b = S - y >= 0 ? 90 : 270 : Math.abs(S - y) < 1 ? b = x - p >= 0 ? 0 : 180 : b = Math.atan2(S - y, x - p) * 180 / Math.PI, i[2] = b, i;
          }
          l += u;
        }
      }
      return i;
    }
    getFractionForPoint(t) {
      if (this.type === 1) {
        const i = this.startX, e = this.startY, s = this.endX, n = this.endY;
        if (i === s && e === n) return 0;
        {
          const o = t.x, r = t.y;
          let l = 0, h = 0;
          if (i === s) return e < n ? (l = e, h = n) : (l = n, h = e), r <= l ? l === e ? 0 : 1 : r >= h ? h === e ? 0 : 1 : Math.abs(r - e) / (h - l);
          if (e === n) return i < s ? (l = i, h = s) : (l = s, h = i), o <= l ? l === i ? 0 : 1 : o >= h ? h === i ? 0 : 1 : Math.abs(o - i) / (h - l);
          {
            const f = (s - i) ** 2 + (n - e) ** 2, a = Point2.a();
            G.Ll(i, e, s, n, o, r, a);
            const c = a.x, u = a.y;
            return Point2.o(a), Math.sqrt(((c - i) ** 2 + (u - e) ** 2) / f);
          }
        }
      } else if (this.type === 2) {
        const i = this.startX, e = this.startY, s = this.endX, n = this.endY;
        if (i === s && e === n) return 0;
        {
          const o = s - i, r = n - e, l = o * 2 + r * 2;
          let h = t.x, f = t.y;
          h = Math.min(Math.max(h, i), s), f = Math.min(Math.max(f, e), n);
          const a = Math.abs(h - i), c = Math.abs(h - s), u = Math.abs(f - e), d = Math.abs(f - n), m = Math.min(a, c, u, d);
          if (m === u) return h / l;
          if (m === c) return (o + f) / l;
          if (m === d) return (o * 2 + r - h) / l;
          if (m === a) return (o * 2 + r * 2 - f) / l;
        }
      } else {
        const i = this.flattenedSegments, e = this.flattenedLengths, s = this.flattenedTotalLength, n = Point2.a();
        let o = 1 / 0, r = 0, l = 0;
        const h = i.length;
        let f = 0, a = 0;
        for (let u = 0; u < h; u++) {
          const d = i[u], m = e[u], g = d.length;
          for (let p = 0; p < g; p += 2) {
            const y = d[p], x = d[p + 1];
            if (p === 0) {
              f = y, a = x;
              continue;
            }
            G.Ll(f, a, y, x, t.x, t.y, n);
            const S = (n.x - t.x) ** 2 + (n.y - t.y) ** 2;
            S < o && (o = S, r = l, r += Math.sqrt((n.x - f) ** 2 + (n.y - a) ** 2)), l += m[(p - 2) / 2], f = y, a = x;
          }
        }
        Point2.o(n);
        const c = r / s;
        return c < 0 ? 0 : c > 1 ? 1 : c;
      }
      return 0;
    }
    get flattenedSegments() {
      return this.eT(), this.Tf;
    }
    eT() {
      if (this.Tf === null) {
        const t = this.Tf = [], i = this.Fu = [];
        this.cR(t, i);
      }
    }
    get flattenedLengths() {
      return this.eT(), this.Fu;
    }
    get flattenedTotalLength() {
      let t = this.Iu;
      if (isNaN(t)) {
        if (this.type === 1) {
          const i = Math.abs(this.endX - this.startX), e = Math.abs(this.endY - this.startY);
          t = Math.sqrt(i * i + e * e);
        } else if (this.type === 2) {
          const i = Math.abs(this.endX - this.startX), e = Math.abs(this.endY - this.startY);
          t = i * 2 + e * 2;
        } else {
          const i = this.flattenedLengths, e = i.length;
          t = 0;
          for (let s = 0; s < e; s++) {
            const n = i[s], o = n.length;
            for (let r = 0; r < o; r++) t += n[r];
          }
        }
        this.Iu = t;
      }
      return t;
    }
    vk(t) {
      const i = [];
      let e = 0, s = 0;
      const n = t.length;
      for (let o = 0; o < n; o += 2) {
        const r = t[o], l = t[o + 1];
        if (o === 0) {
          e = r, s = l;
          continue;
        }
        const h = Math.sqrt(Point2.distanceSquared(e, s, r, l));
        i.push(h), e = r, s = l;
      }
      return i;
    }
    cR(t, i) {
      let e = [];
      const s = [];
      if (this.type === 1) e.push(this.startX), e.push(this.startY), e.push(this.endX), e.push(this.endY), t.push(e), s.push(Math.sqrt((this.startX - this.endX) ** 2 + (this.startY - this.endY) ** 2)), i.push(s);
      else if (this.type === 2) e.push(this.startX), e.push(this.startY), e.push(this.endX), e.push(this.startY), e.push(this.endX), e.push(this.endY), e.push(this.startX), e.push(this.endY), e.push(this.startX), e.push(this.startY), t.push(e), s.push(Math.abs(this.startX - this.endX)), s.push(Math.abs(this.startY - this.endY)), s.push(Math.abs(this.startX - this.endX)), s.push(Math.abs(this.startY - this.endY)), i.push(s);
      else if (this.type === 3) {
        const n = new PathFigure2();
        n.startX = this.endX, n.startY = (this.startY + this.endY) / 2;
        const o = new PathSegment2(5);
        o.startAngle = 0, o.sweepAngle = 360, o.centerX = (this.startX + this.endX) / 2, o.centerY = (this.startY + this.endY) / 2, o.radiusX = Math.abs(this.startX - this.endX) / 2, o.radiusY = Math.abs(this.startY - this.endY) / 2, n.add(o);
        const r = o.Vo(n), l = r.length;
        if (l === 0) e.push(o.centerX), e.push(o.centerY);
        else {
          let h = n.startX, f = n.startY;
          for (let a = 0; a < l; a++) {
            const c = r[a];
            G._n(h, f, c[2], c[3], c[4], c[5], c[6], c[7], 0.5, e), h = c[6], f = c[7];
          }
        }
        t.push(e), i.push(this.vk(e));
      } else {
        const n = this.figures.iterator;
        for (; n.next(); ) {
          const o = n.value;
          e = [], e.push(o.startX), e.push(o.startY);
          let r = o.startX, l = o.startY, h = r, f = l;
          const a = o.segments.h, c = a.length;
          for (let u = 0; u < c; u++) {
            const d = a[u];
            switch (d.type) {
              case 1:
                e.length >= 4 && (t.push(e), i.push(this.vk(e))), e = [], e.push(d.endX), e.push(d.endY), r = d.endX, l = d.endY, h = r, f = l;
                break;
              case 2:
                e.push(d.endX), e.push(d.endY), r = d.endX, l = d.endY;
                break;
              case 3:
                G._n(r, l, d.point1X, d.point1Y, d.point2X, d.point2Y, d.endX, d.endY, 0.5, e), r = d.endX, l = d.endY;
                break;
              case 4:
                G.am(r, l, d.point1X, d.point1Y, d.endX, d.endY, 0.5, e), r = d.endX, l = d.endY;
                break;
              case 5: {
                const m = d.Vo(o), g = m.length;
                if (g === 0) {
                  e.push(d.centerX), e.push(d.centerY), r = d.centerX, l = d.centerY;
                  break;
                }
                for (let p = 0; p < g; p++) {
                  const y = m[p];
                  G._n(r, l, y[2], y[3], y[4], y[5], y[6], y[7], 0.5, e), r = y[6], l = y[7];
                }
                break;
              }
              case 6: {
                const m = d.ea(o, r, l), g = m.length, p = d.endX, y = d.endY;
                if (g === 0) {
                  e.push(p), e.push(y), r = p, l = y;
                  break;
                }
                for (let x = 0; x < g; x++) {
                  const S = m[x];
                  G._n(r, l, S[2], S[3], S[4], S[5], S[6], S[7], 0.5, e), r = S[6], l = S[7];
                }
                break;
              }
              default:
                U.n("Segment not of valid type: " + d.type);
            }
            d.isClosed && (e.push(h), e.push(f));
          }
          e.length >= 4 && (t.push(e), i.push(this.vk(e)));
        }
      }
    }
    get type() {
      return this.tt;
    }
    set type(t) {
      this.tt !== t && (Debug && U.W(t, GeometryType2, "GeometryType"), this.u && U.D(this, t), this.tt = t, t === 4 ? this.Ws = new List2() : (Geometry2.yx === null && (Geometry2.yx = new List2().S()), this.Ws = Geometry2.yx), this.kt = true);
    }
    get startX() {
      return this.Fe;
    }
    set startX(t) {
      this.Fe !== t && (Debug && U.r(t, Geometry2, "startX"), this.u && U.D(this, t), this.Fe = t, this.kt = true);
    }
    get startY() {
      return this.Ie;
    }
    set startY(t) {
      this.Ie !== t && (Debug && U.r(t, Geometry2, "startY"), this.u && U.D(this, t), this.Ie = t, this.kt = true);
    }
    get endX() {
      return this.le;
    }
    set endX(t) {
      this.le !== t && (Debug && U.r(t, Geometry2, "endX"), this.u && U.D(this, t), this.le = t, this.kt = true);
    }
    get endY() {
      return this.he;
    }
    set endY(t) {
      this.he !== t && (Debug && U.r(t, Geometry2, "endY"), this.u && U.D(this, t), this.he = t, this.kt = true);
    }
    get figures() {
      return this.Ws;
    }
    set figures(t) {
      this.Ws !== t && (Debug && U.s(t, List2, Geometry2, "figures"), this.u && U.D(this, t), this.Ws = t, this.kt = true);
    }
    add(t) {
      return Debug && U.s(t, PathFigure2, Geometry2, "add"), this.Ws.add(t), this;
    }
    setSpots(t, i, e, s, n, o, r, l) {
      return this.u && U.D(this), this.to = new Spot2(t, i, n, o), this.io = new Spot2(e, s, r, l), this;
    }
    get spot1() {
      return this.to;
    }
    set spot1(t) {
      Debug && U.s(t, Spot2, Geometry2, "spot1"), this.u && U.D(this, t), this.to = t.T();
    }
    get spot2() {
      return this.io;
    }
    set spot2(t) {
      Debug && U.s(t, Spot2, Geometry2, "spot2"), this.u && U.D(this, t), this.io = t.T();
    }
    get defaultStretch() {
      return this.eo;
    }
    set defaultStretch(t) {
      this.eo = t;
    }
    get bounds() {
      return this.Gk() && this.wx(), this.mm;
    }
    polygonClosestSegment(t, i) {
      if (i === void 0 && (i = 10), this.type !== 4) return null;
      const e = t.x, s = t.y;
      let n = 1 / 0, o = 0, r = 0, l = 0, h = 0, f = 0, a = 0, c = 0, u = 0;
      return this.figures.each((d) => {
        let m = d.startX, g = d.startY;
        d.segments.each((p) => {
          let y = p.endX, x = p.endY, S = 0;
          if (p.type === 2) S = Point2.distanceLineSegmentSquared(e, s, m, g, y, x);
          else {
            m = p.endX, g = p.endY;
            return;
          }
          S < n && (n = S, o = l, r = h, f = m, a = g, c = y, u = x), m = y, g = x, h++, p.isClosed && (y = d.startX, x = d.startY, S = Point2.distanceLineSegmentSquared(e, s, m, g, y, x), S < n && (n = S, o = l, r = h, f = m, a = g, c = y, u = x), h++);
        }), l++, h = 0;
      }), n < i * i ? { figi: o, segi: r, ax: f, ay: a, bx: c, by: u } : null;
    }
    get polygonArea() {
      if (this.type === 4) {
        const t = this.figures.iterator;
        let i = 0, e = 0, s = 0, n = 0, o = 0;
        for (; t.next(); ) {
          const r = t.value;
          if (!r.isFilled) continue;
          i = r.startX, e = r.startY;
          const l = r.segments.iterator;
          for (; l.next(); ) {
            const h = l.value;
            s = h.endX, n = h.endY, h.type === 1 || h.type !== 5 && (o += i * n - e * s), i = s, e = n;
          }
          o += i * r.startY - e * r.startX;
        }
        return Math.abs(o) / 2;
      } else if (this.type === 2) {
        const t = Math.abs(this.startX - this.endX), i = Math.abs(this.startY - this.endY);
        return t * i;
      } else if (this.type === 3) {
        const t = Math.abs(this.startX - this.endX), i = Math.abs(this.startY - this.endY);
        return Math.PI * t / 2 * i / 2;
      } else return 0;
    }
    get polygonLength() {
      if (this.type === 4) {
        const t = this.figures.iterator;
        let i = 0, e = 0, s = 0, n = 0, o = 0;
        for (; t.next(); ) {
          const r = t.value;
          i = r.startX, e = r.startY;
          const l = r.segments.iterator;
          for (; l.next(); ) {
            const f = l.value;
            s = f.endX, n = f.endY, f.type === 1 || f.type !== 5 && (o += Math.sqrt((s - i) * (s - i) + (n - e) * (n - e))), i = s, e = n;
          }
          const h = r.segments.last();
          h && h.isClosed && (s = r.startX, n = r.startY, o += Math.sqrt((s - i) * (s - i) + (n - e) * (n - e)));
        }
        return o;
      } else if (this.type === 2) {
        const t = Math.abs(this.startX - this.endX), i = Math.abs(this.startY - this.endY);
        return t * 2 + i * 2;
      } else if (this.type === 3) {
        const t = Math.abs(this.startX - this.endX) / 2, i = Math.abs(this.startY - this.endY) / 2;
        if (t + i === 0) return 0;
        const e = (t - i) * (t - i) / ((t + i) * (t + i));
        let s = e, n = 1 + s / 4;
        return s *= e, n += s / 64, s *= e, n += s / 256, s *= e, n += s * 25 / 16384, s *= e, n += s * 49 / 65536, s *= e, n += s * 441 / 1048576, Math.PI * (t + i) * n;
      } else {
        const t = this.startX, i = this.startY, e = this.endX, s = this.endY;
        return Math.sqrt((e - t) * (e - t) + (s - i) * (s - i));
      }
    }
    static computeConvexHull(t) {
      t.sort((s, n) => s.x === n.x ? n.y - s.y : n.x - s.x);
      const i = [];
      for (let s = 0; s < t.length; s++) {
        for (; i.length >= 2 && t[s].compareWithLineSegmentPoint(i[i.length - 2], i[i.length - 1]) >= 0; ) i.pop();
        i.push(t[s]);
      }
      i.pop();
      const e = [];
      for (let s = t.length - 1; s >= 0; s--) {
        for (; e.length >= 2 && t[s].compareWithLineSegmentPoint(e[e.length - 2], e[e.length - 1]) >= 0; ) e.pop();
        e.push(t[s]);
      }
      return e.pop(), i.concat(e);
    }
    static generatePolygon(t, i, e) {
      i === void 0 && (i = 0), e === void 0 && (e = true);
      const s = new Geometry2();
      if (t.length > 1) if (i > 0) if (e) {
        t.push(t[0]), t.push(t[1]);
        let n = true;
        const o = new PathFigure2(0, 0, e, false);
        for (let l = 1; l < t.length; l++) {
          const h = (t[l - 1].x + t[l].x) / 2, f = (t[l - 1].y + t[l].y) / 2, a = t[l - 1].distanceSquaredPoint(t[l]), c = 0.5 * i / Math.sqrt(a);
          if (c < 0.5) {
            const u = t[l - 1].x + (t[l].x - t[l - 1].x) * c, d = t[l - 1].y + (t[l].y - t[l - 1].y) * c;
            if (n ? (n = false, o.startX = u, o.startY = d) : o.add(new PathSegment2(3, u, d, t[l - 1].x, t[l - 1].y, t[l - 1].x, t[l - 1].y)), l < t.length - 1) {
              const m = t[l].x + (t[l - 1].x - t[l].x) * c, g = t[l].y + (t[l - 1].y - t[l].y) * c;
              o.add(new PathSegment2(2, m, g));
            }
          } else n ? (n = false, o.startX = h, o.startY = f) : o.add(new PathSegment2(3, h, f, t[l - 1].x, t[l - 1].y, t[l - 1].x, t[l - 1].y));
        }
        const r = o.segments.last();
        r && r.close(), s.add(o);
      } else {
        const n = new PathFigure2(t[0].x, t[0].y, false, false);
        for (let o = 1; o < t.length; o++) {
          const r = (t[o - 1].x + t[o].x) / 2, l = (t[o - 1].y + t[o].y) / 2, h = t[o - 1].distanceSquaredPoint(t[o]), f = 0.5 * i / Math.sqrt(h);
          if (f < 0.5) {
            if (o > 1) {
              const u = t[o - 1].x + (t[o].x - t[o - 1].x) * f, d = t[o - 1].y + (t[o].y - t[o - 1].y) * f;
              n.add(new PathSegment2(3, u, d, t[o - 1].x, t[o - 1].y, t[o - 1].x, t[o - 1].y));
            }
            const a = t[o].x + (t[o - 1].x - t[o].x) * f, c = t[o].y + (t[o - 1].y - t[o].y) * f;
            n.add(new PathSegment2(2, a, c));
          } else o > 1 && n.add(new PathSegment2(3, r, l, t[o - 1].x, t[o - 1].y, t[o - 1].x, t[o - 1].y));
          o === t.length - 1 && n.add(new PathSegment2(2, t[o].x, t[o].y));
        }
        s.add(n);
      }
      else {
        const n = new PathFigure2(t[0].x, t[0].y, e, false);
        for (let o = 1; o < t.length; o++) n.add(new PathSegment2(2, t[o].x, t[o].y));
        if (e) {
          const o = n.segments.last();
          o && o.close();
        }
        s.add(n);
      }
      return s;
    }
  }
  Geometry2.stringify = Geometry2.stringify, Geometry2.stringifyFixed = Geometry2.stringifyFixed, Geometry2.fillPath = Geometry2.fillPath, Geometry2.parse = Geometry2.parse;
  class PathFigure2 {
    l;
    Fe;
    Ie;
    Ff;
    wm;
    $e;
    constructor(t, i, e, s, n) {
      e === void 0 && (e = true), s === void 0 && (s = true), n === void 0 && (n = false), this.l = 2 | (e ? 4 : 0) | (s ? 8 : 0) | (n ? 16 : 0), t !== void 0 ? (Debug && U.r(t, PathFigure2, "sx"), this.Fe = t) : this.Fe = 0, i !== void 0 ? (Debug && U.r(i, PathFigure2, "sy"), this.Ie = i) : this.Ie = 0, this.Ff = new List2(), this.wm = this.Ff.ut, this.$e = null;
    }
    copy() {
      const t = new PathFigure2();
      t.l = this.l & -2, t.Fe = this.Fe, t.Ie = this.Ie;
      const i = this.Ff.h, e = i.length, s = t.Ff;
      for (let n = 0; n < e; n++) {
        const r = i[n].copy();
        s.add(r);
      }
      return t.wm = this.wm, t.$e = this.$e, t;
    }
    equalsApprox(t) {
      if (!(t instanceof PathFigure2) || !G.p(this.startX, t.startX) || !G.p(this.startY, t.startY)) return false;
      const i = this.segments.h, e = t.segments.h, s = i.length;
      if (s !== e.length) return false;
      for (let n = 0; n < s; n++) {
        const o = i[n], r = e[n];
        if (!o.equalsApprox(r)) return false;
      }
      return true;
    }
    toString(t) {
      t === void 0 && (t = -1);
      let i = "";
      if (t < 0) i = "M" + this.startX.toString() + " " + this.startY.toString();
      else {
        const n = (o) => o === 0 ? "0" : o.toFixed(t);
        i = "M" + n(this.startX) + " " + n(this.startY);
      }
      const e = this.segments.h, s = e.length;
      for (let n = 0; n < s; n++) {
        const o = e[n];
        i += " " + o.toString(t);
      }
      return i;
    }
    get u() {
      return (this.l & 1) !== 0;
    }
    set u(t) {
      t ? this.l |= 1 : this.l &= -2;
    }
    get kt() {
      return (this.l & 2) !== 0;
    }
    set kt(t) {
      t ? this.l |= 2 : this.l &= -3;
    }
    S() {
      this.u = true;
      const t = this.segments;
      t.S();
      const i = t.h, e = t.length;
      for (let s = 0; s < e; s++) i[s].S();
      return this;
    }
    Gk() {
      if (this.kt) return true;
      const t = this.segments;
      if (this.wm !== t.ut) return true;
      for (const i of t) if (i.kt) return true;
      return false;
    }
    aR() {
      this.kt = false, this.$e = null;
      const t = this.segments;
      this.wm = t.ut;
      for (const i of t) i.kt = false, i.Js = null;
    }
    get isFilled() {
      return (this.l & 4) !== 0;
    }
    set isFilled(t) {
      Debug && U.i(t, "boolean", PathFigure2, "isFilled"), this.u && U.D(this, t), t ? this.l |= 4 : this.l &= -5;
    }
    get isShadowed() {
      return (this.l & 8) !== 0;
    }
    set isShadowed(t) {
      Debug && U.i(t, "boolean", PathFigure2, "isShadowed"), this.u && U.D(this, t), t ? this.l |= 8 : this.l &= -9;
    }
    get isEvenOdd() {
      return (this.l & 16) !== 0;
    }
    set isEvenOdd(t) {
      Debug && U.i(t, "boolean", PathFigure2, "isEvenOdd"), this.u && U.D(this, t), t ? this.l |= 16 : this.l &= -17;
    }
    get startX() {
      return this.Fe;
    }
    set startX(t) {
      Debug && U.r(t, PathFigure2, "startX"), this.u && U.D(this, t), this.Fe = t, this.$e = null, this.kt = true;
    }
    get startY() {
      return this.Ie;
    }
    set startY(t) {
      Debug && U.r(t, PathFigure2, "startY"), this.u && U.D(this, t), this.Ie = t, this.$e = null, this.kt = true;
    }
    get segments() {
      return this.Ff;
    }
    set segments(t) {
      Debug && U.s(t, List2, PathFigure2, "segments"), this.u && U.D(this, t), this.Ff = t, this.$e = null, this.kt = true;
    }
    add(t) {
      return Debug && U.s(t, PathSegment2, PathFigure2, "add"), this.Ff.add(t), this.$e = null, this;
    }
    Hk(t, i, e) {
      const s = this;
      let n = s.startX, o = s.startY, r = n, l = o;
      const h = s.segments.h, f = h.length;
      for (let a = 0; a < f; a++) {
        const c = h[a];
        switch (c.type) {
          case 1:
            r = c.endX, l = c.endY, n = c.endX, o = c.endY;
            break;
          case 2:
            if (G.Ui(n, o, c.endX, c.endY, e, t, i)) return true;
            n = c.endX, o = c.endY;
            break;
          case 3:
            if (G.gx(n, o, c.point1X, c.point1Y, c.point2X, c.point2Y, c.endX, c.endY, 0.5, t, i, e)) return true;
            n = c.endX, o = c.endY;
            break;
          case 4:
            if (G.Kk(n, o, c.point1X, c.point1Y, c.endX, c.endY, 0.5, t, i, e)) return true;
            n = c.endX, o = c.endY;
            break;
          case 5:
          case 6:
            const u = c.type === 5 ? c.Vo(s) : c.ea(s, n, o), d = u.length, m = c.type === 5 ? c.centerX : c.endX, g = c.type === 5 ? c.centerY : c.endY;
            if (d === 0) {
              if (G.Ui(n, o, m, g, e, t, i)) return true;
              n = m, o = g;
              break;
            }
            let p = null;
            for (let y = 0; y < d; y++) if (p = u[y], y === 0 && G.Ui(n, o, p[0], p[1], e, t, i) || G.gx(p[0], p[1], p[2], p[3], p[4], p[5], p[6], p[7], 0.5, t, i, e)) return true;
            p !== null && (n = p[6], o = p[7]);
            break;
          default:
            U.n("Unknown Segment type: " + c.type);
        }
        if (c.isClosed && (n !== r || o !== l) && G.Ui(n, o, r, l, e, t, i)) return true;
      }
      return false;
    }
  }
  var SegmentType2 = ((w) => (w[w.Move = 1] = "Move", w[w.Line = 2] = "Line", w[w.Bezier = 3] = "Bezier", w[w.QuadraticBezier = 4] = "QuadraticBezier", w[w.Arc = 5] = "Arc", w[w.SvgArc = 6] = "SvgArc", w))(SegmentType2 || {});
  class PathSegment2 {
    tt;
    l;
    le;
    he;
    Sn;
    Fl;
    Il;
    Nr;
    Js;
    constructor(t, i, e, s, n, o, r, l) {
      if (GSet2._i(this), t === void 0 ? t = 2 : Debug && U.W(t, SegmentType2, "SegmentType"), this.tt = t, this.l = 2, i !== void 0 ? (Debug && U.r(i, PathSegment2, "ex"), this.le = i) : this.le = 0, e !== void 0 ? (Debug && U.r(e, PathSegment2, "ey"), this.he = e) : this.he = 0, s === void 0 && (s = 0), n === void 0 && (n = 0), o === void 0 && (o = 0), r === void 0 && (r = 0), t === 6) {
        let h = o;
        h = h % 360, h < 0 && (h += 360), this.Sn = h, this.Fl = 0, Debug && U.r(s, PathSegment2, "x1"), this.Il = Math.max(s, 0), Debug && U.r(n, PathSegment2, "y1"), this.Nr = Math.max(n, 0), typeof r == "boolean" ? r && (this.isLargeArc = true) : typeof r == "number" && r && (this.isLargeArc = true), l && (this.isClockwiseArc = true);
      } else Debug && U.r(s, PathSegment2, "x1"), this.Sn = s, Debug && U.r(n, PathSegment2, "y1"), this.Fl = n, Debug && U.r(o, PathSegment2, "x2"), t === 5 && (o = Math.max(o, 0)), this.Il = o, typeof r == "number" ? (t === 5 && (r = Math.max(r, 0)), this.Nr = r) : this.Nr = 0;
      this.Js = null;
    }
    copy() {
      const t = new PathSegment2();
      return t.tt = this.tt, t.l = this.l & -2, t.le = this.le, t.he = this.he, t.Sn = this.Sn, t.Fl = this.Fl, t.Il = this.Il, t.Nr = this.Nr, t;
    }
    equalsApprox(t) {
      if (!(t instanceof PathSegment2) || this.type !== t.type || this.isClosed !== t.isClosed) return false;
      switch (this.type) {
        case 1:
        case 2:
          return G.p(this.endX, t.endX) && G.p(this.endY, t.endY);
        case 3:
          return G.p(this.endX, t.endX) && G.p(this.endY, t.endY) && G.p(this.point1X, t.point1X) && G.p(this.point1Y, t.point1Y) && G.p(this.point2X, t.point2X) && G.p(this.point2Y, t.point2Y);
        case 4:
          return G.p(this.endX, t.endX) && G.p(this.endY, t.endY) && G.p(this.point1X, t.point1X) && G.p(this.point1Y, t.point1Y);
        case 5:
          return G.p(this.startAngle, t.startAngle) && G.p(this.sweepAngle, t.sweepAngle) && G.p(this.centerX, t.centerX) && G.p(this.centerY, t.centerY) && G.p(this.radiusX, t.radiusX) && G.p(this.radiusY, t.radiusY);
        case 6:
          return this.isClockwiseArc === t.isClockwiseArc && this.isLargeArc === t.isLargeArc && G.p(this.xAxisRotation, t.xAxisRotation) && G.p(this.endX, t.endX) && G.p(this.endY, t.endY) && G.p(this.radiusX, t.radiusX) && G.p(this.radiusY, t.radiusY);
        default:
          return false;
      }
    }
    gi(t) {
      t in SegmentType2 ? this.type = t : U.xr(this, t);
    }
    toString(t) {
      t === void 0 && (t = -1);
      const i = (s) => s === 0 ? "0" : s.toFixed(t);
      let e = "";
      switch (this.type) {
        case 1:
          t < 0 ? e = "M" + this.endX.toString() + " " + this.endY.toString() : e = "M" + i(this.endX) + " " + i(this.endY);
          break;
        case 2:
          t < 0 ? e = "L" + this.endX.toString() + " " + this.endY.toString() : e = "L" + i(this.endX) + " " + i(this.endY);
          break;
        case 3:
          t < 0 ? e = "C" + this.point1X.toString() + " " + this.point1Y.toString() + " " + this.point2X.toString() + " " + this.point2Y.toString() + " " + this.endX.toString() + " " + this.endY.toString() : e = "C" + i(this.point1X) + " " + i(this.point1Y) + " " + i(this.point2X) + " " + i(this.point2Y) + " " + i(this.endX) + " " + i(this.endY);
          break;
        case 4:
          t < 0 ? e = "Q" + this.point1X.toString() + " " + this.point1Y.toString() + " " + this.endX.toString() + " " + this.endY.toString() : e = "Q" + i(this.point1X) + " " + i(this.point1Y) + " " + i(this.endX) + " " + i(this.endY);
          break;
        case 5:
          t < 0 ? e = "B" + this.startAngle.toString() + " " + this.sweepAngle.toString() + " " + this.centerX.toString() + " " + this.centerY.toString() + " " + this.radiusX.toString() + " " + this.radiusY.toString() : e = "B" + i(this.startAngle) + " " + i(this.sweepAngle) + " " + i(this.centerX) + " " + i(this.centerY) + " " + i(this.radiusX) + " " + i(this.radiusY);
          break;
        case 6:
          t < 0 ? e = "A" + this.radiusX.toString() + " " + this.radiusY.toString() + " " + this.xAxisRotation.toString() + " " + (this.isLargeArc ? 1 : 0) + " " + (this.isClockwiseArc ? 1 : 0) + " " + this.endX.toString() + " " + this.endY.toString() : e = "A" + i(this.radiusX) + " " + i(this.radiusY) + " " + i(this.xAxisRotation) + " " + (this.isLargeArc ? 1 : 0) + " " + (this.isClockwiseArc ? 1 : 0) + " " + i(this.endX) + " " + i(this.endY);
          break;
        default:
          e = SegmentType2[this.type];
      }
      return e + (this.isClosed ? "z" : "");
    }
    static Move = 1;
    static Line = 2;
    static Bezier = 3;
    static QuadraticBezier = 4;
    static Arc = 5;
    static SvgArc = 6;
    get u() {
      return (this.l & 1) !== 0;
    }
    set u(t) {
      t ? this.l |= 1 : this.l &= -2;
    }
    get kt() {
      return (this.l & 2) !== 0;
    }
    set kt(t) {
      t ? this.l |= 2 : this.l &= -3;
    }
    S() {
      return this.u = true, this;
    }
    close() {
      return this.isClosed = true, this;
    }
    Vo(t) {
      if (this.Js !== null && t.kt === false) return this.Js;
      const i = this.radiusX;
      let e = this.radiusY;
      if (e === void 0 && (e = i), i === 0 || e === 0) return this.Js = [], this.Js;
      const s = this.Sn, n = this.Fl, o = G.jA(0, 0, i < e ? i : e, this.startAngle, this.startAngle + this.sweepAngle, false);
      if (i !== e) {
        const l = Transform.a();
        l.Ki(), i < e ? l.lt(1, e / i) : l.lt(i / e, 1), Geometry2._A(o, l), Transform.o(l);
      }
      const r = o.length;
      for (let l = 0; l < r; l++) {
        const h = o[l];
        h[0] += s, h[1] += n, h[2] += s, h[3] += n, h[4] += s, h[5] += n, h[6] += s, h[7] += n;
      }
      return this.Js = o, this.Js;
    }
    ea(t, i, e) {
      if (this.Js !== null && t.kt === false) return this.Js;
      if (this.radiusX === 0 || this.radiusY === 0) return this.Js = [], this.Js;
      const s = i, n = e;
      let o = this.Il, r = this.Nr;
      o === 0 && (o = 1e-4), r === 0 && (r = 1e-4);
      const l = this.Sn * (Math.PI / 180), h = this.isLargeArc, f = this.isClockwiseArc, a = this.le, c = this.he, u = Math.cos(l), d = Math.sin(l), m = u * (s - a) / 2 + d * (n - c) / 2, g = -d * (s - a) / 2 + u * (n - c) / 2, p = m * m / (o * o) + g * g / (r * r);
      p > 1 && (o *= Math.sqrt(p), r *= Math.sqrt(p));
      let y = (h === f ? -1 : 1) * Math.sqrt((o * o * r * r - o * o * g * g - r * r * m * m) / (o * o * g * g + r * r * m * m));
      isNaN(y) && (y = 0);
      let x = y * o * g / r, S = y * -r * m / o;
      isNaN(x) && (x = 0), isNaN(S) && (S = 0);
      const b = (s + a) / 2 + u * x - d * S, k = (n + c) / 2 + d * x + u * S, P = (Y, z) => Math.sqrt(Y * Y + z * z), A = (Y, z, H, W) => (Y * H + z * W) / (P(Y, z) * P(H, W)), C = (Y, z, H, W) => (Y * W < z * H ? -1 : 1) * Math.acos(A(Y, z, H, W)), M = C(1, 0, (m - x) / o, (g - S) / r), N = (m - x) / o, L = (g - S) / r, T = (-m - x) / o, D = (-g - S) / r;
      let F = C(N, L, T, D);
      const R = A(N, L, T, D);
      R <= -1 ? F = Math.PI : R >= 1 && (F = 0), !f && F > 0 && (F = F - 2 * Math.PI), f && F < 0 && (F = F + 2 * Math.PI);
      const I = o > r ? o : r, O = o > r ? 1 : o / r, X = o > r ? r / o : 1, K = G.jA(0, 0, I, M, M + F, true), B = Transform.a();
      return B.Ki(), B.vs(b, k), B.Ns(this.Sn, 0, 0), B.lt(O, X), Geometry2._A(K, B), Transform.o(B), this.Js = K, this.Js;
    }
    get isClosed() {
      return (this.l & 8) !== 0;
    }
    set isClosed(t) {
      this.isClosed !== t && (t ? this.l |= 8 : this.l &= -9, this.kt = true);
    }
    get type() {
      return this.tt;
    }
    set type(t) {
      Debug && U.W(t, SegmentType2, "SegmentType"), this.u && U.D(this, t), this.tt = t, this.kt = true;
    }
    get endX() {
      return this.le;
    }
    set endX(t) {
      Debug && U.r(t, PathSegment2, "endX"), this.u && U.D(this, t), this.le = t, this.kt = true;
    }
    get endY() {
      return this.he;
    }
    set endY(t) {
      Debug && U.r(t, PathSegment2, "endY"), this.u && U.D(this, t), this.he = t, this.kt = true;
    }
    get point1X() {
      return this.Sn;
    }
    set point1X(t) {
      Debug && U.r(t, PathSegment2, "point1X"), this.u && U.D(this, t), this.Sn = t, this.kt = true;
    }
    get point1Y() {
      return this.Fl;
    }
    set point1Y(t) {
      Debug && U.r(t, PathSegment2, "point1Y"), this.u && U.D(this, t), this.Fl = t, this.kt = true;
    }
    get point2X() {
      return this.Il;
    }
    set point2X(t) {
      Debug && U.r(t, PathSegment2, "point2X"), this.u && U.D(this, t), this.Il = t, this.kt = true;
    }
    get point2Y() {
      return this.Nr;
    }
    set point2Y(t) {
      Debug && U.r(t, PathSegment2, "point2Y"), this.u && U.D(this, t), this.Nr = t, this.kt = true;
    }
    get centerX() {
      return this.Sn;
    }
    set centerX(t) {
      Debug && U.r(t, PathSegment2, "centerX"), this.u && U.D(this, t), this.Sn = t, this.kt = true;
    }
    get centerY() {
      return this.Fl;
    }
    set centerY(t) {
      Debug && U.r(t, PathSegment2, "centerY"), this.u && U.D(this, t), this.Fl = t, this.kt = true;
    }
    get radiusX() {
      return this.Il;
    }
    set radiusX(t) {
      Debug && U.r(t, PathSegment2, "radiusX"), t < 0 && U.G(t, ">= zero", PathSegment2, "radiusX"), this.u && U.D(this, t), this.Il = t, this.kt = true;
    }
    get radiusY() {
      return this.Nr;
    }
    set radiusY(t) {
      Debug && U.r(t, PathSegment2, "radiusY"), t < 0 && U.G(t, ">= zero", PathSegment2, "radiusY"), this.u && U.D(this, t), this.Nr = t, this.kt = true;
    }
    get startAngle() {
      return this.le;
    }
    set startAngle(t) {
      Debug && U.r(t, PathSegment2, "startAngle"), this.u && U.D(this, t), t = t % 360, t < 0 && (t += 360), this.le = t, this.kt = true;
    }
    get sweepAngle() {
      return this.he;
    }
    set sweepAngle(t) {
      Debug && U.r(t, PathSegment2, "sweepAngle"), this.u && U.D(this, t), t > 360 && (t = 360), t < -360 && (t = -360), this.he = t, this.kt = true;
    }
    get isClockwiseArc() {
      return (this.l & 4) !== 0;
    }
    set isClockwiseArc(t) {
      this.u && U.D(this, t), t ? this.l |= 4 : this.l &= -5, this.kt = true;
    }
    get isLargeArc() {
      return (this.l & 16) !== 0;
    }
    set isLargeArc(t) {
      this.u && U.D(this, t), t ? this.l |= 16 : this.l &= -17, this.kt = true;
    }
    get xAxisRotation() {
      return this.Sn;
    }
    set xAxisRotation(t) {
      Debug && U.r(t, PathSegment2, "xAxisRotation"), this.u && U.D(this, t), t = t % 360, t < 0 && (t += 360), this.Sn = t, this.kt = true;
    }
  }
  class InputEvent2 {
    f;
    Sx;
    kx;
    xm;
    bm;
    Sm;
    km;
    Pm;
    Mm;
    Nm;
    Cm;
    Am;
    Tm;
    Lm;
    zo;
    Dm;
    Fm;
    Cs;
    Re;
    constructor() {
      this.f = null, this.Sx = new Point2(0, 0).S(), this.kx = new Point2(0, 0).S(), this.xm = 0, this.bm = 0, this.Sm = 1, this.km = "", this.Pm = "", this.Mm = false, this.Nm = false, this.Cm = 0, this.Am = 0, this.Tm = false, this.Lm = false, this.zo = false, this.Dm = null, this.Fm = 0, this.Cs = null, this.Re = null;
    }
    copy() {
      const t = new InputEvent2();
      return this.clone(t);
    }
    clone(t) {
      return t.f = this.f, t.Sx.c(this.viewPoint), t.kx.c(this.documentPoint), t.xm = this.xm, t.bm = this.bm, t.Sm = this.Sm, t.km = this.km, t.Pm = this.Pm, t.Mm = this.Mm, t.Nm = this.Nm, t.Cm = this.Cm, t.Am = this.Am, t.Tm = this.Tm, t.Lm = this.Lm, t.zo = this.zo, t.Dm = this.Dm, t.Fm = this.Fm, t.Cs = this.Cs, t.Re = this.Re, t;
    }
    toString() {
      let t = "^";
      return this.modifiers !== 0 && (t += "M:" + this.modifiers), this.button !== 0 && (t += "B:" + this.button), this.key !== "" && (t += "K:" + this.key), this.clickCount !== 0 && (t += "C:" + this.clickCount), this.delta !== 0 && (t += "D:" + this.delta), this.handled && (t += "h"), this.bubbles && (t += "b"), this.documentPoint !== null && (t += "@" + this.documentPoint.toString()), t;
    }
    get diagram() {
      return this.f;
    }
    set diagram(t) {
      this.f = t;
    }
    get viewPoint() {
      return this.Sx;
    }
    set viewPoint(t) {
      Debug && U.s(t, Point2, InputEvent2, "viewPoint"), this.Sx.c(t);
    }
    get documentPoint() {
      return this.kx;
    }
    set documentPoint(t) {
      Debug && U.s(t, Point2, InputEvent2, "documentPoint"), this.kx.c(t);
    }
    getMultiTouchViewPoint(t, i) {
      const e = this.diagram;
      return e === null || e.sT(this.event, t, i), i;
    }
    getMultiTouchDocumentPoint(t, i) {
      const e = this.diagram;
      return e === null || (e.sT(this.event, t, i), i.c(e.transformViewToDoc(i))), i;
    }
    get modifiers() {
      return this.xm;
    }
    set modifiers(t) {
      this.xm = t;
    }
    get button() {
      return this.bm;
    }
    set button(t) {
      if (this.bm = t, this.event === null) switch (t) {
        case 0:
          this.buttons = 1;
          return;
        case 1:
          this.buttons = 4;
          return;
        case 2:
          this.buttons = 2;
          return;
      }
    }
    get buttons() {
      return this.Sm;
    }
    set buttons(t) {
      this.Sm = t;
    }
    get key() {
      return this.km;
    }
    set key(t) {
      this.km = t;
    }
    get code() {
      return this.Pm;
    }
    set code(t) {
      this.Pm = t;
    }
    get down() {
      return this.Mm;
    }
    set down(t) {
      this.Mm = t;
    }
    get up() {
      return this.Nm;
    }
    set up(t) {
      this.Nm = t;
    }
    get clickCount() {
      return this.Cm;
    }
    set clickCount(t) {
      this.Cm = t;
    }
    get delta() {
      return this.Am;
    }
    set delta(t) {
      this.Am = t;
    }
    get isMultiTouch() {
      return this.Tm;
    }
    set isMultiTouch(t) {
      this.Tm = t;
    }
    get handled() {
      return this.Lm;
    }
    set handled(t) {
      this.Lm = t;
    }
    get bubbles() {
      return this.zo;
    }
    set bubbles(t) {
      this.zo = t;
    }
    get event() {
      return this.Dm;
    }
    set event(t) {
      this.Dm = t;
    }
    get isTouchEvent() {
      const t = this.event;
      return t === null ? false : t.pointerType === "touch" || t.pointerType === "pen";
    }
    get timestamp() {
      return this.Fm;
    }
    set timestamp(t) {
      this.Fm = t;
    }
    get targetDiagram() {
      return this.Cs;
    }
    set targetDiagram(t) {
      this.Cs = t;
    }
    get targetObject() {
      return this.Re;
    }
    set targetObject(t) {
      this.Re = t;
    }
    get control() {
      return (this.modifiers & 1) !== 0;
    }
    set control(t) {
      this.modifiers = t ? this.modifiers | 1 : this.modifiers & -2;
    }
    get shift() {
      return (this.modifiers & 4) !== 0;
    }
    set shift(t) {
      this.modifiers = t ? this.modifiers | 4 : this.modifiers & -5;
    }
    get alt() {
      return (this.modifiers & 2) !== 0;
    }
    set alt(t) {
      this.modifiers = t ? this.modifiers | 2 : this.modifiers & -3;
    }
    get meta() {
      return (this.modifiers & 8) !== 0;
    }
    set meta(t) {
      this.modifiers = t ? this.modifiers | 8 : this.modifiers & -9;
    }
    get left() {
      const t = this.event;
      return t !== null && (t.type === "mousedown" || t.type === "mouseup" || t.type === "pointerdown" || t.type === "pointerup") ? this.button === 0 : (this.buttons & 1) !== 0;
    }
    set left(t) {
      t ? this.buttons |= 1 : this.buttons &= -2;
    }
    get right() {
      const t = this.event;
      return t !== null && (t.type === "mousedown" || t.type === "mouseup" || t.type === "pointerdown" || t.type === "pointerup") ? this.button === 2 : (this.buttons & 2) !== 0;
    }
    set right(t) {
      t ? this.buttons |= 2 : this.buttons &= -3;
    }
    get middle() {
      const t = this.event;
      return t !== null && (t.type === "mousedown" || t.type === "mouseup" || t.type === "pointerdown" || t.type === "pointerup") ? this.button === 1 : (this.buttons & 4) !== 0;
    }
    set middle(t) {
      t ? this.buttons |= 4 : this.buttons &= -5;
    }
    get commandKey() {
      const t = this.code, i = this.key;
      return "cxvyzagCXVYZAG".includes(i) ? i.toLowerCase() : t === "KeyC" ? "c" : t === "KeyX" ? "x" : t === "KeyV" ? "v" : t === "KeyY" ? "y" : t === "KeyZ" ? "z" : t === "KeyA" ? "a" : t === "KeyG" ? "g" : t !== "" ? t : i;
    }
  }
  class DiagramEvent2 {
    f;
    At;
    Im;
    Rm;
    constructor() {
      this.f = null, this.At = "", this.Im = null, this.Rm = null;
    }
    copy() {
      const t = new DiagramEvent2();
      return t.f = this.f, t.At = this.At, t.Im = this.Im, t.Rm = this.Rm, t;
    }
    toString() {
      let t = "*" + this.name;
      return this.subject !== null && (t += ":" + this.subject.toString()), this.parameter !== null && (t += "(" + this.parameter.toString() + ")"), t;
    }
    get diagram() {
      return this.f;
    }
    set diagram(t) {
      this.f = t;
    }
    get name() {
      return this.At;
    }
    set name(t) {
      this.At = t;
    }
    get subject() {
      return this.Im;
    }
    set subject(t) {
      this.Im = t;
    }
    get parameter() {
      return this.Rm;
    }
    set parameter(t) {
      this.Rm = t;
    }
  }
  var ChangeType2 = ((w) => (w[w.Transaction = 1] = "Transaction", w[w.Property = 2] = "Property", w[w.Insert = 3] = "Insert", w[w.Remove = 4] = "Remove", w))(ChangeType2 || {});
  class ChangedEvent2 {
    Eu;
    Om;
    kn;
    Di;
    f;
    Bu;
    If;
    Rf;
    Of;
    Ef;
    constructor() {
      this.Eu = 2, this.Om = "", this.kn = "", this.Di = null, this.f = null, this.Bu = null, this.If = null, this.Rf = null, this.Of = null, this.Ef = null;
    }
    static Transaction = 1;
    static Property = 2;
    static Insert = 3;
    static Remove = 4;
    clear() {
      this.Di = null, this.f = null, this.Bu = null, this.If = null, this.Rf = null, this.Of = null, this.Ef = null;
    }
    copy() {
      const t = new ChangedEvent2();
      t.Eu = this.Eu, t.Om = this.Om, t.kn = this.kn, t.Di = this.Di, t.f = this.f, t.Bu = this.Bu;
      let i = this.If;
      return U.it(i) && U.at(i.copyFrozen) ? t.If = i.copyFrozen() : t.If = i, i = this.Rf, U.it(i) && U.at(i.copyFrozen) ? t.Rf = i.copyFrozen() : t.Rf = i, i = this.Of, U.it(i) && U.at(i.copyFrozen) ? t.Of = i.copyFrozen() : t.Of = i, i = this.Ef, U.it(i) && U.at(i.copyFrozen) ? t.Ef = i.copyFrozen() : t.Ef = i, t;
    }
    gi(t) {
      t in ChangeType2 ? this.change = t : U.xr(this, t);
    }
    toString() {
      let t = "";
      return this.change === 1 ? t += "* " : this.change === 2 ? t += this.model !== null ? "!m" : "!d" : t += (this.model !== null ? "!m" : "!d") + this.change, this.propertyName && typeof this.propertyName == "string" && (t += " " + this.propertyName), this.modelChange && this.modelChange !== this.propertyName && (t += " " + this.modelChange), t += ": ", this.change === 1 ? this.oldValue !== null && (t += " " + this.oldValue) : (this.object !== null && (t += U.toString(this.object)), this.oldValue !== null && (t += "  old: " + U.toString(this.oldValue)), this.oldParam !== null && (t += " " + this.oldParam), this.newValue !== null && (t += "  new: " + U.toString(this.newValue)), this.newParam !== null && (t += " " + this.newParam)), t;
    }
    getValue(t) {
      return t ? this.oldValue : this.newValue;
    }
    getParam(t) {
      return t ? this.oldParam : this.newParam;
    }
    canUndo() {
      return this.model !== null || this.diagram !== null;
    }
    undo() {
      this.canUndo() && (this.model !== null ? this.model.changeState(this, true) : this.diagram !== null && this.diagram.nT(this, true));
    }
    canRedo() {
      return this.model !== null || this.diagram !== null;
    }
    redo() {
      this.canRedo() && (this.model !== null ? this.model.changeState(this, false) : this.diagram !== null && this.diagram.nT(this, false));
    }
    get model() {
      return this.Di;
    }
    set model(t) {
      this.Di = t;
    }
    get diagram() {
      return this.f;
    }
    set diagram(t) {
      this.f = t;
    }
    get change() {
      return this.Eu;
    }
    set change(t) {
      this.Eu = t;
    }
    get modelChange() {
      return this.Om;
    }
    set modelChange(t) {
      Debug && U.i(t, "string", ChangedEvent2, "modelChange"), this.Om = t;
    }
    get propertyName() {
      return this.kn;
    }
    set propertyName(t) {
      Debug && typeof t != "string" && U.C(t, ChangedEvent2, "propertyName"), this.kn = t;
    }
    get isTransactionFinished() {
      return this.Eu === 1 && (this.kn === "CommittedTransaction" || this.kn === "FinishedUndo" || this.kn === "FinishedRedo");
    }
    get object() {
      return this.Bu;
    }
    set object(t) {
      this.Bu = t;
    }
    get oldValue() {
      return this.If;
    }
    set oldValue(t) {
      this.If = t;
    }
    get oldParam() {
      return this.Rf;
    }
    set oldParam(t) {
      this.Rf = t;
    }
    get newValue() {
      return this.Of;
    }
    set newValue(t) {
      this.Of = t;
    }
    get newParam() {
      return this.Ef;
    }
    set newParam(t) {
      this.Ef = t;
    }
  }
  class Transaction2 {
    oT;
    At;
    Wk;
    constructor() {
      this.oT = new List2().S(), this.At = "", this.Wk = false;
    }
    toString(t) {
      let i = "Transaction: " + this.name + " " + this.changes.count.toString() + (this.isComplete ? "" : ", incomplete");
      if (t !== void 0 && t > 0) {
        const e = this.changes.count;
        for (let s = 0; s < e; s++) {
          const n = this.changes.elt(s);
          n !== null && (i += `
  ` + n.toString());
        }
      }
      return i;
    }
    clear() {
      const t = this.changes;
      t.di();
      for (let i = t.count - 1; i >= 0; i--) {
        const e = t.elt(i);
        e !== null && e.clear();
      }
      t.clear(), t.S();
    }
    canUndo() {
      return this.isComplete;
    }
    undo() {
      if (this.canUndo()) for (let t = this.changes.count - 1; t >= 0; t--) {
        const i = this.changes.elt(t);
        i !== null && i.undo();
      }
    }
    canRedo() {
      return this.isComplete;
    }
    redo() {
      if (!this.canRedo()) return;
      const t = this.changes.count;
      for (let i = 0; i < t; i++) {
        const e = this.changes.elt(i);
        e !== null && e.redo();
      }
    }
    uR(t) {
      const i = this.changes;
      for (let e = i.count - 1; e >= t; e--) {
        const s = i.elt(e);
        s !== null && s.undo(), i.di(), i.removeAt(e);
      }
      i.S();
    }
    thaw() {
      this.changes.di();
    }
    optimize() {
      if (!this.isComplete) return;
      const t = this.changes;
      t.di();
      const i = /* @__PURE__ */ new Map();
      for (let s = 0; s < t.count; s++) {
        const n = t.elt(s);
        if (n === null || n.change !== 2 || !n.object) continue;
        let o = i.get(n.object);
        o || (o = /* @__PURE__ */ new Map(), i.set(n.object, o));
        const r = o.get(n.propertyName);
        r === void 0 ? o.set(n.propertyName, -1) : (r > 0 && t.setElt(r, null), o.set(n.propertyName, s));
      }
      let e = 0;
      for (let s = 0; s < t.count; s++) {
        const n = t.elt(s);
        n !== null && (s > e && t.setElt(e, n), e++);
      }
      for (; t.length > e; ) t.pop();
      t.S();
    }
    get changes() {
      return this.oT;
    }
    get name() {
      return this.At;
    }
    set name(t) {
      this.At = t;
    }
    get isComplete() {
      return this.Wk;
    }
    set isComplete(t) {
      this.Wk = t;
    }
  }
  class UndoManager2 {
    Px;
    Gi;
    rT;
    $s;
    jk;
    Em;
    Rl;
    Mx;
    Jk;
    Pn;
    Bf;
    Nx;
    Zs;
    Cx;
    Ax;
    Bm;
    Tx;
    constructor(t) {
      this.Px = new GSet2(), this.Gi = false, this.rT = new List2().S(), this.$s = -1, this.jk = 999, this.Zs = false, this.Em = null, this.Rl = 0, this.Mx = false, Debug && (this.Mx = true), this.Jk = 23, this.Pn = new List2().S(), this.Bf = new List2(), this.Nx = true, this.Cx = false, this.Ax = false, this.Bm = false, this.Tx = false, t && Object.assign(this, t);
    }
    toString(t) {
      let i = "UndoManager " + this.historyIndex + "<" + this.history.count + "<=" + this.maxHistoryLength;
      i += "[";
      let e = this.nestedTransactionNames.count;
      for (let s = 0; s < e; s++) s > 0 && (i += " "), i += this.nestedTransactionNames.elt(s);
      if (i += "]", t !== void 0 && t > 0) {
        e = this.history.count;
        for (let s = 0; s < e; s++) i += `
 ` + this.history.elt(s).toString(t - 1);
      }
      return i;
    }
    clear() {
      const t = this.history;
      t.di();
      for (let i = t.count - 1; i >= 0; i--) {
        const e = t.elt(i);
        e !== null && e.clear();
      }
      t.clear(), this.$s = -1, t.S(), this.Zs = false, this.Em = null, this.Rl = 0, this.Pn.di(), this.Pn.clear(), this.Pn.S(), this.Bf.clear(), this.Cx = false, this.Ax = false, this.Bm = false, this.Tx = false;
    }
    copyProperties(t) {
      this.isEnabled = t.isEnabled, this.maxHistoryLength = t.maxHistoryLength, this.Vu = t.Vu;
    }
    addModel(t) {
      this.Px.add(t);
    }
    removeModel(t) {
      this.Px.delete(t);
    }
    startTransaction(t) {
      if (t === void 0 && (t = ""), t === null && (t = ""), this.isUndoingRedoing) return false;
      this.Nx === true && (this.Nx = false, this.Rl++, this.Ol || this.El("StartingFirstTransaction", t, this.currentTransaction), this.Rl > 0 && this.Rl--), this.isEnabled && (this.Pn.di(), this.Pn.add(t), this.Pn.S(), this.currentTransaction === null ? this.Bf.add(0) : this.Bf.add(this.currentTransaction.changes.count)), this.Rl++;
      const i = this.transactionLevel === 1;
      return i && (this.Ol || this.El("StartedTransaction", t, this.currentTransaction)), i;
    }
    commitTransaction(t) {
      return t === void 0 && (t = ""), this.lT(true, t);
    }
    rollbackTransaction() {
      return this.lT(false, "");
    }
    lT(t, i) {
      if (this.isUndoingRedoing) return false;
      this.Vu && this.transactionLevel < 1 && U.ot("Ending transaction without having started a transaction: " + i);
      const e = this.transactionLevel === 1;
      let s = this.currentTransaction;
      e && t && (this.Ol || this.El("CommittingTransaction", i, s));
      let n = 0;
      if (this.transactionLevel > 0 && (this.Rl--, this.isEnabled)) {
        const o = this.Pn.count;
        o > 0 && (i === "" && (i = this.Pn.elt(0)), this.Pn.di(), this.Pn.removeAt(o - 1), this.Pn.S());
        const r = this.Bf.count;
        r > 0 && (n = this.Bf.elt(r - 1), this.Bf.removeAt(r - 1));
      }
      if (e) {
        if (t) {
          if (this.Bm = false, s === null && i !== "" && (s = this.currentTransaction), this.isEnabled && s !== null) {
            const o = s;
            o.isComplete || (o.isComplete = true, o.name = i), this.discardHistoryAfterIndex();
            const r = this.history;
            r.di();
            const l = this.maxHistoryLength;
            if (l >= 0) {
              if (l === 0) r.clear();
              else if (r.count >= l) {
                const h = r.elt(0);
                h !== null && h.clear(), r.removeAt(0), this.$s--;
              }
            }
            l !== 0 && (r.count === 0 || r.get(r.count - 1) !== o) && (r.add(o), this.$s++), r.S(), s = o;
          }
          this.Ol || this.El("CommittedTransaction", i, s);
        } else {
          this.Zs = true;
          try {
            this.isEnabled && s !== null && (s.isComplete = true, s.undo());
          } finally {
            this.Ol || this.El("RolledBackTransaction", i, s), this.Zs = false;
          }
          s !== null && s.clear();
        }
        return this.Em = null, this.Lx && this.clear(), this.Lx = false, this.Dx = false, true;
      } else return this.isEnabled && !t && s !== null && s.uR(n), false;
    }
    discardHistoryAfterIndex() {
      if (this.isUndoingRedoing || !this.canRedo()) return;
      const t = this.history;
      t.di();
      for (let i = t.count - 1; i > this.historyIndex; i--) {
        const e = t.elt(i);
        e !== null && e.clear(), t.removeAt(i), this.Bm = true;
      }
      t.S();
    }
    thaw() {
      this.history.di();
    }
    canUndo() {
      if (!this.isEnabled || this.transactionLevel > 0) return false;
      const t = this.transactionToUndo;
      return !!(t !== null && t.canUndo());
    }
    undo() {
      if (!this.canUndo()) return;
      const t = this.transactionToUndo;
      if (t !== null) try {
        this.Zs = true, this.El("StartingUndo", "Undo", t), this.$s--, t.undo();
      } catch (i) {
        U.ot("undo error: " + i.toString());
      } finally {
        this.El("FinishedUndo", "Undo", t), this.Zs = false;
      }
    }
    canRedo() {
      if (!this.isEnabled || this.transactionLevel > 0) return false;
      const t = this.transactionToRedo;
      return !!(t !== null && t.canRedo());
    }
    redo() {
      if (!this.canRedo()) return;
      const t = this.transactionToRedo;
      if (t !== null) try {
        this.Zs = true, this.El("StartingRedo", "Redo", t), this.$s++, t.redo();
      } catch (i) {
        U.ot("redo error: " + i.toString());
      } finally {
        this.El("FinishedRedo", "Redo", t), this.Zs = false;
      }
    }
    El(t, i, e) {
      const s = new ChangedEvent2();
      s.change = 1, s.propertyName = t, s.object = e, s.oldValue = i;
      const n = this.models;
      for (; n.next(); ) {
        const o = n.value;
        s.model = o, o.dR(s);
      }
    }
    handleChanged(t) {
      if (this.isEnabled && !this.isUndoingRedoing && !this.skipsEvent(t)) {
        let i = this.currentTransaction;
        i === null && (i = new Transaction2(), this.Em = i);
        const e = t.copy(), s = i.changes;
        if (s.di(), s.add(e), s.S(), this.Vu && this.Jk > 0 && this.transactionLevel <= 0 && !this.Nx) {
          const n = t.diagram;
          if (n !== null && n.sa === false) return;
          U.ot("Change not within a transaction: " + e.toString()), this.Jk--;
        }
      }
    }
    skipsEvent(t) {
      if (t === null || t.change === 1) return true;
      const i = t.object;
      if (i === null) return false;
      if (i.layer !== void 0) {
        const e = i.layer;
        if (e !== null && e.isTemporary) return true;
      } else if (i.isTemporary) return true;
      return false;
    }
    get models() {
      return this.Px.iterator;
    }
    get isEnabled() {
      return this.Gi;
    }
    set isEnabled(t) {
      this.Gi = t;
    }
    get transactionToUndo() {
      return this.historyIndex >= 0 && this.historyIndex <= this.history.count - 1 ? this.history.elt(this.historyIndex) : null;
    }
    get transactionToRedo() {
      return this.historyIndex < this.history.count - 1 ? this.history.elt(this.historyIndex + 1) : null;
    }
    get isUndoingRedoing() {
      return this.Zs;
    }
    get history() {
      return this.rT;
    }
    get maxHistoryLength() {
      return this.jk;
    }
    set maxHistoryLength(t) {
      this.jk = t;
    }
    get historyIndex() {
      return this.$s;
    }
    get currentTransaction() {
      return this.Em;
    }
    get transactionLevel() {
      return this.Rl;
    }
    get isInTransaction() {
      return this.Rl > 0;
    }
    get Vu() {
      return this.Mx;
    }
    set Vu(t) {
      this.Mx = t;
    }
    get nestedTransactionNames() {
      return this.Pn;
    }
    get Lx() {
      return this.Cx;
    }
    set Lx(t) {
      this.Cx = t;
    }
    get Dx() {
      return this.Ax;
    }
    set Dx(t) {
      this.Ax = t;
    }
    get Ol() {
      return this.Tx;
    }
    set Ol(t) {
      this.Tx = t;
    }
    get isJustDiscarded() {
      return this.Bm;
    }
  }
  class Tool2 {
    f;
    At;
    Gi;
    $k;
    Zk;
    Vm;
    hT;
    constructor() {
      GSet2._i(this), this.f = Diagram2.zm(), this.At = "", this.Gi = true, this.$k = false, this.Zk = null, this.hT = new InputEvent2(), this.Vm = -1;
    }
    get diagram() {
      return this.f;
    }
    set diagram(t) {
      t instanceof Diagram2 && (this.f = t);
    }
    toString() {
      return this.name !== "" ? this.name + " Tool" : U.$n(this.constructor);
    }
    updateAdornments(t) {
    }
    canStart() {
      return this.isEnabled;
    }
    doStart() {
    }
    doActivate() {
      this.isActive = true;
    }
    doDeactivate() {
      this.isActive = false;
    }
    doStop() {
    }
    doCancel() {
      this.transactionResult = null, this.stopTool();
    }
    stopTool() {
      const t = this.diagram;
      t.currentTool === this && (t.currentTool = null, t.currentCursor = "");
    }
    doMouseDown() {
      !this.isActive && this.canStart() && this.doActivate();
    }
    doMouseMove() {
    }
    doMouseUp() {
      this.stopTool();
    }
    doMouseWheel() {
    }
    canStartMultiTouch() {
      return true;
    }
    standardPinchZoomStart() {
      const t = this.diagram, i = t.lastInput, e = i.getMultiTouchViewPoint(0, Point2.U(NaN, NaN)), s = i.getMultiTouchViewPoint(1, Point2.U(NaN, NaN));
      if (!e.isReal() || !s.isReal()) {
        Point2.o(e), Point2.o(s);
        return;
      }
      if (this.doCancel(), t.getInputOption("hasGestureZoom")) {
        t.Qk = t.scale;
        const n = s.x - e.x, o = s.y - e.y, r = Math.sqrt(n * n + o * o);
        t._k = r, i.bubbles = false;
      }
      Point2.o(e), Point2.o(s);
    }
    standardPinchZoomMove() {
      const t = this.diagram, i = t.lastInput, e = i.getMultiTouchViewPoint(0, Point2.U(NaN, NaN)), s = i.getMultiTouchViewPoint(1, Point2.U(NaN, NaN));
      if (!e.isReal() || !s.isReal()) {
        Point2.o(e), Point2.o(s);
        return;
      }
      if (this.doCancel(), t.getInputOption("hasGestureZoom")) {
        const n = s.x - e.x, o = s.y - e.y, l = Math.sqrt(n * n + o * o) / t._k, h = new Point2((Math.min(s.x, e.x) + Math.max(s.x, e.x)) / 2, (Math.min(s.y, e.y) + Math.max(s.y, e.y)) / 2), f = t.Qk * l, a = t.commandHandler;
        if (f !== t.scale && a.canResetZoom(f)) {
          const c = t.zoomPoint;
          t.zoomPoint = h, a.resetZoom(f), t.zoomPoint = c;
        }
        i.bubbles = false;
      }
      Point2.o(e), Point2.o(s);
    }
    doKeyDown() {
      this.diagram.lastInput.code === "Escape" && this.doCancel();
    }
    doKeyUp() {
    }
    startTransaction(t) {
      return t === void 0 && (t = this.name), this.transactionResult = null, this.diagram.startTransaction(t);
    }
    stopTransaction() {
      const t = this.diagram;
      return this.transactionResult === null ? t.rollbackTransaction() : t.commitTransaction(this.transactionResult);
    }
    standardMouseSelect() {
      const t = this.diagram;
      if (!t.allowSelect) return;
      const i = t.lastInput, e = t.findPartAt(i.documentPoint, false);
      if (e !== null) {
        if (U.wr ? i.meta : i.control) {
          t.F("ChangingSelection", t.selection);
          let s = e;
          for (; s !== null && !s.canSelect(); ) s = s.containingGroup;
          s !== null && (s.isSelected = !s.isSelected), t.F("ChangedSelection", t.selection);
        } else if (i.shift) {
          if (!e.isSelected) {
            t.F("ChangingSelection", t.selection);
            let s = e;
            for (; s !== null && !s.canSelect(); ) s = s.containingGroup;
            s !== null && (s.isSelected = true), t.F("ChangedSelection", t.selection);
          }
        } else if (!e.isSelected) {
          let s = e;
          for (; s !== null && !s.canSelect(); ) s = s.containingGroup;
          s !== null && t.select(s);
        }
      } else i.left && !(U.wr ? i.meta : i.control) && !i.shift && t.clearSelection();
    }
    standardMouseClick(t, i) {
      t === void 0 && (t = null), i === void 0 && (i = (o) => !o.layer?.isTemporary);
      const e = this.diagram, s = e.lastInput, n = e.findObjectAt(s.documentPoint, t, i);
      return s.targetObject = n, this.aT(n, s, e);
    }
    aT(t, i, e) {
      if (i.handled = false, t !== null && !t.isEnabledObject()) return false;
      let s = 0;
      i.left ? i.clickCount === 1 ? s = 1 : i.clickCount === 2 ? s = 2 : s = 1 : i.right && i.clickCount === 1 && (s = 3);
      let n = "ObjectSingleClicked";
      if (t !== null) {
        switch (s) {
          case 1:
            n = "ObjectSingleClicked";
            break;
          case 2:
            n = "ObjectDoubleClicked";
            break;
          case 3:
            n = "ObjectContextClicked";
            break;
        }
        s !== 0 && e.F(n, t);
      } else {
        switch (s) {
          case 1:
            n = "BackgroundSingleClicked";
            break;
          case 2:
            n = "BackgroundDoubleClicked";
            break;
          case 3:
            n = "BackgroundContextClicked";
            break;
        }
        s !== 0 && e.F(n);
      }
      if (t !== null) for (; t !== null; ) {
        let o = null;
        switch (s) {
          case 1:
            o = t.click;
            break;
          case 2:
            o = t.doubleClick ? t.doubleClick : t.click;
            break;
          case 3:
            o = t.contextClick;
            break;
        }
        if (o !== null && (o(i, t), i.handled)) break;
        t = t.panel;
      }
      else {
        let o = null;
        switch (s) {
          case 1:
            o = e.click;
            break;
          case 2:
            o = e.doubleClick ? e.doubleClick : e.click;
            break;
          case 3:
            o = e.contextClick;
            break;
        }
        o !== null && o(i);
      }
      return i.handled;
    }
    standardMouseOver() {
      const t = this.diagram, i = t.lastInput;
      if (t.animationManager.Mi === true) return;
      const e = t.skipsUndoManager;
      t.skipsUndoManager = true;
      let s = t.viewportBounds.containsPoint(i.documentPoint) ? t.findObjectAt(i.documentPoint, null, null) : null;
      i.event && (i.event.type === "pointercancel" || i.event.type === "pointerout") && (s = null), i.targetObject = s;
      let n = false;
      if (s !== t.Vf) {
        let o = t.Vf;
        const r = o;
        for (t.Vf = s, this.fT(o, s), i.handled = false; o !== null; ) {
          const l = o.mouseLeave;
          if (l !== null && (s === o || s !== null && s.isContainedBy(o) || (l(i, o, s), n = true, i.handled))) break;
          o = o.panel;
        }
        for (o = r, i.handled = false; s !== null; ) {
          const l = s.mouseEnter;
          if (l !== null && (o === s || o !== null && o.isContainedBy(s) || (l(i, s, o), n = true, i.handled))) break;
          s = s.panel;
        }
        s = t.Vf;
      }
      if (s !== null) {
        let o = s, r = "";
        for (; o !== null && (r = o.cursor, r === ""); ) o = o.panel;
        for (t.currentCursor = r, i.handled = false, o = s; o !== null; ) {
          const l = o.mouseOver;
          if (l !== null && (l(i, o), n = true, i.handled)) break;
          o = o.panel;
        }
      } else {
        this.doUpdateCursor(null);
        const o = t.mouseOver;
        o !== null && (o(i), n = true);
      }
      n && t.requestUpdate(), t.skipsUndoManager = e;
    }
    doUpdateCursor(t) {
      const i = this.diagram;
      i && (i.currentCursor = "");
    }
    fT(t, i) {
    }
    standardMouseWheel() {
      const t = this.diagram, i = t.lastInput;
      let e = i.delta;
      if (e === 0 || !t.documentBounds.isReal()) return;
      const s = t.commandHandler, n = t.toolManager.mouseWheelBehavior;
      if (s !== null && (n === 2 && !i.shift || n === 1 && i.control)) {
        if (e > 0 ? s.canIncreaseZoom() : s.canDecreaseZoom()) {
          const o = t.zoomPoint;
          t.zoomPoint = i.viewPoint, e > 0 ? s.increaseZoom() : s.decreaseZoom(), t.zoomPoint = o;
        }
        i.bubbles = false;
      } else if (n === 2 && i.shift || n === 1 && !i.control) {
        const o = t.position.copy(), r = i.event, l = r.deltaMode;
        let h = r.deltaX, f = r.deltaY, a = "pixel";
        if ((h !== 0 || f !== 0) && !i.shift) {
          switch (l) {
            case 0:
              a = "pixel";
              break;
            case 1:
              a = "line";
              break;
            case 2:
              a = "page";
              break;
          }
          if (h !== 0 && t.allowHorizontalScroll) {
            const c = t.scrollHorizontalLineChange;
            h = h * (c / 16), t.scroll(a, h > 0 ? "right" : "left", Math.abs(h));
          }
          if (f !== 0 && t.allowVerticalScroll) {
            const c = t.scrollVerticalLineChange;
            f = f * (c / 16), t.scroll(a, f > 0 ? "down" : "up", Math.abs(f));
          }
        } else !i.shift && t.allowVerticalScroll ? (e = e * 3 * t.scrollVerticalLineChange, t.scroll(a, e > 0 ? "up" : "down", Math.abs(e))) : i.shift && t.allowHorizontalScroll && (e = e * 3 * t.scrollHorizontalLineChange, t.scroll(a, e > 0 ? "left" : "right", Math.abs(e)));
        this.doWheelChange(t, o, i);
      }
    }
    doWheelChange(t, i, e) {
      (!t.position.equals(i) || e.event.wheelDeltaX !== 0) && (e.bubbles = false);
    }
    standardWaitAfter(t, i) {
      Debug && U.i(t, "number", Tool2, "standardWaitAfter:delay"), i === void 0 && (i = this.diagram.lastInput), this.cancelWaitAfter();
      const e = this, s = i.clone(this.hT);
      this.Vm = U.yn(() => e.doWaitAfter(s), t);
    }
    cancelWaitAfter() {
      this.Vm !== -1 && U.Nf(this.Vm), this.Vm = -1;
    }
    doWaitAfter(t) {
    }
    findToolHandleAt(t, i) {
      const s = this.diagram.findObjectAt(t, (n) => {
        for (; n !== null && !(n.panel instanceof Adornment2); ) n = n.panel;
        return n;
      });
      return s === null ? null : s.part.category === i ? s : null;
    }
    isBeyondDragSize(t, i) {
      const e = this.diagram;
      t === void 0 && (t = e.firstInput.viewPoint), i === void 0 && (i = e.lastInput.viewPoint);
      const s = e.toolManager.dragSize;
      let n = s.width, o = s.height;
      return e.firstInput.isTouchEvent && (n += 6, o += 6), Math.abs(i.x - t.x) > n || Math.abs(i.y - t.y) > o;
    }
    get name() {
      return this.At;
    }
    set name(t) {
      U.i(t, "string", Tool2, "name"), this.At = t;
    }
    get isEnabled() {
      return this.Gi;
    }
    set isEnabled(t) {
      U.i(t, "boolean", Tool2, "isEnabled"), this.Gi = t;
    }
    get isActive() {
      return this.$k;
    }
    set isActive(t) {
      U.i(t, "boolean", Tool2, "isActive"), this.$k = t;
    }
    get transactionResult() {
      return this.Zk;
    }
    set transactionResult(t) {
      t !== null && U.i(t, "string", Tool2, "transactionResult"), this.Zk = t;
    }
  }
  var WheelMode2 = ((w) => (w[w.Scroll = 1] = "Scroll", w[w.Zoom = 2] = "Zoom", w[w.None = 3] = "None", w))(WheelMode2 || {}), GestureMode2 = ((w) => (w[w.Zoom = 1] = "Zoom", w[w.Cancel = 2] = "Cancel", w[w.None = 3] = "None", w))(GestureMode2 || {});
  class ToolManager2 extends Tool2 {
    cT;
    uT;
    dT;
    tP;
    iP;
    eP;
    sP;
    nP;
    oP;
    rP;
    Xm;
    na;
    constructor(t) {
      super(), this.name = "ToolManager", this.cT = new List2(), this.uT = new List2(), this.dT = new List2(), this.tP = 850, this.iP = 850, this.eP = new Size2(2, 2).Ct(), this.sP = 5e3, this.nP = 1, this.oP = 1, this.rP = null, this.Xm = null, this.na = -1, t && Object.assign(this, t);
    }
    static WheelScroll = 1;
    static WheelZoom = 2;
    static WheelNone = 3;
    static GestureZoom = 1;
    static GestureCancel = 2;
    static GestureNone = 3;
    get mouseWheelBehavior() {
      return this.nP;
    }
    set mouseWheelBehavior(t) {
      U.W(t, WheelMode2, "WheelMode"), this.nP = t;
    }
    get gestureBehavior() {
      return this.oP;
    }
    set gestureBehavior(t) {
      U.W(t, GestureMode2, "GestureMode"), this.oP = t;
    }
    initializeStandardTools() {
    }
    updateAdornments(t) {
      const i = this.currentToolTip;
      if (i instanceof Adornment2 && this.Xm === t) {
        const e = i.adornedObject;
        (t !== null ? e !== null && e.part === t : e === null) ? this.showToolTip(i, e) : this.hideToolTip();
      }
    }
    doMouseDown() {
      const t = this.diagram, i = t.lastInput;
      if (i.isTouchEvent && this.gestureBehavior === 2 && (i.bubbles = false), i.isMultiTouch) {
        if (this.cancelWaitAfter(), this.gestureBehavior === 3) {
          i.bubbles = true;
          return;
        }
        if (this.gestureBehavior === 2) return;
        if (t.currentTool.canStartMultiTouch()) {
          t.currentTool.standardPinchZoomStart();
          return;
        }
      }
      const e = t.undoManager;
      Debug && e.Vu && e.transactionLevel !== 0 && U.ot("WARNING: In ToolManager.doMouseDown: UndoManager.transactionLevel is not zero");
      const s = this.mouseDownTools.length;
      for (let n = 0; n < s; n++) {
        const o = this.mouseDownTools.elt(n);
        if (o.diagram = this.diagram, o.canStart()) {
          t.doFocus(), t.currentTool = o, t.currentTool === o && (o.isActive || o.doActivate(), o.doMouseDown());
          return;
        }
      }
      t.lastInput.button === 1 && (this.mouseWheelBehavior === 1 ? this.mouseWheelBehavior = 2 : this.mouseWheelBehavior === 2 && (this.mouseWheelBehavior = 1)), this.doActivate(), this.standardWaitAfter(this.holdDelay, i);
    }
    doMouseMove() {
      const t = this.diagram, i = t.lastInput;
      if (i.isMultiTouch) {
        if (this.gestureBehavior === 3) {
          i.bubbles = true;
          return;
        }
        if (this.gestureBehavior === 2) return;
        if (t.currentTool.canStartMultiTouch()) {
          t.currentTool.standardPinchZoomMove();
          return;
        }
      }
      if (this.isActive) {
        const s = this.mouseMoveTools.length;
        for (let n = 0; n < s; n++) {
          const o = this.mouseMoveTools.elt(n);
          if (o.diagram = this.diagram, o.canStart()) {
            t.doFocus(), t.currentTool = o, t.currentTool === o && (o.isActive || o.doActivate(), o.doMouseMove());
            return;
          }
        }
      }
      this.gT(t);
      const e = i.event;
      e !== null && (e.type === "pointermove" || !e.cancelable) && (i.bubbles = true);
    }
    gT(t) {
      this.standardMouseOver(), this.isBeyondDragSize() && this.standardWaitAfter(this.isActive ? this.holdDelay : this.hoverDelay, t.lastInput);
    }
    fT(t, i) {
      const e = this.currentToolTip;
      e !== null && (i !== null && e instanceof Adornment2 && (i === e || i.isContainedBy(e)) || this.hideToolTip());
    }
    doWaitAfter(t) {
      const i = this.diagram;
      if (!i.gR()) return;
      const e = i.lastInput;
      if (i.lastInput = t, this.doMouseHover(), this.isActive || this.doToolTip(), t.isTouchEvent && !i.lastInput.handled) {
        const s = t.copy();
        s.button = 2, i.lastInput = s, i.Fx = true, i.doMouseUp();
      }
      i.lastInput = e;
    }
    doMouseHover() {
      const t = this.diagram, i = t.lastInput;
      i.targetObject === null && (i.targetObject = t.findObjectAt(i.documentPoint, null, null));
      let e = i.targetObject;
      if (e !== null) for (i.handled = false; e !== null; ) {
        const s = this.isActive ? e.mouseHold : e.mouseHover;
        if (s !== null && (s(i, e), i.handled)) break;
        e = e.panel;
      }
      else {
        const s = this.isActive ? t.mouseHold : t.mouseHover;
        s !== null && s(i);
      }
    }
    doToolTip() {
      const t = this.diagram, i = t.lastInput;
      i.targetObject === null && (i.targetObject = t.findObjectAt(i.documentPoint, null, null));
      let e = i.targetObject;
      if (e !== null) {
        const s = this.currentToolTip;
        if (s instanceof Adornment2 && (e === s || e.isContainedBy(s))) return;
        for (; e !== null; ) {
          const n = e.toolTip;
          if (n !== null) {
            this.showToolTip(n, e);
            return;
          }
          e = e.panel;
        }
        this.hideToolTip();
      } else {
        const s = t.toolTip;
        s !== null ? this.showToolTip(s, null) : this.hideToolTip();
      }
    }
    showToolTip(t, i) {
      Debug && !(t instanceof Adornment2 || t instanceof HTMLInfo2) && U.n("showToolTip:tooltip must be an Adornment or HTMLInfo."), i !== null && U.s(i, GraphObject2, ToolManager2, "showToolTip:obj");
      const e = this.diagram;
      if (t !== this.currentToolTip && this.hideToolTip(), t instanceof Adornment2) {
        t.layerName = "Tool", t.selectable = false, t.scale = 1 / e.scale, t.category = "ToolTip", t.hasPlaceholder() && (t.placeholder.scale = e.scale);
        const s = t.diagram;
        s !== null && s !== e && s.remove(t), e.add(t), i !== null ? t.adornedObject = i : t.data = e.model, t.ensureBounds(), this.positionToolTip(t, i);
      } else t instanceof HTMLInfo2 && t !== this.currentToolTip && t.show !== null && t.show(i, e, this);
      this.currentToolTip = t, this.extendToolTip(this.toolTipDuration);
    }
    positionToolTip(t, i) {
      if (t.hasPlaceholder()) return;
      const e = t, s = this.diagram, n = s.lastInput.documentPoint.copy(), o = e.measuredBounds, r = s.viewportBounds;
      s.lastInput.isTouchEvent && (n.x -= o.width), n.x + o.width > r.right && (n.x -= o.width + 5 / s.scale), n.x < r.x && (n.x = r.x), n.y + 20 / s.scale + o.height > r.bottom ? n.y -= o.height + 5 / s.scale : n.y += 20 / s.scale, n.y < r.y && (n.y = r.y), e.position = n;
    }
    extendToolTip(t) {
      t === void 0 && (t = 3e3), this.currentToolTip !== null && (this.na !== -1 && (U.Nf(this.na), this.na = -1), t > 0 && t !== 1 / 0 && (this.na = U.yn(() => this.hideToolTip(), t)));
    }
    hideToolTip() {
      this.na !== -1 && (U.Nf(this.na), this.na = -1);
      const t = this.diagram, i = this.currentToolTip;
      i !== null && (i instanceof Adornment2 ? (t.remove(i), this.Xm !== null && this.Xm.removeAdornment(i.category), i.data = null, i.adornedObject = null) : i instanceof HTMLInfo2 && i.hide !== null && i.hide(t, this), this.currentToolTip = null);
    }
    get currentToolTip() {
      return this.rP;
    }
    set currentToolTip(t) {
      Debug && t !== null && !(t instanceof Adornment2 || t instanceof HTMLInfo2) && U.n("ToolManager.currentToolTip must be an Adornment or HTMLInfo."), this.rP = t, this.Xm = t !== null && t instanceof Adornment2 ? t.adornedPart : null;
    }
    doMouseUp() {
      this.cancelWaitAfter();
      const t = this.diagram;
      if (this.isActive) {
        const i = this.mouseUpTools.length;
        for (let e = 0; e < i; e++) {
          const s = this.mouseUpTools.elt(e);
          if (s.diagram = this.diagram, s.canStart()) {
            t.doFocus(), t.currentTool = s, t.currentTool === s && (s.isActive || s.doActivate(), s.doMouseUp());
            return;
          }
        }
      }
      t.doFocus(), this.doDeactivate();
    }
    doMouseWheel() {
      this.standardMouseWheel();
    }
    doKeyDown() {
      const t = this.diagram;
      t.commandHandler !== null && t.commandHandler.doKeyDown();
    }
    doKeyUp() {
      const t = this.diagram;
      t.commandHandler !== null && t.commandHandler.doKeyUp();
    }
    findTool(t) {
      U.i(t, "string", ToolManager2, "findTool:name");
      let i = this.mouseDownTools.length;
      for (let e = 0; e < i; e++) {
        const s = this.mouseDownTools.elt(e);
        if (s.name === t) return s;
      }
      i = this.mouseMoveTools.length;
      for (let e = 0; e < i; e++) {
        const s = this.mouseMoveTools.elt(e);
        if (s.name === t) return s;
      }
      i = this.mouseUpTools.length;
      for (let e = 0; e < i; e++) {
        const s = this.mouseUpTools.elt(e);
        if (s.name === t) return s;
      }
      return null;
    }
    replaceTool(t, i) {
      U.i(t, "string", ToolManager2, "replaceTool:name"), i !== null && (U.s(i, Tool2, ToolManager2, "replaceTool:newtool"), i.diagram = this.diagram);
      let e = this.mouseDownTools.length;
      for (let s = 0; s < e; s++) {
        const n = this.mouseDownTools.elt(s);
        if (n.name === t) return i !== null ? this.mouseDownTools.setElt(s, i) : this.mouseDownTools.removeAt(s), n;
      }
      e = this.mouseMoveTools.length;
      for (let s = 0; s < e; s++) {
        const n = this.mouseMoveTools.elt(s);
        if (n.name === t) return i !== null ? this.mouseMoveTools.setElt(s, i) : this.mouseMoveTools.removeAt(s), n;
      }
      e = this.mouseUpTools.length;
      for (let s = 0; s < e; s++) {
        const n = this.mouseUpTools.elt(s);
        if (n.name === t) return i !== null ? this.mouseUpTools.setElt(s, i) : this.mouseUpTools.removeAt(s), n;
      }
      return null;
    }
    replaceStandardTool(t, i, e) {
      this.ti(t, i, e);
    }
    ti(t, i, e) {
      U.i(t, "string", ToolManager2, "replaceStandardTool:name"), U.s(e, List2, ToolManager2, "replaceStandardTool:list"), i !== null && (U.s(i, Tool2, ToolManager2, "replaceStandardTool:newtool"), i.name = t, i.diagram = this.diagram), this.findTool(t) ? this.replaceTool(t, i) : i !== null && e.add(i);
    }
    get mouseDownTools() {
      return this.cT;
    }
    get mouseMoveTools() {
      return this.uT;
    }
    get mouseUpTools() {
      return this.dT;
    }
    get hoverDelay() {
      return this.tP;
    }
    set hoverDelay(t) {
      U.i(t, "number", ToolManager2, "hoverDelay"), this.tP = t;
    }
    get holdDelay() {
      return this.iP;
    }
    set holdDelay(t) {
      U.i(t, "number", ToolManager2, "holdDelay"), this.iP = t;
    }
    get dragSize() {
      return this.eP;
    }
    set dragSize(t) {
      U.s(t, Size2, ToolManager2, "dragSize"), this.eP = t.T();
    }
    get toolTipDuration() {
      return this.sP;
    }
    set toolTipDuration(t) {
      U.i(t, "number", ToolManager2, "toolTipDuration"), this.sP = t;
    }
    get actionTool() {
      return this.findTool("Action");
    }
    set actionTool(t) {
      this.ti("Action", t, this.mouseDownTools);
    }
    get relinkingTool() {
      return this.findTool("Relinking");
    }
    set relinkingTool(t) {
      this.ti("Relinking", t, this.mouseDownTools);
    }
    get linkReshapingTool() {
      return this.findTool("LinkReshaping");
    }
    set linkReshapingTool(t) {
      this.ti("LinkReshaping", t, this.mouseDownTools);
    }
    get resizingTool() {
      return this.findTool("Resizing");
    }
    set resizingTool(t) {
      this.ti("Resizing", t, this.mouseDownTools);
    }
    get rotatingTool() {
      return this.findTool("Rotating");
    }
    set rotatingTool(t) {
      this.ti("Rotating", t, this.mouseDownTools);
    }
    get linkingTool() {
      return this.findTool("Linking");
    }
    set linkingTool(t) {
      this.ti("Linking", t, this.mouseMoveTools);
    }
    get draggingTool() {
      return this.findTool("Dragging");
    }
    set draggingTool(t) {
      this.ti("Dragging", t, this.mouseMoveTools);
    }
    get dragSelectingTool() {
      return this.findTool("DragSelecting");
    }
    set dragSelectingTool(t) {
      this.ti("DragSelecting", t, this.mouseMoveTools);
    }
    get panningTool() {
      return this.findTool("Panning");
    }
    set panningTool(t) {
      this.ti("Panning", t, this.mouseMoveTools);
    }
    get contextMenuTool() {
      return this.findTool("ContextMenu");
    }
    set contextMenuTool(t) {
      this.ti("ContextMenu", t, this.mouseUpTools);
    }
    get textEditingTool() {
      return this.findTool("TextEditing");
    }
    set textEditingTool(t) {
      this.ti("TextEditing", t, this.mouseUpTools);
    }
    get clickCreatingTool() {
      return this.findTool("ClickCreating");
    }
    set clickCreatingTool(t) {
      this.ti("ClickCreating", t, this.mouseUpTools);
    }
    get clickSelectingTool() {
      return this.findTool("ClickSelecting");
    }
    set clickSelectingTool(t) {
      this.ti("ClickSelecting", t, this.mouseUpTools);
    }
  }
  class DraggingTool2 extends Tool2 {
    lP;
    hP;
    Mn;
    aP;
    fP;
    cP;
    uP;
    zf;
    Ym;
    dP;
    oa;
    Cr;
    mT;
    gP;
    zu;
    Xu;
    mP;
    pP;
    yP;
    wP;
    static Ix = new List2();
    static fi = null;
    static ra = null;
    constructor(t) {
      super(), this.name = "Dragging", this.lP = true, this.wP = true, this.hP = true, this.Mn = null, this.aP = null, this.fP = null, this.cP = null, this.uP = false, this.zu = false, this.zf = new Point2(NaN, NaN), this.Ym = new Point2(), this.dP = true, this.oa = 100, this.Cr = [], this.mT = new GSet2().S(), this.gP = new DraggingOptions2(), this.Xu = null, this.mP = "copy", this.pP = "", this.yP = "no-drop", t && Object.assign(this, t);
    }
    get isCopyEnabled() {
      return this.lP;
    }
    set isCopyEnabled(t) {
      U.i(t, "boolean", DraggingTool2, "isCopyEnabled"), this.lP = t;
    }
    get copiesEffectiveCollection() {
      return this.hP;
    }
    set copiesEffectiveCollection(t) {
      U.i(t, "boolean", DraggingTool2, "copiesEffectiveCollection"), this.hP = t;
    }
    get dragOptions() {
      return this.gP;
    }
    set dragOptions(t) {
      U.s(t, DraggingOptions2, DraggingTool2, "dragOptions"), this.gP = t;
    }
    get isGridSnapEnabled() {
      return this.dragOptions.isGridSnapEnabled;
    }
    set isGridSnapEnabled(t) {
      U.i(t, "boolean", DraggingTool2, "isGridSnapEnabled"), this.dragOptions.isGridSnapEnabled = t;
    }
    get isComplexRoutingRealtime() {
      return this.dP;
    }
    set isComplexRoutingRealtime(t) {
      this.dP = t;
      const i = this.diagram.findRouter("AvoidsLinks");
      i !== null && (i.isRealtime = t);
    }
    get isGridSnapRealtime() {
      return this.dragOptions.isGridSnapRealtime;
    }
    set isGridSnapRealtime(t) {
      U.i(t, "boolean", DraggingTool2, "isGridSnapRealtime"), this.dragOptions.isGridSnapRealtime = t;
    }
    get gridSnapCellSize() {
      return this.dragOptions.gridSnapCellSize;
    }
    set gridSnapCellSize(t) {
      U.s(t, Size2, DraggingTool2, "gridSnapCellSize"), this.dragOptions.gridSnapCellSize.equals(t) || (t = t.T(), this.dragOptions.gridSnapCellSize = t);
    }
    get gridSnapCellSpot() {
      return this.dragOptions.gridSnapCellSpot;
    }
    set gridSnapCellSpot(t) {
      U.s(t, Spot2, DraggingTool2, "gridSnapCellSpot"), this.dragOptions.gridSnapCellSpot.equals(t) || (t = t.T(), this.dragOptions.gridSnapCellSpot = t);
    }
    get gridSnapOrigin() {
      return this.dragOptions.gridSnapOrigin;
    }
    set gridSnapOrigin(t) {
      U.s(t, Point2, DraggingTool2, "gridSnapOrigin"), this.dragOptions.gridSnapOrigin.equals(t) || (t = t.T(), this.dragOptions.gridSnapOrigin = t);
    }
    get dragsLink() {
      return this.dragOptions.dragsLink;
    }
    set dragsLink(t) {
      U.i(t, "boolean", DraggingTool2, "dragsLink"), this.dragOptions.dragsLink = t;
    }
    get dragsTree() {
      return this.dragOptions.dragsTree;
    }
    set dragsTree(t) {
      U.i(t, "boolean", DraggingTool2, "dragsTree"), this.dragOptions.dragsTree = t;
    }
    get copyCursor() {
      return this.mP;
    }
    set copyCursor(t) {
      this.mP = t;
    }
    get moveCursor() {
      return this.pP;
    }
    set moveCursor(t) {
      this.pP = t;
    }
    get nodropCursor() {
      return this.yP;
    }
    set nodropCursor(t) {
      this.yP = t;
    }
    get currentPart() {
      return this.aP;
    }
    set currentPart(t) {
      t !== null && U.s(t, Part2, DraggingTool2, "currentPart"), this.aP = t;
    }
    get copiedParts() {
      return this.cP;
    }
    set copiedParts(t) {
      this.cP = t;
    }
    get draggedParts() {
      return this.fP;
    }
    set draggedParts(t) {
      this.fP = t;
    }
    get draggingParts() {
      return this.copiedParts !== null ? this.copiedParts.toKeySet() : this.draggedParts !== null ? this.draggedParts.toKeySet() : this.mT;
    }
    get draggedLink() {
      return this.diagram.draggedLink;
    }
    set draggedLink(t) {
      t !== null && U.s(t, Link2, DraggingTool2, "draggedLink"), this.diagram.draggedLink = t;
    }
    get isDragOutStarted() {
      return this.uP;
    }
    set isDragOutStarted(t) {
      this.uP = t;
    }
    get startPoint() {
      return this.Ym;
    }
    set startPoint(t) {
      U.s(t, Point2, DraggingTool2, "startPoint"), this.Ym.equals(t) || this.Ym.c(t);
    }
    get delay() {
      return this.oa;
    }
    set delay(t) {
      U.i(t, "number", DraggingTool2, "delay"), this.oa = t;
    }
    canStart() {
      if (!this.isEnabled) return false;
      const t = this.diagram;
      if (t === null || t.isReadOnly && !t.allowDragOut || !t.allowMove && !t.allowCopy && !t.allowDragOut || !t.allowSelect) return false;
      const i = t.lastInput;
      return !i.left || t.currentTool !== this && (!this.isBeyondDragSize() || i.isTouchEvent && i.timestamp - t.firstInput.timestamp < this.oa) ? false : this.findDraggablePart() !== null;
    }
    findDraggablePart() {
      const t = this.diagram;
      let i = t.findPartAt(t.firstInput.documentPoint, false);
      if (i === null) return null;
      for (; i !== null && !i.canSelect(); ) i = i.containingGroup;
      return i !== null && (i.canMove() || i.canCopy()) ? i : null;
    }
    standardMouseSelect() {
      const t = this.diagram;
      if (!t.allowSelect) return;
      let i = t.findPartAt(t.firstInput.documentPoint, false);
      if (i !== null) {
        for (; i !== null && !i.canSelect(); ) i = i.containingGroup;
        if (this.currentPart = i, this.currentPart !== null && !this.currentPart.isSelected) {
          t.F("ChangingSelection", t.selection);
          const e = t.lastInput;
          !(U.wr ? e.meta : e.control) && !e.shift && t.clearSelection(true), this.currentPart.isSelected = true, t.F("ChangedSelection", t.selection);
        }
      }
    }
    doActivate() {
      const t = this.diagram;
      this.Xu = null, this.currentPart === null && this.standardMouseSelect();
      const i = this.currentPart;
      if (i === null || !i.canMove() && !i.canCopy()) return;
      t.cacheGroupExternalLinks(true), DraggingTool2.fi = null, this.isActive = true, this.zf.set(t.position), this.xP(t.selection), this.Cr.length = 0, t.animationManager.stopAnimation();
      const e = this.computeEffectiveCollection(t.selection, this.dragOptions);
      this.draggedParts = e, this.wP = !!this.diagram.layout.isRealtime, this.diagram.layout.isRealtime = false, t.Yu = true, t.getRenderingHint("temporaryPixelRatio") === true && t.avgSpf > 30 && t.Rx(), t.pT(this.draggedParts), t.Ku = true, this.startTransaction("Drag"), this.startPoint = t.firstInput.documentPoint, t.isMouseCaptured = true, t.allowDragOut && this.mR();
    }
    xP(t) {
      if (!this.dragsLink) return;
      const i = this.diagram, e = i.model.Km(), s = t.first();
      e && t.count === 1 && s instanceof Link2 && this.mayDragLink(s) ? (this.draggedLink = s, this.draggedLink.canRelinkFrom() && this.draggedLink.canRelinkTo() && this.draggedLink.clearAdornments(), this.Mn = i.toolManager.findTool("Relinking"), this.Mn === null && (this.Mn = new RelinkingTool2(), this.Mn.diagram = i), this.Mn.originalLink = this.draggedLink) : (this.draggedLink = null, this.Mn = null);
    }
    mayDragLink(t) {
      const i = this.diagram;
      return i !== null && i.allowRelink;
    }
    computeEffectiveCollection(t, i) {
      return this.diagram.commandHandler.computeEffectiveCollection(t, i);
    }
    Qs(t) {
      return t === void 0 ? new DraggingInfo2(Point2.wn) : this.isGridSnapEnabled ? new DraggingInfo2(new Point2(Math.round(t.x * 1e3) / 1e3, Math.round(t.y * 1e3) / 1e3)) : new DraggingInfo2(t.copy());
    }
    doDeactivate() {
      this.isActive = false;
      const t = this.diagram;
      this.diagram.layout.isRealtime = this.wP, t.Ku = false, t.Bl = true, t.cacheGroupExternalLinks(false), t.stopAutoScroll(), this.bP(), t.SP(this.draggedParts), this.Xu = null, this.currentPart = null, this.draggedParts = null, this.isDragOutStarted = false, this.zu = false, DraggingTool2.pR(), this.yT(), this.zf.e(NaN, NaN), DraggingTool2.ra !== null && (DraggingTool2.ra.currentCursor = ""), DraggingTool2.ra = null, DraggingTool2.fi = null, this.Vl(), t.isMouseCaptured = false, t.currentCursor = "", t.Yu = false, this.stopTransaction(), t.kP(true);
    }
    stopTransaction() {
      const t = this.diagram, i = super.stopTransaction();
      return i && t.undoManager.transactionToUndo !== null && t.undoManager.transactionToUndo.optimize(), i;
    }
    bP() {
      const t = this.diagram, i = t.skipsUndoManager;
      t.skipsUndoManager = true;
      const e = t.lastInput;
      this.wT(e, null), t.skipsUndoManager = i, this.Cr.length = 0;
    }
    xT() {
      this.Vl(), this.PP();
      const t = this.diagram;
      this.zf.isReal() && (t.position = this.zf), t.stopAutoScroll();
    }
    doCancel() {
      this.Vl(), this.PP();
      const t = this.diagram;
      this.zf.isReal() && (t.position = this.zf), this.stopTool();
    }
    doKeyDown() {
      const t = this.diagram;
      if (!this.isActive) return;
      const i = t.lastInput, e = t.previousInput;
      i.code === "Escape" ? this.doCancel() : (i.code !== e.code || i.modifiers !== e.modifiers) && this.doMouseMove();
    }
    doKeyUp() {
      this.isActive && this.doMouseMove();
    }
    yR(t, i) {
      let e = 1 / 0, s = 1 / 0, n = -1 / 0, o = -1 / 0;
      const r = t.iterator;
      for (; r.next(); ) {
        const l = r.value;
        if (!l.isVisible()) continue;
        const h = l.location, f = h.x, a = h.y;
        isNaN(f) || isNaN(a) || (f < e && (e = f), a < s && (s = a), f > n && (n = f), a > o && (o = a));
      }
      return e === 1 / 0 ? i.e(0, 0, 0, 0) : i.e(e, s, n - e, o - s), i;
    }
    MP(t) {
      if (this.copiedParts !== null) return;
      const i = this.diagram;
      if (t && (i.isReadOnly || i.isModelReadOnly) || this.draggedParts === null) return;
      const e = i.undoManager;
      e.isEnabled && e.isInTransaction ? e.currentTransaction !== null && e.currentTransaction.changes.count > 0 && (i.undoManager.rollbackTransaction(), i.startTransaction("Drag")) : this.PP(), i.skipsUndoManager = !t, i.partManager.addsToTemporaryLayer = !t, this.startPoint = i.firstInput.documentPoint;
      const s = this.copiesEffectiveCollection ? this.draggedParts.toKeySet() : i.selection, n = i.copyParts(s, i, true), o = new GMap2(), r = this.draggedParts.iterator;
      for (; r.next(); ) {
        const h = r.key;
        if (h.Oe() && h.canCopy()) {
          const f = n.get(h);
          if (f === null) continue;
          f.location = h.location, f.ensureBounds(), o.set(f, this.Qs(f.location));
        }
      }
      const l = n.iterator;
      for (; l.next(); ) {
        const h = l.value;
        h instanceof Link2 && h.canCopy() && o.set(h, this.Qs());
      }
      if (this.copiedParts = o, this.xP(o.toKeySet()), this.draggedLink !== null) {
        const h = this.draggedLink, f = h.routeBounds;
        h.Ar(this.startPoint.x - (f.x + f.width / 2), this.startPoint.y - (f.y + f.height / 2));
      }
      this.doUpdateCursor(null);
    }
    Vl() {
      const t = this.diagram;
      if (this.copiedParts !== null) {
        if (t.removeParts(this.copiedParts.toKeySet(), false), this.copiedParts = null, this.draggedParts !== null) {
          const i = this.draggedParts.iterator;
          for (; i.next(); ) if (i.key instanceof Link2) {
            const s = i.value;
            s.point = new Point2(0, 0);
          }
        }
        this.doUpdateCursor(null);
      }
      t.skipsUndoManager = false, t.partManager.addsToTemporaryLayer = false, this.startPoint = t.firstInput.documentPoint;
    }
    yT() {
      this.draggedLink !== null && (this.dragsLink && this.Mn !== null && (this.Mn.stopDraggingMouseMove(), this.Mn.originalLink = null), this.draggedLink = null, this.Mn = null);
    }
    Xf(t, i) {
      if (t === null) return;
      const e = this.diagram, s = this.startPoint, n = Point2.a();
      n.c(e.lastInput.documentPoint), this.moveParts(t, n.subtract(s), i), Point2.o(n), e.getRenderingHint("temporaryPixelRatio") === true && e.zl === null && e.avgSpf > 30 && (e.Rx(), e.Uu());
    }
    moveParts(t, i, e) {
      e === void 0 && (e = false);
      const s = this.diagram;
      s !== null && s.Ox(t, i, this.dragOptions, e);
    }
    PP() {
      if (this.draggedParts === null) return;
      const t = this.diagram;
      let i = this.draggedParts.iterator;
      for (; i.next(); ) {
        const e = i.key;
        e.Oe() && (e.location = i.value.point);
      }
      for (i = this.draggedParts.iterator; i.next(); ) {
        const e = i.key;
        if (e instanceof Link2 && e.suspendsRouting) {
          const s = i.value.point;
          this.draggedParts.set(e, this.Qs()), e.Ar(-s.x, -s.y);
        }
      }
      t.maybeUpdate();
    }
    wR(t) {
      if (t === null) return true;
      const i = t.part;
      return !!(i === null || i instanceof Adornment2 || i.layer?.isTemporary || this.draggedParts && this.draggedParts.has(i) || this.copiedParts && this.copiedParts.has(i));
    }
    NP(t) {
      const i = this.diagram;
      this.dragsLink && (this.draggedLink !== null && (this.draggedLink.fromNode = null, this.draggedLink.toNode = null), this.bT(false));
      const e = this.findDragOverObject(t), s = i.lastInput;
      s.targetObject = e, this.doUpdateCursor(e);
      const n = i.skipsUndoManager;
      let o = false;
      try {
        if (i.skipsUndoManager = true, o = this.wT(s, e), !this.isActive && DraggingTool2.fi === null) return;
        const r = e !== null ? e.part : null;
        if (r === null || i.handlesDragDropForTopLevelParts && r.isTopLevel && !(r instanceof Group2)) {
          const l = i.mouseDragOver;
          l !== null && (l(s), o = true);
        }
        if (!this.isActive && DraggingTool2.fi === null || (this.doDragOver(t, e), !this.isActive && DraggingTool2.fi === null)) return;
      } finally {
        i.skipsUndoManager = n, o && i.maybeUpdate();
      }
      this.Xu = e, !i.isReadOnly && (i.allowMove || i.allowCopy) && (i.allowHorizontalScroll || i.allowVerticalScroll) && i.doAutoScroll(s.viewPoint);
    }
    findDragOverObject(t) {
      return this.diagram.CP(t, null, (i) => !this.wR(i));
    }
    doUpdateCursor(t) {
      const i = this.diagram;
      (t === null || this.Xu !== t) && (!this.diagram.currentTool.isActive || this.mayCopy() ? i.currentCursor = this.copyCursor : this.mayMove() ? i.currentCursor = this.moveCursor : this.mayDragOut() && (i.currentCursor = this.nodropCursor));
    }
    wT(t, i) {
      let e = false, s = this.Cr.length;
      const n = s > 0 ? this.Cr[0] : null;
      if (i === n) return false;
      t.handled = false;
      for (let r = 0; r < s; r++) {
        const l = this.Cr[r], h = l.mouseDragLeave;
        if (h !== null && (h(t, l, i), e = true, t.handled)) break;
      }
      if (this.Cr.length = 0, !this.isActive && DraggingTool2.fi === null || i === null) return e;
      t.handled = false;
      let o = i;
      for (; o !== null; ) this.Cr.push(o), o = this.ST(o);
      s = this.Cr.length;
      for (let r = 0; r < s; r++) {
        const l = this.Cr[r], h = l.mouseDragEnter;
        if (h !== null && (h(t, l, n), e = true, t.handled)) break;
      }
      return e;
    }
    RB(t, i) {
      return t === null ? false : !!(t === i || t.isContainedBy(i) || i instanceof Group2 && !(t instanceof Group2) && i.handlesDragDropForMembers && t.part?.isMemberOf(i));
    }
    ST(t) {
      const i = t.panel;
      if (i !== null) return i;
      if (t instanceof Part2 && !(t instanceof Group2)) {
        const e = t.containingGroup;
        if (e !== null && e.handlesDragDropForMembers) return e;
      }
      return null;
    }
    kT(t, i) {
      const e = this.diagram, s = this.Mn;
      if (s === null) return null;
      const n = s.portGravity, o = e.findObjectsNear(t, n, (f) => s.findValidLinkablePort(f, i)), r = Point2.a();
      let l = 1 / 0, h = null;
      for (const f = o.iterator; f.next(); ) {
        const a = f.value;
        if (a.part === null) continue;
        const u = a.getDocumentPoint(Spot2.Center, r), d = t.distanceSquaredPoint(u);
        d < l && (h = a, l = d);
      }
      return Point2.o(r), h;
    }
    bT(t) {
      const i = this.draggedLink;
      if (i !== null) {
        if (i.pointsCount < 2) return;
        const e = this.diagram;
        if (e.isReadOnly) return;
        const s = this.Mn;
        if (s === null) return;
        let n = null, o = null;
        i.fromNode === null && (n = this.kT(i.getPoint(0), false), n !== null && (o = n.part));
        let r = null, l = null;
        i.toNode === null && (r = this.kT(i.getPoint(i.pointsCount - 1), true), r !== null && (l = r.part)), s.isValidLink(o, n, l, r) ? t ? (i.defaultFromPoint = i.getPoint(0), i.defaultToPoint = i.getPoint(i.pointsCount - 1), i.suspendsRouting = false, i.fromNode = o, n !== null && (i.fromPortId = n.portId), i.toNode = l, r !== null && (i.toPortId = r.portId), i.fromPort !== e.AP && e.F("LinkRelinked", i, e.AP), i.toPort !== e.TP && e.F("LinkRelinked", i, e.TP)) : s.doDraggingMouseMove(o, n, l, r) : s.doDraggingMouseMove(null, null, null, null);
      }
    }
    doDragOver(t, i) {
    }
    PT(t) {
      const i = this.diagram;
      this.dragsLink && this.bT(true), this.bP();
      const e = this.findDragOverObject(t), s = i.lastInput;
      if (s.targetObject = e, e !== null) {
        s.handled = false;
        let l = e;
        for (; l !== null; ) {
          const h = l.mouseDrop;
          if (h !== null && (h(s, l), s.handled)) break;
          this.xR(s, l), l = this.ST(l);
        }
      } else {
        const l = i.mouseDrop;
        l !== null && l(s);
      }
      if (!this.isActive && DraggingTool2.fi === null) return;
      const n = this.copiedParts || this.draggedParts;
      if (n !== null) {
        const l = n.iterator;
        for (; l.next(); ) {
          const h = l.key;
          h instanceof Node2 && h.linksConnected.each((f) => f.suspendsRouting = false);
        }
      }
      if (this.doDropOnto(t, e), !this.isActive && DraggingTool2.fi === null) return;
      const o = Rect2.a(), r = i.selection.iterator;
      for (; r.next(); ) {
        const l = r.value;
        l instanceof Node2 && this.bR(i, l, o);
      }
      Rect2.o(o);
    }
    xR(t, i) {
      const e = this.diagram, s = i.part;
      if (e.handlesDragDropForTopLevelParts && s !== null && s.isTopLevel && !(s instanceof Group2)) {
        const n = e.mouseDrop;
        n !== null && n(t);
      }
    }
    bR(t, i, e) {
      if (!i.canAvoid()) return;
      let s = false;
      e = i.getAvoidableRect(e), t.viewportBounds.containsRect(e) && (s = true);
      const n = this.copiedParts || this.draggedParts;
      if (n === null) return;
      const o = t.LP(e, (l) => l.part, (l) => l instanceof Link2, true, (l) => l instanceof Link2, s);
      if (o.count === 0) return;
      const r = o.iterator;
      for (; r.next(); ) {
        const l = r.value;
        n.has(l) && n.has(i) || !l.isMemberOf(i) && l.isAvoiding && l.ii();
      }
    }
    doDropOnto(t, i) {
    }
    doMouseMove() {
      if (!this.isActive) return;
      const t = this.diagram, i = t.lastInput;
      if (this.simulatedMouseMove(i.event, i.documentPoint, i.targetDiagram)) return;
      this.currentPart !== null && this.draggedParts !== null && (this.mayCopy() ? (this.MP(false), this.Xf(this.copiedParts, false)) : this.mayMove() ? (this.Vl(), this.Xf(this.draggedParts, true)) : this.mayDragOut() ? (this.MP(false), this.Xf(this.copiedParts, false)) : this.Vl(), this.NP(t.lastInput.documentPoint));
    }
    doMouseUp() {
      if (!this.isActive) return;
      const t = this.diagram, i = t.lastInput;
      if (this.simulatedMouseUp(i.event, i.documentPoint, i.targetDiagram)) return;
      let e = false;
      const s = this.mayCopy();
      if (s && this.copiedParts !== null ? (this.Vl(), this.MP(true), this.Xf(this.copiedParts, false), this.copiedParts !== null && (t.F("ChangingSelection", t.selection), t.clearSelection(true), this.copiedParts.iteratorKeys.each((n) => {
        n.isSelected = true;
      }))) : (e = true, this.Vl(), this.mayMove() && (this.Xf(this.draggedParts, true), this.NP(t.lastInput.documentPoint))), this.zu = true, this.PT(t.lastInput.documentPoint), this.isActive) {
        const n = s && this.copiedParts, o = n ? this.copiedParts?.toKeySet() : this.draggedParts ? this.draggedParts.toKeySet() : null;
        this.copiedParts = null, e && this.SR(), t.invalidateDocumentBounds(), t.SP(this.draggedParts), this.transactionResult = n ? "Copy" : "Move", t.F(n ? "SelectionCopied" : "SelectionMoved", o);
      }
      this.stopTool(), s && t.F("ChangedSelection", t.selection);
    }
    simulatedMouseMove(t, i, e) {
      if (DraggingTool2.fi === null) return false;
      const s = DraggingTool2.fi.diagram;
      e instanceof Diagram2 || (e = null);
      const n = DraggingTool2.ra;
      if (e !== n) {
        if (n !== null && n !== s) {
          n.stopAutoScroll(), DraggingTool2.fi.isDragOutStarted = false;
          const r = n.toolManager.findTool("Dragging");
          r !== null && r.doSimulatedDragLeave();
        }
        if (DraggingTool2.ra = e, e !== null && e !== s) {
          DraggingTool2.fi.xT();
          const r = e.toolManager.findTool("Dragging");
          r !== null && (r.MT(), r.doSimulatedDragEnter());
        }
        this.doUpdateCursor(null);
      }
      if (e === null || e === s || !e.allowDrop || e.isReadOnly || !e.allowInsert) return false;
      const o = e.toolManager.findTool("Dragging");
      if (o !== null) {
        let r = i;
        t !== null && (t.targetTouches !== void 0 && (t.targetTouches.length > 0 ? t = t.targetTouches[0] : t.changedTouches.length > 0 && (t = t.changedTouches[0])), r = e.getMouse(t)), e.lastInput.documentPoint = r, e.lastInput.viewPoint = e.transformDocToView(r), e.lastInput.down = false, e.lastInput.up = false, o.doSimulatedDragOver();
      }
      return true;
    }
    simulatedMouseUp(t, i, e) {
      if (DraggingTool2.fi === null) return false;
      const s = DraggingTool2.ra, n = DraggingTool2.fi.diagram;
      if (e === null) return DraggingTool2.fi.doCancel(), true;
      if (e !== s) {
        if (s !== null) {
          const r = s.toolManager.findTool("Dragging");
          if (s !== null && s !== n && r !== null) return s.stopAutoScroll(), DraggingTool2.fi.isDragOutStarted = false, r.doSimulatedDragLeave(), false;
        }
        DraggingTool2.ra = e;
        const o = e.toolManager.findTool("Dragging");
        o !== null && (DraggingTool2.fi.xT(), o.MT(), o.doSimulatedDragEnter());
      }
      if (e !== this.diagram) {
        let o = i;
        t !== null ? (t.targetTouches !== void 0 && (t.targetTouches.length > 0 ? t = t.targetTouches[0] : t.changedTouches.length > 0 && (t = t.changedTouches[0])), o = e.getMouse(t)) : o === null && (o = new Point2()), e.lastInput.documentPoint = o, e.lastInput.viewPoint = e.transformDocToView(o), e.lastInput.down = false, e.lastInput.up = true;
        const r = e.toolManager.findTool("Dragging");
        r !== null && r.doSimulatedDrop();
        const l = DraggingTool2.fi;
        if (l !== null) {
          const h = l.mayCopy();
          l.transactionResult = h ? "Copy" : "Move", l.stopTool();
        }
        return true;
      }
      return false;
    }
    SR() {
      if (this.draggedParts === null) return;
      const t = this.draggedParts.iterator;
      for (; t.next(); ) {
        const i = t.key;
        if (i instanceof Node2) {
          const e = i.containingGroup;
          e !== null && e.hasPlaceholder() && !this.draggedParts.has(e) && e.placeholder.g();
        }
      }
    }
    mayCopy() {
      if (!this.isCopyEnabled) return false;
      const t = this.diagram;
      if (t.isReadOnly || t.isModelReadOnly || !t.allowInsert || !t.allowCopy || !(U.wr ? t.lastInput.alt : t.lastInput.control)) return false;
      const i = t.selection.iterator;
      for (; i.next(); ) if (i.value.canCopy()) return true;
      return !!(this.draggedLink !== null && this.dragsLink && this.draggedLink.canCopy());
    }
    mayDragOut() {
      if (!this.isCopyEnabled) return false;
      const t = this.diagram;
      if (!t.allowDragOut || !t.allowCopy || t.allowMove) return false;
      const i = t.selection.iterator;
      for (; i.next(); ) if (i.value.canCopy()) return true;
      return !!(this.draggedLink !== null && this.dragsLink && this.draggedLink.canCopy());
    }
    mayMove() {
      const t = this.diagram;
      if (t.isReadOnly || !t.allowMove) return false;
      const i = t.selection.iterator;
      for (; i.next(); ) if (i.value.canMove()) return true;
      return !!(this.draggedLink !== null && this.dragsLink && this.draggedLink.canMove());
    }
    MT() {
      DraggingTool2.Ix.has(this) || DraggingTool2.Ix.add(this);
    }
    static pR() {
      if (DraggingTool2.Ix.count > 0) {
        const t = DraggingTool2.Ix, i = t.length;
        for (let e = 0; e < i; e++) {
          const s = t.elt(e);
          s.yT(), s.Vl(), s.bP(), s.diagram.stopAutoScroll();
        }
        t.clear();
      }
    }
    kR(t, i, e) {
      return !this.zu && this.draggedParts !== null && !this.draggedParts.has(t) ? (e.c(i), true) : false;
    }
    get draggingSource() {
      return DraggingTool2.fi;
    }
    mayDragIn() {
      const t = this.diagram;
      if (!t.allowDrop || t.isReadOnly || t.isModelReadOnly || !t.allowInsert) return false;
      const i = DraggingTool2.fi;
      return !(i === null || i.diagram.model.dataFormat !== t.model.dataFormat);
    }
    doSimulatedDragEnter() {
      if (!this.mayDragIn()) return;
      const t = this.diagram;
      t.animationManager.stopAnimation(), t.Tr(), t.animationManager.stopAnimation();
      const i = DraggingTool2.fi;
      i !== null && (this.diagram.Yu = true, t.lastInput.event === null && (t.lastInput.event = i.diagram.lastInput.event)), this.doUpdateCursor(null);
    }
    doSimulatedDragLeave() {
      const t = DraggingTool2.fi;
      t !== null && t.doSimulatedDragOut(), this.diagram.Yu = false, this.doCancel();
    }
    doSimulatedDragOver() {
      const t = this.diagram;
      t.animationManager.Gu = true;
      const i = DraggingTool2.fi;
      if (i !== null && i.draggedParts !== null) {
        if (!this.mayDragIn()) return;
        this.NT(i.draggedParts.toKeySet(), false, t.firstInput), this.Xf(this.copiedParts, false), this.NP(t.lastInput.documentPoint);
      }
      t.animationManager.Gu = false;
    }
    doSimulatedDrop() {
      const t = this.diagram, i = DraggingTool2.fi;
      if (i !== null) {
        const e = i.diagram;
        if (i.zu = true, this.Vl(), i.draggedParts === null || !this.mayDragIn()) return;
        t.animationManager.Gu = true, t.F("ChangingSelection", t.selection), this.startTransaction("Drop"), this.NT(i.draggedParts.toKeySet(), true, t.lastInput), this.Xf(this.copiedParts, false);
        const s = new GSet2();
        this.copiedParts !== null && (t.clearSelection(true), this.copiedParts.iteratorKeys.each((n) => {
          n.isSelected = true, s.add(n);
        })), this.PT(t.lastInput.documentPoint), t.invalidateDocumentBounds(), this.copiedParts !== null && (this.transactionResult = "ExternalCopy"), this.copiedParts = null, t.doFocus(), t.Yu = false, t.F("ExternalObjectsDropped", s, e), this.stopTransaction(), t.F("ChangedSelection", t.selection);
      }
      t.animationManager.Gu = false;
    }
    NT(t, i, e) {
      if (this.copiedParts !== null) return;
      const s = this.diagram;
      if (s.isReadOnly || s.isModelReadOnly) return;
      s.skipsUndoManager = !i, s.partManager.addsToTemporaryLayer = !i, this.startPoint = e.documentPoint;
      const n = s.copyParts(t, s, true), o = Rect2.a();
      this.yR(t, o);
      const r = o.x + o.width / 2, l = o.y + o.height / 2;
      Rect2.o(o);
      const h = this.Ym, f = new GMap2(), a = Point2.a(), c = t.iterator;
      for (; c.next(); ) {
        const d = c.value;
        if (d instanceof Link2 && d.canCopy()) {
          const m = n.get(d);
          if (m === null) continue;
          m.points = d.points, m.Ar(h.x - r, h.y - l), m.suspendsRouting = true, f.set(m, this.Qs());
        }
      }
      const u = t.iterator;
      for (; u.next(); ) {
        const d = u.value;
        if (d.Oe() && d.canCopy()) {
          const m = n.get(d);
          if (m === null) continue;
          const g = d.location;
          a.e(h.x - (r - g.x), h.y - (l - g.y)), m.location = a, m.ensureBounds(), f.set(m, this.Qs(a));
        }
      }
      if (Point2.o(a), this.copiedParts = f, this.xP(f.toKeySet()), this.draggedLink !== null) {
        const d = this.draggedLink, m = d.routeBounds;
        d.Ar(this.startPoint.x - (m.x + m.width / 2), this.startPoint.y - (m.y + m.height / 2));
      }
      this.doUpdateCursor(null);
    }
    mR() {
      this.isDragOutStarted = true, this.zu = false, DraggingTool2.fi = this, DraggingTool2.ra = this.diagram, this.doSimulatedDragOut();
    }
    doSimulatedDragOut() {
      const t = this.diagram;
      !this.mayCopy() && !this.mayMove() ? t.currentCursor = this.nodropCursor : t.currentCursor = "", this.Xu = null;
    }
    computeMove(t, i, e, s) {
      const n = this.diagram;
      return n !== null ? n.computeMove(t, i, this.dragOptions, s) : new Point2();
    }
  }
  ToolManager2.prototype.doCancel = function() {
    DraggingTool2.fi !== null && DraggingTool2.fi.doCancel(), Tool2.prototype.doCancel.call(this);
  };
  class LinkingBaseTool2 extends Tool2 {
    DP;
    FP;
    Xl;
    IP;
    RP;
    la;
    OP;
    ha;
    EP;
    BP;
    VP;
    zP;
    XP;
    YP;
    CT;
    KP;
    Yl;
    UP;
    constructor() {
      super(), this.DP = 100, this.FP = false, this.Xl = "pointer", this.IP = new Link2({ layerName: "Tool" }).add(new Shape2({ isPanelMain: true, stroke: "blue" }).theme("stroke", "tempLink"), new Shape2({ toArrow: "Standard", fill: "blue", stroke: "blue" }).theme("fill", "tempLink").theme("stroke", "tempLink")).Yt(), this.la = new Shape2("Rectangle", { portId: "", fill: null, stroke: "magenta", strokeWidth: 2, desiredSize: Size2.Bk }).theme("stroke", "tempPort"), this.RP = new Node2({ selectable: false, layerName: "Tool" }).add(this.la).Yt(), this.ha = new Shape2("Rectangle", { portId: "", fill: null, stroke: "magenta", strokeWidth: 2, desiredSize: Size2.Bk }).theme("stroke", "tempPort"), this.OP = new Node2({ selectable: false, layerName: "Tool" }).add(this.ha).Yt(), this.EP = null, this.BP = null, this.VP = null, this.zP = null, this.XP = null, this.YP = true, this.CT = new GMap2(), this.KP = null, this.Yl = null, this.UP = null;
    }
    doStop() {
      this.diagram.stopAutoScroll(), this.originalLink = null, this.originalFromNode = null, this.originalFromPort = null, this.originalToNode = null, this.originalToPort = null, this.validPortsCache.clear(), this.targetPort = null;
    }
    get portGravity() {
      return this.DP;
    }
    set portGravity(t) {
      U.i(t, "number", LinkingBaseTool2, "portGravity"), t >= 0 && (this.DP = t);
    }
    get isUnconnectedLinkValid() {
      return this.FP;
    }
    set isUnconnectedLinkValid(t) {
      U.i(t, "boolean", LinkingBaseTool2, "isUnconnectedLinkValid"), this.FP = t;
    }
    get linkingCursor() {
      return this.Xl;
    }
    set linkingCursor(t) {
      this.Xl = t;
    }
    get temporaryLink() {
      return this.IP;
    }
    set temporaryLink(t) {
      U.s(t, Link2, LinkingBaseTool2, "temporaryLink"), t.Yt(), this.IP = t;
    }
    get temporaryFromNode() {
      return this.RP;
    }
    set temporaryFromNode(t) {
      U.s(t, Node2, LinkingBaseTool2, "temporaryFromNode"), t.Yt(), this.RP = t, t && (this.la = t.port);
    }
    get temporaryFromPort() {
      return this.la;
    }
    set temporaryFromPort(t) {
      if (U.s(t, GraphObject2, LinkingBaseTool2, "temporaryFromPort"), this.la !== null) {
        const i = this.la.panel;
        if (i !== null) {
          const e = i.O.indexOf(this.la);
          i.removeAt(e), i.insertAt(e, t);
        }
      }
      this.la = t;
    }
    get temporaryToNode() {
      return this.OP;
    }
    set temporaryToNode(t) {
      U.s(t, Node2, LinkingBaseTool2, "temporaryToNode"), t.Yt(), this.OP = t, t && (this.ha = t.port);
    }
    get temporaryToPort() {
      return this.ha;
    }
    set temporaryToPort(t) {
      if (U.s(t, GraphObject2, LinkingBaseTool2, "temporaryToPort"), this.ha !== null) {
        const i = this.ha.panel;
        if (i !== null) {
          const e = i.O.indexOf(this.ha);
          i.removeAt(e), i.insertAt(e, t);
        }
      }
      this.ha = t;
    }
    get originalLink() {
      return this.EP;
    }
    set originalLink(t) {
      t !== null && U.s(t, Link2, LinkingBaseTool2, "originalLink"), this.EP = t;
    }
    get originalFromNode() {
      return this.BP;
    }
    set originalFromNode(t) {
      t !== null && U.s(t, Node2, LinkingBaseTool2, "originalFromNode"), this.BP = t;
    }
    get originalFromPort() {
      return this.VP;
    }
    set originalFromPort(t) {
      t !== null && U.s(t, GraphObject2, LinkingBaseTool2, "originalFromPort"), this.VP = t;
    }
    get originalToNode() {
      return this.zP;
    }
    set originalToNode(t) {
      t !== null && U.s(t, Node2, LinkingBaseTool2, "originalToNode"), this.zP = t;
    }
    get originalToPort() {
      return this.XP;
    }
    set originalToPort(t) {
      t !== null && U.s(t, GraphObject2, LinkingBaseTool2, "originalToPort"), this.XP = t;
    }
    get isForwards() {
      return this.YP;
    }
    set isForwards(t) {
      this.YP = t;
    }
    get validPortsCache() {
      return this.CT;
    }
    get targetPort() {
      return this.KP;
    }
    set targetPort(t) {
      t !== null && U.s(t, GraphObject2, LinkingBaseTool2, "targetPort"), this.KP = t;
    }
    copyPortProperties(t, i, e, s, n) {
      if (t === null || i === null || e === null || s === null) return;
      const o = i.getDocumentScale(), r = Size2.a();
      r.width = i.naturalBounds.width * o, r.height = i.naturalBounds.height * o, s.desiredSize = r, Size2.o(r), n ? (s.toSpot = i.toSpot, s.toEndSegmentLength = i.toEndSegmentLength) : (s.fromSpot = i.fromSpot, s.fromEndSegmentLength = i.fromEndSegmentLength), e.locationSpot = Spot2.Center;
      const l = Point2.a();
      e.location = i.getDocumentPoint(Spot2.Center, l), Point2.o(l), s.angle = i.getDocumentAngle(), this.portTargeted !== null && this.portTargeted(t, i, e, s, n);
    }
    setNoTargetPortProperties(t, i, e) {
      i !== null && (i.desiredSize = Size2.Bk, i.fromSpot = Spot2.None, i.toSpot = Spot2.None), t !== null && (t.location = this.diagram.lastInput.documentPoint), this.portTargeted !== null && this.portTargeted(null, null, t, i, e);
    }
    doMouseDown() {
      this.isActive && this.doMouseMove();
    }
    doMouseMove() {
      if (this.isActive) {
        const t = this.diagram;
        if (this.targetPort = this.findTargetPort(this.isForwards), this.targetPort !== null && this.targetPort.part instanceof Node2) {
          const i = this.targetPort.part;
          this.isForwards ? this.copyPortProperties(i, this.targetPort, this.temporaryToNode, this.temporaryToPort, true) : this.copyPortProperties(i, this.targetPort, this.temporaryFromNode, this.temporaryFromPort, false);
        } else this.isForwards ? this.setNoTargetPortProperties(this.temporaryToNode, this.temporaryToPort, true) : this.setNoTargetPortProperties(this.temporaryFromNode, this.temporaryFromPort, false);
        (t.allowHorizontalScroll || t.allowVerticalScroll) && t.doAutoScroll(t.lastInput.viewPoint);
      }
    }
    findValidLinkablePort(t, i) {
      if (t === null) return null;
      const e = t.part;
      if (!(e instanceof Node2)) return null;
      for (; t !== null; ) {
        const s = i ? t.toLinkable : t.fromLinkable;
        if (s === true && (t.portId !== null || t instanceof Node2) && (i ? this.isValidTo(e, t) : this.isValidFrom(e, t))) return t;
        if (s === false) return null;
        t = t.panel;
      }
      return null;
    }
    findTargetPort(t) {
      const i = this.diagram, e = i.lastInput.documentPoint;
      let s = this.portGravity;
      const n = i.findObjectsNear(e, s, (h) => this.findValidLinkablePort(h, t), null, true);
      let o = 1 / 0, r = null;
      const l = n.iterator;
      for (; l.next(); ) {
        const h = l.value, f = h.part;
        if (!(f instanceof Node2)) continue;
        const a = h.getDocumentPoint(Spot2.Center, Point2.a()), c = e.x - a.x, u = e.y - a.y;
        Point2.o(a);
        const d = c * c + u * u;
        if (d < o) {
          const m = this.validPortsCache.get(h);
          m !== null ? m && (r = h, o = d) : t && this.isValidLink(this.originalFromNode, this.originalFromPort, f, h) || !t && this.isValidLink(f, h, this.originalToNode, this.originalToPort) ? (this.validPortsCache.set(h, true), r = h, o = d) : this.validPortsCache.set(h, false);
        }
      }
      if (r !== null) {
        const h = r.part;
        if (h instanceof Node2 && (h.layer === null || h.layer.allowLink)) return r;
      }
      return null;
    }
    isValidFrom(t, i) {
      if (t === null || i === null) return this.isUnconnectedLinkValid;
      if (this.diagram.currentTool === this && (t.layer !== null && !t.layer.allowLink || i.fromLinkable !== true)) return false;
      const e = i.fromMaxLinks;
      if (e < 1 / 0) {
        if (this.originalLink !== null && t === this.originalFromNode && i === this.originalFromPort) return true;
        let s = i.portId;
        if (s === null && (s = ""), t.findLinksOutOf(s).count >= e) return false;
      }
      return true;
    }
    isValidTo(t, i) {
      if (t === null || i === null) return this.isUnconnectedLinkValid;
      if (this.diagram.currentTool === this && (t.layer !== null && !t.layer.allowLink || i.toLinkable !== true)) return false;
      const e = i.toMaxLinks;
      if (e < 1 / 0) {
        if (this.originalLink !== null && t === this.originalToNode && i === this.originalToPort) return true;
        let s = i.portId;
        if (s === null && (s = ""), t.findLinksInto(s).count >= e) return false;
      }
      return true;
    }
    isInSameNode(t, i) {
      if (t === null || i === null) return false;
      if (t === i) return true;
      const e = t.part, s = i.part;
      return e !== null && e === s;
    }
    isLinked(t, i) {
      if (t === null || i === null) return false;
      const e = t.part;
      if (!(e instanceof Node2)) return false;
      let s = t.portId;
      s === null && (s = "");
      const n = i.part;
      if (!(n instanceof Node2)) return false;
      let o = i.portId;
      o === null && (o = "");
      const r = n.findLinksInto(o);
      for (; r.next(); ) {
        const l = r.value;
        if (l.fromNode === e && l.fromPortId === s) return true;
      }
      return false;
    }
    isValidLink(t, i, e, s) {
      if (!this.isValidFrom(t, i) || !this.isValidTo(e, s) || i !== null && s !== null && (!(i.fromLinkableSelfNode && s.toLinkableSelfNode) && this.isInSameNode(i, s) || !(i.fromLinkableDuplicates && s.toLinkableDuplicates) && this.isLinked(i, s)) || this.originalLink !== null && (t !== null && this.isLabelDependentOnLink(t, this.originalLink) || e !== null && this.isLabelDependentOnLink(e, this.originalLink)) || t !== null && e !== null && (t.data === null && e.data !== null || t.data !== null && e.data === null) || !this.isValidCycle(t, e, this.originalLink)) return false;
      let n;
      return t !== null && i !== null && (n = t.linkValidation, n !== null && !n(t, i, e, s, this.originalLink)) || e !== null && s !== null && (n = e.linkValidation, n !== null && !n(t, i, e, s, this.originalLink)) ? false : (n = this.linkValidation, n !== null ? n(t, i, e, s, this.originalLink) : true);
    }
    isLabelDependentOnLink(t, i) {
      if (t === null) return false;
      const e = t.labeledLink;
      if (e === null) return false;
      if (e === i) return true;
      const s = new GSet2();
      return s.add(t), this.GP(e, i, s);
    }
    GP(t, i, e) {
      if (t === i) return true;
      const s = t.fromNode;
      if (s !== null && s.labeledLink && (e.add(s), this.GP(s.labeledLink, i, e))) return true;
      const n = t.toNode;
      return !!(n !== null && n.labeledLink && (e.add(n), this.GP(n.labeledLink, i, e)));
    }
    isValidCycle(t, i, e) {
      if (e === void 0 && (e = null), t === null || i === null) return this.isUnconnectedLinkValid;
      const s = this.diagram;
      let n = 1;
      if (s && (s.model.Um() ? n = s.isTreePathToChildren ? 5 : 6 : n = s.validCycle), n === 1) return true;
      if (n === 5) {
        const o = e || this.temporaryLink;
        if (o !== null && !o.isTreeLink) return true;
        const r = i.linksConnected;
        for (; r.next(); ) {
          const l = r.value;
          if (l !== e && l.isTreeLink && l.toNode === i) return false;
        }
        return !this.qu(t, i, e, true);
      } else if (n === 6) {
        const o = e || this.temporaryLink;
        if (o !== null && !o.isTreeLink) return true;
        const r = t.linksConnected;
        for (; r.next(); ) {
          const l = r.value;
          if (l !== e && l.isTreeLink && l.fromNode === t) return false;
        }
        return !this.qu(t, i, e, true);
      } else {
        if (n === 2) return !this.PR(t, i, e);
        if (n === 3) return !this.qu(t, i, e, false);
        if (n === 4) return !this.MR(t, i, e);
      }
      return true;
    }
    qu(t, i, e, s) {
      if (t === i) return true;
      if (t === null || i === null) return false;
      const n = t.linksConnected;
      for (; n.next(); ) {
        const o = n.value;
        if (o === e || s && !o.isTreeLink || o.toNode !== t) continue;
        const r = o.fromNode;
        if (!(r === t || r === null) && this.qu(r, i, e, s)) return true;
      }
      return false;
    }
    PR(t, i, e) {
      if (t === i) return true;
      const s = /* @__PURE__ */ new Set();
      return s.add(i), this.AT(s, t, i, e);
    }
    AT(t, i, e, s) {
      if (i === e) return true;
      if (i === null || e === null || t.has(i)) return false;
      t.add(i);
      const n = i.linksConnected;
      for (; n.next(); ) {
        const o = n.value;
        if (o === s || o.toNode !== i) continue;
        const r = o.fromNode;
        if (!(r === i || r === null) && this.AT(t, r, e, s)) return true;
      }
      return false;
    }
    MR(t, i, e) {
      if (t === i) return true;
      const s = /* @__PURE__ */ new Set();
      return s.add(i), this.TT(s, t, i, e);
    }
    TT(t, i, e, s) {
      if (i === e) return true;
      if (i === null || e === null || t.has(i)) return false;
      t.add(i);
      const n = i.linksConnected;
      for (; n.next(); ) {
        const o = n.value;
        if (o === s) continue;
        const r = o.fromNode, l = o.toNode, h = r === i ? l : r;
        if (!(h === i || h === null) && this.TT(t, h, e, s)) return true;
      }
      return false;
    }
    get linkValidation() {
      return this.Yl;
    }
    set linkValidation(t) {
      t !== null && U.C(t, LinkingBaseTool2, "linkValidation"), this.Yl = t;
    }
    get portTargeted() {
      return this.UP;
    }
    set portTargeted(t) {
      t !== null && U.C(t, LinkingBaseTool2, "portTargeted"), this.UP = t;
    }
  }
  var LinkingDirection2 = ((w) => (w[w.Either = 1] = "Either", w[w.ForwardsOnly = 2] = "ForwardsOnly", w[w.BackwardsOnly = 3] = "BackwardsOnly", w))(LinkingDirection2 || {});
  class LinkingTool2 extends LinkingBaseTool2 {
    qP;
    HP;
    N;
    vP;
    constructor(t) {
      super(), this.name = "Linking", this.qP = {}, this.HP = null, this.N = 1, this.vP = null, t && Object.assign(this, t);
    }
    static Either = 1;
    static ForwardsOnly = 2;
    static BackwardsOnly = 3;
    get archetypeLinkData() {
      return this.qP;
    }
    set archetypeLinkData(t) {
      t !== null && U.Oo(t, LinkingTool2, "archetypeLinkData"), t instanceof GraphObject2 && U.s(t, Link2, LinkingTool2, "archetypeLinkData"), this.qP = t;
    }
    get archetypeLabelNodeData() {
      return this.HP;
    }
    set archetypeLabelNodeData(t) {
      t !== null && U.Oo(t, LinkingTool2, "archetypeLabelNodeData"), t instanceof GraphObject2 && U.s(t, Node2, LinkingTool2, "archetypeLabelNodeData"), this.HP = t;
    }
    get direction() {
      return this.N;
    }
    set direction(t) {
      U.W(t, LinkingDirection2, "LinkingDirection"), this.N = t;
    }
    get startObject() {
      return this.vP;
    }
    set startObject(t) {
      t !== null && U.s(t, GraphObject2, LinkingTool2, "startObject"), this.vP = t;
    }
    canStart() {
      if (!this.isEnabled) return false;
      const t = this.diagram;
      return t.isReadOnly || t.isModelReadOnly || !t.allowLink || !t.model.Ex() || !t.lastInput.left || t.currentTool !== this && !this.isBeyondDragSize() ? false : this.findLinkablePort() !== null;
    }
    findLinkablePort() {
      const t = this.diagram;
      let i = this.startObject;
      if (i === null && (i = t.findObjectAt(t.firstInput.documentPoint, null, null)), i === null) return null;
      const e = i.part;
      if (!(e instanceof Node2)) return null;
      const s = this.direction;
      if (s === 1 || s === 2) {
        const n = this.findValidLinkablePort(i, false);
        if (n !== null) return this.isForwards = true, n;
        if (this.startObject === e) {
          const o = e.port;
          if (this.findValidLinkablePort(o, false)) return this.isForwards = true, o;
        }
      }
      if (s === 1 || s === 3) {
        const n = this.findValidLinkablePort(i, true);
        if (n !== null) return this.isForwards = false, n;
        if (this.startObject === e) {
          const o = e.port;
          if (this.findValidLinkablePort(o, true)) return this.isForwards = false, o;
        }
      }
      return null;
    }
    doActivate() {
      const t = this.diagram, i = this.findLinkablePort();
      if (i === null) {
        this.stopTool();
        return;
      }
      if (this.startTransaction(this.name), t.isMouseCaptured = true, t.currentCursor = this.linkingCursor, this.isForwards) {
        this.temporaryToNode !== null && (this.temporaryToNode.location = t.lastInput.documentPoint), this.originalFromPort = i;
        const e = this.originalFromPort.part;
        e instanceof Node2 && (this.originalFromNode = e), this.copyPortProperties(this.originalFromNode, this.originalFromPort, this.temporaryFromNode, this.temporaryFromPort, false);
      } else {
        this.temporaryFromNode !== null && (this.temporaryFromNode.location = t.lastInput.documentPoint), this.originalToPort = i;
        const e = this.originalToPort.part;
        e instanceof Node2 && (this.originalToNode = e), this.copyPortProperties(this.originalToNode, this.originalToPort, this.temporaryToNode, this.temporaryToPort, true);
      }
      t.add(this.temporaryFromNode), this.temporaryFromNode && this.temporaryFromNode.ensureBounds(), t.add(this.temporaryToNode), this.temporaryToNode && this.temporaryToNode.ensureBounds(), this.temporaryLink !== null && (this.temporaryFromNode !== null && (this.temporaryLink.fromNode = this.temporaryFromNode), this.temporaryToNode !== null && (this.temporaryLink.toNode = this.temporaryToNode), this.temporaryLink.isTreeLink = this.isNewTreeLink(), this.temporaryLink.ii(), t.add(this.temporaryLink)), this.isActive = true;
    }
    doDeactivate() {
      this.isActive = false;
      const t = this.diagram;
      t.remove(this.temporaryLink), t.remove(this.temporaryFromNode), t.remove(this.temporaryToNode), t.isMouseCaptured = false, t.currentCursor = "", this.stopTransaction();
    }
    doStop() {
      super.doStop(), this.startObject = null;
    }
    doMouseUp() {
      if (this.isActive) {
        const t = this.diagram;
        this.transactionResult = null;
        let i = null, e = null, s = null, n = null, o = null;
        try {
          this.targetPort = this.findTargetPort(this.isForwards);
          const r = this.targetPort;
          if (r !== null) {
            const l = r.part;
            l instanceof Node2 && (this.isForwards ? (this.originalFromNode !== null && (i = this.originalFromNode, e = this.originalFromPort), s = l, n = r) : (i = l, e = r, this.originalToNode !== null && (s = this.originalToNode, n = this.originalToPort)));
          } else this.isForwards ? this.originalFromNode !== null && this.isUnconnectedLinkValid && (i = this.originalFromNode, e = this.originalFromPort) : this.originalToNode !== null && this.isUnconnectedLinkValid && (s = this.originalToNode, n = this.originalToPort);
          i !== null || s !== null ? (o = this.insertLink(i, e, s, n), o !== null ? (r === null && (this.isForwards ? o.defaultToPoint = t.lastInput.documentPoint : o.defaultFromPoint = t.lastInput.documentPoint), t.allowSelect && (t.F("ChangingSelection", t.selection), t.clearSelection(true), o.isSelected = true), this.transactionResult = this.name, t.F("LinkDrawn", o)) : this.doNoLink(i, e, s, n)) : this.isForwards ? this.doNoLink(this.originalFromNode, this.originalFromPort, null, null) : this.doNoLink(null, null, this.originalToNode, this.originalToPort);
        } finally {
          this.stopTool(), o && t.allowSelect && t.F("ChangedSelection", t.selection);
        }
      }
    }
    isNewTreeLink() {
      const t = this.archetypeLinkData;
      if (t === null) return true;
      if (t instanceof Link2) return t.isTreeLink;
      const i = this.diagram;
      if (i === null) return true;
      const e = i.partManager.getLinkCategoryForData(t), s = i.partManager.findLinkTemplateForCategory(e);
      return s !== null ? s.isTreeLink : true;
    }
    insertLink(t, i, e, s) {
      return this.diagram.partManager.insertLink(t, i, e, s);
    }
    doNoLink(t, i, e, s) {
    }
  }
  class RelinkingTool2 extends LinkingBaseTool2 {
    LT = null;
    DT = null;
    WP = null;
    jP = null;
    As;
    JP;
    constructor(t) {
      super(), this.name = "Relinking", this.fromHandleArchetype = new Shape2("Diamond", { desiredSize: Size2.Tu, fill: "lightblue", stroke: "dodgerblue", cursor: this.linkingCursor, segmentIndex: 0 }).theme("fill", "adornmentFill").theme("stroke", "adornmentStroke"), this.toHandleArchetype = new Shape2("Diamond", { desiredSize: Size2.Tu, fill: "lightblue", stroke: "dodgerblue", cursor: this.linkingCursor, segmentIndex: -1 }).theme("fill", "adornmentFill").theme("stroke", "adornmentStroke"), this.As = null, this.JP = new Rect2(), t && Object.assign(this, t);
    }
    updateAdornments(t) {
      if (t === null || !(t instanceof Link2)) return;
      let i = "RelinkFrom", e = null;
      if (t.isSelected && !this.diagram.isReadOnly) {
        const s = t.selectionObject;
        s !== null && t.canRelinkFrom() && t.actualBounds.isReal() && t.isVisible() && s.actualBounds.isReal() && s.isVisibleObject() && (e = t.findAdornment(i), e === null && (e = this.makeAdornment(s, false), t.addAdornment(i, e)));
      }
      if (e === null && t.removeAdornment(i), i = "RelinkTo", e = null, t.isSelected && !this.diagram.isReadOnly) {
        const s = t.selectionObject;
        s !== null && t.canRelinkTo() && t.actualBounds.isReal() && t.isVisible() && s.actualBounds.isReal() && s.isVisibleObject() && (e = t.findAdornment(i), e === null ? (e = this.makeAdornment(s, true), t.addAdornment(i, e)) : e.g());
      }
      e === null && t.removeAdornment(i);
    }
    makeAdornment(t, i) {
      let e = i ? this.jP : this.WP;
      return e && (e = e.copy(), e.adornedObject = t), e;
    }
    get fromHandleArchetype() {
      return this.LT;
    }
    set fromHandleArchetype(t) {
      t !== null && U.s(t, GraphObject2, RelinkingTool2, "fromHandleArchetype"), this.LT = t, t !== null ? this.WP = new Adornment2(Panel2.Link).add(t).Yt() : this.WP = null;
    }
    get toHandleArchetype() {
      return this.DT;
    }
    set toHandleArchetype(t) {
      t !== null && U.s(t, GraphObject2, RelinkingTool2, "toHandleArchetype"), this.DT = t, t !== null ? this.jP = new Adornment2(Panel2.Link).add(t).Yt() : this.jP = null;
    }
    get handle() {
      return this.As;
    }
    set handle(t) {
      t !== null && (U.s(t, GraphObject2, RelinkingTool2, "handle"), t.part instanceof Adornment2 || U.n("new handle is not in an Adornment: " + t)), this.As = t;
    }
    canStart() {
      if (!this.isEnabled) return false;
      const t = this.diagram;
      if (t.isReadOnly || t.isModelReadOnly || !t.allowRelink || !t.model.Ex() || !t.lastInput.left) return false;
      let e = this.findToolHandleAt(t.firstInput.documentPoint, "RelinkFrom");
      return e === null && (e = this.findToolHandleAt(t.firstInput.documentPoint, "RelinkTo")), e !== null;
    }
    doActivate() {
      const t = this.diagram;
      if (this.originalLink === null) {
        let e = this.handle;
        if (e === null && (e = this.findToolHandleAt(t.firstInput.documentPoint, "RelinkFrom"), e === null && (e = this.findToolHandleAt(t.firstInput.documentPoint, "RelinkTo"))), e === null) return;
        const s = e.part;
        if (!(s instanceof Adornment2) || !(s.adornedPart instanceof Link2)) return;
        this.handle = e, this.isForwards = s === null || s.category === "RelinkTo", this.originalLink = s.adornedPart;
      }
      const i = this.originalLink;
      i !== null && (this.startTransaction(this.name), t.isMouseCaptured = true, t.currentCursor = this.linkingCursor, this.originalFromPort = i.fromPort, this.originalFromNode = i.fromNode, this.originalToPort = i.toPort, this.originalToNode = i.toNode, this.JP.set(i.actualBounds), i.pointsCount > 0 && (i.fromNode === null && (this.temporaryFromPort !== null && (this.temporaryFromPort.desiredSize = Size2.ia), this.temporaryFromNode !== null && (this.temporaryFromNode.location = i.getPoint(0))), i.toNode === null && (this.temporaryToPort !== null && (this.temporaryToPort.desiredSize = Size2.ia), this.temporaryToNode !== null && (this.temporaryToNode.location = i.getPoint(i.pointsCount - 1)))), this.copyPortProperties(this.originalFromNode, this.originalFromPort, this.temporaryFromNode, this.temporaryFromPort, false), this.copyPortProperties(this.originalToNode, this.originalToPort, this.temporaryToNode, this.temporaryToPort, true), t.add(this.temporaryFromNode), t.add(this.temporaryToNode), this.temporaryLink !== null && (this.temporaryFromNode !== null && (this.temporaryLink.fromNode = this.temporaryFromNode), this.temporaryToNode !== null && (this.temporaryLink.toNode = this.temporaryToNode), this.copyLinkProperties(i, this.temporaryLink), this.temporaryLink.ii(), t.add(this.temporaryLink)), this.isActive = true);
    }
    copyLinkProperties(t, i) {
      if (t === null || i === null) return;
      i.adjusting = t.adjusting, i.corner = t.corner;
      let e = t.curve;
      (e === 11 || e === 10) && (e = 0), i.curve = e, i.curviness = t.curviness, i.isTreeLink = t.isTreeLink, i.points = t.points, i.routing = t.routing, i.smoothness = t.smoothness, i.fromSpot = t.fromSpot, i.fromEndSegmentLength = t.fromEndSegmentLength, i.fromShortLength = t.fromShortLength, i.toSpot = t.toSpot, i.toEndSegmentLength = t.toEndSegmentLength, i.toShortLength = t.toShortLength;
    }
    doDeactivate() {
      this.isActive = false;
      const t = this.diagram;
      t.remove(this.temporaryLink), t.remove(this.temporaryFromNode), t.remove(this.temporaryToNode), t.isMouseCaptured = false, t.currentCursor = "", this.stopTransaction();
    }
    doStop() {
      super.doStop(), this.handle = null;
    }
    doMouseUp() {
      if (this.isActive) {
        const t = this.diagram;
        this.transactionResult = null;
        let i = this.originalFromNode, e = this.originalFromPort, s = this.originalToNode, n = this.originalToPort, o = this.originalLink;
        try {
          if (this.targetPort = this.findTargetPort(this.isForwards), this.targetPort !== null) {
            const r = this.targetPort.part;
            r instanceof Node2 && (this.isForwards ? (s = r, n = this.targetPort) : (i = r, e = this.targetPort));
          } else this.isUnconnectedLinkValid ? this.isForwards ? (s = null, n = null) : (i = null, e = null) : o = null;
          o !== null ? (this.reconnectLink(o, this.isForwards ? s : i, this.isForwards ? n : e, this.isForwards), this.targetPort === null && (this.isForwards ? o.defaultToPoint = t.lastInput.documentPoint : o.defaultFromPoint = t.lastInput.documentPoint, o.ii()), this.transactionResult = this.name, t.F("LinkRelinked", o, this.isForwards ? this.originalToPort : this.originalFromPort)) : this.originalLink !== null && this.doNoRelink(this.originalLink, this.isForwards), this.originalLink !== null && this.originalLink.invalidateOtherJumpOvers(this.JP);
        } finally {
          this.stopTool();
        }
      }
    }
    reconnectLink(t, i, e, s) {
      const n = e !== null && e.portId !== null ? e.portId : "";
      return s ? (t.toNode = i, t.toPortId = n) : (t.fromNode = i, t.fromPortId = n), true;
    }
    doNoRelink(t, i) {
    }
    doDraggingMouseMove(t, i, e, s) {
      t !== null ? (this.copyPortProperties(t, i, this.temporaryFromNode, this.temporaryFromPort, false), this.diagram.add(this.temporaryFromNode)) : this.diagram.remove(this.temporaryFromNode), e !== null ? (this.copyPortProperties(e, s, this.temporaryToNode, this.temporaryToPort, true), this.diagram.add(this.temporaryToNode)) : this.diagram.remove(this.temporaryToNode);
    }
    stopDraggingMouseMove() {
      this.diagram.remove(this.temporaryFromNode), this.diagram.remove(this.temporaryToNode);
    }
  }
  var ReshapingBehavior2 = ((w) => (w[w.None = 0] = "None", w[w.Horizontal = 1] = "Horizontal", w[w.Vertical = 2] = "Vertical", w[w.All = 3] = "All", w))(ReshapingBehavior2 || {});
  class LinkReshapingTool2 extends Tool2 {
    Lr;
    $P;
    ZP;
    As;
    Bx;
    QP;
    Gm;
    constructor(t) {
      super(), this.name = "LinkReshaping", this.Lr = new Shape2("Rectangle", { desiredSize: Size2.VA, fill: "lightblue", stroke: "dodgerblue" }).theme("fill", "adornmentFill").theme("stroke", "adornmentStroke"), this.$P = new Shape2("Diamond", { desiredSize: Size2.Tu, fill: "lightblue", stroke: "dodgerblue", cursor: "move" }).theme("fill", "adornmentFill").theme("stroke", "adornmentStroke"), this.ZP = 3, this.As = null, this.Bx = null, this.QP = new Point2(), this.Gm = new List2(), t && Object.assign(this, t);
    }
    static None = 0;
    static Horizontal = 1;
    static Vertical = 2;
    static All = 3;
    getReshapingBehavior(t) {
      return t ? t.Dr : 0;
    }
    setReshapingBehavior(t, i) {
      t.Dr = i;
    }
    updateAdornments(t) {
      if (t === null || !(t instanceof Link2)) return;
      let i = null;
      if (t.isSelected && !this.diagram.isReadOnly) {
        const e = t.path;
        e !== null && t.canReshape() && t.actualBounds.isReal() && t.isVisible() && e.actualBounds.isReal() && e.isVisibleObject() && (i = t.findAdornment(this.name), (i === null || i._P !== t.pointsCount || i.tM !== t.resegmentable) && (i = this.makeAdornment(e), i !== null && (i._P = t.pointsCount, i.tM = t.resegmentable, t.addAdornment(this.name, i))));
      }
      i === null && t.removeAdornment(this.name);
    }
    makeAdornment(t) {
      const i = t.part, e = i.points, s = i.pointsCount, n = i.isOrthogonal;
      let o = null;
      if (e !== null && s > 1) {
        o = new Adornment2(), o.type = Panel2.Link;
        const r = i.firstPickIndex, l = i.lastPickIndex, h = n ? 1 : 0;
        if (i.resegmentable && i.computeCurve() !== 9) for (let f = r + h; f < l - h; f++) {
          const a = this.makeResegmentHandle(t, f);
          a !== null && (a.segmentIndex = f, a.segmentFraction = 0.5, a.fromMaxLinks = 999, o.add(a));
        }
        for (let f = r + 1; f < l; f++) {
          const a = this.makeHandle(t, f);
          if (a !== null) {
            if (a.segmentIndex = f, f !== r) if (f === r + 1 && n) {
              const c = i.getPoint(r);
              let u = i.getPoint(r + 1);
              G.p(c.x, u.x) && G.p(c.y, u.y) ? (u = i.getPoint(r - 1), G.p(c.x, u.x) ? (this.setReshapingBehavior(a, 2), a.cursor = "n-resize") : G.p(c.y, u.y) && (this.setReshapingBehavior(a, 1), a.cursor = "w-resize")) : G.p(c.x, u.x) ? (this.setReshapingBehavior(a, 2), a.cursor = "n-resize") : G.p(c.y, u.y) && (this.setReshapingBehavior(a, 1), a.cursor = "w-resize");
            } else if (f === l - 1 && n) {
              let c = i.getPoint(l - 1);
              const u = i.getPoint(l);
              G.p(c.x, u.x) && G.p(c.y, u.y) ? (c = i.getPoint(l + 1), G.p(c.x, u.x) ? (this.setReshapingBehavior(a, 2), a.cursor = "n-resize") : G.p(c.y, u.y) && (this.setReshapingBehavior(a, 1), a.cursor = "w-resize")) : G.p(c.x, u.x) ? (this.setReshapingBehavior(a, 2), a.cursor = "n-resize") : G.p(c.y, u.y) && (this.setReshapingBehavior(a, 1), a.cursor = "w-resize");
            } else f === l || (this.setReshapingBehavior(a, 3), a.cursor = "move");
            o.add(a);
          }
        }
        o.adornedObject = t;
      }
      return o;
    }
    makeHandle(t, i) {
      const e = this.handleArchetype;
      return e === null ? null : e.copy().iM();
    }
    get handleArchetype() {
      return this.Lr;
    }
    set handleArchetype(t) {
      t !== null && U.s(t, GraphObject2, LinkReshapingTool2, "handleArchetype"), this.Lr = t;
    }
    makeResegmentHandle(t, i) {
      const e = this.midHandleArchetype;
      return e === null ? null : e.copy().iM();
    }
    get midHandleArchetype() {
      return this.$P;
    }
    set midHandleArchetype(t) {
      t !== null && U.s(t, GraphObject2, LinkReshapingTool2, "midHandleArchetype"), this.$P = t;
    }
    get handle() {
      return this.As;
    }
    set handle(t) {
      t !== null && (U.s(t, GraphObject2, LinkReshapingTool2, "handle"), t.part instanceof Adornment2 || U.n("new handle is not in an Adornment: " + t)), this.As = t;
    }
    get adornedLink() {
      return this.Bx;
    }
    canStart() {
      if (!this.isEnabled) return false;
      const t = this.diagram;
      return t.isReadOnly || !t.allowReshape || !t.lastInput.left ? false : this.findToolHandleAt(t.firstInput.documentPoint, this.name) !== null;
    }
    doActivate() {
      const t = this.diagram;
      if (this.handle === null && (this.handle = this.findToolHandleAt(t.firstInput.documentPoint, this.name)), this.handle === null) return;
      const i = this.handle.part.adornedPart;
      if (i instanceof Link2) {
        if (this.Bx = i, t.isMouseCaptured = true, this.startTransaction(this.name), i.resegmentable && this.handle.fromMaxLinks === 999) {
          const e = i.points.copy(), s = this.getResegmentingPoint();
          if (e.insertAt(this.handle.segmentIndex + 1, s), i.isOrthogonal && e.insertAt(this.handle.segmentIndex + 1, s), i.points = e, i.invalidateAdornments(), i.updateAdornments(), this.handle = this.findToolHandleAt(t.firstInput.documentPoint, this.name), this.handle === null) {
            this.doDeactivate();
            return;
          }
        }
        this.QP = i.getPoint(this.handle.segmentIndex), this.Gm = i.points.copy(), this.isActive = true;
      }
    }
    doDeactivate() {
      this.stopTransaction(), this.handle = null, this.Bx = null;
      const t = this.diagram;
      t.isMouseCaptured = false, this.isActive = false;
    }
    stopTransaction() {
      const t = this.diagram, i = super.stopTransaction();
      return i && t.undoManager.transactionToUndo !== null && t.undoManager.transactionToUndo.optimize(), i;
    }
    doCancel() {
      const t = this.adornedLink;
      t !== null && (t.points = this.Gm), this.stopTool();
    }
    getResegmentingPoint() {
      return this.handle === null ? this.diagram.lastInput.documentPoint : this.handle.getDocumentPoint(Spot2.Center);
    }
    doMouseMove() {
      const t = this.diagram;
      if (this.isActive) {
        const i = this.computeReshape(t.lastInput.documentPoint);
        this.reshape(i);
      }
    }
    doMouseUp() {
      const t = this.diagram;
      if (this.isActive) {
        const i = this.computeReshape(t.lastInput.documentPoint);
        this.reshape(i);
        const e = this.adornedLink;
        if (e !== null && e.resegmentable && this.handle !== null) {
          const s = this.handle.segmentIndex, n = e.getPoint(s - 1), o = e.getPoint(s), r = e.getPoint(s + 1);
          if (e.isOrthogonal) {
            if (s > e.firstPickIndex + 1 && s < e.lastPickIndex - 1) {
              let l = e.getPoint(s - 2);
              if (this.isWithinResegmentingDistance(n, o) && (this.isInLineOrtho(l, n, o, r, true) || this.isInLineOrtho(l, n, o, r, false))) {
                const h = e.points.copy();
                this.isInLineOrtho(l, n, o, r, true) ? (h.setElt(s - 2, new Point2(l.x, (r.y + l.y) / 2)), h.setElt(s + 1, new Point2(r.x, (r.y + l.y) / 2))) : (h.setElt(s - 2, new Point2((r.x + l.x) / 2, l.y)), h.setElt(s + 1, new Point2((r.x + l.x) / 2, r.y))), h.removeAt(s), h.removeAt(s - 1), e.points = h, e.invalidateAdornments();
              } else if (l = e.getPoint(s + 2), this.isWithinResegmentingDistance(o, r) && (this.isInLineOrtho(n, o, r, l, true) || this.isInLineOrtho(n, o, r, l, false))) {
                const h = e.points.copy();
                this.isInLineOrtho(n, o, r, l, true) ? (h.setElt(s - 1, new Point2(n.x, (n.y + l.y) / 2)), h.setElt(s + 2, new Point2(l.x, (n.y + l.y) / 2))) : (h.setElt(s - 1, new Point2((n.x + l.x) / 2, n.y)), h.setElt(s + 2, new Point2((n.x + l.x) / 2, l.y))), h.removeAt(s + 1), h.removeAt(s), e.points = h, e.invalidateAdornments();
              }
            }
          } else {
            const l = Point2.a();
            if (G.Ll(n.x, n.y, r.x, r.y, o.x, o.y, l) && l.distanceSquaredPoint(o) < this.resegmentingDistance * this.resegmentingDistance) {
              const h = e.points.copy();
              h.removeAt(s), e.points = h, e.invalidateAdornments();
            }
            Point2.o(l);
          }
        }
        t.invalidateDocumentBounds(), this.transactionResult = this.name, t.F("LinkReshaped", this.adornedLink, this.Gm);
      }
      this.stopTool();
    }
    isWithinResegmentingDistance(t, i) {
      return Math.abs(t.x - i.x) < this.resegmentingDistance && Math.abs(t.y - i.y) < this.resegmentingDistance;
    }
    isInLineOrtho(t, i, e, s, n) {
      return n ? Math.abs(t.y - i.y) < this.resegmentingDistance && Math.abs(i.y - e.y) < this.resegmentingDistance && Math.abs(e.y - s.y) < this.resegmentingDistance : Math.abs(t.x - i.x) < this.resegmentingDistance && Math.abs(i.x - e.x) < this.resegmentingDistance && Math.abs(e.x - s.x) < this.resegmentingDistance;
    }
    get resegmentingDistance() {
      return this.ZP;
    }
    set resegmentingDistance(t) {
      U.i(t, "number", LinkReshapingTool2, "resegmentingDistance"), this.ZP = t;
    }
    reshape(t) {
      const i = this.adornedLink;
      if (i === null) return;
      const e = this.handle;
      if (e === null) return;
      i.startRoute();
      let s = e.segmentIndex;
      const n = this.getReshapingBehavior(e);
      if (i.isOrthogonal) if (s === i.firstPickIndex + 1) {
        const o = i.firstPickIndex + 1;
        n === 2 ? (i.setPointAt(o, i.getPoint(o - 1).x, t.y), i.setPointAt(o + 1, i.getPoint(o + 2).x, t.y)) : n === 1 && (i.setPointAt(o, t.x, i.getPoint(o - 1).y), i.setPointAt(o + 1, t.x, i.getPoint(o + 2).y));
      } else if (s === i.lastPickIndex - 1) {
        const o = i.lastPickIndex - 1;
        n === 2 ? (i.setPointAt(o - 1, i.getPoint(o - 2).x, t.y), i.setPointAt(o, i.getPoint(o + 1).x, t.y)) : n === 1 && (i.setPointAt(o - 1, t.x, i.getPoint(o - 2).y), i.setPointAt(o, t.x, i.getPoint(o + 1).y));
      } else {
        let o = s;
        const r = i.getPoint(o), l = i.getPoint(o - 1), h = i.getPoint(o + 1);
        G.p(l.x, r.x) && G.p(r.y, h.y) ? (G.p(l.x, i.getPoint(o - 2).x) && !G.p(l.y, i.getPoint(o - 2).y) ? (i.insertPointAt(o, t.x, l.y), s++, o++) : i.setPointAt(o - 1, t.x, l.y), G.p(h.y, i.getPoint(o + 2).y) && !G.p(h.x, i.getPoint(o + 2).x) ? i.insertPointAt(o + 1, h.x, t.y) : i.setPointAt(o + 1, h.x, t.y)) : G.p(l.y, r.y) && G.p(r.x, h.x) ? (G.p(l.y, i.getPoint(o - 2).y) && !G.p(l.x, i.getPoint(o - 2).x) ? (i.insertPointAt(o, l.x, t.y), s++, o++) : i.setPointAt(o - 1, l.x, t.y), G.p(h.x, i.getPoint(o + 2).x) && !G.p(h.y, i.getPoint(o + 2).y) ? i.insertPointAt(o + 1, t.x, h.y) : i.setPointAt(o + 1, t.x, h.y)) : G.p(l.x, r.x) && G.p(r.x, h.x) ? (G.p(l.x, i.getPoint(o - 2).x) && !G.p(l.y, i.getPoint(o - 2).y) ? (i.insertPointAt(o, t.x, l.y), s++, o++) : i.setPointAt(o - 1, t.x, l.y), G.p(h.x, i.getPoint(o + 2).x) && !G.p(h.y, i.getPoint(o + 2).y) ? i.insertPointAt(o + 1, t.x, h.y) : i.setPointAt(o + 1, t.x, h.y)) : G.p(l.y, r.y) && G.p(r.y, h.y) && (G.p(l.y, i.getPoint(o - 2).y) && !G.p(l.x, i.getPoint(o - 2).x) ? (i.insertPointAt(o, l.x, t.y), s++, o++) : i.setPointAt(o - 1, l.x, t.y), G.p(h.y, i.getPoint(o + 2).y) && !G.p(h.x, i.getPoint(o + 2).x) ? i.insertPointAt(o + 1, h.x, t.y) : i.setPointAt(o + 1, h.x, t.y)), i.setPointAt(s, t.x, t.y);
      }
      else {
        i.setPointAt(s, t.x, t.y);
        let o = i.fromNode, r = i.fromPort;
        if (o !== null) {
          const f = o.findVisibleNode();
          f !== null && f !== o && (o = f, r = o.port);
        }
        if (s === 1 && r !== null && i.computeSpot(true, r).isNoSpot()) {
          const f = r.getDocumentPoint(Spot2.Center, Point2.a()), a = i.getLinkPointFromPoint(o, r, f, t, true, Point2.a());
          i.setPointAt(0, a.x, a.y), Point2.o(f), Point2.o(a);
        }
        let l = i.toNode, h = i.toPort;
        if (l !== null) {
          const f = l.findVisibleNode();
          f !== null && f !== l && (l = f, h = l.port);
        }
        if (s === i.pointsCount - 2 && h !== null && i.computeSpot(false, h).isNoSpot()) {
          const f = h.getDocumentPoint(Spot2.Center, Point2.a()), a = i.getLinkPointFromPoint(l, h, f, t, false, Point2.a());
          i.setPointAt(i.pointsCount - 1, a.x, a.y), Point2.o(f), Point2.o(a);
        }
      }
      i.commitRoute();
    }
    computeReshape(t) {
      const i = this.adornedLink;
      if (i === null) return t;
      const e = this.handle;
      if (e === null) return t;
      const s = e.segmentIndex;
      switch (this.getReshapingBehavior(e)) {
        case 3:
          return t;
        case 2: {
          const n = i.getPoint(s);
          return new Point2(n.x, t.y);
        }
        case 1: {
          const n = i.getPoint(s);
          return new Point2(t.x, n.y);
        }
        default:
        case 0:
          return i.getPoint(s);
      }
    }
    get originalPoint() {
      return this.QP;
    }
    get originalPoints() {
      return this.Gm;
    }
  }
  class ResizingTool2 extends Tool2 {
    Fr;
    Ir;
    Xo;
    Yf;
    eM;
    Ts;
    Lr;
    As;
    qm;
    sM;
    Kf;
    Vx;
    zx;
    Xx;
    constructor(t) {
      super(), this.name = "Resizing", this.Fr = new Size2(1, 1).S(), this.Ir = new Size2(9999, 9999).S(), this.Xo = new Size2(NaN, NaN).S(), this.Yf = false, this.eM = true, this.Ts = null, this.Lr = new Shape2("Rectangle", { alignmentFocus: Spot2.Center, desiredSize: Size2.VA, fill: "lightblue", stroke: "dodgerblue", strokeWidth: 1, cursor: "pointer" }).theme("fill", "adornmentFill").theme("stroke", "adornmentStroke"), this.As = null, this.qm = new Point2(), this.sM = new Size2(), this.Kf = new Point2(), this.Vx = new Size2(0, 0), this.zx = new Size2(1 / 0, 1 / 0), this.Xx = new Size2(1, 1), t && Object.assign(this, t);
    }
    updateAdornments(t) {
      if (t !== null) {
        if (t.Rr()) {
          const i = t.rotateObject;
          if (i === t || i === t.path || i.isPanelMain) return;
        }
        if (t.isSelected && !this.diagram.isReadOnly) {
          const i = t.resizeObject;
          let e = t.findAdornment(this.name);
          if (i !== null && t.canResize() && t.actualBounds.isReal() && t.isVisible() && i.actualBounds.isReal() && i.isVisibleObject() && ((e === null || e.adornedObject !== i) && (e = this.makeAdornment(i)), e !== null)) {
            const s = i.getDocumentAngle();
            t.Kl() && this.updateResizeHandles(e, s), t.addAdornment(this.name, e);
            return;
          }
        }
        t.removeAdornment(this.name);
      }
    }
    makeAdornment(t) {
      let i = null;
      const e = t.part?.resizeAdornmentTemplate;
      if (e) {
        if (i = e.copy(), i === null) return null;
      } else {
        i = new Adornment2(), i.type = Panel2.Spot, i.locationSpot = Spot2.Center;
        const s = new Placeholder2();
        s.isPanelMain = true, i.add(s);
        let n = this.makeHandle(t, Spot2.TopLeft);
        n !== null && i.add(n), n = this.makeHandle(t, Spot2.TopRight), n !== null && i.add(n), n = this.makeHandle(t, Spot2.BottomRight), n !== null && i.add(n), n = this.makeHandle(t, Spot2.BottomLeft), n !== null && i.add(n), n = this.makeHandle(t, Spot2.MiddleTop), n !== null && i.add(n), n = this.makeHandle(t, Spot2.MiddleRight), n !== null && i.add(n), n = this.makeHandle(t, Spot2.MiddleBottom), n !== null && i.add(n), n = this.makeHandle(t, Spot2.MiddleLeft), n !== null && i.add(n);
      }
      return i.adornedObject = t, i;
    }
    makeHandle(t, i) {
      const e = this.handleArchetype;
      if (e === null) return null;
      const s = e.copy().iM();
      return s.alignment = i, s;
    }
    updateResizeHandles(t, i) {
      if (t !== null) {
        if (!t.alignment.isDefault() && (t.cursor === "pointer" || t.cursor.indexOf("resize") > 0)) this.NR(t, i);
        else if (t instanceof Panel2) {
          const e = t.elements;
          for (; e.next(); ) {
            const s = e.value;
            this.updateResizeHandles(s, i);
          }
        }
      }
    }
    NR(t, i) {
      let e = t.alignment;
      e.isNoSpot() && (e = Spot2.Center);
      let s = i;
      if (e.x <= 0) e.y <= 0 ? s += 225 : e.y >= 1 ? s += 135 : s += 180;
      else if (e.x >= 1) e.y <= 0 ? s += 315 : e.y >= 1 && (s += 45);
      else if (e.y <= 0) s += 270;
      else if (e.y >= 1) s += 90;
      else return;
      s = G.Yi(s), s < 22.5 ? t.cursor = "e-resize" : s < 67.5 ? t.cursor = "se-resize" : s < 112.5 ? t.cursor = "s-resize" : s < 157.5 ? t.cursor = "sw-resize" : s < 202.5 ? t.cursor = "w-resize" : s < 247.5 ? t.cursor = "nw-resize" : s < 292.5 ? t.cursor = "n-resize" : s < 337.5 ? t.cursor = "ne-resize" : t.cursor = "e-resize";
    }
    get handleArchetype() {
      return this.Lr;
    }
    set handleArchetype(t) {
      t !== null && U.s(t, GraphObject2, ResizingTool2, "handleArchetype"), this.Lr = t;
    }
    get handle() {
      return this.As;
    }
    set handle(t) {
      t !== null && (U.s(t, GraphObject2, ResizingTool2, "handle"), t.part instanceof Adornment2 || U.n("new handle is not in an Adornment: " + t)), this.As = t;
    }
    get adornedObject() {
      return this.Ts;
    }
    set adornedObject(t) {
      t !== null && (U.s(t, GraphObject2, ResizingTool2, "handle"), t.part instanceof Adornment2 && U.n("new handle must not be in an Adornment: " + t)), this.Ts = t;
    }
    canStart() {
      if (!this.isEnabled) return false;
      const t = this.diagram;
      return t.isReadOnly || !t.allowResize || !t.lastInput.left ? false : this.findToolHandleAt(t.firstInput.documentPoint, this.name) !== null;
    }
    doActivate() {
      const t = this.diagram;
      this.handle === null && (this.handle = this.findToolHandleAt(t.firstInput.documentPoint, this.name)), this.handle !== null && (this.adornedObject = this.handle.part.adornedObject, this.adornedObject !== null && this.adornedObject.part !== null && (t.isMouseCaptured = true, t.animationManager.stopAnimation(), t.Ku = true, this.startTransaction(this.name), this.qm.set(this.adornedObject.getDocumentPoint(this.handle.alignment.opposite())), this.Kf.set(this.adornedObject.part.location), this.sM.set(this.adornedObject.desiredSize), this.Xx = this.computeCellSize(), this.Vx = this.computeMinSize(), this.zx = this.computeMaxSize(), this.isActive = true));
    }
    doDeactivate() {
      const t = this.diagram;
      t.Ku = false, t.Bl = true, this.stopTransaction(), this.handle = null, this.Ts = null, t.isMouseCaptured = false, this.isActive = false;
    }
    stopTransaction() {
      const t = this.diagram, i = super.stopTransaction();
      return i && t.undoManager.transactionToUndo !== null && t.undoManager.transactionToUndo.optimize(), i;
    }
    doCancel() {
      this.adornedObject !== null && this.adornedObject.part !== null && (this.adornedObject.desiredSize = this.originalDesiredSize, this.adornedObject.part.location = this.originalLocation), this.stopTool();
    }
    doMouseMove() {
      const t = this.diagram;
      if (!this.isActive || this.adornedObject === null || this.handle === null) return;
      const i = this.Vx, e = this.zx, s = this.Xx, n = t.lastInput.documentPoint, o = this.adornedObject.getLocalPoint(n, Point2.a()), r = this.computeReshape(), l = this.computeResize(o, this.handle.alignment, i, e, s, r);
      this.resize(l), t.maybeUpdate(), Point2.o(o);
    }
    doMouseUp() {
      const t = this.diagram;
      if (this.isActive && this.adornedObject !== null && this.handle !== null) {
        const i = this.Vx, e = this.zx, s = this.Xx, n = this.adornedObject.getLocalPoint(t.lastInput.documentPoint, Point2.a()), o = this.computeReshape(), r = this.computeResize(n, this.handle.alignment, i, e, s, o);
        this.resize(r), Point2.o(n), t.invalidateDocumentBounds(), this.transactionResult = this.name, t.F("PartResized", this.adornedObject, this.originalDesiredSize);
      }
      this.stopTool();
    }
    resize(t) {
      const i = this.diagram, e = this.adornedObject;
      if (e === null) return;
      e.desiredSize = t.size;
      const s = e.part;
      if (s === null || this.handle === null) return;
      s.ensureBounds();
      const n = e.getDocumentPoint(this.handle.alignment.opposite());
      if (s instanceof Group2) {
        const o = new List2();
        o.add(s);
        let r;
        !this.dragsMembers && !s.hasPlaceholder() && (r = new DraggingOptions2(), r.dragsMembers = false), i.moveParts(o, this.oppositePoint.copy().subtract(n), true, r);
      } else s.location = s.location.copy().subtract(n).add(this.oppositePoint);
      i.maybeUpdate();
    }
    computeResize(t, i, e, s, n, o) {
      if (this.adornedObject === null) return Rect2.rm;
      i.isNoSpot() && (i = Spot2.Center);
      const r = this.adornedObject.naturalBounds, l = r.x, h = r.y, f = r.x + r.width, a = r.y + r.height;
      let c = 1;
      if (!o) {
        let m = r.width, g = r.height;
        m <= 0 && (m = 1), g <= 0 && (g = 1), c = g / m;
      }
      const u = Point2.a();
      G.om(t.x, t.y, l, h, n.width, n.height, u);
      const d = r.copy();
      return i.x <= 0 ? i.y <= 0 ? (d.x = Math.max(u.x, f - s.width), d.x = Math.min(d.x, f - e.width), d.width = Math.max(f - d.x, e.width), d.y = Math.max(u.y, a - s.height), d.y = Math.min(d.y, a - e.height), d.height = Math.max(a - d.y, e.height), o || (d.height / d.width >= 1 ? (d.height = Math.max(Math.min(c * d.width, s.height), e.height), d.width = d.height / c) : (d.width = Math.max(Math.min(d.height / c, s.width), e.width), d.height = c * d.width), d.x = f - d.width, d.y = a - d.height)) : i.y >= 1 ? (d.x = Math.max(u.x, f - s.width), d.x = Math.min(d.x, f - e.width), d.width = Math.max(f - d.x, e.width), d.height = Math.max(Math.min(u.y - h, s.height), e.height), o || (d.height / d.width >= 1 ? (d.height = Math.max(Math.min(c * d.width, s.height), e.height), d.width = d.height / c) : (d.width = Math.max(Math.min(d.height / c, s.width), e.width), d.height = c * d.width), d.x = f - d.width)) : (d.x = Math.max(u.x, f - s.width), d.x = Math.min(d.x, f - e.width), d.width = f - d.x, o || (d.height = Math.max(Math.min(c * d.width, s.height), e.height), d.width = d.height / c, d.y = h + 0.5 * (a - h - d.height))) : i.x >= 1 ? i.y <= 0 ? (d.width = Math.max(Math.min(u.x - l, s.width), e.width), d.y = Math.max(u.y, a - s.height), d.y = Math.min(d.y, a - e.height), d.height = Math.max(a - d.y, e.height), o || (d.height / d.width >= 1 ? (d.height = Math.max(Math.min(c * d.width, s.height), e.height), d.width = d.height / c) : (d.width = Math.max(Math.min(d.height / c, s.width), e.width), d.height = c * d.width), d.y = a - d.height)) : i.y >= 1 ? (d.width = Math.max(Math.min(u.x - l, s.width), e.width), d.height = Math.max(Math.min(u.y - h, s.height), e.height), o || (d.height / d.width >= 1 ? (d.height = Math.max(Math.min(c * d.width, s.height), e.height), d.width = d.height / c) : (d.width = Math.max(Math.min(d.height / c, s.width), e.width), d.height = c * d.width))) : (d.width = Math.max(Math.min(u.x - l, s.width), e.width), o || (d.height = Math.max(Math.min(c * d.width, s.height), e.height), d.width = d.height / c, d.y = h + 0.5 * (a - h - d.height))) : i.y <= 0 ? (d.y = Math.max(u.y, a - s.height), d.y = Math.min(d.y, a - e.height), d.height = a - d.y, o || (d.width = Math.max(Math.min(d.height / c, s.width), e.width), d.height = c * d.width, d.x = l + 0.5 * (f - l - d.width))) : i.y >= 1 && (d.height = Math.max(Math.min(u.y - h, s.height), e.height), o || (d.width = Math.max(Math.min(d.height / c, s.width), e.width), d.height = c * d.width, d.x = l + 0.5 * (f - l - d.width))), Point2.o(u), d;
    }
    computeReshape() {
      let t = 0;
      return this.adornedObject instanceof Shape2 && (t = this.adornedObject.nM()), !(t === 6 || this.diagram.lastInput.shift);
    }
    computeMinSize() {
      if (this.adornedObject === null) return Size2.ia;
      const t = this.adornedObject.minSize.copy(), i = this.minSize;
      return !isNaN(i.width) && i.width > t.width && (t.width = i.width), !isNaN(i.height) && i.height > t.height && (t.height = i.height), t;
    }
    computeMaxSize() {
      if (this.adornedObject === null) return Size2.tx;
      const t = this.adornedObject.maxSize.copy(), i = this.maxSize;
      return !isNaN(i.width) && i.width < t.width && (t.width = i.width), !isNaN(i.height) && i.height < t.height && (t.height = i.height), t;
    }
    computeCellSize() {
      const t = new Size2(NaN, NaN), i = this.adornedObject?.part;
      if (i) {
        const n = i.resizeCellSize;
        !isNaN(n.width) && n.width > 0 && (t.width = n.width), !isNaN(n.height) && n.height > 0 && (t.height = n.height);
      }
      let e = this.cellSize;
      isNaN(t.width) && !isNaN(e.width) && e.width > 0 && (t.width = e.width), isNaN(t.height) && !isNaN(e.height) && e.height > 0 && (t.height = e.height);
      const s = this.diagram;
      if ((isNaN(t.width) || isNaN(t.height)) && s) {
        const n = s.grid;
        n !== null && n.visible && this.isGridSnapEnabled && (e = n.gridCellSize, isNaN(t.width) && !isNaN(e.width) && e.width > 0 && (t.width = e.width), isNaN(t.height) && !isNaN(e.height) && e.height > 0 && (t.height = e.height));
      }
      return (isNaN(t.width) || t.width === 0 || t.width === 1 / 0) && (t.width = 1), (isNaN(t.height) || t.height === 0 || t.height === 1 / 0) && (t.height = 1), t;
    }
    get minSize() {
      return this.Fr;
    }
    set minSize(t) {
      if (U.s(t, Size2, ResizingTool2, "minSize"), !this.Fr.equals(t)) {
        let e = t.width;
        isNaN(e) && (e = 0);
        let s = t.height;
        isNaN(s) && (s = 0), this.Fr.e(e, s);
      }
    }
    get maxSize() {
      return this.Ir;
    }
    set maxSize(t) {
      if (U.s(t, Size2, ResizingTool2, "maxSize"), !this.Ir.equals(t)) {
        let e = t.width;
        isNaN(e) && (e = 1 / 0);
        let s = t.height;
        isNaN(s) && (s = 1 / 0), this.Ir.e(e, s);
      }
    }
    get cellSize() {
      return this.Xo;
    }
    set cellSize(t) {
      U.s(t, Size2, ResizingTool2, "cellSize"), this.Xo.equals(t) || this.Xo.c(t);
    }
    get isGridSnapEnabled() {
      return this.Yf;
    }
    set isGridSnapEnabled(t) {
      U.i(t, "boolean", ResizingTool2, "isGridSnapEnabled"), this.Yf = t;
    }
    get dragsMembers() {
      return this.eM;
    }
    set dragsMembers(t) {
      U.i(t, "boolean", ResizingTool2, "dragsMembers"), this.eM = t;
    }
    get oppositePoint() {
      return this.qm;
    }
    set oppositePoint(t) {
      U.s(t, Point2, ResizingTool2, "oppositePoint"), this.qm.equals(t) || this.qm.c(t);
    }
    get originalDesiredSize() {
      return this.sM;
    }
    get originalLocation() {
      return this.Kf;
    }
  }
  class RotatingTool2 extends Tool2 {
    oM;
    rM;
    Ts = null;
    Lr = null;
    Yx = null;
    As = null;
    lM;
    Hm;
    Kf;
    hM;
    aM;
    constructor(t) {
      super(), this.name = "Rotating", this.oM = 45, this.rM = 2, this.Kf = new Point2(), this.Ts = null, this.handleArchetype = new Shape2("Ellipse", { desiredSize: Size2.Tu, fill: "lightblue", stroke: "dodgerblue", strokeWidth: 1, cursor: "pointer" }).theme("fill", "adornmentFill").theme("stroke", "adornmentStroke"), this.As = null, this.lM = 0, this.Hm = new Point2(NaN, NaN), this.hM = 0, this.aM = 50, t && Object.assign(this, t);
    }
    updateAdornments(t) {
      if (t !== null) {
        if (t.Rr()) {
          const i = t.rotateObject;
          if (i === t || i === t.path || i.isPanelMain) return;
        }
        if (t.isSelected && !this.diagram.isReadOnly) {
          const i = t.rotateObject;
          if (i !== null && t.canRotate() && t.actualBounds.isReal() && t.isVisible() && i.actualBounds.isReal() && i.isVisibleObject()) {
            let e = t.findAdornment(this.name);
            if ((e === null || e.adornedObject !== i) && (e = this.makeAdornment(i)), e !== null) {
              e.angle = i.getDocumentAngle(), e.hasPlaceholder() || (e.location = this.computeAdornmentLocation(i)), t.addAdornment(this.name, e);
              return;
            }
          }
        }
        t.removeAdornment(this.name);
      }
    }
    makeAdornment(t) {
      let i = null;
      const e = t.part?.rotateAdornmentTemplate;
      return e ? i = e.copy() : this.Yx !== null && (i = this.Yx.copy()), i === null ? null : (i.adornedObject = t, i);
    }
    get handleArchetype() {
      return this.Lr;
    }
    set handleArchetype(t) {
      t !== null && U.s(t, GraphObject2, RotatingTool2, "handleArchetype"), this.Lr = t, t !== null ? this.Yx = new Adornment2(Panel2.Position, { locationSpot: Spot2.Center }).add(t).Yt() : this.Yx = null;
    }
    get handle() {
      return this.As;
    }
    set handle(t) {
      t !== null && (U.s(t, GraphObject2, RotatingTool2, "handle"), t.part instanceof Adornment2 || U.n("new handle is not in an Adornment: " + t)), this.As = t;
    }
    get adornedObject() {
      return this.Ts;
    }
    set adornedObject(t) {
      t !== null && (U.s(t, GraphObject2, RotatingTool2, "handle"), t.part instanceof Adornment2 && U.n("new handle must not be in an Adornment: " + t)), this.Ts = t;
    }
    canStart() {
      if (!this.isEnabled) return false;
      const t = this.diagram;
      return t.isReadOnly || !t.allowRotate || !t.lastInput.left ? false : this.findToolHandleAt(t.firstInput.documentPoint, this.name) !== null;
    }
    doActivate() {
      const t = this.diagram;
      if (this.adornedObject === null) {
        if (this.handle === null && (this.handle = this.findToolHandleAt(t.firstInput.documentPoint, this.name)), this.handle === null) return;
        this.adornedObject = this.handle.part.adornedObject;
      }
      this.adornedObject === null || this.adornedObject.part === null || (t.isMouseCaptured = true, t.delaysLayout = true, this.startTransaction(this.name), this.lM = this.adornedObject.angle, this.Hm = this.computeRotationPoint(this.adornedObject), this.Kf = this.adornedObject.part.location.copy(), this.isActive = true);
    }
    computeRotationPoint(t) {
      const i = t.part;
      if (i !== null) {
        const e = i.locationObject;
        if (i.rotationSpot.isSpot()) return t.getDocumentPoint(i.rotationSpot);
        if (t === i || t === e) return e.getDocumentPoint(i.locationSpot);
      }
      return t.getDocumentPoint(Spot2.Center);
    }
    computeAdornmentLocation(t) {
      let i = this.rotationPoint;
      i.isReal() || (i = this.computeRotationPoint(t));
      const e = t.getLocalPoint(i);
      let s = this.handleAngle;
      s = G.Yi(s), s = Math.round(Math.round(s / 45) * 45);
      const n = this.handleDistance;
      return s === 0 ? e.x = t.naturalBounds.width + n : s === 45 ? (e.x = t.naturalBounds.width + n, e.y = t.naturalBounds.height + n) : s === 90 ? e.y = t.naturalBounds.height + n : s === 135 ? (e.x = -n, e.y = t.naturalBounds.height + n) : s === 180 ? e.x = -n : s === 225 ? (e.x = -n, e.y = -n) : s === 270 ? e.y = -n : s === 315 && (e.x = t.naturalBounds.width + n, e.y = -n), t.getDocumentPoint(e);
    }
    doDeactivate() {
      const t = this.diagram;
      this.stopTransaction(), this.handle = null, this.Ts = null, this.Hm = new Point2(NaN, NaN), t.isMouseCaptured = false, this.isActive = false;
    }
    stopTransaction() {
      const t = this.diagram, i = super.stopTransaction();
      return i && t.undoManager.transactionToUndo !== null && t.undoManager.transactionToUndo.optimize(), i;
    }
    doCancel() {
      const t = this.diagram;
      t.delaysLayout = false, this.rotate(this.originalAngle), this.stopTool();
    }
    doMouseMove() {
      const t = this.diagram;
      if (this.isActive) {
        const i = this.computeRotate(t.lastInput.documentPoint);
        this.rotate(i);
      }
    }
    doMouseUp() {
      const t = this.diagram;
      if (this.isActive) {
        t.delaysLayout = false;
        const i = this.computeRotate(t.lastInput.documentPoint);
        this.rotate(i), t.invalidateDocumentBounds(), this.transactionResult = this.name, t.F("PartRotated", this.adornedObject, this.originalAngle);
      }
      this.stopTool();
    }
    rotate(t) {
      Debug && U.r(t, RotatingTool2, "rotate:newangle");
      const i = this.adornedObject;
      if (i === null || i.part === null) return;
      i.angle = t;
      const e = i.part;
      e.ensureBounds();
      const s = e.locationObject, n = e.rotateObject;
      if (s === n || s.isContainedBy(n)) {
        const o = this.Kf.copy();
        e.location = o.subtract(this.rotationPoint).rotate(t - this.originalAngle).add(this.rotationPoint);
      }
      this.diagram.maybeUpdate();
    }
    computeRotate(t) {
      let i = this.rotationPoint.directionPoint(t) - this.handleAngle;
      const e = this.adornedObject?.panel;
      e && (i -= e.getDocumentAngle()), i = G.Yi(i);
      const s = Math.min(Math.abs(this.snapAngleMultiple), 180), n = Math.min(Math.abs(this.snapAngleEpsilon), s / 2);
      return !this.diagram.lastInput.shift && s > 0 && n > 0 && (i % s < n ? i = Math.floor(i / s) * s : i % s > s - n && (i = (Math.floor(i / s) + 1) * s)), G.Yi(i);
    }
    get snapAngleMultiple() {
      return this.oM;
    }
    set snapAngleMultiple(t) {
      U.i(t, "number", RotatingTool2, "snapAngleMultiple"), this.oM = t;
    }
    get snapAngleEpsilon() {
      return this.rM;
    }
    set snapAngleEpsilon(t) {
      U.i(t, "number", RotatingTool2, "snapAngleEpsilon"), this.rM = t;
    }
    get originalAngle() {
      return this.lM;
    }
    get rotationPoint() {
      return this.Hm;
    }
    set rotationPoint(t) {
      this.Hm = t.copy();
    }
    get handleAngle() {
      return this.hM;
    }
    set handleAngle(t) {
      U.i(t, "number", RotatingTool2, "handleAngle"), this.hM = t;
    }
    get handleDistance() {
      return this.aM;
    }
    set handleDistance(t) {
      U.i(t, "number", RotatingTool2, "handleDistance"), this.aM = t;
    }
  }
  class ClickSelectingTool2 extends Tool2 {
    constructor(t) {
      super(), this.name = "ClickSelecting", t && Object.assign(this, t);
    }
    canStart() {
      return !(!this.isEnabled || this.isBeyondDragSize());
    }
    doMouseUp() {
      this.isActive && (this.standardMouseSelect(), this.standardMouseClick() || this.diagram.lastInput.isTouchEvent && this.diagram.toolManager.doToolTip()), this.stopTool();
    }
  }
  class ActionTool2 extends Tool2 {
    Uf;
    constructor(t) {
      super(), this.name = "Action", this.Uf = null, t && Object.assign(this, t);
    }
    canStart() {
      if (!this.isEnabled) return false;
      const t = this.diagram, i = t.lastInput, e = t.findObjectAt(i.documentPoint, (s) => {
        for (; s.panel !== null; ) {
          if (s.isActionable) return s;
          s = s.panel;
        }
        return s;
      });
      return e !== null && e.isActionable ? (this.Uf = e, t.Vf = t.findObjectAt(i.documentPoint, null, null), true) : false;
    }
    doMouseDown() {
      if (!this.isActive) this.canStart() && this.doActivate();
      else {
        const i = this.diagram.lastInput, e = this.Uf;
        if (e === null) return;
        i.targetObject = e, e.actionDown !== null && e.actionDown(i, e);
      }
    }
    doMouseMove() {
      if (this.isActive) {
        const i = this.diagram.lastInput, e = this.Uf;
        if (e === null) return;
        i.targetObject = e, e.actionMove !== null && e.actionMove(i, e);
      }
    }
    doMouseUp() {
      if (this.isActive) {
        const i = this.diagram.lastInput, e = this.Uf;
        if (e === null) return;
        i.targetObject = e, e.actionUp !== null && e.actionUp(i, e), this.standardMouseClick((s) => {
          for (; s.panel !== null; ) {
            if (s.isActionable && s === e) return s;
            s = s.panel;
          }
          return s;
        }, (s) => s === e);
      }
      this.stopTool();
    }
    doCancel() {
      const i = this.diagram.lastInput, e = this.Uf;
      e !== null && (i.targetObject = e, e.actionCancel !== null && e.actionCancel(i, e), this.stopTool());
    }
    doStop() {
      this.Uf = null;
    }
  }
  class ClickCreatingTool2 extends Tool2 {
    Ul;
    fM;
    Yf;
    cM;
    constructor(t) {
      super(), this.name = "ClickCreating", this.Ul = null, this.fM = true, this.Yf = false, this.cM = new Point2(0, 0), t && Object.assign(this, t);
    }
    canStart() {
      if (!this.isEnabled || this.archetypeNodeData === null) return false;
      const t = this.diagram;
      if (t.isReadOnly || t.isModelReadOnly || !t.allowInsert || !t.lastInput.left || this.isBeyondDragSize()) return false;
      if (this.isDoubleClick) {
        if (t.lastInput.clickCount === 1 && (this.cM = t.lastInput.viewPoint.copy()), t.lastInput.clickCount !== 2 || this.isBeyondDragSize(this.cM)) return false;
      } else if (t.lastInput.clickCount !== 1) return false;
      return !(t.currentTool !== this && t.findPartAt(t.lastInput.documentPoint, true) !== null);
    }
    doMouseUp() {
      const t = this.diagram;
      this.isActive && this.insertPart(t.lastInput.documentPoint), this.stopTool();
    }
    insertPart(t) {
      const i = this.diagram, e = this.archetypeNodeData;
      if (e === null) return null;
      let s = null;
      try {
        if (i.F("ChangingSelection", i.selection), this.startTransaction(this.name), e instanceof Part2) e.Oe() && (e.Yt(), s = e.copy(), s !== null && i.add(s));
        else if (e !== null) {
          const n = i.model.copyNodeData(e);
          i.model.addNodeData(n), s = i.findPartForData(n);
        }
        if (s !== null) {
          const n = Point2.U(t.x, t.y);
          this.isGridSnapEnabled && this.diagram.uM(s, t, n), s.location = n, i.allowSelect && (i.clearSelection(true), s.isSelected = true), Point2.o(n);
        }
        i.invalidateDocumentBounds(), this.transactionResult = this.name, i.F("PartCreated", s);
      } finally {
        this.stopTransaction(), i.F("ChangedSelection", i.selection);
      }
      return s;
    }
    get archetypeNodeData() {
      return this.Ul;
    }
    set archetypeNodeData(t) {
      t !== null && U.Oo(t, ClickCreatingTool2, "archetypeNodeData"), this.Ul = t;
    }
    get isDoubleClick() {
      return this.fM;
    }
    set isDoubleClick(t) {
      U.i(t, "boolean", ClickCreatingTool2, "isDoubleClick"), this.fM = t;
    }
    get isGridSnapEnabled() {
      return this.Yf;
    }
    set isGridSnapEnabled(t) {
      U.i(t, "boolean", ClickCreatingTool2, "isGridSnapEnabled"), this.Yf = t;
    }
  }
  class DragSelectingTool2 extends Tool2 {
    oa;
    dM;
    Gl;
    constructor(t) {
      super(), this.name = "DragSelecting", this.oa = 175, this.dM = false, this.Gl = new Part2({ layerName: "Tool", selectable: false }).add(new Shape2("Rectangle", { name: "SHAPE", fill: null, stroke: "magenta" }).theme("stroke", "dragSelect")).Yt(), t && Object.assign(this, t);
    }
    canStart() {
      if (!this.isEnabled) return false;
      const t = this.diagram;
      if (!t.allowSelect) return false;
      const i = t.lastInput;
      return !(!i.left || t.currentTool !== this && (!this.isBeyondDragSize() || i.timestamp - t.firstInput.timestamp < this.delay || t.findPartAt(i.documentPoint, true) !== null));
    }
    doActivate() {
      const t = this.diagram;
      this.isActive = true, t.isMouseCaptured = true, t.skipsUndoManager = true, this.box && t.add(this.box), this.doMouseMove();
    }
    doDeactivate() {
      const t = this.diagram;
      t.stopAutoScroll(), this.box && t.remove(this.box), t.skipsUndoManager = false, t.isMouseCaptured = false, this.isActive = false;
    }
    doMouseMove() {
      const t = this.diagram;
      if (this.isActive && this.box !== null) {
        const i = this.computeBoxBounds();
        let e = this.box.findObject("SHAPE");
        e === null && (e = this.box.findMainElement());
        const s = Size2.a().e(i.width, i.height);
        e !== null && (e.desiredSize = s), this.box.Gf(i.x, i.y, false), Size2.o(s), (t.allowHorizontalScroll || t.allowVerticalScroll) && t.doAutoScroll(t.lastInput.viewPoint);
      }
    }
    doMouseUp() {
      if (this.isActive) {
        const t = this.diagram;
        this.box && t.remove(this.box);
        try {
          t.currentCursor = "wait", t.F("ChangingSelection", t.selection), this.selectInRect(this.computeBoxBounds()), t.F("ChangedSelection", t.selection);
        } finally {
          t.currentCursor = "";
        }
      }
      this.stopTool();
    }
    computeBoxBounds() {
      const t = this.diagram;
      return new Rect2(t.firstInput.documentPoint, t.lastInput.documentPoint);
    }
    selectInRect(t) {
      const i = this.diagram, e = i.lastInput, s = i.findPartsIn(t, this.isPartialInclusion);
      if (U.wr ? e.meta : e.control) if (e.shift) {
        const n = s.iterator;
        for (; n.next(); ) {
          const o = n.value;
          o.isSelected && (o.isSelected = false);
        }
      } else {
        const n = s.iterator;
        for (; n.next(); ) {
          const o = n.value;
          o.isSelected = !o.isSelected;
        }
      }
      else if (e.shift) {
        const n = s.iterator;
        for (; n.next(); ) {
          const o = n.value;
          o.isSelected || (o.isSelected = true);
        }
      } else {
        const n = new List2(), o = i.selection.iterator;
        for (; o.next(); ) {
          const h = o.value;
          s.has(h) || n.add(h);
        }
        const r = n.iterator;
        for (; r.next(); ) {
          const h = r.value;
          h.isSelected = false;
        }
        const l = s.iterator;
        for (; l.next(); ) {
          const h = l.value;
          h.isSelected || (h.isSelected = true);
        }
      }
    }
    get delay() {
      return this.oa;
    }
    set delay(t) {
      U.i(t, "number", DragSelectingTool2, "delay"), this.oa = t;
    }
    get isPartialInclusion() {
      return this.dM;
    }
    set isPartialInclusion(t) {
      U.i(t, "boolean", DragSelectingTool2, "isPartialInclusion"), this.dM = t;
    }
    get box() {
      return this.Gl;
    }
    set box(t) {
      t !== null && (U.s(t, Part2, DragSelectingTool2, "box"), t.Yt()), this.Gl = t;
    }
  }
  class PanningTool2 extends Tool2 {
    Kx;
    FT;
    zo;
    gM;
    constructor(t) {
      super(), this.name = "Panning", this.Kx = new Point2(), this.FT = new Point2(), this.zo = false;
      const i = this;
      this.gM = () => {
        const e = i.diagram;
        e !== null && e.Fi(root.document, "scroll", i.gM, false), i.stopTool();
      }, t && Object.assign(this, t);
    }
    canStart() {
      if (!this.isEnabled) return false;
      const t = this.diagram;
      return !(!t.allowHorizontalScroll && !t.allowVerticalScroll || !t.lastInput.left || t.currentTool !== this && !this.isBeyondDragSize());
    }
    doActivate() {
      const t = this.diagram;
      this.zo ? (t.lastInput.bubbles = true, t.Kt(root.document, "scroll", this.gM, false)) : (t.currentCursor = "move", t.isMouseCaptured = true, this.Kx.c(t.position)), this.isActive = true;
    }
    doDeactivate() {
      const t = this.diagram;
      t.currentCursor = "", t.isMouseCaptured = false, this.isActive = false;
    }
    doCancel() {
      const t = this.diagram;
      t.position = this.Kx, t.isMouseCaptured = false, this.stopTool();
    }
    doMouseMove() {
      this.IT();
    }
    doMouseUp() {
      this.IT(), this.stopTool();
    }
    IT() {
      const t = this.diagram;
      if (this.isActive && t) {
        if (this.zo) {
          t.lastInput.bubbles = true;
          return;
        }
        const i = t.position, e = t.firstInput.documentPoint, s = t.lastInput.documentPoint;
        let n = i.x + e.x - s.x, o = i.y + e.y - s.y;
        t.allowHorizontalScroll || (n = i.x), t.allowVerticalScroll || (o = i.y), t.position = this.FT.e(n, o);
      }
    }
    get bubbles() {
      return this.zo;
    }
    set bubbles(t) {
      U.i(t, "boolean", PanningTool2, "bubbles"), this.zo = t;
    }
    get originalPosition() {
      return this.Kx;
    }
  }
  class HTMLInfo2 {
    Ux;
    Gx;
    mM;
    pM;
    constructor(t) {
      this.Ux = null, this.Gx = null, this.mM = null, this.pM = null, t && Object.assign(this, t);
    }
    get mainElement() {
      return this.mM;
    }
    set mainElement(t) {
      t !== null && U.s(t, HTMLElement, HTMLInfo2, "mainElement"), this.mM = t;
    }
    get show() {
      return this.Ux;
    }
    set show(t) {
      this.Ux !== t && (t !== null && U.C(t, HTMLInfo2, "show"), this.Ux = t);
    }
    get hide() {
      return this.Gx;
    }
    set hide(t) {
      this.Gx !== t && (t !== null && U.C(t, HTMLInfo2, "hide"), this.Gx = t);
    }
    get valueFunction() {
      return this.pM;
    }
    set valueFunction(t) {
      this.pM = t;
    }
  }
  class ContextMenuButtonInfo {
    mi;
    qx;
    qf;
    constructor(t, i, e) {
      this.mi = t, this.qx = i, this.qf = e;
    }
  }
  class ContextMenuTool2 extends Tool2 {
    yM;
    Hx;
    wM;
    xM;
    vx;
    Wx;
    vm;
    constructor(t) {
      super(), this.name = "ContextMenu", this.yM = null, this.Hx = null, this.wM = null, this.xM = new Point2(), this.vx = null, this.vm = false;
      const i = this;
      this.Wx = () => i.stopTool(), t && Object.assign(this, t);
    }
    CR() {
      const t = new HTMLInfo2();
      t.show = (r, l, h) => h.showDefaultContextMenu(), t.hide = (r, l) => l.hideDefaultContextMenu(), ContextMenuTool2.Hu = t;
      const i = this;
      this.Wx = () => i.stopTool();
      const e = U.Le("div"), s = U.Le("div");
      e.style.cssText = "top: 0px;z-index:10002;position: fixed;display: none;text-align: center;left: 25%;width: 50%;background-color: #F5F5F5;padding: 16px;border: 16px solid #444;border-radius: 10px;margin-top: 10px", s.style.cssText = "z-index:10001;position: fixed;display: none;top: 0;left: 0;width: 100%;height: 100%;background-color: black;opacity: 0.8;";
      const n = U.Le("style");
      root.document.getElementsByTagName("head")[0].appendChild(n), n.sheet.insertRule(".goCXul { list-style: none; }", 0), n.sheet.insertRule(".goCXli {font:700 1.5em Helvetica, Arial, sans-serif;position: relative;min-width: 60px; }", 0), n.sheet.insertRule(".goCXa {color: #444;display: inline-block;padding: 4px;text-decoration: none;margin: 2px;border: 1px solid gray;border-radius: 10px; }", 0);
      const o = this.diagram;
      o !== null && (o.Kt(e, "contextmenu", ContextMenuTool2.aa, false), o.Kt(e, "selectstart", ContextMenuTool2.aa, false), o.Kt(s, "contextmenu", ContextMenuTool2.aa, false)), e.className = "goCXforeground", s.className = "goCXbackground", root.document.body && (root.document.body.appendChild(e), root.document.body.appendChild(s)), ContextMenuTool2.Wm = e, ContextMenuTool2.jm = s, ContextMenuTool2.bM = true;
    }
    static Hu = null;
    static bM = false;
    static jm;
    static Wm;
    static aa(t) {
      return t.preventDefault(), false;
    }
    canStart() {
      if (!this.isEnabled) return false;
      const t = this.diagram;
      return this.isBeyondDragSize() || !t.lastInput.right || t.lastInput.clickCount > 1 ? false : !!(t.lastInput.isTouchEvent && this.defaultTouchContextMenu !== null || this.findObjectWithContextMenu() !== null);
    }
    doStart() {
      const t = this.diagram;
      this.xM.set(t.firstInput.documentPoint);
    }
    doStop() {
      this.hideContextMenu(), this.currentObject = null, this.vm = false;
    }
    findObjectWithContextMenu(t) {
      t === void 0 && (t = null);
      const i = this.diagram, e = i.lastInput;
      let s = null;
      if (t instanceof Diagram2 || (t instanceof GraphObject2 ? s = t : s = i.findObjectAt(e.documentPoint, null, (n) => !n.layer?.isTemporary)), s !== null) {
        let n = s;
        for (; n !== null; ) {
          if (n.contextMenu !== null) return n;
          n = n.panel;
        }
        if (i.lastInput.isTouchEvent && this.defaultTouchContextMenu) return s.part;
      } else if (i.contextMenu !== null) return i;
      return null;
    }
    doActivate() {
    }
    doMouseDown() {
      if (super.doMouseDown(), this.isActive && this.currentContextMenu instanceof Adornment2) {
        const t = this.diagram.toolManager.findTool("Action");
        t !== null && t.canStart() && (t.doActivate(), t.doMouseDown(), t.doDeactivate());
      }
      this.diagram.toolManager.mouseDownTools.has(this) && this.doContextClick();
    }
    doMouseUp() {
      if (this.isActive && this.currentContextMenu instanceof Adornment2) {
        const t = this.diagram.toolManager.findTool("Action");
        t !== null && t.canStart() && (t.doActivate(), t.doCancel(), t.doDeactivate());
      }
      this.doContextClick();
    }
    doContextClick() {
      const t = this.diagram;
      if (!this.isActive) this.canStart() && (this.openMenu(true), this.isActive || this.stopTool());
      else {
        const i = this.currentContextMenu;
        if (i === null) return;
        let e = null;
        i instanceof HTMLInfo2 || (e = t.findObjectAt(t.lastInput.documentPoint, null, null), e !== null && e.isContainedBy(i) && this.standardMouseClick(null, null)), this.maybeStopTool(e);
      }
    }
    maybeStopTool(t) {
      this.stopTool(), this.canStart() && (this.diagram.currentTool = this, this.doMouseUp());
    }
    openMenu(t, i) {
      if (i === void 0 && (i = null), this.vm) return;
      this.vm = true;
      let e = false;
      if (i instanceof Diagram2) {
        const s = this.diagram.lastInput;
        s.targetObject = null, e = this.aT(null, s, this.diagram);
      } else t && this.standardMouseSelect(), e = this.standardMouseClick();
      if (this.vm = false, !e) {
        this.isActive = true;
        const s = ContextMenuTool2.Hu;
        if (i === null && (i = this.findObjectWithContextMenu()), i !== null) {
          const n = i.contextMenu;
          n !== null ? (this.currentObject = i instanceof GraphObject2 ? i : null, this.showContextMenu(n, this.currentObject)) : s !== null && this.showContextMenu(s, this.currentObject);
        } else s !== null && this.showContextMenu(s, null);
        this.currentContextMenu instanceof Adornment2 && !this.currentContextMenu.visible && this.stopTool();
      }
    }
    doMouseMove() {
      const t = this.diagram.toolManager.findTool("Action");
      t !== null && t.doMouseMove(), this.isActive && this.diagram.toolManager.doMouseMove();
    }
    showContextMenu(t, i) {
      Debug && !(t instanceof Adornment2 || t instanceof HTMLInfo2) && U.n("showContextMenu:contextMenu must be an Adornment or HTMLInfo."), i !== null && U.s(i, GraphObject2, ContextMenuTool2, "showContextMenu:obj");
      const e = this.diagram;
      if (t !== this.currentContextMenu && this.hideContextMenu(), t instanceof Adornment2) {
        const s = t;
        s.layerName = "Tool", s.selectable = false, s.scale = 1 / e.scale, s.category = this.name, s.hasPlaceholder() && (s.placeholder.scale = e.scale);
        const n = s.diagram;
        n !== null && n !== e && n.remove(s), e.add(s), i !== null ? s.adornedObject = i : s.data = e.model, s.ensureBounds(), this.positionContextMenu(s, i);
      } else t instanceof HTMLInfo2 && t.show !== null && t.show(i, e, this);
      this.currentContextMenu = t;
    }
    positionContextMenu(t, i) {
      if (t.hasPlaceholder()) return;
      const e = t, s = this.diagram, n = s.lastInput.documentPoint.copy(), o = e.measuredBounds, r = s.viewportBounds;
      s.lastInput.isTouchEvent && (n.x -= o.width), n.x + o.width > r.right && (n.x -= o.width + 5 / s.scale), n.x < r.x && (n.x = r.x), n.y + o.height > r.bottom && (n.y -= o.height + 5 / s.scale), n.y < r.y && (n.y = r.y), e.position = n;
    }
    hideContextMenu() {
      const t = this.diagram, i = this.currentContextMenu;
      i !== null && (i instanceof Adornment2 ? (t.remove(i), this.Hx !== null && this.Hx.removeAdornment(i.category), i.data = null, i.adornedObject = null) : i instanceof HTMLInfo2 && (i.hide !== null ? i.hide(t, this) : i.mainElement !== null && (i.mainElement.style.display = "none")), this.currentContextMenu = null, this.standardMouseOver());
    }
    AR() {
      const t = this, i = new List2();
      return i.add(new ContextMenuButtonInfo("Copy", (e) => e.commandHandler.copySelection(), (e) => e.commandHandler.canCopySelection())), i.add(new ContextMenuButtonInfo("Cut", (e) => e.commandHandler.cutSelection(), (e) => e.commandHandler.canCutSelection())), i.add(new ContextMenuButtonInfo("Delete", (e) => e.commandHandler.deleteSelection(), (e) => e.commandHandler.canDeleteSelection())), i.add(new ContextMenuButtonInfo("Paste", (e) => e.commandHandler.pasteSelection(t.mouseDownPoint), (e) => e.commandHandler.canPasteSelection(t.mouseDownPoint))), i.add(new ContextMenuButtonInfo("Select All", (e) => e.commandHandler.selectAll(), (e) => e.commandHandler.canSelectAll())), i.add(new ContextMenuButtonInfo("Undo", (e) => e.commandHandler.undo(), (e) => e.commandHandler.canUndo())), i.add(new ContextMenuButtonInfo("Redo", (e) => e.commandHandler.redo(), (e) => e.commandHandler.canRedo())), i.add(new ContextMenuButtonInfo("Scroll To Part", (e) => e.commandHandler.scrollToPart(), (e) => e.commandHandler.canScrollToPart())), i.add(new ContextMenuButtonInfo("Zoom To Fit", (e) => e.commandHandler.zoomToFit(), (e) => e.commandHandler.canZoomToFit())), i.add(new ContextMenuButtonInfo("Reset Zoom", (e) => e.commandHandler.resetZoom(), (e) => e.commandHandler.canResetZoom())), i.add(new ContextMenuButtonInfo("Group Selection", (e) => e.commandHandler.groupSelection(), (e) => e.commandHandler.canGroupSelection())), i.add(new ContextMenuButtonInfo("Ungroup Selection", (e) => e.commandHandler.ungroupSelection(), (e) => e.commandHandler.canUngroupSelection())), i.add(new ContextMenuButtonInfo("Edit Text", (e) => e.commandHandler.editTextBlock(), (e) => e.commandHandler.canEditTextBlock())), i;
    }
    showDefaultContextMenu() {
      const t = this.diagram;
      this.vx === null && (this.vx = this.AR()), ContextMenuTool2.Wm.innerHTML = "", ContextMenuTool2.jm.addEventListener("pointerdown", this.Wx, false);
      const i = this, e = U.Le("ul");
      e.className = "goCXul", ContextMenuTool2.Wm.appendChild(e), e.innerHTML = "";
      const s = this.vx.iterator;
      for (; s.next(); ) {
        const n = s.value, o = n.qx, r = n.qf;
        if (!U.at(o) || U.at(r) && !r(t)) continue;
        const l = U.Le("li");
        l.className = "goCXli";
        const h = U.Le("a");
        h.className = "goCXa", h.href = "#", h.qx = o, h.addEventListener("pointerdown", function(f) {
          return this.qx(t), i.stopTool(), f.preventDefault(), false;
        }, false), h.textContent = n.mi, l.appendChild(h), e.appendChild(l);
      }
      ContextMenuTool2.Wm.style.display = "block", ContextMenuTool2.jm.style.display = "block";
    }
    hideDefaultContextMenu() {
      if (this.currentContextMenu === null || this.currentContextMenu !== ContextMenuTool2.Hu) return;
      ContextMenuTool2.Wm.style.display = "none", ContextMenuTool2.jm.style.display = "none";
      const t = this.diagram;
      t !== null && t.Fi(ContextMenuTool2.jm, "pointerdown", this.Wx, false), this.currentContextMenu = null;
    }
    doMouseWheel() {
      this.standardMouseWheel();
    }
    get currentContextMenu() {
      return this.yM;
    }
    set currentContextMenu(t) {
      Debug && t !== null && !(t instanceof Adornment2 || t instanceof HTMLInfo2) && U.n("ContextMenuTool.currentContextMenu must be an Adornment or HTMLInfo."), this.yM = t, this.Hx = t instanceof Adornment2 ? t.adornedPart : null;
    }
    get defaultTouchContextMenu() {
      return ContextMenuTool2.bM === false && ContextMenuTool2.Hu === null && Diagram2.isUsingDOM() && this.CR(), ContextMenuTool2.Hu;
    }
    set defaultTouchContextMenu(t) {
      Debug && t !== null && !(t instanceof Adornment2 || t instanceof HTMLInfo2) && U.n("ContextMenuTool.defaultTouchContextMenu must be an Adornment or HTMLInfo."), t === null && (ContextMenuTool2.bM = true), ContextMenuTool2.Hu = t;
    }
    get currentObject() {
      return this.wM;
    }
    set currentObject(t) {
      t !== null && U.s(t, GraphObject2, ContextMenuTool2, "currentObject"), this.wM = t;
    }
    get mouseDownPoint() {
      return this.xM;
    }
  }
  var TextEditingAccept2 = ((w) => (w[w.LostFocus = 1] = "LostFocus", w[w.MouseDown = 2] = "MouseDown", w[w.Tab = 3] = "Tab", w[w.Enter = 4] = "Enter", w))(TextEditingAccept2 || {}), TextEditingStarting2 = ((w) => (w[w.SingleClick = 1] = "SingleClick", w[w.SingleClickSelected = 2] = "SingleClickSelected", w[w.DoubleClick = 3] = "DoubleClick", w))(TextEditingStarting2 || {}), TextEditingState2 = ((w) => (w[w.None = 1] = "None", w[w.Active = 2] = "Active", w[w.Editing = 3] = "Editing", w[w.Validating = 4] = "Validating", w[w.Invalid = 5] = "Invalid", w[w.Validated = 6] = "Validated", w))(TextEditingState2 || {});
  class TextEditingTool2 extends Tool2 {
    Ee;
    SM;
    kM;
    ql;
    Wt;
    PM;
    MM;
    NM;
    jx;
    Jx;
    constructor(t) {
      super(), this.name = "TextEditing", this.Ee = new TextBlock2(), this.SM = null, this.kM = 2, this.ql = null, this.Wt = 1, this.PM = 1, this.MM = true, this.NM = null, this.jx = new HTMLInfo2(), this.Jx = null, this.TR(this.jx), t && Object.assign(this, t);
    }
    static LostFocus = 1;
    static MouseDown = 2;
    static Tab = 3;
    static Enter = 4;
    static SingleClick = 1;
    static SingleClickSelected = 2;
    static DoubleClick = 3;
    static StateNone = 1;
    static StateActive = 2;
    static StateEditing = 3;
    static StateValidating = 4;
    static StateInvalid = 5;
    static StateValidated = 6;
    TR(t) {
      if (!Diagram2.isUsingDOM()) return;
      const i = U.Le("textarea");
      this.Jx = i;
      const e = this;
      i.addEventListener("input", function(s) {
        if (e.textBlock === null) return;
        const n = e.measureTemporaryTextBlock(this.value), o = this.textScale;
        this.style.width = 20 + Math.max(e.textBlock.measuredBounds.width, n.measuredBounds.width) * o + "px", this.rows = Math.max(e.textBlock.lineCount, n.lineCount);
      }, false), i.addEventListener("keydown", function(s) {
        if (s.isComposing || e.textBlock === null) return;
        const n = s.key;
        if (n === "Enter") {
          e.textBlock.isMultiline === false && s.preventDefault(), e.acceptText(4);
          return;
        } else if (n === "Tab") {
          e.acceptText(3), s.preventDefault();
          return;
        } else n === "Escape" && (e.doCancel(), e.diagram !== null && e.diagram.doFocus());
      }, false), i.addEventListener("focus", function(s) {
        e.LR(s);
      }, false), i.addEventListener("blur", function(s) {
        e.DR(s);
      }, false), t.valueFunction = () => i.value, t.mainElement = i, t.show = (s, n, o) => {
        if (!(s instanceof TextBlock2) || !n || !n.div || !(o instanceof TextEditingTool2)) return;
        if (o.state === 5) {
          i.style.border = "3px solid red", i.focus();
          return;
        }
        const r = s.getDocumentPoint(Spot2.Center), l = n.position, h = n.scale;
        let f = s.getDocumentScale() * h;
        f < o.minimumEditorScale && (f = o.minimumEditorScale);
        const a = s.naturalBounds.width * f + 6, c = s.naturalBounds.height * f + 2, u = (r.x - l.x) * h, d = (r.y - l.y) * h, m = s.verticalAlignment, p = (s.lineHeight + s.spacingAbove + s.spacingBelow) * s.lineCount * f, y = 0.5 * c - 0.5 * p, x = m.y * c - m.y * p + m.offsetY - y - p / 2;
        i.value = s.text, n.div.style.font = s.font;
        const S = 1;
        i.style.position = "absolute", i.style.zIndex = "100", i.style.font = "inherit", i.style.fontSize = f * 100 + "%", i.style.lineHeight = "normal", i.style.width = a + "px", i.style.left = (u - a / 2 | 0) - S + "px", i.style.top = (d + x | 0) - S + "px", i.style.textAlign = s.textAlign, i.style.margin = "0", i.style.padding = S + "px", i.style.border = "0", i.style.outline = "none", i.style.whiteSpace = "pre-wrap", i.style.overflow = "hidden", i.rows = s.lineCount, i.textScale = f, i.className = "goTXarea", n.div.appendChild(i), i.focus(), o.selectsTextOnActivate && (i.select(), i.setSelectionRange(0, 9999));
      }, t.hide = (s, n) => {
        s.div && s.div.removeChild(i);
      };
    }
    get textBlock() {
      return this.SM;
    }
    set textBlock(t) {
      t !== null && U.s(t, TextBlock2, TextEditingTool2, "textBlock"), this.SM = t;
    }
    get currentTextEditor() {
      return this.NM;
    }
    set currentTextEditor(t) {
      this.NM = t;
    }
    get defaultTextEditor() {
      return this.jx;
    }
    set defaultTextEditor(t) {
      Debug && !(t instanceof HTMLInfo2) && U.n("TextEditingTool.defaultTextEditor must be an HTMLInfo."), this.jx = t;
    }
    get starting() {
      return this.kM;
    }
    set starting(t) {
      U.W(t, TextEditingStarting2, "TextEditingStarting"), this.kM = t;
    }
    canStart() {
      if (!this.isEnabled) return false;
      const t = this.diagram;
      if (t === null || t.isReadOnly || TextEditingTool2.Hf && TextEditingTool2.Hf !== this && (TextEditingTool2.Hf.acceptText(2), TextEditingTool2.Hf && TextEditingTool2.Hf !== this) || !t.lastInput.left || this.isBeyondDragSize()) return false;
      const i = t.lastInput.documentPoint, e = t.findObjectAt(i);
      if (e === null || !(e instanceof TextBlock2) || !e.editable || e.part === null || !e.part.canEdit()) return false;
      const s = e.part;
      return !(s === null || this.starting === 2 && !s.isSelected || this.starting === 3 && t.lastInput.clickCount < 2);
    }
    doStart() {
      TextEditingTool2.Hf = this, this.textBlock !== null && this.doActivate();
    }
    doActivate() {
      if (this.isActive) return;
      const t = this.diagram;
      if (t === null) return;
      let i = this.textBlock;
      if (i === null && (i = t.findObjectAt(t.lastInput.documentPoint)), i === null || !(i instanceof TextBlock2) || (this.textBlock = i, i.part === null)) return;
      t.animationManager.stopAnimation(), this.isActive = true, this.Wt = 2;
      let s = this.defaultTextEditor;
      i.textEditor !== null && (s = i.textEditor), this.Ee = this.textBlock.copy();
      const n = new Rect2(this.textBlock.getDocumentPoint(Spot2.TopLeft), this.textBlock.getDocumentPoint(Spot2.BottomRight));
      t.scrollToRect(n), s !== null && s.show !== null && s.show(i, t, this), this.currentTextEditor = s;
    }
    doCancel() {
      this.stopTool();
    }
    doMouseUp() {
      this.canStart() && this.doActivate();
    }
    doMouseDown() {
      this.isActive && this.acceptText(2);
    }
    acceptText(t) {
      switch (t) {
        case 2:
          this.Wt === 6 ? this.currentTextEditor instanceof HTMLElement && this.currentTextEditor.focus() : (this.Wt === 2 || this.Wt === 5 || this.Wt === 3) && (this.Wt = 4, this.RT());
          break;
        case 1:
        case 4:
        case 3:
          if (t === 4 && this.textBlock !== null && this.textBlock.isMultiline === true) return;
          (this.Wt === 2 || this.Wt === 5 || this.Wt === 3) && (this.Wt = 4, this.RT());
          break;
      }
    }
    RT() {
      const t = this.textBlock, i = this.diagram, e = this.currentTextEditor;
      if (t !== null && e !== null) {
        const s = t.text;
        let n = "";
        if (e.valueFunction !== null && (n = e.valueFunction()), !this.isValidText(t, s, n)) {
          this.Wt = 5, this.doError(s, n);
          return;
        }
        this.startTransaction(this.name), this.Wt = 6, this.transactionResult = this.name, t.text = n, this.doSuccess(s, n), i !== null && i.F("TextEdited", t, s), this.stopTransaction(), this.stopTool(), i !== null && i.doFocus();
      }
    }
    doError(t, i) {
      const e = this.textBlock;
      if (e === null) return;
      e.errorFunction !== null && e.errorFunction(this, t, i);
      const s = this.currentTextEditor;
      s !== null && s.show !== null && s.show(e, this.diagram, this);
    }
    doSuccess(t, i) {
      const e = this.textBlock;
      e !== null && e.textEdited !== null && e.textEdited(e, t, i);
    }
    doDeactivate() {
      const t = this.diagram;
      if (t !== null) {
        if (this.Wt = 1, this.currentTextEditor !== null) {
          const i = this.currentTextEditor;
          i !== null && i.hide !== null && i.hide(t, this);
        }
        this.textBlock = null, this.isActive = false;
      }
    }
    doStop() {
      TextEditingTool2.Hf = null;
    }
    LR(t) {
      if (this.currentTextEditor === null || this.state === 1) return;
      const i = this.Jx;
      this.Wt === 2 && (this.Wt = 3), U.at(i.select) && this.selectsTextOnActivate && (i.select(), i.setSelectionRange(0, 9999));
    }
    DR(t) {
      if (this.currentTextEditor === null || this.state === 1) return;
      const i = this.Jx;
      U.at(i.focus) && i.focus(), U.at(i.select) && this.selectsTextOnActivate && (i.select(), i.setSelectionRange(0, 9999));
    }
    isValidText(t, i, e) {
      U.s(t, TextBlock2, TextEditingTool2, "isValidText:textblock");
      const s = this.textValidation;
      if (s !== null && !s(t, i, e)) return false;
      const n = t.textValidation;
      return !(n !== null && !n(t, i, e));
    }
    get textValidation() {
      return this.ql;
    }
    set textValidation(t) {
      t !== null && U.C(t, TextEditingTool2, "textValidation"), this.ql = t;
    }
    get minimumEditorScale() {
      return this.PM;
    }
    set minimumEditorScale(t) {
      t !== null && U.i(t, "number", TextEditingTool2, "minimumEditorScale"), this.PM = t;
    }
    get selectsTextOnActivate() {
      return this.MM;
    }
    set selectsTextOnActivate(t) {
      t !== null && U.i(t, "boolean", TextEditingTool2, "selectsTextOnActivate"), this.MM = t;
    }
    get state() {
      return this.Wt;
    }
    set state(t) {
      this.Wt !== t && (U.W(t, TextEditingState2, "TextEditingState"), this.Wt = t);
    }
    measureTemporaryTextBlock(t) {
      const i = this.Ee;
      return i.text = t, this.textBlock !== null && i.gt(this.textBlock.Hl, 1 / 0), i;
    }
    static Hf = null;
  }
  var AnimationStyle2 = ((w) => (w[w.Default = 1] = "Default", w[w.AnimateLocations = 2] = "AnimateLocations", w[w.None = 3] = "None", w))(AnimationStyle2 || {});
  class AnimationManager2 {
    f;
    Ii;
    Gi;
    Or;
    so;
    Yo;
    CM;
    AM;
    Jm;
    $x;
    Mi;
    vf;
    Nn;
    $m;
    fa;
    Zx;
    Zm;
    Qx;
    Wf;
    Gu;
    Qm;
    constructor(t) {
      this.f = Diagram2.zm(), this.Ii = false, this.Jm = false, this.$x = false, this.Mi = false, this.vf = false, this.Qx = true, this.Wf = 1, this.Gu = false, this.Gi = true, this.Or = true, this.Yo = 600, this.CM = false, this.AM = false, this.so = new GSet2(), this.Nn = new Animation2(), this.$m = new Animation2(), this.Nn.Ls = this, this.fa = new GSet2(), this.Zx = new GSet2(), this.Zm = new GSet2(), this.Qm = new GSet2(), t && Object.assign(this, t);
    }
    Ko(t) {
      this.f = t;
    }
    OB() {
      return this.f;
    }
    canStart(t) {
      return true;
    }
    vl(t) {
      return !this.Gi || !this.canStart(t) ? false : (this.so.add(t), this.defaultAnimation.isAnimating && this.stopAnimation(), this.f.Ri(), this.Mi = true, true);
    }
    getBundleAnimation() {
      return this.$m;
    }
    TM() {
      if (!this.Gi || (this.$m.xe.count > 0 && this.$m.start(), !this.Mi)) return;
      const t = this.Nn, i = this.f, e = this.so.has("Model");
      if (e && (this.vf = true, this.Wf === 1 ? (t.isViewportUnconstrained = true, t.xe.clear(), t.add(i, "position", i.position.copy().offset(0, -200), i.position), t.add(i, "opacity", 0, 1)) : this.Wf === 3 && t.xe.clear(), this.Wf === 2 && i._x.equals(i.yt) ? this.Qx = true : this.Qx = false, i.F("InitialAnimationStarting", this)), e && !this.Or || t.xe.count === 0) {
        this.so.clear(), this.Mi = false, t.xe.clear(), t.t1(i), this.vf = false, i.L();
        return;
      }
      this.so.clear(), i.Er = false;
      const s = t.xe.get(i);
      i.autoScale !== 1 && s !== null && (delete s.ci.scale, delete s.Ds.scale);
      const n = this;
      root.requestAnimationFrame(() => {
        n.Mi === false || t.Ii || (i.getRenderingHint("temporaryPixelRatio") && i.Rx(), i.LM(), n.Mi = false, t.start(), t.Ii && (n.vu(), i.invalidateDocumentBounds(), t.OT(0), i.Tr(true), n.Wu(), i.F("AnimationStarting", n)));
      });
    }
    DM() {
      return this.so.has("Trigger") && this.so.count === 1;
    }
    ET(t, i, e, s) {
      this.isTicking || this.DM() || t instanceof Link2 && (t.fromNode !== null || t.toNode !== null) || this.Nn.add(t, "position", i, e, s);
    }
    i1(t) {
      return this.Nn.i1(t);
    }
    FM(t) {
      return this.Nn.FM(t);
    }
    FR(t) {
      const i = this.fa, e = this;
      function s() {
        if (e.Zm.count > 0 && (i.addAll(e.Zm), e.Zm.clear(), e.Ii = true), e.Ii === false || i.count === 0) {
          e.$x = false;
          return;
        }
        e.Zx.addAll(i);
        const n = e.Zx.iterator;
        for (; n.next(); ) {
          const o = n.value;
          o.Ii !== false && (o.IR() ? o.BT(false) : o.jf = true);
        }
        if (e.Zx.clear(), e.Ii === false) {
          root.requestAnimationFrame(s);
          return;
        }
        e.vu(), e.f.Tr(), e.Wu(), root.requestAnimationFrame(s);
      }
      this.Ii ? this.VT(t) : (this.Ii = true, this.$x ? this.VT(t) : (this.$x = true, i.add(t), root.requestAnimationFrame(() => s())));
    }
    VT(t) {
      this.Zm.add(t);
    }
    RR() {
      const t = this.fa.iterator;
      for (; t.next(); ) t.value.jf = false;
    }
    vu() {
      if (this.Jm) return;
      const t = this.f;
      this.CM = t.skipsUndoManager, this.AM = t.be, t.skipsUndoManager = true, t.be = true, this.Jm = true;
    }
    Wu() {
      const t = this.f;
      t.skipsUndoManager = this.CM, t.be = this.AM, this.Jm = false;
    }
    stopAnimation(t) {
      const i = this.Nn;
      if (this.Mi === true && (this.Mi = false, this.vf = false, this.so.clear(), i.OR() && this.f.requestUpdate()), !this.Ii) {
        i.xe.clear(), i.t1(this.f);
        return;
      }
      if (i.ju(true), i.t1(null), t === true) {
        const e = this.fa.toArray();
        for (let s = 0; s < e.length; s++) e[s].ju(true);
      }
    }
    ju(t) {
      this.fa.delete(t), this.fa.count === 0 && (this.Ii = false, this.f.requestUpdate()), t === this.defaultAnimation && this.f.F("AnimationFinished", this);
    }
    Jf(t, i) {
      this.Mi && (!this.so.has("Expand Tree") && !this.so.has("Expand SubGraph") || (this.Nn.Jf(t, i), this.zT(t)));
    }
    $f(t, i) {
      this.Mi && (!this.so.has("Collapse Tree") && !this.so.has("Collapse SubGraph") || (this.Nn.$f(t, i), this.Nn.IM(i, "position", i.position, i.position), this.zT(t)));
    }
    XT(t, i) {
      !this.Mi || t.equals(i) || this.DM() || (this.f.sa || (t = i.copy()), this.Nn.IM(this.f, "position", t, i));
    }
    YT(t, i) {
      this.Mi && (this.DM() || this.Nn.add(this.f, "scale", t, i));
    }
    RM(t, i) {
      t.Be && (t.Br = i, this.Qm.add(t));
    }
    zT(t) {
      const i = t.findLinksConnected();
      for (; i.next(); ) {
        const e = i.value;
        e.Be && (e.Br = e.points.copy(), this.Qm.add(e));
      }
    }
    get isEnabled() {
      return this.Gi;
    }
    set isEnabled(t) {
      U.i(t, "boolean", AnimationManager2, "isEnabled"), this.Gi = t, t && this.fa.each((i) => {
        !i.isAnimating && i.runCount === 1 / 0 && i.start();
      });
    }
    get duration() {
      return this.Yo;
    }
    set duration(t) {
      U.i(t, "number", AnimationManager2, "duration"), t < 1 && U.G(t, ">= 1", AnimationManager2, "duration"), this.Yo = t;
    }
    get isAnimating() {
      return this.Ii;
    }
    get isTicking() {
      return this.Jm;
    }
    get isInitial() {
      return this.Or;
    }
    set isInitial(t) {
      U.i(t, "boolean", AnimationManager2, "isInitial"), this.Or = t;
    }
    get defaultAnimation() {
      return this.Nn;
    }
    get activeAnimations() {
      return this.fa;
    }
    get initialAnimationStyle() {
      return this.Wf;
    }
    set initialAnimationStyle(t) {
      Debug && U.W(t, AnimationStyle2, "AnimationStyle"), this.Wf = t;
    }
    static e1 = new GMap2();
    static defineAnimationEffect(t, i) {
      AnimationManager2.e1.set(t, i);
    }
    static OM(t, i, e, s, n) {
      t === null && (t = [0, 0, 0, 0]), i === null && (i = [0, 0, 0, 0]);
      let o = t[0], r = t[1];
      const l = t[2], h = t[3];
      let f = i[0], a = i[1];
      const c = i[2], u = i[3];
      l === 0 || l === 100 ? (o = f, r = a) : (c === 0 || c === 100) && (f = o, a = r), Math.abs(f - o) > 180 && (f > o ? o += 360 : f += 360);
      const d = n(e, o, f - o, s) % 360, m = n(e, r, a - r, s), g = n(e, l, c - l, s), p = n(e, h, u - h, s);
      return "hsla(" + d + ", " + m + "%, " + g + "%, " + p + ")";
    }
    static Default = 1;
    static AnimateLocations = 2;
    static None = 3;
  }
  {
    const w = AnimationManager2.e1, t = (i, e, s, n, o, r) => {
      i.position = new Point2(n(o, e.x, s.x - e.x, r), n(o, e.y, s.y - e.y, r));
    };
    w.set("position:diagram", t), w.set("position", t), w.set("position:part", (i, e, s, n, o, r) => {
      o < r ? i.Gf(n(o, e.x, s.x - e.x, r), n(o, e.y, s.y - e.y, r), false) : i.position = new Point2(n(o, e.x, s.x - e.x, r), n(o, e.y, s.y - e.y, r));
    }), w.set("location", (i, e, s, n, o, r) => {
      o < r ? i.Gf(n(o, e.x, s.x - e.x, r), n(o, e.y, s.y - e.y, r), true) : i.location = new Point2(n(o, e.x, s.x - e.x, r), n(o, e.y, s.y - e.y, r));
    }), w.set("position:placeholder", (i, e, s, n, o, r) => {
      o < r ? i.Gf(n(o, e.x, s.x - e.x, r), n(o, e.y, s.y - e.y, r), false) : i.position = new Point2(n(o, e.x, s.x - e.x, r), n(o, e.y, s.y - e.y, r));
    }), w.set("position:nodeCollapse", (i, e, s, n, o, r) => {
      const l = i.actualBounds, h = s.actualBounds, f = h.x + h.width / 2 - l.width / 2, a = h.y + h.height / 2 - l.height / 2;
      o < r ? i.Gf(n(o, e.x, f - e.x, r), n(o, e.y, a - e.y, r), false) : i.position = new Point2(n(o, e.x, f - e.x, r), n(o, e.y, a - e.y, r));
    }), w.set("desiredSize", (i, e, s, n, o, r) => {
      i.desiredSize = new Size2(n(o, e.width, s.width - e.width, r), n(o, e.height, s.height - e.height, r));
    }), w.set("width", (i, e, s, n, o, r) => {
      i.width = n(o, e, s - e, r);
    }), w.set("height", (i, e, s, n, o, r) => {
      i.height = n(o, e, s - e, r);
    }), w.set("fill", (i, e, s, n, o, r) => {
      i.fill = AnimationManager2.OM(e, s, o, r, n);
    }), w.set("stroke", (i, e, s, n, o, r) => {
      i.stroke = AnimationManager2.OM(e, s, o, r, n);
    }), w.set("strokeWidth", (i, e, s, n, o, r) => {
      i.strokeWidth = n(o, e, s - e, r);
    }), w.set("strokeDashOffset", (i, e, s, n, o, r) => {
      i.strokeDashOffset = n(o, e, s - e, r);
    }), w.set("background", (i, e, s, n, o, r) => {
      i.background = AnimationManager2.OM(e, s, o, r, n);
    }), w.set("opacity", (i, e, s, n, o, r) => {
      i.opacity = n(o, e, s - e, r);
    }), w.set("scale", (i, e, s, n, o, r) => {
      i.scale = n(o, e, s - e, r);
    }), w.set("angle", (i, e, s, n, o, r) => {
      i.angle = n(o, e, s - e, r);
    });
  }
  class Animation2 {
    s1;
    _m;
    Ii;
    Ju;
    Yo;
    Fs;
    KT;
    Zf;
    xe;
    o1;
    ci;
    no;
    $u;
    Qf;
    l1;
    h1;
    jf;
    EM;
    a1;
    Ls;
    f;
    BM;
    VM;
    zM;
    constructor(t) {
      this.f = null, this.Ls = null, this.EM = null, this.a1 = null, this.BM = false, this.Ii = false, this.jf = false, this.ci = 0, this.no = 0, this.s1 = Animation2.EaseInOutQuad, this._m = Animation2.EaseInOutQuad, this.$u = false, this.Qf = false, this.l1 = 1, this.h1 = 0, this.Yo = NaN, this.Fs = NaN, this.VM = 0, this.Ju = null, this.KT = Point2.wn, this.xe = new GMap2(), this.o1 = new GMap2(), this.Zf = new GSet2(), this.zM = 1, t && Object.assign(this, t);
    }
    suspend() {
      this.jf = true;
    }
    advanceTo(t, i) {
      i && (this.jf = false), this.$u && t >= this.Fs && (this.Qf = true, t = t - this.Fs), this.VM = t, this.BT(true), this.Ls.vu(), this.f.Tr(), this.Ls.Wu(), this.f.redraw();
    }
    t1(t) {
      if (this.o1.clear(), this.Qf = false, this.h1 = 0, this.Fs = NaN, this.Zf.count > 0 && this.Zf.clear(), t !== null) {
        const i = t.links;
        for (; i.next(); ) i.value.Br = null;
      }
    }
    OR() {
      return this.xe.count > 0;
    }
    start() {
      if (this.xe.count === 0) return this;
      if (this.Ii) return this;
      let t = this.f;
      const i = this.xe.iterator;
      for (; i.next(); ) {
        const s = i.key;
        t === null && (s instanceof Diagram2 ? t = s : s instanceof GraphObject2 && (t = s.diagram));
      }
      if (t !== null) this.f = t, this.Ls = t.animationManager;
      else return this;
      const e = this.Ls;
      return e.isEnabled === false ? this : (this.Fs = isNaN(this.Yo) ? e.duration : this.Yo, this._m = this.s1, e.vf && e.Wf === 1 && this === e.defaultAnimation && (this._m = Animation2.EaseOutExpo, this.Fs = isNaN(this.Yo) ? e.duration === 600 ? 900 : e.duration : this.Yo), this.zM = t.scrollMode, this.isViewportUnconstrained && (t.ca = 2), e.vu(), this.Zf.each((s) => {
        s.data = null, t.add(s);
      }), e.Wu(), this.Ii = true, this.ci = +/* @__PURE__ */ new Date(), this.no = this.ci + this.Fs, e.FR(this), this);
    }
    addTemporaryPart(t, i) {
      return t.Oe() ? (Debug && (i === void 0 && U.n("addTemporaryPart: Required Diagram argument missing"), t.diagram === i && U.n("addTemporaryPart: Part already in Diagram, did you mean to pass in a copy?"), this.f !== null && this.f !== i && U.n("addTemporaryPart: A different Diagram is already associated with this Animation: " + this.f.toString())), this.Zf.add(t), this.f = i, this) : this;
    }
    add(t, i, e, s, n) {
      if (this.f === null && (t instanceof Diagram2 ? this.f = t : t instanceof GraphObject2 && t.diagram !== null && (this.f = t.diagram)), t instanceof Part2) {
        if (!t.isAnimated) return this;
        i === "position" && (i = "position:part");
      }
      return this.IM(t, i, e, s, n), this;
    }
    IM(t, i, e, s, n) {
      const o = this.xe;
      let r, l, h;
      if (t instanceof Diagram2 && i === "position" && (i = "position:diagram"), (i === "fill" || i === "stroke" || i === "background") && (Brush2.Uo(e), Brush2.XM(), e = [Brush2.qi.n0, Brush2.qi.n1, Brush2.qi.n2, Brush2.qi.n3], Brush2.Uo(s), Brush2.XM(), s = [Brush2.qi.n0, Brush2.qi.n1, Brush2.qi.n2, Brush2.qi.n3]), o.has(t)) r = o.get(t), l = r.ci, h = r.Ds, l[i] === void 0 && (l[i] = this.Zu(e)), h[i] = this.Zu(s);
      else {
        if (i === "position" && e.equalsApprox(s)) return;
        l = {}, h = {}, l[i] = this.Zu(e), h[i] = this.Zu(s), r = new AnimationState(l, h, n), o.set(t, r);
      }
      const f = l[i];
      f instanceof Point2 && !f.isReal() && f.c(this.KT), n && i.indexOf("position:") === 0 && t instanceof Part2 ? r.f1.location = this.Zu(t.location) : n && (r.f1[i] = this.Zu(e));
    }
    Zu(t) {
      return t instanceof Point2 || t instanceof Size2 ? t.copy() : t;
    }
    ER(t) {
      const i = this.xe;
      if (i.has(t)) {
        const e = i.get(t);
        e.c1 = true;
      }
    }
    i1(t) {
      if (!this.Ii) return false;
      const i = this.xe.get(t);
      return i !== null && i.c1;
    }
    FM(t) {
      if (!this.Ii) return false;
      const i = this.xe.get(t);
      return i !== null && !!(i.ci.position || i.ci["position:part"] || i.ci.location);
    }
    IR() {
      if (this.Zf.count > 0) return true;
      const t = this.xe.iterator;
      for (; t.next(); ) {
        const i = t.key;
        if (i instanceof GraphObject2 && i.diagram !== null || i instanceof Diagram2) return true;
      }
      return false;
    }
    BT(t) {
      if (this.jf && !t) return;
      const i = this.Ls;
      if (this.Ii === false) return;
      const e = +/* @__PURE__ */ new Date();
      let s = e > this.no ? this.Fs : e - this.ci;
      t && (s = this.VM, s < this.Fs ? (this.ci = +/* @__PURE__ */ new Date() - s, this.no = this.ci + this.Fs) : s = this.Fs), i.vu(), this.OT(s), this.f.Tr(true), i.Wu(), e > this.no && (this.$u && !this.Qf ? (this.ci = +/* @__PURE__ */ new Date(), this.no = this.ci + this.Fs, this.Qf = true) : this.ju(false));
    }
    OT(t) {
      const i = this.Fs, e = this.xe.iterator, s = this.Qf;
      for (; e.next(); ) {
        const n = e.key;
        if (n instanceof GraphObject2 && n.diagram === null) continue;
        const o = e.value, r = s ? o.Ds : o.ci, l = s ? o.ci : o.Ds, h = AnimationManager2.e1;
        for (const f in l) f === "position" && (l["position:placeholder"] || l["position:nodeCollapse"]) || h.get(f) !== null && h.get(f)(n, r[f], l[f], this._m, t, i, this);
      }
    }
    stop() {
      return this.Ii ? (this.ju(true), this) : this;
    }
    ju(t) {
      if (this.a1 !== null && this.a1.BR(this.EM), !this.Ii) return;
      const i = this.f, e = this.Ls;
      e.vf = false, this.Ii = false, this.jf = false, e.vu();
      const s = this.xe, n = this.Zf.iterator;
      for (; n.next(); ) i.remove(n.value);
      const o = this.$u, r = s.iterator, l = AnimationManager2.e1;
      for (; r.next(); ) {
        const f = r.key, a = r.value, c = o ? a.Ds : a.ci, u = o ? a.ci : a.Ds, d = a.f1;
        for (const m in u) if (l.get(m) !== null) {
          let g = m;
          a.u1 && (g === "position:nodeCollapse" || g === "position:placeholder") && (g = "position"), l.get(g)(f, c[m], d[m] !== void 0 ? d[m] : a.u1 ? c[m] : u[m], this._m, this.Fs, this.Fs, this);
        }
        a.u1 && d.location !== void 0 && f instanceof Part2 && (f.location = d.location), a.c1 && f instanceof Part2 && f.Hi(false);
      }
      this.h1++;
      const h = !t && this.l1 > this.h1;
      if (!h && (this === e.$m || this === e.defaultAnimation) && this.xe.clear(), i.d1.clear(), i.kP(false), i.invalidateDocumentBounds(), i.L(), i.Tr(true), e.defaultAnimation === this) {
        const f = e.Qm.iterator;
        for (; f.next(); ) f.value.VR();
        e.Qm.clear();
      }
      if (i.Tr(true), this.isViewportUnconstrained && (i.scrollMode = this.zM), e.Wu(), h) {
        this.Qf = false, this.start();
        return;
      }
      this.t1(null), i.UT(), e.ju(this), this.Ju && this.Ju(this), i.requestUpdate();
    }
    Jf(t, i) {
      const e = i.actualBounds;
      let s = null;
      if (i instanceof Group2 && (s = i.placeholder), s !== null && s.visible) {
        const n = s.getDocumentPoint(Spot2.TopLeft), o = s.padding;
        n.x += o.left, n.y += o.top, this.add(t, "position", n, t.position, false);
      } else this.add(t, "position", new Point2(e.x + e.width / 2, e.y + e.height / 2), t.position, false);
      this.add(t, "scale", 0.01, t.scale, false), t instanceof Group2 && this.zR(t, i);
    }
    zR(t, i) {
      const e = t.memberParts;
      for (; e.next(); ) {
        const s = e.value;
        s instanceof Node2 && this.Jf(s, i);
      }
    }
    $f(t, i) {
      if (!t.isVisible()) return;
      let e = null;
      if (i instanceof Group2 && (e = i.placeholder), e !== null && e.visible) {
        const s = e.getDocumentPoint(Spot2.TopLeft), n = e.padding;
        s.x += n.left, s.y += n.top, this.add(t, "position:placeholder", t.position, s, true);
      } else this.add(t, "position:nodeCollapse", t.position, i, true);
      this.add(t, "scale", t.scale, 0.01, true), this.ER(t), t instanceof Group2 && this.XR(t, i);
    }
    XR(t, i) {
      const e = t.memberParts;
      for (; e.next(); ) {
        const s = e.value;
        s instanceof Node2 && this.$f(s, i);
      }
    }
    get duration() {
      return this.Yo;
    }
    set duration(t) {
      U.i(t, "number", Animation2, "duration"), t < 1 && U.G(t, ">= 1", Animation2, "duration"), this.Yo = t;
    }
    get reversible() {
      return this.$u;
    }
    set reversible(t) {
      this.$u = t;
    }
    get runCount() {
      return this.l1;
    }
    set runCount(t) {
      t > 0 ? this.l1 = t : U.n("Animation.runCount value must be a positive integer.");
    }
    get finished() {
      return this.Ju;
    }
    set finished(t) {
      this.Ju !== t && (t !== null && U.C(t, Animation2, "finished"), this.Ju = t);
    }
    get easing() {
      return this.s1;
    }
    set easing(t) {
      this.s1 = t;
    }
    get isViewportUnconstrained() {
      return this.BM;
    }
    set isViewportUnconstrained(t) {
      this.BM = t;
    }
    get isAnimating() {
      return this.Ii;
    }
    getTemporaryState(t) {
      let i = this.o1.get(t);
      return i === null && (i = {}, this.o1.set(t, i)), i;
    }
    static EaseLinear = (t, i, e, s) => e * t / s + i;
    static EaseInOutQuad = (t, i, e, s) => (t /= s / 2, t < 1 ? e / 2 * t * t + i : -e / 2 * (--t * (t - 2) - 1) + i);
    static EaseInQuad = (t, i, e, s) => e * (t /= s) * t + i;
    static EaseOutQuad = (t, i, e, s) => -e * (t /= s) * (t - 2) + i;
    static EaseInExpo = (t, i, e, s) => t === 0 ? i : e * Math.pow(2, 10 * (t / s - 1)) + i;
    static EaseOutExpo = (t, i, e, s) => t === s ? i + e : e * (-Math.pow(2, -10 * t / s) + 1) + i;
  }
  class AnimationState {
    ci;
    Ds;
    f1;
    u1;
    c1;
    constructor(t, i, e) {
      this.ci = t, this.Ds = i, this.f1 = {}, this.u1 = e, this.c1 = false;
    }
  }
  var TriggerStart2 = ((w) => (w[w.Default = 1] = "Default", w[w.Immediate = 2] = "Immediate", w[w.Bundled = 3] = "Bundled", w))(TriggerStart2 || {});
  class AnimationTrigger2 {
    Re;
    kn;
    Qu;
    _f;
    constructor(t, i, e) {
      e && Debug && U.W(e, TriggerStart2, "TriggerStart"), this.Re = null, this.kn = t, this.Qu = e || 1, this._f = null, i !== void 0 && (this._f = i, e === void 0 && (this.Qu = 2));
    }
    copy() {
      const t = new AnimationTrigger2(this.kn);
      t.Qu = this.Qu;
      const i = this._f;
      if (i !== null) {
        const e = {};
        i.duration !== void 0 && (e.duration = i.duration), i.finished !== void 0 && (e.finished = i.finished), i.easing !== void 0 && (e.easing = i.easing), t._f = e;
      }
      return t;
    }
    get propertyName() {
      return this.kn;
    }
    set propertyName(t) {
      this.kn = t;
    }
    get animationSettings() {
      return this._f;
    }
    set animationSettings(t) {
      this._f = t;
    }
    YR(t) {
      const i = this._f;
      i !== null && (i.duration && (t.duration = i.duration), i.finished && (t.finished = i.finished), i.easing && (t.easing = i.easing));
    }
    get startCondition() {
      return this.Qu;
    }
    set startCondition(t) {
      Debug && U.W(t, TriggerStart2, "TriggerStart"), this.Qu = t;
    }
    static Default = 1;
    static Immediate = 2;
    static Bundled = 3;
  }
  class Layer2 {
    f;
    At;
    ei;
    Vr;
    Wl;
    jl;
    Jl;
    $l;
    Zl;
    Ql;
    _l;
    th;
    ih;
    eh;
    nh;
    oh;
    qf;
    lh;
    g1;
    t0;
    _u;
    Ft;
    constructor(t) {
      GSet2._i(this), this.f = null, this.Ft = new List2(), this.At = "", this.ei = 1, this.Vr = false, this.Wl = true, this.jl = true, this.Jl = true, this.$l = true, this.Zl = true, this.Ql = true, this._l = true, this.th = true, this.ih = true, this.eh = true, this.nh = true, this.oh = true, this.qf = true, this.lh = true, this.g1 = true, this.t0 = false, this._u = [], t && Object.assign(this, t);
    }
    KR() {
      const t = this.Ft;
      for (let i = 0; i < t.length; i++) t.h[i].YM(null);
      t.clear(), this._u.length = 0;
    }
    Ko(t) {
      this.f = t;
    }
    toString(t) {
      t === void 0 && (t = 0);
      const i = 'Layer "' + this.name + '"';
      if (t <= 0) return i;
      let e = 0, s = 0, n = 0, o = 0, r = 0;
      const l = this.Ft.iterator;
      for (; l.next(); ) {
        const f = l.value;
        f instanceof Group2 ? n++ : f instanceof Node2 ? s++ : f instanceof Link2 ? o++ : f instanceof Adornment2 ? r++ : e++;
      }
      let h = "";
      if (e > 0 && (h += e + " Parts "), s > 0 && (h += s + " Nodes "), n > 0 && (h += n + " Groups "), o > 0 && (h += o + " Links "), r > 0 && (h += r + " Adornments "), t > 1) {
        const f = this.Ft.iterator;
        for (; f.next(); ) {
          const a = f.value;
          h += `
    ` + a.toString();
          const c = a.data;
          c !== null && GSet2.Ps(c) && (h += " #" + GSet2.Ps(c)), a instanceof Node2 ? h += " " + U.toString(c) : a instanceof Link2 && (h += " " + U.toString(a.fromNode) + " " + U.toString(a.toNode));
        }
      }
      return i + " " + this.Ft.count + ": " + h;
    }
    findObjectAt(t, i, e) {
      if (i === void 0 && (i = null), e === void 0 && (e = null), this.lh === false) return null;
      Debug && !t.isReal() && U.n("findObjectAt: Point must have a real value, not: " + t.toString());
      let s = false;
      this.diagram !== null && this.diagram.viewportBounds.containsPoint(t) && (s = true);
      const n = Point2.a(), o = this.Ft.h, r = o.length;
      for (let l = r; l--; ) {
        const h = o[l];
        if (s === true && h.Kl() === false || !h.isVisible()) continue;
        n.c(t), n.je(h._s);
        let f = h.GT(n, i, e);
        if (f !== null && (i !== null && (f = i(f)), f !== null && (e === null || e(f)))) return Point2.o(n), f;
      }
      return Point2.o(n), null;
    }
    findObjectsAt(t, i, e, s) {
      if (i === void 0 && (i = null), e === void 0 && (e = null), !(s instanceof List2) && !(s instanceof GSet2) && (s = new GSet2()), this.lh === false) return s;
      Debug && !t.isReal() && U.n("findObjectsAt: Point must have a real value, not: " + t.toString());
      let n = false;
      this.diagram !== null && this.diagram.viewportBounds.containsPoint(t) && (n = true);
      const o = Point2.a(), r = this.Ft.h, l = r.length;
      for (let h = l; h--; ) {
        const f = r[h];
        if (n === true && f.Kl() === false || !f.isVisible()) continue;
        o.c(t), o.je(f._s);
        let a = f;
        f.qT(o, i, e, s) && (i !== null && (a = i(a)), a !== null && (e === null || e(a)) && s.add(a));
      }
      return Point2.o(o), s;
    }
    findObjectsIn(t, i, e, s, n) {
      if (i === void 0 && (i = null), e === void 0 && (e = null), s === void 0 && (s = false), !(n instanceof List2) && !(n instanceof GSet2) && (n = new GSet2()), this.lh === false) return n;
      Debug && !t.isReal() && U.n("findObjectsIn: Rect must have a real value, not: " + t.toString());
      let o = false;
      this.diagram !== null && this.diagram.viewportBounds.containsRect(t) && (o = true);
      const r = this.Ft.h, l = r.length;
      for (let h = l; h--; ) {
        const f = r[h];
        if (o === true && f.Kl() === false || !f.isVisible()) continue;
        let a = f;
        f.i0(t, i, e, s, n) && (i !== null && (a = i(a)), a !== null && (e === null || e(a)) && n.add(a));
      }
      return n;
    }
    LP(t, i, e, s, n, o, r) {
      if (this.lh === false) return n;
      const l = this.Ft.h, h = l.length;
      for (let f = h; f--; ) {
        const a = l[f];
        if (r === true && a.Kl() === false || !o(a) || !a.isVisible()) continue;
        let c = a;
        a.i0(t, i, e, s, n) && (i !== null && (c = i(c)), c !== null && (e === null || e(c)) && n.add(c));
      }
      return n;
    }
    findObjectsNear(t, i, e, s, n, o) {
      if (e === void 0 && (e = null), s === void 0 && (s = null), n === void 0 && (n = true), n !== false && n !== true && ((n instanceof List2 || n instanceof GSet2) && (o = n), n = true), !(o instanceof List2) && !(o instanceof GSet2) && (o = new GSet2()), this.lh === false) return o;
      Debug && !t.isReal() && U.n("findObjectsNear: Point must have a real value, not: " + t.toString());
      let r = false;
      this.diagram !== null && this.diagram.viewportBounds.containsPoint(t) && (r = true);
      const l = Point2.a(), h = Point2.a(), f = this.Ft.h, a = f.length;
      for (let c = a; c--; ) {
        const u = f[c];
        if (r === true && u.Kl() === false || !u.isVisible()) continue;
        l.c(t), l.je(u._s), h.e(t.x + i, t.y), h.je(u._s);
        let d = u;
        u.HT(l, h, e, s, n, o) && (e !== null && (d = e(d)), d !== null && (s === null || s(d)) && o.add(d));
      }
      return Point2.o(l), Point2.o(h), o;
    }
    KM() {
      return this.Ft.h;
    }
    Is(t, i) {
      if (!this.visible) return;
      const e = this.Ft.h, s = e.length;
      if (s === 0) return;
      const n = U.ft(), o = U.ft();
      for (let r = 0; r < s; r++) {
        const l = e[r];
        if (l.UM = r, l instanceof Link2) {
          if (l.Be === false) continue;
        } else if (l instanceof Adornment2 && l.adornedPart !== null) continue;
        const h = l.actualBounds;
        l.isVisible() && h.KA(i, 10) ? (l.Is(true), n.push(l)) : (l.Is(false), l.adornments !== null && l.adornments.count > 0 && o.push(l));
      }
      for (let r = 0; r < n.length; r++) {
        const l = n[r];
        l.GM();
        const h = l.adornments;
        for (; h.next(); ) {
          const f = h.value;
          f.gt(1 / 0, 1 / 0), f.Ut(), f.Is(true);
        }
      }
      for (let r = 0; r < o.length; r++) o[r].GM();
      U.et(n), U.et(o);
    }
    td(t) {
      let i = 1;
      return this.ei !== 1 && (i = t.globalAlpha, t.globalAlpha = i * this.ei), i;
    }
    vT(t, i) {
      for (let e = 0; e < i; e++) t[e].tc();
    }
    vi(t, i, e) {
      if (!this.visible || this.ei === 0 || (e === void 0 && (e = true), !e && this.isTemporary)) return;
      const s = this.Ft.h, n = s.length;
      if (n === 0) return;
      t.Vr && this.vT(s, n);
      const o = this.td(t), r = this._u;
      r.length = 0;
      const l = i.scale, h = Rect2.a();
      for (let f = 0; f < n; f++) {
        const a = s[f];
        this.e0(t, a, i, r, l, h, true);
      }
      Rect2.o(h), t.Vr && this.vT(s, n), t.globalAlpha = o;
    }
    EB(t, i, e) {
      if (!this.visible || this.ei === 0) return;
      const s = this.Ft.h, n = s.length;
      if (n === 0) return;
      const o = this.td(t), r = this._u;
      r.length = 0;
      const l = i.scale, h = Rect2.a();
      for (let f = 0; f < n; f++) {
        const a = s[f];
        e.has(a) || this.e0(t, a, i, r, l, h, true);
      }
      Rect2.o(h), t.globalAlpha = o;
    }
    UR(t, i, e, s) {
      if (!this.visible || this.ei === 0 || !s && this.isTemporary) return;
      const n = this.Ft.h, o = n.length;
      if (o === 0) return;
      const r = this.td(t), l = this._u;
      l.length = 0;
      const h = i.scale, f = Rect2.a();
      for (let a = 0; a < o; a++) {
        const c = n[a];
        e.has(c) && this.e0(t, c, i, l, h, f, false);
      }
      Rect2.o(f), t.globalAlpha = r;
    }
    GR(t, i, e, s, n) {
      if (!this.visible || this.opacity === 0) return;
      const o = this.diagram.grid.part;
      if (!s && this.isTemporary) {
        if (n && o.layer === this) {
          const r = this.td(t);
          o.vi(t, e), t.globalAlpha = r;
        }
      } else {
        const r = this.td(t), l = e.scale, h = Rect2.a(), f = this.Ft.h, a = f.length;
        for (let c = 0; c < a; c++) {
          const u = f[c];
          !n && u === o || this.e0(t, u, e, null, l, h, false);
        }
        Rect2.o(h), t.globalAlpha = r;
      }
    }
    BB(t, i, e) {
      if (!this.visible || this.ei === 0) return;
      const s = this.td(t), n = this._u;
      n.length = 0;
      const o = i.scale, r = Rect2.a(), l = this.Ft.h, h = l.length, f = e.length;
      for (let a = 0; a < h; a++) {
        const c = l[a], u = c.ua(c.actualBounds);
        this.qR(u, e, f, o) && this.e0(t, c, i, n, o, r, true);
      }
      Rect2.o(r), t.globalAlpha = s;
    }
    e0(t, i, e, s, n, o, r) {
      if (r && !i.Kl()) {
        t.removePartFromView(i);
        return;
      }
      if (s !== null && i instanceof Link2 && (i.isOrthogonal && s.push(i), i.Be === false)) {
        t.removePartFromView(i);
        return;
      }
      let l = false, h = i.containingGroup;
      for (; h !== null; ) l ? h.ui !== null && o.intersectRect(h.ui) : h.ui !== null && (l = true, o.c(h.ui)), h = h.containingGroup;
      const f = i.actualBounds;
      let a = false;
      if (l && i.isVisible()) {
        if (!o.intersectsRect(f)) {
          t.removePartFromView(i);
          return;
        }
        a = !o.containsRect(f);
      }
      a && (t.save(), t instanceof SVGContext ? t.partClipRect = o.copy() : (t.beginPath(), t.rect(o.x, o.y, o.width, o.height), t.clip())), f.width * n > e.s0 || f.height * n > e.s0 ? i.vi(t, e) : this.HR(t, i, e), a && (t.restore(), t.clearContextCache(true));
    }
    HR(t, i, e) {
      if (t instanceof SVGContext) {
        i.vi(t, e);
        return;
      }
      const s = i.actualBounds, n = i.naturalBounds;
      if (s.width === 0 || s.height === 0 || isNaN(s.x) || isNaN(s.y) || !i.isVisible()) return;
      const o = i.E;
      if (i.background === null) {
        i.Cn(t, "rgba(0,0,0,0.3)", true, false, n, s), t.fillRect(s.x, s.y, s.width, s.height);
        return;
      }
      if (t.transform(o.m11, o.m12, o.m21, o.m22, o.dx, o.dy), i.Cn(t, i.background, true, false, n, s), t.fillRect(0, 0, n.width / 2, n.height / 2), !o.Xk()) {
        const r = 1 / (o.m11 * o.m22 - o.m12 * o.m21);
        t.transform(o.m22 * r, -o.m12 * r, -o.m21 * r, o.m11 * r, r * (o.m21 * o.dy - o.m22 * o.dx), r * (o.m12 * o.dx - o.m11 * o.dy));
      }
    }
    qR(t, i, e, s) {
      const n = 2 / s, o = 4 / s;
      for (let r = 0; r < e; r++) {
        const l = i[r];
        if (!(l.width === 0 || l.height === 0) && t.intersects(l.x - n, l.y - n, l.width + o, l.height + o)) return true;
      }
      return false;
    }
    t(t, i, e, s, n) {
      const o = this.diagram;
      o !== null && o.raiseChangedEvent(2, t, this, i, e, s, n);
    }
    da(t, i, e) {
      const s = this.Ft;
      if (i.YM(this), t >= s.count) t = s.count;
      else if (s.elt(t) === i) return -1;
      s.insertAt(t, i), i.o0(e);
      const n = this.diagram;
      return n !== null && (e ? n.L() : n.da(i)), this.m1(t, i), t;
    }
    ae(t, i, e) {
      if (!e && i.layer !== this && i.layer !== null) return i.layer.ae(t, i, e);
      const s = this.Ft;
      if (t < 0 || t >= s.length) {
        if (t = s.indexOf(i), t < 0) return -1;
      } else if (s.elt(t) !== i && (t = s.indexOf(i), t < 0)) return -1;
      i.r0(e), s.removeAt(t);
      const n = this.diagram;
      return n !== null && (e ? n.L() : n.ae(i)), i.YM(null), t;
    }
    m1(t, i) {
      t = this.vR(t, i), i instanceof Group2 && this.WR(t, i), i.svg !== null && i.svg.remove();
    }
    vR(t, i) {
      const e = i.zOrder;
      if (isNaN(e)) return t;
      const s = this.Ft, n = s.count;
      if (n <= 1) return t;
      if (t < 0 && (t = s.indexOf(i)), t < 0) return -1;
      let o = t - 1, r = NaN;
      for (; o >= 0 && (r = s.elt(o).zOrder, !!isNaN(r)); ) o--;
      let l = t + 1, h = NaN;
      for (; l < n && (h = s.elt(l).zOrder, !!isNaN(h)); ) l++;
      if (!isNaN(r) && r > e) for (; ; ) {
        if (o === -1 || r <= e) return o++, o === t ? t : (s.removeAt(t), s.insertAt(o, i), o);
        for (r = NaN; --o >= 0 && (r = s.elt(o).zOrder, !!isNaN(r)); ) ;
      }
      else if (!isNaN(h) && h < e) for (; ; ) {
        if (l === n || h >= e) return l--, l === t ? t : (s.removeAt(t), s.insertAt(l, i), l);
        for (h = NaN; ++l < n && (h = s.elt(l).zOrder, !!isNaN(h)); ) ;
      }
      return t;
    }
    WR(t, i) {
      if (i === null || !isNaN(i.zOrder)) return;
      this.jR(t, i);
      const e = i.containingGroup;
      e !== null && this.m1(-1, e);
    }
    jR(t, i) {
      if (i.memberParts.count === 0) return;
      let e = -1;
      const s = this.Ft.h, n = s.length;
      for (let o = 0; o < n; o++) {
        const r = s[o];
        if (r === i && (t = o, e >= 0) || e < 0 && r.containingGroup === i && (e = o, t >= 0)) break;
      }
      if (!(e < 0) && e < t) {
        const o = this.Ft;
        o.removeAt(t), o.insertAt(e, i);
      }
    }
    get parts() {
      return this.Ft.iterator;
    }
    get partsBackwards() {
      return this.Ft.iteratorBackwards;
    }
    get diagram() {
      return this.f;
    }
    get name() {
      return this.At;
    }
    set name(t) {
      U.i(t, "string", Layer2, "name");
      const i = this.At;
      if (i !== t) {
        const e = this.diagram;
        if (e !== null) {
          i === "" && U.n("Cannot rename default Layer to: " + t);
          const n = e.layers;
          for (; n.next(); ) n.value.name === t && U.n("Layer.name is already present in this diagram: " + t);
        }
        this.At = t, this.t("name", i, t);
        const s = this.Ft.iterator;
        for (; s.next(); ) {
          const n = s.value;
          n.layerName = this.At;
        }
      }
    }
    get opacity() {
      return this.ei;
    }
    set opacity(t) {
      const i = this.ei;
      if (i !== t) {
        U.i(t, "number", Layer2, "opacity"), (t < 0 || t > 1) && U.G(t, "0 <= value <= 1", Layer2, "opacity"), this.ei = t;
        const e = this.diagram;
        e !== null && e.L(), this.t("opacity", i, t);
      }
    }
    get isViewportAligned() {
      return this.t0;
    }
    set isViewportAligned(t) {
      const i = this.t0;
      i !== t && (this.t0 = t, this.diagram && (this.WT(), this.diagram.L()), this.t("isViewportAligned", i, t), t && (this.isInDocumentBounds = false));
    }
    WT() {
      if (!this.t0) return;
      const t = this.diagram;
      if (t === null) return;
      const i = this.Ft.h, e = i.length, s = t.Pt, n = t.Mt;
      for (let o = 0; o < e; o++) {
        const r = i[o], l = r.naturalBounds.width, h = r.naturalBounds.height;
        let f = r.alignment;
        (f.isDefault() || !f.isSpot()) && (f = Spot2.BottomRight);
        let a = r.alignmentFocus;
        a.isDefault() && (a = new Spot2(f.x, f.y));
        const c = f.x * s + f.offsetX - (a.x * l + a.offsetX), u = f.y * n + f.offsetY - (a.y * h + a.offsetY), d = Point2.U(c, u);
        t.JR(d), r.Gf(d.x, d.y, true), Point2.o(d), r.lt = 1 / t.scale;
      }
    }
    get isTemporary() {
      return this.Vr;
    }
    set isTemporary(t) {
      const i = this.Vr;
      i !== t && (U.i(t, "boolean", Layer2, "isTemporary"), this.Vr = t, this.t("isTemporary", i, t));
    }
    get visible() {
      return this.qf;
    }
    set visible(t) {
      const i = this.qf;
      if (i !== t) {
        U.i(t, "boolean", Layer2, "visible"), this.qf = t;
        const e = this.Ft.iterator;
        for (; e.next(); ) e.value.Hi(t);
        const s = this.diagram;
        s !== null && s.L(), this.t("visible", i, t);
      }
    }
    get pickable() {
      return this.lh;
    }
    set pickable(t) {
      const i = this.lh;
      i !== t && (U.i(t, "boolean", Layer2, "pickable"), this.lh = t, this.t("pickable", i, t));
    }
    get isInDocumentBounds() {
      return this.g1;
    }
    set isInDocumentBounds(t) {
      const i = this.g1;
      i !== t && (this.g1 = t, this.diagram !== null && this.diagram.invalidateDocumentBounds(), this.t("isInDocumentBounds", i, t));
    }
    get allowCopy() {
      return this.Wl;
    }
    set allowCopy(t) {
      const i = this.Wl;
      i !== t && (U.i(t, "boolean", Layer2, "allowCopy"), this.Wl = t, this.t("allowCopy", i, t));
    }
    get allowDelete() {
      return this.jl;
    }
    set allowDelete(t) {
      const i = this.jl;
      i !== t && (U.i(t, "boolean", Layer2, "allowDelete"), this.jl = t, this.t("allowDelete", i, t));
    }
    get allowTextEdit() {
      return this.Jl;
    }
    set allowTextEdit(t) {
      const i = this.Jl;
      i !== t && (U.i(t, "boolean", Layer2, "allowTextEdit"), this.Jl = t, this.t("allowTextEdit", i, t));
    }
    get allowGroup() {
      return this.$l;
    }
    set allowGroup(t) {
      const i = this.$l;
      i !== t && (U.i(t, "boolean", Layer2, "allowGroup"), this.$l = t, this.t("allowGroup", i, t));
    }
    get allowUngroup() {
      return this.Zl;
    }
    set allowUngroup(t) {
      const i = this.Zl;
      i !== t && (U.i(t, "boolean", Layer2, "allowUngroup"), this.Zl = t, this.t("allowUngroup", i, t));
    }
    get allowLink() {
      return this.Ql;
    }
    set allowLink(t) {
      const i = this.Ql;
      i !== t && (U.i(t, "boolean", Layer2, "allowLink"), this.Ql = t, this.t("allowLink", i, t));
    }
    get allowRelink() {
      return this._l;
    }
    set allowRelink(t) {
      const i = this._l;
      i !== t && (U.i(t, "boolean", Layer2, "allowRelink"), this._l = t, this.t("allowRelink", i, t));
    }
    get allowMove() {
      return this.th;
    }
    set allowMove(t) {
      const i = this.th;
      i !== t && (U.i(t, "boolean", Layer2, "allowMove"), this.th = t, this.t("allowMove", i, t));
    }
    get allowReshape() {
      return this.ih;
    }
    set allowReshape(t) {
      const i = this.ih;
      i !== t && (U.i(t, "boolean", Layer2, "allowReshape"), this.ih = t, this.t("allowReshape", i, t));
    }
    get allowResize() {
      return this.eh;
    }
    set allowResize(t) {
      const i = this.eh;
      i !== t && (U.i(t, "boolean", Layer2, "allowResize"), this.eh = t, this.t("allowResize", i, t));
    }
    get allowRotate() {
      return this.nh;
    }
    set allowRotate(t) {
      const i = this.nh;
      i !== t && (U.i(t, "boolean", Layer2, "allowRotate"), this.nh = t, this.t("allowRotate", i, t));
    }
    get allowSelect() {
      return this.oh;
    }
    set allowSelect(t) {
      const i = this.oh;
      i !== t && (U.i(t, "boolean", Layer2, "allowSelect"), this.oh = t, this.t("allowSelect", i, t));
    }
  }
  var AutoScale2 = ((w) => (w[w.None = 1] = "None", w[w.Uniform = 2] = "Uniform", w[w.UniformToFill = 3] = "UniformToFill", w))(AutoScale2 || {}), CycleMode2 = ((w) => (w[w.All = 1] = "All", w[w.NotDirected = 2] = "NotDirected", w[w.NotDirectedFast = 3] = "NotDirectedFast", w[w.NotUndirected = 4] = "NotUndirected", w[w.DestinationTree = 5] = "DestinationTree", w[w.SourceTree = 6] = "SourceTree", w))(CycleMode2 || {}), ScrollMode2 = ((w) => (w[w.Document = 1] = "Document", w[w.Infinite = 2] = "Infinite", w))(ScrollMode2 || {}), CollapsePolicy2 = ((w) => (w[w.TreeParent = 1] = "TreeParent", w[w.AllParents = 2] = "AllParents", w[w.AnyParents = 3] = "AnyParents", w))(CollapsePolicy2 || {});
  class Diagram2 {
    Ls;
    Qt;
    qM;
    p1;
    zr;
    ed;
    w1;
    b1;
    S1;
    k1;
    P1;
    M1;
    ga;
    ca;
    N1;
    C1;
    A1;
    hh;
    ic;
    Xr;
    l0;
    T1;
    L1;
    sd;
    oo;
    Yr;
    ma;
    Go;
    h0;
    ec;
    a0;
    sc;
    nd;
    Kr;
    ro;
    HM;
    vM;
    D1;
    F1;
    WM;
    I1;
    jM;
    JM;
    $M;
    R1;
    f0;
    Ur;
    Gr;
    qr;
    Hr;
    vr;
    Wr;
    O1;
    jr;
    E1;
    Jr;
    $r;
    Zr;
    Qr;
    B1;
    ZM;
    qo;
    QM;
    V1;
    z1;
    _M;
    Di;
    t2;
    nc;
    i2;
    $s;
    Ho;
    Gi;
    X1;
    Wl;
    jl;
    Y1;
    K1;
    Jl;
    $l;
    Zl;
    U1;
    Ql;
    _l;
    th;
    ih;
    eh;
    nh;
    oh;
    G1;
    q1;
    e2;
    od;
    rd;
    H1;
    v1;
    W1;
    j1;
    c0;
    J1;
    $1;
    Z1;
    si;
    jT;
    Q1;
    JT;
    ld;
    An;
    lo;
    fe;
    ho;
    $T;
    ah;
    s2;
    o2;
    u0;
    _1;
    hd;
    d0;
    tb;
    _r;
    fh;
    pa;
    l2;
    h2;
    g0;
    ib;
    eb;
    cs;
    ad;
    m0;
    fd;
    vo;
    oc;
    p0;
    tl;
    ya;
    a2;
    y0;
    $t;
    E;
    Ze;
    Er;
    Wi;
    Rs;
    f2;
    ch;
    il;
    Bl;
    el;
    wa;
    rc;
    c2;
    cd;
    xa;
    ud;
    Ht;
    uh;
    yt;
    lt;
    dd;
    Pt;
    Mt;
    ht;
    lc;
    Fx;
    sb;
    ba;
    hc;
    nb;
    ob;
    w0;
    $R;
    ZR;
    te;
    zl;
    s0;
    x0;
    u2;
    d2;
    ZT;
    b0;
    QR;
    _R;
    tO;
    rb;
    iO;
    eO;
    sO;
    Sa;
    QT;
    dh;
    ka;
    Pa;
    Ma;
    Na;
    Uu;
    aa;
    _t;
    Tt;
    ac;
    Qk;
    _k;
    Vf;
    ei;
    static lb = null;
    static _T = new GMap2();
    static g2;
    static m2 = null;
    Ku;
    hb;
    ab;
    gd;
    fb;
    cb;
    S0;
    p2;
    k0;
    P0;
    M0;
    _x;
    w2;
    b2;
    fc;
    N0;
    C0;
    constructor(t, i) {
      if (Diagram2.Zw || (Diagram2.Yk(), Diagram2.Zw = true), GSet2._i(this), Diagram2.tL(this), this.$t = true, this.Tt = null, this.Pt = 0, this.Mt = 0, this.ht = null, Diagram2.isUsingDOM()) {
        const s = this, n = () => {
          s.Fi(root.document, "DOMContentLoaded", n, false), s.setRTL();
        };
        root.document.body !== null ? this.setRTL() : s.Kt(root.document, "DOMContentLoaded", n, false);
      }
      this.lc = null, Diagram2.S2("Model", PartManager);
      const e = this;
      return this.t2 = (s) => e.partManager.doModelDataChanged(s), this.nc = (s) => e.partManager.doModelChanged(s), this.nb = null, this.ob = null, this.iL(), this.model = Model2.k2(), this.themeManager = new ThemeManager2(), this.qo = true, this.eL(), this.layout = new Layout2(), this.qo = false, this.QR = null, this._R = null, this.tO = null, this.rb = null, this.iO = null, this.eO = null, this.sO = null, this.Sa = null, this.QT = null, this.dh = null, this.ka = null, this.Pa = null, this.Ma = null, this.Na = null, this.Uu = () => {
      }, this.aa = null, this.fd = false, this.ac = new DiagramHelper(this), t !== void 0 && (typeof t == "string" || root.Element && t instanceof Element ? this.P2(t) : i = t), i && this.setProperties(i), this.$t = false, this.requestUpdate(), this;
    }
    gR() {
      return this.ht !== null;
    }
    get renderer() {
      return this.oc;
    }
    set renderer(t) {
      if (this instanceof Overview2) return;
      t === "" && (t = "default");
      const i = t.toLowerCase(), e = this.oc;
      if (i === e) return;
      this.oc = i;
      let s = null;
      i === "default" || i === "canvas" ? (s = this.vo.get("svg"), s !== null && s.Nt.remove(), this.ht && (this._t = this.ht.ni), this._t.clearContextCache(true)) : i === "svg" ? (this.vo.has("svg") ? s = this.vo.get("svg") : (s = new SVGSurface(this, root.document), this.addRenderer("svg", s)), this.div !== null && (s.Nt.role = "img", this.div.appendChild(s.Nt)), this._t = s.ni, this.ht && (this.ht.ni.setTransform(this.te, 0, 0, this.te, 0, 0), this.ht.ni.clearRect(0, 0, this.Pt, this.Mt))) : i === "debug" && (this.vo.has("SVG") || (s = new SVGSurface(this, root.document), this.addRenderer("SVG", s), s.Nt.style.backgroundColor = "whitesmoke", this.div !== null && this.div.after(s.Nt))), this.$t || this.redraw();
    }
    iL() {
      if (this.fc = new List2(), this.setupRouters(), this.Ls = new AnimationManager2(), this.Ls.Ko(this), this.Qt = 17, this.qM = false, this.dd = false, this.p1 = "default", this.Ht = new List2(), this.vo) {
        const t = this.vo.get("svg");
        t !== null && t.Nt.remove(), this.ht && (this._t = this.ht.ni, this._t.clearContextCache(true));
      }
      this.vo = new GMap2(), this.oc = "default", this.resetRenderingHints(), this.nO(), this.ei = 1, this.yt = new Point2(NaN, NaN).S(), this._x = new Point2(NaN, NaN), this.lt = 1, this.y0 = 1, this.w1 = new Point2(NaN, NaN).S(), this.b1 = NaN, this.S1 = 1e-4, this.k1 = 100, this.E = new Transform(), this.P1 = new Point2(NaN, NaN).S(), this.M1 = new Rect2(NaN, NaN, NaN, NaN).S(), this.ga = new Margin2(0, 0, 0, 0).Ct(), this.ca = 1, this.N1 = false, this.C1 = null, this.A1 = null, this.hh = 1, this.ic = Spot2.Default, this.Xr = 1, this.l0 = Spot2.Default, this.T1 = Spot2.None, this.L1 = Spot2.None, this.Ze = true, this.sd = false, this.oo = /* @__PURE__ */ new Set(), this.Yr = new GSet2(), this.ma = new GSet2(), this.Go = false, this.uh = new GMap2(), this.cd = true, this.h0 = 250, this.ec = -1, this.a0 = new Margin2(16, 16, 16, 16).Ct(), this.Er = false, this.sc = false, this.nd = true, this.p0 = new InputEvent2(), this.p0.diagram = this, this.tl = new InputEvent2(), this.tl.diagram = this, this.ya = new InputEvent2(), this.ya.diagram = this, this.Kr = null, this.ro = null, this.Fx = false, this.oO(), this.el = new GSet2(), this.D1 = true, this.F1 = 1, this.WM = false, this.I1 = 1, this.R1 = "auto", this.f0 = "auto", this.Ur = null, this.Gr = null, this.qr = null, this.Hr = null, this.vr = null, this.Wr = null, this.O1 = null, this.jr = null, this.E1 = false, this.Jr = null, this.$r = null, this.Zr = null, this.Qr = null, this.B1 = false, this.sb = {}, this.ba = [null, null], this.qo = false, this.QM = false, this.V1 = false, this.z1 = false, this._M = true, this.Rs = false, this.xa = false, this.i2 = true, this.$s = -2, this.ch = new GMap2(), this.ud = new List2(), this.Ho = false, this.Gi = true, this.X1 = true, this.Wl = true, this.jl = true, this.Y1 = false, this.K1 = true, this.Jl = true, this.$l = true, this.Zl = true, this.U1 = true, this.Ql = true, this._l = true, this.th = true, this.ih = true, this.eh = true, this.nh = true, this.oh = true, this.G1 = true, this.q1 = true, this.e2 = false, this.hc = false, this.od = true, this.rd = true, this.H1 = true, this.v1 = true, this.W1 = 16, this.j1 = 16, this.c0 = false, this.J1 = false, this.$1 = 0, this.Z1 = 0, this.si = new Margin2(5).Ct(), this.jT = new GSet2().S(), this.Q1 = 999999999, this.JT = new GSet2().S(), this.wa = true, this.ld = true, this.rc = true, this.An = false, this.lo = false, this.il = true, this.Bl = false, this.ho = false, this.$T = new GSet2(), this.c2 = new GSet2(), this.ah = null, this.s2 = new Size2(Link2.sL, Link2.nL), this.o2 = 999, this.u0 = false, this.Qk = 1, this._k = 0, this.Wi = { scale: 1, position: new Point2(), bounds: new Rect2(), canvasSize: new Size2(), newCanvasSize: new Size2(), isScroll: false }, this.Wi.canvasSize = this.Wi.canvasSize, this.Wi.newCanvasSize = this.Wi.newCanvasSize, this.Wi.isScroll = false, this._1 = new Rect2(NaN, NaN, NaN, NaN).S(), this.hd = new Size2(NaN, NaN).S(), this.d0 = new Rect2(NaN, NaN, NaN, NaN).S(), this.tb = false, this.N0 = null, this.C0 = null, this.rO(), this.cs = null, this.ad = false, this.Vf = null, this.partManager = new PartManager(), this.toolManager = new ToolManager2(), this.toolManager.initializeStandardTools(), this.defaultTool = this.toolManager, this.currentTool = this.defaultTool, this.ab = null, this.gd = new DraggingOptions2(), this.fb = null, this.cb = null, this.hb = false, this.Ku = false, this.commandHandler = new CommandHandler2(), this.P0 = null, this.M0 = Point2.xn, this.w2 = false, this.te = 1, this.zl = null, this.s0 = 1, this.S0 = 0, this.p2 = [0, 0, 0, 0, 0], this.k0 = 0, this.x0 = 1, this.u2 = 0, this.d2 = new Point2(), this.ZT = 500, this.m0 = new Point2(), this.b0 = false;
    }
    static oL = root.document !== void 0;
    static isUsingDOM() {
      return Diagram2.oL;
    }
    static useDOM(t) {
      Diagram2.oL = t ? root.document !== void 0 : false;
    }
    static Qe = /* @__PURE__ */ new WeakMap();
    clear() {
      this.animationManager.stopAnimation(), this.model.clear(), Diagram2.rL(), this.lL(false), this.ud.clear(), this.hL(), this.ah = null, this.invalidateDocumentBounds(), this.ensureBounds(), this.L();
    }
    lL(t) {
      this.animationManager.stopAnimation(true), this.clearSelection(), this.clearHighlighteds();
      const i = this.skipsUndoManager, e = this.Di !== null && this.Di !== void 0;
      e && (this.skipsUndoManager = true);
      let s = null;
      this.cs !== null && (s = this.cs.part, s !== null && this.remove(s));
      const n = [], o = this.Ht.length;
      if (t) {
        for (let r = 0; r < o; r++) {
          const h = this.Ht.h[r].parts;
          for (; h.next(); ) {
            const f = h.value;
            f !== s && f.data === null && n.push(f);
          }
        }
        for (let r = 0; r < n.length; r++) {
          const l = n[r];
          this.remove(l);
        }
      }
      for (let r = 0; r < o; r++) this.Ht.h[r].KR();
      return this.partManager.clear(), this.oo.clear(), this.Yr.clear(), this.ma.clear(), this.uh.clear(), this.el.clear(), this.Vf = null, this.ud.clear(), this.hL(), U.Ok = [], s !== null && (this.add(s), this.partManager.parts.delete(s)), e && (this.skipsUndoManager = i), n;
    }
    static A0 = null;
    static ub = "";
    static rL() {
      Diagram2.A0 = null, Diagram2.ub = "";
    }
    static VB() {
      return null;
    }
    reset() {
      this.clear(), this.$t = true, this.iL(), this.themeManager = new ThemeManager2(), this.gh(), this.qo = true, this.eL(), this.layout = new Layout2(), this.qo = false, this.model = Model2.k2(), this.model.undoManager = new UndoManager2(), this.fd = false, this.$t = false, this.L();
    }
    rO() {
      this._r = new GMap2(), this.l2 = new Node2().add(new TextBlock2({ stroke: "black", font: "10pt sans-serif" }).bind("text", "", U.toString).theme("stroke", "text").theme("font", "normal")), this._r.set("", this.l2), this._r.set("Comment", new Node2().add(new TextBlock2({ stroke: "brown", font: "10pt sans-serif" }).bind("text", "", U.toString).theme("stroke", "comment").theme("font", "normal"))), this._r.set("LinkLabel", new Node2({ selectable: false, avoidable: false }).add(new Shape2("Ellipse", { fill: "black", stroke: null, desiredSize: new Size2(3, 3).Ct() }).theme("fill", "link"))), this.pa = new GMap2(), this.f2 = new Group2(Panel2.Vertical, { selectionObjectName: "GROUPPANEL" }).add(new TextBlock2({ stroke: "black", font: "bold 12pt sans-serif" }).bind("text", "", U.toString).theme("stroke", "text").theme("font", "bold"), new Panel2(Panel2.Auto, { name: "GROUPPPANEL" }).add(new Shape2({ fill: "rgba(128,128,128,0.2)", stroke: "black", strokeWidth: 1 }).theme("fill", "group").theme("stroke", "outline").theme("strokeWidth", "group"), new Placeholder2({ padding: 5 }).theme("padding", "group"))), this.pa.set("", this.f2), this.fh = new GMap2(), this.h2 = new Link2().add(new Shape2({ isPanelMain: true, stroke: "black" }).theme("stroke", "link"), new Shape2({ toArrow: "Standard", fill: "black", stroke: null, strokeWidth: 0 }).theme("toArrow").theme("fill", "link")), this.fh.set("", this.h2), this.fh.set("Comment", new Link2().add(new Shape2({ isPanelMain: true, stroke: "brown" }).theme("stroke", "comment"))), this.g0 = new Adornment2(Panel2.Auto).add(new Shape2({ fill: null, stroke: "dodgerblue", strokeWidth: 3 }).theme("stroke", "selection").theme("strokeWidth", "selection"), new Placeholder2({ margin: 1.5 }).theme("margin", "selection", "numbers", null, (t) => t ? new Margin2(t / 2) : 1.5)).freezeBindings(), this.ib = this.g0, this.eb = new Adornment2(Panel2.Link).add(new Shape2({ isPanelMain: true, fill: null, stroke: "dodgerblue", strokeWidth: 3 }).theme("stroke", "selection").theme("strokeWidth", "selection")).freezeBindings();
    }
    setRTL(t) {
      let i = t === void 0 ? this.div : t;
      i === null && (i = root.document.body);
      const e = U.Le("div");
      e.dir = "rtl", e.style.cssText = "font-size: 14px; width: 1px; height: 1px; position: absolute; top: -1000px; overflow: scroll;", e.textContent = "A", i.appendChild(e);
      let s = "reverse";
      e.scrollLeft > 0 ? s = "default" : (e.scrollLeft = 1, e.scrollLeft === 0 && (s = "negative")), i.removeChild(e), this.p1 = s;
    }
    setScrollWidth(t) {
      let i = t === void 0 ? this.div : t;
      i === null && (i = root.document.body);
      let e = 0;
      if (Diagram2.isUsingDOM()) {
        let s = Diagram2.m2, n = Diagram2.g2;
        s === null && (Diagram2.m2 = U.Le("p"), s = Diagram2.m2, s.style.width = "100%", s.style.height = "200px", s.style.boxSizing = "content-box", Diagram2.g2 = U.Le("div"), n = Diagram2.g2, n.style.position = "absolute", n.style.visibility = "hidden", n.style.width = "200px", n.style.height = "150px", n.style.boxSizing = "content-box", n.appendChild(s)), n.style.overflow = "hidden", i.appendChild(n);
        const o = s.offsetWidth;
        n.style.overflow = "scroll";
        let r = s.offsetWidth;
        o === r && (r = n.clientWidth), i.removeChild(n), e = o - r, e === 0 && !U.wr && (e = 11);
      }
      this.Qt = e, this.qM = true;
    }
    gi(t) {
      t in AutoScale2 ? this.autoScale = t : U.xr(this, t);
    }
    toString(t) {
      t === void 0 && (t = 0);
      let i = "";
      this.div && this.div.id && (i = this.div.id);
      let e = 'Diagram "' + i + '"';
      if (t <= 0) return e;
      const s = this.Ht.iterator;
      for (; s.next(); ) {
        const n = s.value;
        e += `
  ` + n.toString(t - 1);
      }
      return e;
    }
    static tL(t) {
      Diagram2.lb = t;
    }
    static zm() {
      return Diagram2.lb;
    }
    static fromDiv(t) {
      let i = t;
      if (typeof t == "string" && (i = root.document.getElementById(t)), i instanceof HTMLDivElement) {
        const e = Diagram2.Qe.get(i);
        if (e) return e;
      }
      return null;
    }
    get div() {
      return this.Tt;
    }
    set div(t) {
      if (t !== null && U.s(t, HTMLDivElement, Diagram2, "div"), this.Tt !== t) {
        const i = this.Tt;
        if (i !== null) {
          if (Diagram2.Qe.delete(i), i.goDiagram = void 0, i.go = void 0, i.innerHTML = "", this.ht !== null) {
            const s = this.ht.Nt;
            this.Fi(s, "pointermove", this.ka, false), this.Fi(s, "pointerdown", this.dh, false), this.Fi(s, "pointerup", this.Pa, false), this.Fi(s, "pointerout", this.Ma, false), this.Fi(s, "pointercancel", this.Na, false), this.ht.dispose();
          }
          this.lc && (this.lc.disconnect(), this.lc = null);
          const e = this.toolManager;
          e !== null && (e.mouseDownTools.each((s) => s.cancelWaitAfter()), e.mouseMoveTools.each((s) => s.cancelWaitAfter()), e.mouseUpTools.each((s) => s.cancelWaitAfter())), e.cancelWaitAfter(), this.currentTool.doCancel(), this.ht = null, this.Fi(root, "resize", this.rb, false), this.Fi(root, "wheel", this.Sa, true), Diagram2.zm() === this && Diagram2.tL(null);
        } else this.dh === null && (this.ho = false);
        if (this.Tt = null, t !== null) {
          const e = Diagram2.Qe.get(t);
          e && (e.div = null), this.P2(t), this.Uu(), this.themeManager && this.themeManager.lO();
        } else this.themeManager && this.themeManager.hO();
      }
    }
    setupRouters() {
      this.fc.push(new AvoidsNodesRouter());
    }
    P2(t) {
      const i = this;
      if (!Diagram2.isUsingDOM()) return;
      t == null && U.n("Diagram setup requires an argument DIV."), i.Tt !== null && U.n("Diagram has already completed setup."), typeof t == "string" ? i.Tt = root.document.getElementById(t) : t instanceof HTMLDivElement ? i.Tt = t : U.n("No DIV or DIV id supplied: " + t), i.Tt === null && U.n("Invalid DIV id; could not get element with id: " + t);
      const e = Diagram2.Qe.get(i.Tt);
      if (e && e !== this && U.n("Invalid div id; div already has a Diagram associated with it."), !i.lc && root.ResizeObserver) {
        const a = root.ResizeObserver, c = U.Rk(() => i.requestUpdate(), 250, false);
        i.lc = new a(() => c()), i.lc.observe(i.Tt);
      }
      root.getComputedStyle(i.Tt, null).position === "static" && (i.Tt.style.position = "relative");
      let s = 5;
      const n = "rgba(2" + s + "5, 255, 255, 0)";
      s--, i.Tt.style["-webkit-tap-highlight-color"] = n, i.Tt.innerHTML = "", Diagram2.Qe.set(i.Tt, i), i.Tt.goDiagram = i, i.Tt.go = root.go;
      const o = new CanvasSurface(i);
      o.style !== void 0 && (o.style.position = "absolute", o.style.top = "0px", o.style.left = "0px", root.getComputedStyle(i.Tt, null).getPropertyValue("direction") === "rtl" && (i.dd = true), o.style.zIndex = "2", o.style.userSelect = "none", o.style.MozUserSelect = "none", o.style.touchAction = "none", o.style.letterSpacing = "normal !important", o.style.wordSpacing = "normal !important", o.style.lang = "unknown"), o.Nt.setAttribute("role", "application"), i.ht = o, i._t = o.ni;
      const r = i._t;
      i.te = i.computePixelRatio(), i.viewSize.isReal() || (i.Pt = i.Tt.clientWidth || 1, i.Mt = i.Tt.clientHeight || 1), i.aL(i.Pt, i.Mt);
      const l = i;
      i.Tt.insertBefore(o.Nt, i.Tt.firstChild);
      const h = new CanvasSurface(null);
      if (h.width = 1, h.height = 1, i.$R = h, i.ZR = h.ni, Diagram2.isUsingDOM()) {
        const a = U.Le("div"), c = U.Le("div");
        a.style.position = "absolute", a.style.overflow = "auto", a.style.width = i.Pt + "px", a.style.height = i.Mt + "px", a.style.zIndex = "1", c.style.position = "absolute", c.style.width = "1px", c.style.height = "1px", i.Tt.appendChild(a), a.appendChild(c), a.onscroll = Diagram2.aO, a.addEventListener("pointerdown", Diagram2.fO), a.f = i, a.cO = true, a.uO = true, i.nb = a, i.ob = c;
      }
      i.Uu = U.Rk(() => {
        i.zl = null, i.L();
      }, 300, false), i.rb = U.Rk(() => {
        i.LM();
      }, 250, false), i.aa = (a) => (a.preventDefault(), false), i.Sa = (a) => {
        if (!l.isEnabled) return;
        const c = l.cc(a, true);
        c.bubbles = true;
        let u = 0, d = 0;
        c.delta = 0, a.deltaX !== void 0 ? (a.deltaX !== 0 && (u = a.deltaX > 0 ? 1 : -1), a.deltaY !== 0 && (d = a.deltaY > 0 ? 1 : -1), c.delta = Math.abs(a.deltaX) > Math.abs(a.deltaY) ? -u : -d) : a.wheelDeltaX !== void 0 ? (a.wheelDeltaX !== 0 && (u = a.wheelDeltaX > 0 ? -1 : 1), a.wheelDeltaY !== 0 && (d = a.wheelDeltaY > 0 ? -1 : 1), c.delta = Math.abs(a.wheelDeltaX) > Math.abs(a.wheelDeltaY) ? -u : -d) : a.wheelDelta !== void 0 && a.wheelDelta !== 0 && (c.delta = a.wheelDelta > 0 ? 1 : -1), l.doMouseWheel(), l.Ca(c, a);
      }, i.QT = (a) => {
        if (!l.isEnabled) return;
        i.hc = false, l.cc(a, true);
        const c = l.currentTool;
        c.cancelWaitAfter(), c.standardMouseOver();
      }, i.dh = (a) => {
        if (!l.isEnabled) return;
        i.hc = true;
        const c = l.sb;
        c[a.pointerId] === void 0 && (c[a.pointerId] = a);
        const u = l.ba;
        let d = false;
        if (u[0] !== null && (u[0].pointerId === a.pointerId || u[0].pointerType !== a.pointerType)) u[0] = a;
        else if (u[1] !== null && u[1].pointerId === a.pointerId) u[1] = a, d = true;
        else if (u[0] === null) u[0] = a;
        else if (u[1] === null) u[1] = a, d = true;
        else {
          a.preventDefault();
          return;
        }
        const m = a.pointerType === "touch" || a.pointerType === "pen";
        m && (l.Fx = false, l.b0 = true);
        const g = l.dO(a, a, d), p = l.d2, y = m ? 25 : 10;
        if (a.timeStamp - l.u2 < l.ZT && !(Math.abs(p.x - a.screenX) > y || Math.abs(p.y - a.screenY) > y) ? l.x0++ : l.x0 = 1, g.clickCount = l.x0, l.u2 = a.timeStamp, l.d2.setTo(a.screenX, a.screenY), l.doMouseDown(), a.button === 1) {
          a.preventDefault();
          return;
        }
        l.Ca(g, a);
      }, i.ka = (a) => {
        if (!l.isEnabled) return;
        i.hc = true;
        const c = l.ba;
        if (c[0] !== null && (c[0].pointerId === a.pointerId || c[0].pointerType !== a.pointerType)) c[0] = a;
        else if (c[1] !== null && c[1].pointerId === a.pointerId) {
          c[1] = a;
          return;
        } else if (c[0] === null) c[0] = a;
        else return;
        if (c[0].pointerId !== a.pointerId) return;
        const u = l.gO(a, a, c[1] !== null);
        l.doMouseMove(), l.Ca(u, a);
      }, i.Pa = (a) => {
        if (!l.isEnabled) return;
        i.hc = true;
        const c = a.pointerType === "touch" || a.pointerType === "pen", u = l.sb;
        if (c && l.Fx) {
          delete u[a.pointerId], a.preventDefault();
          return;
        }
        const d = l.ba;
        if (d[0] !== null && (d[0].pointerId === a.pointerId || d[0].pointerType !== a.pointerType)) d[0] = null;
        else if (d[1] !== null && d[1].pointerId === a.pointerId) {
          d[1] = null;
          return;
        } else return;
        const m = l.M2(a, false, true, false, true, false);
        let g = root.document.elementFromPoint(a.clientX, a.clientY) || null;
        g !== null && g.shadowRoot && (g = g.shadowRoot.elementFromPoint(a.clientX, a.clientY) || null), g !== null && g.f instanceof Diagram2 && g.f !== l && g.f.T0(a, m), g === null && (g = a.target), l.T0(a, m), m.clickCount = l.x0, m.targetDiagram = l.db(a, g), m.targetObject = null, l.doMouseUp(), l.Ca(m, a), c && (l.b0 = false);
      }, i.Ma = (a) => {
        if (!l.isEnabled) return;
        i.hc = false;
        const c = l.sb;
        c[a.pointerId] && delete c[a.pointerId];
        const u = l.ba;
        if (u[0] !== null && u[0].pointerId === a.pointerId && (u[0] = null), u[1] !== null && u[1].pointerId === a.pointerId && (u[1] = null), a.pointerType === "touch" || a.pointerType === "pen") return;
        const d = l.currentTool;
        d.cancelWaitAfter(), d.standardMouseOver();
      }, i.Na = (a) => {
        const c = l.ba;
        c[0] !== null && c[0].pointerId === a.pointerId ? (c[0] = null, l.b0 = false) : c[1] !== null && c[1].pointerId === a.pointerId && (c[1] = null);
      };
      const f = r;
      if (i.w0 = f.B[U.Qi("7eba17a4ca3b1a8346")][U.Qi("78a118b7")](f.B, Diagram2.Aa, s, s), r.clearContextCache(true), i.mO(), this.oc === "svg") {
        const a = this.vo.get("svg");
        this.Tt && this.Tt.appendChild(a.Nt), this._t = a.ni;
      }
    }
    addEventListener(t, i, e, s) {
      t.addEventListener(i, e, { capture: s, passive: false });
    }
    Kt(t, i, e, s) {
      t.addEventListener(i, e, { capture: s, passive: false });
    }
    removeEventListener(t, i, e, s) {
      t.removeEventListener(i, e, { capture: s });
    }
    Fi(t, i, e, s) {
      t.removeEventListener(i, e, { capture: s });
    }
    mO() {
      const t = this;
      let i = this.ht.Nt;
      i instanceof HTMLCanvasElement || (i = t.div), this.Kt(i, "pointerdown", t.dh, false), this.Kt(i, "pointermove", t.ka, false), this.Kt(i, "pointerup", t.Pa, false), this.Kt(i, "pointerout", t.Ma, false), this.Kt(i, "pointercancel", t.Na, false), this.Kt(i, "pointerenter", t.pO, false), this.Kt(i, "pointerleave", t.yO, false), this.Kt(i, "wheel", t.Sa, false), this.Kt(i, "keydown", t.wO, false), this.Kt(i, "keyup", t.xO, false), this.Kt(i, "blur", t.bO, false), this.Kt(i, "focus", t.SO, false), this.Kt(i, "selectstart", (e) => (e.preventDefault(), false), false), this.Kt(i, "contextmenu", (e) => (e.preventDefault(), false), false), this.Kt(root, "resize", t.rb, false);
    }
    Rx() {
      this.S0 > 30 && (this.zl = 1);
    }
    kP(t) {
      this.zl !== null && (this.zl = null, t && this.Uu(), Debug && Debug.drawFrames || (this.S0 = 0, this.p2 = [0, 0, 0, 0, 0], this.k0 = 0));
    }
    computePixelRatio() {
      return this.zl !== null ? this.zl : root.devicePixelRatio || 1;
    }
    get avgSpf() {
      return this.S0;
    }
    doMouseDown() {
      this.currentTool.doMouseDown();
    }
    doMouseMove() {
      this.currentTool.doMouseMove();
    }
    doMouseUp() {
      this.currentTool.doMouseUp();
    }
    doMouseWheel() {
      this.currentTool.doMouseWheel();
    }
    doKeyDown() {
      const t = this.commandHandler;
      if (!this.toggleKeyboardControl()) {
        if ((t.isFocusEnabled || t.isVirtualPointerEnabled) && t.doVirtualFocusKeyDown()) {
          const i = this.lastInput;
          i.bubbles = false;
          const e = i.event;
          e && (e.stopPropagation && e.stopPropagation(), e.cancelable !== false && e.preventDefault());
          return;
        }
        this.currentTool.doKeyDown();
      }
    }
    toggleKeyboardControl() {
      const t = this.lastInput, i = t.commandKey;
      if ((t.control || t.meta) && t.alt && (i === "Enter" || i === "NumpadEnter")) {
        const e = this.commandHandler, s = e.isFocusEnabled || e.isVirtualPointerEnabled;
        return e.isFocusEnabled = !s, e.isVirtualPointerEnabled = !s, e.focus = e.findFirstFocus(), this.F("FocusOrVirtualPointerEnabledChanged"), true;
      }
      return false;
    }
    doKeyUp() {
      const t = this.commandHandler;
      if ((t.isFocusEnabled || t.isVirtualPointerEnabled) && t.doVirtualFocusKeyUp()) {
        const i = this.lastInput;
        i.bubbles = false;
        const e = i.event;
        e && (e.stopPropagation && e.stopPropagation(), e.cancelable !== false && e.preventDefault());
        return;
      }
      this.currentTool.doKeyUp();
    }
    doFocus() {
      this.focus();
    }
    focus() {
      if (this.ht) if (this.scrollsPageOnFocus) this.ht.focus();
      else {
        const t = root.scrollX, i = root.scrollY;
        this.ht.focus(), root.scrollTo(t, i);
      }
    }
    SO(t) {
      const i = Diagram2.Qe.get(this);
      i && i.F("GainedFocus");
    }
    bO(t) {
      const i = Diagram2.Qe.get(this);
      i && i.F("LostFocus");
    }
    LM() {
      if (this.ht === null) return;
      const i = this.Tt;
      if (i === null || i.clientWidth === 0 || i.clientHeight === 0) return;
      this.qM || this.setScrollWidth();
      const e = this.lo ? this.Qt : 0, s = this.An ? this.Qt : 0, n = this.te;
      if (this.te = this.computePixelRatio(), this.te !== n && (this.sd = true, this.requestUpdate()), i.clientWidth !== this.Pt + e || i.clientHeight !== this.Mt + s) {
        this.Ta(), this.Ze = true;
        const o = this.layout;
        o !== null && o.isViewportSized && this.autoScale === 1 && (this.sc = true, o.b()), this.Rs || this.requestUpdate();
      }
    }
    eL() {
      let t = 0, i = new Layer2();
      i.name = "Grid", i.allowSelect = false, i.pickable = false, i.isTemporary = true, i.isInDocumentBounds = false, this.sl(i, t++), i = new Layer2(), i.name = "ViewportBackground", i.isViewportAligned = true, i.isTemporary = true, i.isInDocumentBounds = false, this.sl(i, t++), i = new Layer2(), i.name = "Background", this.sl(i, t++), i = new Layer2(), i.name = "", this.sl(i, t++), i = new Layer2(), i.name = "Foreground", this.sl(i, t++), i = new Layer2(), i.name = "ViewportForeground", i.isViewportAligned = true, i.isTemporary = true, i.isInDocumentBounds = false, this.sl(i, t++), i = new Layer2(), i.name = "Adornment", i.isTemporary = true, i.isInDocumentBounds = false, this.sl(i, t++), i = new Layer2(), i.name = "Tool", i.isTemporary = true, i.isInDocumentBounds = true, this.sl(i, t++);
    }
    fL() {
      const t = new Panel2(Panel2.Grid, { name: "GRID" }).add(new Shape2("LineH", { stroke: "lightgray", strokeWidth: 0.5, interval: 1 }).theme("stroke", "gridMinor"), new Shape2("LineV", { stroke: "lightgray", strokeWidth: 0.5, interval: 1 }).theme("stroke", "gridMinor"), new Shape2("LineH", { stroke: "gray", strokeWidth: 0.5, interval: 5 }).theme("stroke", "gridMajor"), new Shape2("LineV", { stroke: "gray", strokeWidth: 0.5, interval: 5 }).theme("stroke", "gridMajor"), new Shape2("LineH", { stroke: "gray", strokeWidth: 1, interval: 10 }).theme("stroke", "gridMajor"), new Shape2("LineV", { stroke: "gray", strokeWidth: 1, interval: 10 }).theme("stroke", "gridMajor")), i = new Part2({ layerName: "Grid", zOrder: 0, isInDocumentBounds: false, isAnimated: false, pickable: false, locationObjectName: "GRID" }).add(t);
      return this.add(i), this.partManager.parts.delete(i), t.visible = false, t;
    }
    static aO() {
      const t = Diagram2.Qe.get(this.parentElement || this);
      if (t) {
        if (t.J1) {
          t.J1 = false;
          return;
        }
        if (!t.isEnabled) {
          t.cL();
          return;
        }
        t.diagramScroll(this);
      }
    }
    static fO(t) {
      if (!this.f.isEnabled) {
        this.f.updateScroll();
        return;
      }
      this.f.$1 = t.target.scrollTop, this.f.Z1 = t.target.scrollLeft;
    }
    diagramScroll(t) {
      if (this.ht === null) return;
      const i = this.nb, e = this.ob;
      this.c0 = true;
      let s = this.documentBounds, n = this.viewportBounds;
      const o = this.ga;
      let r = s.x - o.left, l = s.y - o.top;
      const h = s.width + o.left + o.right, f = s.height + o.top + o.bottom;
      let a = s.right + o.right, c = s.bottom + o.bottom, u = n.x, d = n.y;
      const m = n.width, g = n.height;
      let p = n.right, y = n.bottom;
      const x = this.scale;
      let S, b = t.scrollLeft;
      if (this.dd) switch (this.p1) {
        case "negative":
          b = b + t.scrollWidth - t.clientWidth;
          break;
        case "reverse":
          b = t.scrollWidth - b - t.clientWidth;
          break;
      }
      const k = b;
      if (m < h || g < f) {
        S = Point2.U(this.position.x, this.position.y), this.allowHorizontalScroll && this.Z1 !== k && (S.x = k / x + r, this.Z1 = k), this.allowVerticalScroll && this.$1 !== t.scrollTop && (S.y = t.scrollTop / x + l, this.$1 = t.scrollTop), this.position = S, Point2.o(S), this.c0 = false, this.ld = false;
        return;
      }
      if (S = Point2.a(), t.cO && this.allowHorizontalScroll && (r < u && (this.position = S.e(k + r, this.position.y)), a > p)) {
        const P = i.scrollWidth - this.Pt;
        this.position = S.e(-P + k - this.Pt / x + a, this.position.y);
      }
      if (t.uO && this.allowVerticalScroll && (l < d && (this.position = S.e(this.position.x, t.scrollTop + l)), c > y)) {
        const P = i.scrollHeight - this.Mt;
        this.position = S.e(this.position.x, -P + t.scrollTop - this.Mt / x + c);
      }
      Point2.o(S), this.mh(), this.c0 = false, this.ld = false, s = this.documentBounds, n = this.viewportBounds, a = s.right, p = n.right, c = s.bottom, y = n.bottom, r = s.x, u = n.x, l = s.y, d = n.y, m >= h && r >= u && a <= p && (e.style.width = "1px"), g >= f && l >= d && c <= y && (e.style.height = "1px");
    }
    computeBounds(t) {
      return t === void 0 && (t = new Rect2()), this.Ri(), this.uL(t);
    }
    uL(t) {
      if (this.fixedBounds.isReal()) return t.c(this.fixedBounds), t.addMargin(this.si), t;
      let i = true;
      const e = this.Ht.h, s = e.length;
      for (let n = 0; n < s; n++) {
        const o = e[n];
        if (!o.visible || !o.isInDocumentBounds) continue;
        const r = o.Ft.h, l = r.length;
        for (let h = 0; h < l; h++) {
          const f = r[h];
          if (!f.isInDocumentBounds || !f.isVisible()) continue;
          const a = f.actualBounds;
          a.isReal() && (i ? (i = false, t.c(a)) : t.unionRect(a));
        }
      }
      return i && t.e(0, 0, 0, 0), t.addMargin(this.si), t;
    }
    computePartsBounds(t, i) {
      i === void 0 && (i = false);
      let e;
      if (Array.isArray(t)) for (let s = 0; s < t.length; s++) {
        const n = t[s];
        !i && n instanceof Link2 || (n.ensureBounds(), e === void 0 ? e = n.actualBounds.copy() : e.unionRect(n.actualBounds));
      }
      else {
        const s = t.iterator;
        for (; s.next(); ) {
          const n = s.value;
          !i && n instanceof Link2 || (n.ensureBounds(), e === void 0 ? e = n.actualBounds.copy() : e.unionRect(n.actualBounds));
        }
      }
      return e === void 0 ? new Rect2(NaN, NaN, 0, 0) : e;
    }
    tn(t) {
      if (!t && !this.ho || this.$t || this.ht === null || !this.documentBounds.isReal()) return;
      if (this.$t = true, t) {
        const c = this.initialPosition;
        if (c.isReal()) {
          this.$t = false, this.position = c;
          return;
        }
        let u = this.initialDocumentSpot, d = this.initialViewportSpot;
        u.isNoSpot() && (u = Spot2.TopLeft), d.isNoSpot() && (d = Spot2.TopLeft);
        const m = Point2.a();
        m.setRectSpot(this.documentBounds, u);
        const g = this.viewportBounds, p = Rect2.U(0, 0, g.width, g.height), y = Point2.a();
        y.setRectSpot(p, d), y.e(m.x - y.x, m.y - y.y), this.$t = false, this.position = y, Rect2.o(p), Point2.o(y);
      }
      let i = this.hh;
      t && this.Xr !== 1 && (i = this.Xr);
      const e = i !== 1 ? this.md(i) : this.scale, s = this.yt.x, n = this.yt.y, o = this.Pt / e, r = this.Mt / e;
      let l = this.ic;
      const h = this.l0;
      if (t && !l.isSpot() && (h.isSpot() || h.isDefault())) {
        const c = this.initialDocumentSpot.isSpot() && this.initialViewportSpot.isSpot();
        l = h.isDefault() && !c ? Spot2.Center : h;
      }
      this.N2(this.documentBounds, o, r, l, t);
      const f = this.scale;
      this.scale = e, this.$t = false;
      const a = this.viewportBounds;
      a.equalsApproxTo(s, n, o, r) || this.onViewportBoundsChanged(new Rect2(s, n, o, r), a, f, false);
    }
    md(t) {
      const i = this.y0;
      if (this.ht === null) return i;
      if (t === 1) return this.scale;
      this.ensureBounds();
      const e = this.documentBounds;
      if (!e.isReal()) return i;
      const s = e.width, n = e.height, o = this.Pt + (this.lo ? this.Qt : 0), r = this.Mt + (this.An ? this.Qt : 0);
      let l = o / s, h = r / n;
      const f = this.ga, a = f.left + f.right !== 0, c = f.top + f.bottom !== 0;
      (a || c) && (h === l ? (h = (r - this.Qt) / n, l = (o - this.Qt) / s) : h > l ? h = (r - this.Qt) / n : l = (o - this.Qt) / s);
      let u = 0;
      return t === 2 ? u = Math.min(h, l) : t === 3 && (h > l ? u = (r - this.Qt) / n : u = (o - this.Qt) / s), u > i && (u = i), u < this.minScale && (u = this.minScale), u > this.maxScale && (u = this.maxScale), u;
    }
    zoomToFit() {
      const t = this.ca;
      this.ca = 1, this.scale = this.md(2), this.alignDocument(Spot2.Center, Spot2.Center), t !== 1 && (this.tn(false), this.N2(this.documentBounds, this.Pt / this.lt, this.Mt / this.lt, this.ic, false)), this.ca = t;
    }
    zoomToRect(t, i) {
      i === void 0 && (i = 2);
      const e = t.width, s = t.height;
      if (e === 0 || s === 0 || isNaN(e) && isNaN(s)) return;
      let n = 1;
      if (i === 2 || i === 3) if (isNaN(e)) n = this.viewportBounds.height * this.scale / s;
      else if (isNaN(s)) n = this.viewportBounds.width * this.scale / e;
      else {
        const o = this.Pt, r = this.Mt;
        i === 3 ? r / s > o / e ? n = (r - (this.An ? this.Qt : 0)) / s : n = (o - (this.lo ? this.Qt : 0)) / e : n = Math.min(r / s, o / e);
      }
      this.scale = n, this.position = new Point2(t.x, t.y);
    }
    get kO() {
      return this.$t;
    }
    set kO(t) {
      this.$t = t;
    }
    alignDocument(t, i) {
      this.ensureBounds();
      const e = this.documentBounds, s = this.viewportBounds;
      this.position = new Point2(e.x + (t.x * e.width + t.offsetX) - (i.x * s.width - i.offsetX), e.y + (t.y * e.height + t.offsetY) - (i.y * s.height - i.offsetY));
    }
    focusObject(t) {
      if (t instanceof GraphObject2) {
        this.P0 = t;
        const i = Point2.a();
        this.M0 = this.transformDocToView(t.getDocumentPoint(Spot2.TopLeft, i)), Point2.o(i);
      } else this.P0 = null, this.M0 = Point2.xn;
    }
    N2(t, i, e, s, n) {
      const o = Point2.U(this.yt.x, this.yt.y);
      let r = o.x, l = o.y;
      if (this.P0 !== null) {
        let h = Point2.a();
        h = this.P0.getDocumentPoint(Spot2.TopLeft, h), r = h.x - this.M0.x / this.scale, l = h.y - this.M0.y / this.scale, s = Spot2.None, Point2.o(h);
      }
      if (n || this.scrollMode === 1) {
        s.isSpot() && (i > t.width && (r = t.x + (s.x * t.width + s.offsetX) - (s.x * i - s.offsetX)), e > t.height && (l = t.y + (s.y * t.height + s.offsetY) - (s.y * e - s.offsetY)));
        const h = this.ga, f = i - t.width;
        if (i < t.width + h.left + h.right) {
          let c = r + i / 2;
          c = Math.min(c, t.right + Math.max(f, h.right) - i / 2), c = Math.max(c, t.left - Math.max(f, h.left) + i / 2), r = c - i / 2;
        } else r > t.left ? r = t.left : r < t.right - i && (r = t.right - i);
        const a = e - t.height;
        if (e < t.height + h.top + h.bottom) {
          let c = l + e / 2;
          c = Math.min(c, t.bottom + Math.max(a, h.bottom) - e / 2), c = Math.max(c, t.top - Math.max(a, h.top) + e / 2), l = c - e / 2;
        } else l > t.top ? l = t.top : l < t.bottom - e && (l = t.bottom - e);
      }
      if (o.x = isFinite(r) ? r : -this.si.left, o.y = isFinite(l) ? l : -this.si.top, this.positionComputation !== null) {
        const h = this.positionComputation(this, o);
        o.x = h.x, o.y = h.y;
      }
      this.Ls.XT(this.yt, o), this.yt.e(o.x, o.y), this.L0(), this.gh(), this.PO(), Point2.o(o);
    }
    findPartAt(t, i) {
      if (i === void 0 && (i = true), i) {
        const e = this.CP(t, (s) => s.part, (s) => s.canSelect());
        if (e instanceof Part2) return e;
      } else {
        const e = this.CP(t, (s) => s.part);
        if (e instanceof Part2) return e;
      }
      return null;
    }
    findObjectAt(t, i, e) {
      i === void 0 && (i = null), e === void 0 && (e = null), this.Ri();
      const s = this.Ht.iteratorBackwards;
      for (; s.next(); ) {
        const n = s.value;
        if (!n.visible) continue;
        const o = n.findObjectAt(t, i, e);
        if (o !== null) return o;
      }
      return null;
    }
    CP(t, i, e) {
      i === void 0 && (i = null), e === void 0 && (e = null), this.Ri();
      const s = this.Ht.iteratorBackwards;
      for (; s.next(); ) {
        const n = s.value;
        if (!n.visible || n.isTemporary) continue;
        const o = n.findObjectAt(t, i, e);
        if (o !== null) return o;
      }
      return null;
    }
    findPartsAt(t, i, e) {
      return i === void 0 && (i = true), this.MO(t, (s) => s.part, i ? (s) => s instanceof Part2 && s.canSelect() : null, e);
    }
    MO(t, i, e, s) {
      i === void 0 && (i = null), e === void 0 && (e = null), !(s instanceof List2) && !(s instanceof GSet2) && (s = new GSet2()), this.Ri();
      const n = this.Ht.iteratorBackwards;
      for (; n.next(); ) {
        const o = n.value;
        !o.visible || o.isTemporary || o.findObjectsAt(t, i, e, s);
      }
      return s;
    }
    findObjectsAt(t, i, e, s) {
      i === void 0 && (i = null), e === void 0 && (e = null), !(s instanceof List2) && !(s instanceof GSet2) && (s = new GSet2()), this.Ri();
      const n = this.Ht.iteratorBackwards;
      for (; n.next(); ) {
        const o = n.value;
        o.visible && o.findObjectsAt(t, i, e, s);
      }
      return s;
    }
    findPartsIn(t, i, e, s) {
      return i === void 0 && (i = false), e === void 0 && (e = true), this.NO(t, null, (n) => n instanceof Part2 && (!e || n.canSelect()), i, s);
    }
    findObjectsIn(t, i, e, s, n) {
      i === void 0 && (i = null), e === void 0 && (e = null), s === void 0 && (s = false), !(n instanceof List2) && !(n instanceof GSet2) && (n = new GSet2()), this.Ri();
      const o = this.Ht.iteratorBackwards;
      for (; o.next(); ) {
        const r = o.value;
        r.visible && r.findObjectsIn(t, i, e, s, n);
      }
      return n;
    }
    LP(t, i, e, s, n, o) {
      const r = new GSet2();
      this.Ri();
      const l = this.Ht.iteratorBackwards;
      for (; l.next(); ) {
        const h = l.value;
        h.visible && h.LP(t, i, e, s, r, n, o);
      }
      return r;
    }
    NO(t, i, e, s, n) {
      i === void 0 && (i = null), e === void 0 && (e = null), s === void 0 && (s = false), !(n instanceof List2) && !(n instanceof GSet2) && (n = new GSet2()), this.Ri();
      const o = this.Ht.iteratorBackwards;
      for (; o.next(); ) {
        const r = o.value;
        !r.visible || r.isTemporary || r.findObjectsIn(t, i, e, s, n);
      }
      return n;
    }
    findPartsNear(t, i, e, s, n) {
      return e === void 0 && (e = true), s === void 0 && (s = true), this.CO(t, i, null, (o) => o instanceof Part2 && (!s || o.canSelect()), e, n);
    }
    findObjectsNear(t, i, e, s, n, o) {
      e === void 0 && (e = null), s === void 0 && (s = null), n === void 0 && (n = true), n !== false && n !== true && ((n instanceof List2 || n instanceof GSet2) && (o = n), n = true), !(o instanceof List2) && !(o instanceof GSet2) && (o = new GSet2()), this.Ri();
      const r = this.Ht.iteratorBackwards;
      for (; r.next(); ) {
        const l = r.value;
        l.visible && l.findObjectsNear(t, i, e, s, n, o);
      }
      return o;
    }
    CO(t, i, e, s, n, o) {
      e === void 0 && (e = null), s === void 0 && (s = null), n === void 0 && (n = true), n !== false && n !== true && ((n instanceof List2 || n instanceof GSet2) && (o = n), n = true), !(o instanceof List2) && !(o instanceof GSet2) && (o = new GSet2()), this.Ri();
      const r = this.Ht.iteratorBackwards;
      for (; r.next(); ) {
        const l = r.value;
        !l.visible || l.isTemporary || l.findObjectsNear(t, i, e, s, n, o);
      }
      return o;
    }
    acceptEvent(t) {
      return this.cc(t, t instanceof MouseEvent);
    }
    cc(t, i) {
      const e = this.tl;
      this.tl = this.ya, this.ya = e, e.diagram = this, e.event = t, i ? this.T0(t, e) : (e.viewPoint = this.tl.viewPoint, e.documentPoint = this.tl.documentPoint);
      let s = 0;
      const n = t;
      return n.ctrlKey && (s += 1), n.altKey && (s += 2), n.shiftKey && (s += 4), n.metaKey && (s += 8), e.modifiers = s, e.button = n.button, n.buttons !== void 0 && (e.buttons = n.buttons), U.wr && n.button === 0 && n.ctrlKey && (e.button = 2), e.down = false, e.up = false, e.clickCount = 1, e.delta = 0, e.handled = false, e.bubbles = false, e.timestamp = t.timeStamp, e.isMultiTouch = false, e.targetDiagram = this.db(t, t.target), e.targetObject = null, e;
    }
    db(t, i) {
      if (i === null) return null;
      const e = Diagram2.Qe.get(i);
      if (e) return e;
      let s = t.path;
      if (!s && U.at(t.composedPath) && (s = t.composedPath()), s && s[0]) {
        const n = Diagram2.Qe.get(s[0]);
        if (n) return n;
      }
      return null;
    }
    dO(t, i, e) {
      const s = this.M2(t, true, false, false, true, e);
      return this.T0(i, s), s.targetDiagram = this.db(t, t.target), s.targetObject = null, e || s.clone(this.p0), s;
    }
    gO(t, i, e) {
      const s = this.M2(t, false, false, false, false, e);
      let n = root.document.elementFromPoint(i.clientX, i.clientY) || null;
      n !== null && n.shadowRoot && (n = n.shadowRoot.elementFromPoint(i.clientX, i.clientY) || null);
      let o = this, r = t;
      if (n) {
        const l = this.db(t, n);
        l && (r = i, o = l);
      }
      return s.targetDiagram = o, this.T0(r, s), s.targetObject = null, s;
    }
    M2(t, i, e, s, n, o) {
      const r = this.tl;
      this.tl = this.ya, this.ya = r, r.diagram = this, r.clickCount = 1, r.delta = 0;
      let l = 0;
      return t.ctrlKey && (l += 1), t.altKey && (l += 2), t.shiftKey && (l += 4), t.metaKey && (l += 8), r.modifiers = l, r.event = t, r.timestamp = t.timeStamp, r.button = e ? this.firstInput.button : t.button, r.buttons = t.buttons, U.wr && t.button === 0 && t.ctrlKey && (r.button = 2), r.down = i, r.up = e, r.handled = s, r.bubbles = n, r.isMultiTouch = o, r;
    }
    Ca(t, i) {
      return t.bubbles ? (Debug && Debug.handleMessages && U.ot("NOT handled " + i.type + " " + t.toString()), true) : (Debug && Debug.handleMessages && U.ot("handled " + i.type + " " + this.currentTool.name + " " + t.toString()), i.stopPropagation !== void 0 && i.stopPropagation(), i.cancelable !== false && i.preventDefault(), i.cancelBubble = true, false);
    }
    wO(t) {
      const i = Diagram2.Qe.get(this);
      if (!i || !i.isEnabled) return false;
      const e = i.cc(t, false);
      return e.key = t.key, e.code = t.code, e.down = true, i.doKeyDown(), i.Ca(e, t);
    }
    xO(t) {
      const i = Diagram2.Qe.get(this);
      if (!i || !i.isEnabled) return false;
      const e = i.cc(t, false);
      return e.key = t.key, e.code = t.code, e.up = true, i.doKeyUp(), i.Ca(e, t);
    }
    pO(t) {
      const i = Diagram2.Qe.get(this);
      if (!i || !i.isEnabled) return false;
      const e = i.cc(t, true);
      return i.mouseEnter !== null && i.mouseEnter(e), i.currentTool.standardMouseOver(), i.Ca(e, t);
    }
    yO(t) {
      const i = Diagram2.Qe.get(this);
      if (!i || !i.isEnabled) return false;
      const e = i.cc(t, true);
      return i.mouseLeave !== null && i.mouseLeave(e), i.Ca(e, t);
    }
    getMouse(t) {
      const i = this.ht;
      if (i === null) return new Point2(0, 0);
      const e = i.getBoundingClientRect(), s = (t.clientX - e.left) * (this.Pt / e.width), n = (t.clientY - e.top) * (this.Mt / e.height);
      return new Point2(s, n).je(this.E);
    }
    T0(t, i) {
      const e = this.ht;
      let s = 0, n = 0;
      if (e !== null) {
        const r = e.getBoundingClientRect();
        s = (t.clientX - r.left) * (this.Pt / r.width), n = (t.clientY - r.top) * (this.Mt / r.height);
      }
      i.viewPoint.e(s, n);
      const o = Point2.U(s, n);
      this.E.De(o), i.documentPoint.c(o), Point2.o(o);
    }
    sT(t, i, e) {
      let s;
      if (this.ba[0] !== null) s = this.ba[i];
      else return;
      const n = this.ht;
      if (n !== null) {
        const o = n.getBoundingClientRect();
        e.e((s.clientX - o.left) * (this.Pt / o.width), (s.clientY - o.top) * (this.Mt / o.height));
      }
    }
    invalidateDocumentBounds() {
      this.wa || (this.wa = true, this.requestUpdate(false));
    }
    AO() {
      this.Rs || this.Ri(), this.ensureBounds();
    }
    redraw() {
      this.$t || this.Rs || (this.L(), this.maybeUpdate());
    }
    isUpdateRequested() {
      return this.Er;
    }
    delayInitialization(t) {
      t === void 0 && (t = null);
      const i = this.animationManager, e = i.isEnabled;
      i.stopAnimation(), i.isEnabled = false, this.Tr(), this.ho = false, this._x = new Point2(NaN, NaN), i.isEnabled = e, this.Rs = true;
      const s = this;
      t !== null && U.yn(() => {
        s.Rs = false, i.vl("Model"), t(s);
      }, 1);
    }
    requestUpdate(t) {
      if (t === void 0 && (t = false), this.Er === true || this.$t || t === false && this.Rs) return;
      this.Er = true;
      const i = this;
      root.requestAnimationFrame(() => {
        i.Er && i.maybeUpdate();
      });
    }
    maybeUpdate() {
      this.nd && !this.Er || (this.nd && (this.nd = false), this.Tr());
    }
    C2(t, i) {
      !this.ld || this.$t || this.animationManager.defaultAnimation.isAnimating || this.cL() || (t && this.Ri(), i && this.tn(false));
    }
    Tr(t) {
      if (this.Rs || (this.Er = false, this.Tt === null && !this.hd.isReal())) return;
      this.Rs = true;
      const i = this.animationManager, e = this.ud;
      if (!i.isAnimating && e.length !== 0) {
        const a = e.h, c = a.length;
        for (let u = 0; u < c; u++) {
          const d = a[u];
          d.Se(false), d.g();
        }
        e.clear();
      }
      const s = this.c2;
      s.count > 0 && (s.each((a) => a.A2()), s.clear());
      let n = false, o = false;
      i.defaultAnimation.isAnimating && (o = true, n = this.skipsUndoManager, this.skipsUndoManager = true), i.Mi || this.LM(), t || this.C2(false, true);
      const r = !this.undoManager.isUndoingRedoing && (this.Bl || this.fc.count !== 0 && this.Yr.size !== 0), l = !this.ho || this.il;
      this.Ri(true);
      let h = false;
      (l || r) && (this.ho ? this.T2(!this.sc, r) : (this.startTransaction("Initial Layout"), i.isEnabled === false && i.stopAnimation(), this.T2(false, r)), h = l), this.sc = false, this.Bl = false, this.Ri(), this.cs !== null && (this.cs.visible && !this.ad && (this.ph(), this.ad = true), !this.cs.visible && this.ad && (this.ad = false)), this.V1 || this.AO(), t || this.C2(true, false);
      let f = false;
      if (h) {
        const a = Rect2.a();
        a.c(this.viewportBounds), this.ho || (this.ho = true, f = true, this.skipsUndoManager || (this.undoManager.Lx = true), this.undoManager.Dx = true, this.TO()), this.LO(), this.Ri(false), t || this.C2(true, true), Rect2.o(a);
      } else if (i.vf && i.Qx) {
        if (this.Xr !== 1) this.scale = this.md(this.Xr);
        else if (this.hh !== 1) this.scale = this.md(this.hh);
        else {
          const a = this.initialScale;
          isFinite(a) && a > 0 && (this.scale = a);
        }
        this.tn(true);
      }
      h && f && this.commitTransaction("Initial Layout"), t || this.vi(this._t), o && (this.skipsUndoManager = n), this.Rs = false;
    }
    get sa() {
      return this.ho;
    }
    TO() {
      if (this.Xr !== 1) this.scale = this.md(this.Xr);
      else if (this.hh !== 1) this.scale = this.md(this.hh);
      else {
        const i = this.initialScale;
        isFinite(i) && i > 0 && (this.scale = i);
      }
      this.tn(true);
      const t = this.Ht.h;
      this.Is(t, t.length, this, this.viewportBounds), this.F("InitialLayoutCompleted"), this._x.c(this.yt), this.ph();
    }
    LO() {
      this.F("LayoutCompleted");
    }
    D0(t) {
      this.oo.add(t);
    }
    addInvalidRoute(t) {
      this.Go ? this.ma.add(t) : this.Yr.add(t);
    }
    Ri(t) {
      if (this.oo.size !== 0 && !(!this.Rs && this.animationManager.isTicking)) {
        if (this.Rs || (this.Bl = true), t) {
          this.dL(this.oo);
          return;
        }
        for (let i = 0; i < 23 && this.oo.size !== 0; i++) {
          const e = new Set(this.oo);
          this.oo.clear(), this.A2(e, this.oo), Debug && i === 22 && U.ot("failure to validate parts");
        }
        this.nodes.each((i) => {
          i instanceof Group2 && i.gL(false);
        });
      }
    }
    dL(t, i) {
      for (const e of t) !e.Oe() || e instanceof Group2 || (e.nl() ? (e.gt(1 / 0, 1 / 0), e.Ut()) : i && i.add(e));
      for (const e of t) if (e instanceof Group2) {
        if (!e.isVisible()) continue;
        this.gb(e);
      }
    }
    A2(t, i) {
      this.dL(t, i);
      for (const e of t) {
        if (!(e instanceof Link2)) continue;
        const s = e;
        s.isVisible() && (s.nl() ? (s.gt(1 / 0, 1 / 0), s.Ut()) : i.add(s));
      }
      for (const e of t) e instanceof Adornment2 && e.isVisible() && (e.nl() ? (e.gt(1 / 0, 1 / 0), e.Ut()) : i.add(e));
    }
    pd(t) {
      const i = t instanceof Diagram2, e = i ? t.links : t.memberParts, s = this.oo;
      if (i) this.Ri(true);
      else {
        for (; e.next(); ) {
          const n = e.value;
          s.has(n) && (!n.Oe() || n instanceof Group2 || n.nl() && (n.gt(1 / 0, 1 / 0), n.Ut()));
        }
        for (e.reset(); e.next(); ) {
          const n = e.value;
          if (s.has(n) && n instanceof Group2) {
            if (!n.isVisible()) continue;
            this.gb(n);
          }
        }
        e.reset();
      }
      for (; e.next(); ) {
        const n = e.value;
        n instanceof Link2 && s.has(n) && n.isVisible() && n.nl() && (n.gt(1 / 0, 1 / 0), n.Ut());
      }
    }
    gb(t) {
      const i = U.ft(), e = U.ft(), s = t.memberParts;
      for (; s.next(); ) {
        const o = s.value;
        o.isVisible() && (o instanceof Group2 ? (o.Wo() || o.us() || o.yh()) && this.gb(o) : o instanceof Link2 ? o.fromNode === t || o.toNode === t ? e.push(o) : i.push(o) : (o.gt(1 / 0, 1 / 0), o.Ut()));
      }
      let n = i.length;
      for (let o = 0; o < n; o++) {
        const r = i[o];
        r.gt(1 / 0, 1 / 0), r.Ut();
      }
      U.et(i), t.gt(1 / 0, 1 / 0), t.Ut(), n = e.length;
      for (let o = 0; o < n; o++) {
        const r = e[o];
        r.gt(1 / 0, 1 / 0), r.Ut();
      }
      U.et(e);
    }
    Is(t, i, e, s) {
      if (!(!this.rc && !this.animationManager.isAnimating)) {
        for (let n = 0; n < i; n++) t[n].Is(e, s);
        this.Ri();
      }
    }
    vi(t) {
      if (this.Tt === null) return;
      this.ht === null && U.n("No canvas specified"), this.oc === "svg" ? this.DO(t) : this.FO(t);
    }
    FO(t) {
      const i = this.animationManager;
      if (i.Mi || i.isAnimating && !i.isTicking) return;
      const e = /* @__PURE__ */ new Date();
      if (this.F0(), this.Tt && this.Tt.style.opacity === "0") return;
      const s = t !== this._t, n = this.Ht.h, o = n.length, r = this;
      if (this.Is(n, o, r, r.viewportBounds), s) t.clearContextCache(true), this.mh();
      else if (!this.Ze && !i.isAnimating) return;
      const l = this.E, h = this.te;
      t.setTransform(h, 0, 0, h, 0, 0), t.clearRect(0, 0, this.Pt, this.Mt), this.ei !== 1 && (t.globalAlpha = this.ei), this.L2(t);
      for (let m = 0; m < o; m++) t.setTransform(h, 0, 0, h, 0, 0), t.transform(l.m11, l.m12, l.m21, l.m22, l.dx, l.dy), t.commitTransform(), n[m].vi(t, r);
      let f = false;
      this.ac ? this.ac.Aa(this, t) && (f = this.w0()) : f = true, f && (Transform.prototype.De = Transform.prototype.Lu), s ? (this._t.clearContextCache(true), this.mh()) : (this.rc = false, this.Ze = false);
      const c = +/* @__PURE__ */ new Date() - +e, u = Debug && Debug.drawFrames, d = this.p2;
      if (u || this.zl === null) {
        d[this.k0] = c, this.k0 = (this.k0 + 1) % d.length;
        let m = 0;
        for (let g = 0; g < d.length; g++) m += d[g];
        this.S0 = m / d.length;
      }
      if (this.ei !== 1 && (t.globalAlpha = 1), u) {
        t.setTransform(1, 0, 0, 1, 0, 0);
        for (let m = 0; m < d.length; m++) t.fillText(d[m].toString(), 20, 150 + +(m * 20));
      }
    }
    DO(t) {
      if (this.Tt === null) return;
      const i = this.animationManager;
      if (i.Mi || i.isAnimating && !i.isTicking) return;
      this.F0();
      const e = this.Pt, s = this.Mt;
      t.surface.resize(e, s, e, s);
      const o = this.Ht.h, r = o.length, l = this;
      if (this.Is(o, r, l, l.viewportBounds), !this.Ze && !i.isAnimating) return;
      const h = this.E;
      t.lastDrawnPart = null, t.setDiagramPosScale(h.m11, h.m12, h.m21, h.m22, h.dx, h.dy), this.ei !== 1 && (t.globalAlpha = this.ei), this.L2(t);
      const f = this.te, a = this.ht.ni;
      a.setTransform(f, 0, 0, f, 0, 0), a.clearRect(0, 0, this.Pt, this.Mt);
      for (let u = 0; u < r; u++) o[u].vi(t, l);
      let c = false;
      this.ac ? this.ac.Aa(this, a) && (c = this.w0()) : c = true, c && (Transform.prototype.De = Transform.prototype.Lu), this.rc = false, this.Ze = false;
    }
    pb(t, i, e, s, n, o, r, l, h) {
      if (this.Tt === null) return;
      this.ht === null && U.n("No canvas specified"), o === void 0 && (o = null), r === void 0 && (r = null), l === void 0 && (l = false), h === void 0 && (h = false), this.F0(), this._t.clearContextCache(true), this.mh(), this.xa = true;
      const f = this.lt;
      this.lt = s;
      const a = this, c = this.Ht.h, u = c.length;
      try {
        const d = new Rect2(n.x, n.y, e.width / s, e.height / s), m = d.copy();
        m.addMargin(i), this.ph(m), this.Ri(), this.Is(c, u, a, d), t.setTransform(1, 0, 0, 1, 0, 0), t.clearRect(0, 0, e.width, e.height), r !== null && r !== "" && (t.fillStyle = r, t.fillBackground(0, 0, e.width, e.height));
        const g = Transform.a();
        g.Ki(), g.vs(i.left, i.top), g.lt(s), (n.x !== 0 || n.y !== 0) && g.vs(-n.x, -n.y), t.setTransform(g.m11, g.m12, g.m21, g.m22, g.dx, g.dy), t.commitTransform(), t instanceof SVGContext && t.setDiagramPosScale(g.m11, g.m12, g.m21, g.m22, g.dx, g.dy), Transform.o(g), this.L2(t), t.globalAlpha = this.ei;
        const p = this.findLayer("Grid");
        if (o) {
          const y = new GSet2(), x = o.iterator;
          for (x.reset(); x.next(); ) {
            const S = x.value;
            S instanceof Part2 && (!h && S.layer === p || (S.tc(), y.add(S)));
          }
          for (let S = 0; S < u; S++) c[S].UR(t, a, y, l);
          y.each((S) => S.tc());
        } else for (let y = 0; y < u; y++) {
          const x = c[y];
          x === p ? h && x.vi(t, a, true) : x.vi(t, a, l);
        }
        this.xa = false, this.ac && this.ac.Aa(this, this._t) && this.w0();
      } finally {
        this.lt = f, this._t.clearContextCache(true), this.mh(), this.Is(c, u, a, a.viewportBounds), this.ph(), this._t instanceof SVGContext && (this._t.diagramGroup.replaceChildren(), this.redraw());
      }
    }
    getRenderingHint(t) {
      return this.zr[t];
    }
    setRenderingHint(t, i) {
      t === "minDrawingLength" && (this.s0 = i), this.zr[t] = i, this.redraw();
    }
    resetRenderingHints() {
      this.zr = new PropertyCollection(), this.zr.drawShadows = true, this.zr.textGreeking = true, this.zr.viewportOptimizations = !U.wr, this.zr.temporaryPixelRatio = true, this.zr.pictureRatioOptimization = true, this.zr.minDrawingLength = 1, this.s0 = 1;
    }
    L2(t) {
      const i = this.zr;
      if (i === null) return;
      if (i.imageSmoothingEnabled !== void 0) {
        const s = !!i.imageSmoothingEnabled;
        t.setImageSmoothingEnabled(s);
      }
      const e = i.defaultFont;
      e != null && (t.font = e);
    }
    getInputOption(t) {
      return this.ed[t];
    }
    setInputOption(t, i) {
      this.ed[t] = i;
    }
    nO() {
      this.ed = new PropertyCollection(), this.ed.extraTouchArea = 10, this.ed.extraTouchThreshold = 10, this.ed.hasGestureZoom = true;
    }
    set(t) {
      if (!t) return this;
      if (Debug) for (const i in t) (i.startsWith("_") || i.indexOf(".") !== -1) && U.n("Property with underscore or period passed to Diagram.set. Did you mean to use Diagram.assign?");
      return Object.assign(this, t), this;
    }
    attach(t) {
      return this.setProperties(t);
    }
    setProperties(t) {
      return Diagram2.I0(this, t), this;
    }
    static I0(t, i) {
      if (!i) return;
      const e = t instanceof Panel2, s = t instanceof Diagram2;
      for (const n in i) {
        n === "" && U.n("Setting properties requires non-empty property names");
        let o = t, r = n;
        if (e || s) {
          const h = n.indexOf(".");
          if (h > 0) {
            const f = n.substring(0, h);
            e ? o = t.findObject(f) : (o = t[f], o == null && (o = t.toolManager[f])), U.it(o) ? r = n.substring(h + 1) : U.n("Unable to find object named: " + f + " in " + t.toString() + " when trying to set property: " + n);
          }
        }
        if (r[0] !== "_" && !U.$w(o, r)) if (s && r === "ModelChanged") {
          t.addModelChangedListener(i[r]);
          continue;
        } else if (s && r === "Changed") {
          t.addChangedListener(i[r]);
          continue;
        } else if (s && U.$w(t.toolManager, r)) o = t.toolManager;
        else if (s && t.mL(r)) {
          t.addDiagramListener(r, i[r]);
          continue;
        } else if (t instanceof Model2 && r === "Changed") {
          t.addChangedListener(i[r]);
          continue;
        } else U.n('Trying to set undefined property "' + r + '" on object: ' + o.toString());
        const l = i[n];
        o[r] = l, r[0] === "_" && o instanceof GraphObject2 && o.addCopyProperty(r);
      }
    }
    UT() {
      if (this.uh.count !== 0 && !(this.undoManager.transactionLevel > 1)) {
        for (; this.uh.count > 0; ) {
          const t = this.uh;
          this.uh = new GMap2();
          const i = t.iterator;
          for (; i.next(); ) {
            const e = i.key;
            e.invalidateOtherJumpOvers(i.value), e.ie();
          }
        }
        this.L();
      }
    }
    L(t) {
      if (t === void 0) this.Ze = true, this.requestUpdate();
      else {
        const i = this.viewportBounds;
        t.isReal() && i.intersectsRect(t) && (this.Ze = true, this.requestUpdate());
      }
      this.F("InvalidateDraw");
    }
    invalidateViewport(t, i) {
      if (this.Ze === true) return;
      if (this.Ze = true, this.oc === "svg") {
        this.maybeUpdate();
        return;
      }
      this.getRenderingHint("temporaryPixelRatio") === true ? (this.Rx(), this.maybeUpdate(), this.kP(true)) : this.maybeUpdate();
    }
    Ta() {
      this.ld = true;
    }
    mh() {
      this.rc = true;
    }
    F0() {
      this.sd !== false && (this.sd = false, this.aL(this.Pt, this.Mt));
    }
    aL(t, i) {
      this.gh();
      const e = this.te, s = t * e, n = i * e;
      this.ht.resize(s, n, t, i) && (this.Ze = true, this._t.clearContextCache(true));
    }
    cL() {
      const t = this.ht;
      if (t === null || this.hd.isReal()) return true;
      const i = this.Pt, e = this.Mt, s = this.Tt;
      let n = false, o = this.lo ? this.Qt : 0, r = this.An ? this.Qt : 0, l = s.clientWidth || i + o, h = s.clientHeight || e + r;
      const f = this.viewportBounds, a = f.x, c = f.y, u = f.width, d = f.height;
      if ((l !== i + o || h !== e + r) && (this.lo = false, this.An = false, o = 0, r = 0, this.Pt = l, this.Mt = h, this.sd = true, n = true, this.gh()), !this.ho || !this.viewportBounds.isReal()) return true;
      const m = this.nb, g = this.ob;
      if (this.ld = false, !n && !this.lo && !this.An && !this.od && !this.rd) return true;
      const p = this.documentBounds;
      let y = 0, x = 0, S = 0, b = 0;
      const k = f.width, P = f.height, A = this.ga;
      this.contentAlignment.isSpot() ? (p.width > k && (y = A.left, x = A.right), p.height > P && (S = A.top, b = A.bottom)) : (y = A.left, x = A.right, S = A.top, b = A.bottom);
      const C = p.width + y + x, M = p.height + S + b, N = this.scale, L = N;
      let T = C > l / N, D = M > h / N;
      if (!n && !this.lo && !this.An && !T && !D) return true;
      const F = p.x - y, R = f.x, I = p.right + x;
      let O = f.right + o;
      const X = p.y - S, K = f.y, B = p.bottom + b;
      let Y = f.bottom + r, z = "1px", H = "1px";
      if (this.scrollMode === 1 && (T || D)) {
        if (T && this.hasHorizontalScrollbar && this.allowHorizontalScroll) {
          let V = 1;
          F + 1 < R && (V = Math.max((R - F) * N + this.Pt, V)), I > O + 1 && (V = Math.max((I - O) * N + this.Pt, V)), k + o + 1 < C && (V = Math.max((C - k) * N + this.Pt, V)), z = V.toString() + "px";
        }
        if (D && this.hasVerticalScrollbar && this.allowVerticalScroll) {
          let V = 1;
          X + 1 < K && (V = Math.max((K - X) * N + this.Mt, V)), B > Y + 1 && (V = Math.max((B - Y) * N + this.Mt, V)), P + r + 1 < M && (V = Math.max((M - P) * N + this.Mt, V)), H = V.toString() + "px";
        }
      }
      let W = z !== "1px", j = H !== "1px";
      if (!(W && j) && (W || j)) {
        if (T = !(C < k + o), D = !(M < P + r), j && (O -= this.Qt), W && (Y -= this.Qt), T && this.hasHorizontalScrollbar && this.allowHorizontalScroll) {
          let $ = 1;
          F + 1 < R && ($ = Math.max((R - F) * N + this.Pt, $)), I > O + 1 && ($ = Math.max((I - O) * N + this.Pt, $)), k + 1 < C && ($ = Math.max((C - k) * N + this.Pt, $)), z = $.toString() + "px";
        }
        W = z !== "1px";
        let V = this.Mt;
        if (W !== this.An && (V = W ? this.Mt - this.Qt : this.Mt + this.Qt), D && this.hasVerticalScrollbar && this.allowVerticalScroll) {
          let $ = 1;
          X + 1 < K && ($ = Math.max((K - X) * N + V, $)), B > Y + 1 && ($ = Math.max((B - Y) * N + V, $)), P + 1 < M && ($ = Math.max((M - P) * N + V, $)), H = $.toString() + "px";
        }
        j = H !== "1px";
      }
      if (this.c0 && !(W !== this.An || j !== this.lo)) return (i !== this.Pt || e !== this.Mt) && this.maybeUpdate(), false;
      if (W !== this.An && (z === "1px" ? this.Mt = this.Mt + this.Qt : this.Mt = Math.max(this.Mt - this.Qt, 1), n = true), this.An = W, g.style.width = z, j !== this.lo && (H === "1px" ? this.Pt = this.Pt + this.Qt : this.Pt = Math.max(this.Pt - this.Qt, 1), n = true, this.dd)) {
        const V = Point2.a();
        j ? (t.style.left = this.Qt + "px", this.position = V.e(this.yt.x + this.Qt / this.scale, this.yt.y)) : (t.style.left = "0px", this.position = V.e(this.yt.x - this.Qt / this.scale, this.yt.y)), Point2.o(V);
      }
      n && this.gh(), this.lo = j, g.style.height = H, this.J1 = true, n && (this.sd = true);
      let Z = m.scrollLeft;
      if (this.hasHorizontalScrollbar && this.allowHorizontalScroll && (k + 1 < C ? Z = (this.position.x - F) * N : F + 1 < R ? Z = m.scrollWidth - m.clientWidth : I > O + 1 && (Z = this.position.x * N)), this.dd) switch (this.p1) {
        case "negative":
          Z = -(m.scrollWidth - Z - m.clientWidth);
          break;
        case "reverse":
          Z = m.scrollWidth - Z - m.clientWidth;
          break;
      }
      if (m.scrollLeft = Z, this.hasVerticalScrollbar && this.allowVerticalScroll && (P + 1 < M ? m.scrollTop = (this.position.y - X) * N : X + 1 < K ? m.scrollTop = m.scrollHeight - m.clientHeight : B > Y + 1 && (m.scrollTop = this.position.y * N)), l = this.Pt, h = this.Mt, m.style.width = l + (this.lo ? this.Qt : 0) + "px", m.style.height = h + (this.An ? this.Qt : 0) + "px", i !== l || e !== h || this.animationManager.Mi) {
        const V = Rect2.U(a, c, u, d);
        return this.onViewportBoundsChanged(V, this.viewportBounds, L, n), Rect2.o(V), false;
      }
      return true;
    }
    add(t) {
      U.s(t, Part2, Diagram2, "add:part");
      const i = t.diagram;
      if (i === this) return;
      i !== null && U.n("Cannot add part " + t.toString() + " to " + this.toString() + ". It is already a part of " + i.toString());
      let e = this.findLayer(t.layerName);
      if (e === null && (e = this.findLayer("")), e === null && U.n('Cannot add a Part when unable find a Layer named "' + t.layerName + '" and there is no default Layer'), t.layer === e) return;
      const s = e.da(99999999, t, t.diagram === this);
      s >= 0 && this.raiseChangedEvent(3, "parts", e, null, t, null, s), e.isTemporary || this.invalidateDocumentBounds(), t.invalidateLayout(1);
      const n = t.layerChanged;
      n !== null && n(t, null, e);
    }
    da(t) {
      this.partManager.da(t);
      const i = this;
      t.Tn((s) => i.pL(s)), t.data || t.jo(), t.hasPlaceholder() && t.g(), t.data !== null && t.Tn((s) => i.partManager.D2(s, null)), (t.us() === true || t.yh() === true) && this.D0(t), t.yL(true, this), t.wL() ? (t.actualBounds.isReal() && this.L(t.ua(t.actualBounds)), this.invalidateDocumentBounds()) : t.isVisible() && t.actualBounds.isReal() && this.L(t.ua(t.actualBounds)), this.N0 !== null && this.N0(this, t), this.requestUpdate();
    }
    ae(t) {
      t.clearAdornments(), this.partManager.ae(t);
      const i = this;
      t.data !== null && t.Tn((s) => i.partManager.F2(s, i)), this.oo.delete(t), t instanceof Link2 && this.Yr.delete(t), t.wL() ? (t.actualBounds.isReal() && this.L(t.ua(t.actualBounds)), this.invalidateDocumentBounds()) : t.isVisible() && t.actualBounds.isReal() && this.L(t.ua(t.actualBounds)), this.C0 !== null && this.C0(this, t), this.requestUpdate();
    }
    remove(t) {
      U.s(t, Part2, Diagram2, "remove:part"), this.I2(t, true);
    }
    I2(t, i) {
      const e = t.layer;
      if (e === null || e.diagram !== this) return;
      t.isSelected = false, t.isHighlighted = false, t.invalidateLayout(2), i && t.uc();
      const s = e.ae(-1, t, false);
      s >= 0 && this.raiseChangedEvent(4, "parts", e, t, null, s, null);
      const n = t.layerChanged;
      n !== null && n(t, e, null);
    }
    removeParts(t, i) {
      if (i === void 0 && (i = false), Array.isArray(t)) {
        const e = t.length;
        for (let s = 0; s < e; s++) {
          const n = t[s];
          i && !n.canDelete() || this.remove(n);
        }
      } else {
        const e = new GSet2();
        e.addAll(t);
        const s = e.iterator;
        for (; s.next(); ) {
          const n = s.value;
          i && !n.canDelete() || this.remove(n);
        }
      }
    }
    copyParts(t, i, e) {
      e === void 0 && (e = false);
      let s = null;
      const n = i || this, o = n.model;
      let r = false, l = false;
      try {
        o.Um() && (r = o.copiesParentKeyOfNodeData, o.copiesParentKeyOfNodeData = n.commandHandler.copiesParentKey), (o.Km() || o.yb()) && (l = o.copiesGroupKeyOfNodeData, o.copiesGroupKeyOfNodeData = n.commandHandler.copiesGroupKey), s = this.partManager.copyParts(t, i, e);
      } finally {
        o.Um() && (o.copiesParentKeyOfNodeData = r), (o.Km() || o.yb()) && (o.copiesGroupKeyOfNodeData = l);
      }
      return s;
    }
    moveParts(t, i, e, s) {
      if (e === void 0 && (e = false), s === void 0 && (s = this.R0()), U.s(i, Point2, Diagram2, "moveParts:offset"), this.toolManager === null) return;
      const o = new GMap2();
      if (t !== null) if (Array.isArray(t)) for (let r = 0; r < t.length; r++) this.ol(o, t[r], e, s);
      else {
        const r = t.iterator;
        for (; r.next(); ) this.ol(o, r.value, e, s);
      }
      else {
        let r = this.parts;
        for (; r.next(); ) {
          const l = r.value;
          this.ol(o, l, e, s);
        }
        for (r = this.nodes; r.next(); ) {
          const l = r.value;
          this.ol(o, l, e, s);
        }
        for (r = this.links; r.next(); ) {
          const l = r.value;
          this.ol(o, l, e, s);
        }
      }
      this.Ox(o, i, s, e);
    }
    ol(t, i, e, s, n) {
      if (!t.has(i) && (n === void 0 && (n = false), !(e && !n && !i.canMove() && !i.canCopy()))) if (s === void 0 && (s = this.R0()), i instanceof Node2) {
        if (t.set(i, this.Qs(s, i, i.location)), i instanceof Group2 && (i.hasPlaceholder() || s.dragsMembers)) {
          const r = i.memberParts;
          for (; r.next(); ) {
            const l = r.value;
            this.ol(t, l, e, s, s.groupsAlwaysMove);
          }
        }
        const o = i.linksConnected;
        for (; o.next(); ) {
          const r = o.value;
          if (t.has(r)) continue;
          const l = r.fromNode, h = r.toNode;
          l !== null && t.has(l) && h !== null && t.has(h) && this.ol(t, r, e, s);
        }
        if (s.dragsTree) {
          const r = i.findTreeChildrenNodes();
          for (; r.next(); ) {
            const l = r.value;
            this.ol(t, l, e, s);
          }
        }
      } else if (i instanceof Link2) {
        t.set(i, this.Qs(s, i));
        const o = i.labelNodes;
        for (; o.next(); ) {
          const r = o.value;
          this.ol(t, r, e, s);
        }
      } else i instanceof Adornment2 || t.set(i, this.Qs(s, i, i.location));
    }
    Ox(t, i, e, s) {
      if (t === null || (U.s(t, GMap2, Diagram2, "moveParts:parts"), t.count === 0)) return;
      const n = Point2.a(), o = Point2.a();
      o.c(i), isNaN(o.x) && (o.x = 0), isNaN(o.y) && (o.y = 0);
      const r = this.hb;
      r || this.pT(t);
      const l = U.ft(), h = U.ft(), f = t.iterator;
      let a = Point2.a();
      for (; f.next(); ) {
        const g = f.key, p = f.value;
        if (g.Oe()) {
          const y = this.xL(g, t);
          if (y !== null) l.push(new DraggingNodeInfoPair(g, p, y));
          else if (!s || g.canMove()) {
            const x = p.point;
            n.c(x), this.computeMove(g, n.add(o), e, a), g.location = a, p.shifted === void 0 && (p.shifted = new Point2()), p.shifted.c(a.subtract(x));
          }
        } else f.key instanceof Link2 && h.push(new KeyValuePair(f.key, f.value));
      }
      Point2.o(a);
      const c = l.length;
      for (let g = 0; g < c; g++) {
        const p = l[g], y = p.bL.point;
        n.c(y), p.wb.shifted === void 0 && (p.wb.shifted = new Point2()), p.Ve.location = n.add(p.wb.shifted);
      }
      const u = Point2.a(), d = Point2.a(), m = h.length;
      for (let g = 0; g < m; g++) {
        const p = h[g], y = p.key;
        if (y instanceof Link2) {
          if (y.suspendsRouting) {
            y.Br = null;
            const x = y.fromNode, S = y.toNode;
            if (this.draggedLink !== null && e.dragsLink) {
              const b = p.value.point;
              if (y.dragComputation === null) {
                t.set(y, this.Qs(e, y, o));
                const k = o.x - b.x, P = o.y - b.y;
                y.Ar(k, P);
              } else {
                const k = Point2.U(0, 0), P = y.getPoint(0);
                P && P.isReal() && k.c(P), a = Point2.a().c(k).add(o);
                let A = a;
                e.isGridSnapEnabled && (e.isGridSnapRealtime || this.lastInput.up) && (A = Point2.a(), this.uM(y, a, A, e)), a.c(y.dragComputation(y, a, A)).subtract(k), t.set(y, this.Qs(e, y, a));
                const C = a.x - b.x, M = a.y - b.y;
                y.Ar(C, M), Point2.o(k), Point2.o(a), A !== a && Point2.o(A);
              }
            } else {
              if (x !== null) {
                u.c(x.location);
                const b = t.get(x);
                b !== null && u.subtract(b.point);
              }
              if (S !== null) {
                d.c(S.location);
                const b = t.get(S);
                b !== null && d.subtract(b.point);
              }
              if (x !== null && S !== null) if (u.equalsApprox(d)) {
                const b = p.value.point, k = n;
                k.c(u), k.subtract(b), t.set(y, this.Qs(e, y, u)), y.Ar(k.x, k.y);
              } else y.suspendsRouting = false, y.ii();
              else {
                const b = p.value.point;
                let k;
                x !== null ? k = u : S !== null ? k = d : k = o, t.set(y, this.Qs(e, y, k));
                const P = k.x - b.x, A = k.y - b.y;
                y.Ar(P, A);
              }
            }
          } else if (y.fromNode === null || y.toNode === null) {
            const x = p.value.point;
            t.set(y, this.Qs(e, y, o));
            const S = o.x - x.x, b = o.y - x.y;
            y.Ar(S, b);
          }
        }
      }
      Point2.o(n), Point2.o(o), Point2.o(u), Point2.o(d), U.et(l), U.et(h), r || (this.Ri(), this.SP(t));
    }
    computeMove(t, i, e, s) {
      if (s === void 0 && (s = new Point2()), s.c(i), t === null) return s;
      let n = i;
      const o = e.isGridSnapEnabled;
      o && (e.isGridSnapRealtime || this.lastInput.up) && (n = Point2.a(), this.uM(t, i, n, e));
      const r = t.dragComputation !== null ? t.dragComputation(t, i, n) : n, l = t.minLocation;
      let h = l.x;
      isNaN(h) && (h = o ? Math.round(t.location.x * 1e3) / 1e3 : t.location.x);
      let f = l.y;
      isNaN(f) && (f = o ? Math.round(t.location.y * 1e3) / 1e3 : t.location.y);
      const a = t.maxLocation;
      let c = a.x;
      isNaN(c) && (c = o ? Math.round(t.location.x * 1e3) / 1e3 : t.location.x);
      let u = a.y;
      return isNaN(u) && (u = o ? Math.round(t.location.y * 1e3) / 1e3 : t.location.y), s.e(Math.max(h, Math.min(r.x, c)), Math.max(f, Math.min(r.y, u))), n !== i && Point2.o(n), s;
    }
    R0() {
      const t = this.toolManager.findTool("Dragging");
      return t instanceof DraggingTool2 ? t.dragOptions : this.gd;
    }
    uM(t, i, e, s) {
      if (s === void 0 && (s = this.R0()), e.c(i), t === null) return e;
      const n = this.grid, o = s.gridSnapCellSize;
      let r = o.width, l = o.height;
      const h = s.gridSnapOrigin;
      let f = h.x, a = h.y;
      const c = s.gridSnapCellSpot;
      if (n !== null) {
        const d = n.gridCellSize;
        isNaN(r) && (r = d.width), isNaN(l) && (l = d.height);
        const m = n.gridOrigin;
        isNaN(f) && (f = m.x), isNaN(a) && (a = m.y);
      }
      const u = Point2.U(0, 0);
      return u.setSpot(0, 0, r, l, c), G.om(i.x, i.y, f + u.x, a + u.y, r, l, e), Point2.o(u), e;
    }
    pT(t) {
      if (t === null) return;
      this.hb = true;
      const i = t.iterator;
      for (; i.next(); ) {
        const e = i.key;
        e instanceof Link2 && (e.suspendsRouting = true);
      }
    }
    SP(t) {
      if (t === null) return;
      const i = t.iterator;
      for (; i.next(); ) {
        const e = i.key;
        e instanceof Link2 && (e.suspendsRouting = false, e.SL() && e.ii());
      }
      this.hb = false;
    }
    get draggedLink() {
      return this.ab;
    }
    set draggedLink(t) {
      this.ab !== t && (this.ab = t, t !== null && (this.fb = t.fromPort, this.cb = t.toPort));
    }
    get AP() {
      return this.fb;
    }
    set AP(t) {
      this.fb = t;
    }
    get TP() {
      return this.cb;
    }
    set TP(t) {
      this.cb = t;
    }
    xL(t, i) {
      const e = t.containingGroup;
      if (e !== null) {
        let s = this.xL(e, i);
        if (s !== null || (s = i.get(e), s !== null)) return s;
      }
      return null;
    }
    Qs(t, i, e) {
      if (e === void 0) return new DraggingInfo2(Point2.wn);
      let s = t.isGridSnapEnabled;
      return !t.groupsSnapMembers && i.containingGroup !== null && (s = false), s ? new DraggingInfo2(new Point2(Math.round(e.x * 1e3) / 1e3, Math.round(e.y * 1e3) / 1e3)) : new DraggingInfo2(e.copy());
    }
    R2(t, i) {
      if (U.s(t, Layer2, Diagram2, "addLayer:layer"), t.diagram !== null && t.diagram !== this && U.n("Cannot share a Layer with another Diagram: " + t + " of " + t.diagram), i === null ? t.diagram !== null && U.n("Cannot add an existing Layer to this Diagram again: " + t) : (U.s(i, Layer2, Diagram2, "addLayer:existingLayer"), i.diagram !== this && U.n("Existing Layer must be in this Diagram: " + i + " not in " + i.diagram), t === i && U.n("Cannot move a Layer before or after itself: " + t)), t.diagram === this) return;
      const e = t.name, s = this.Ht, n = s.count;
      for (let o = 0; o < n; o++) s.elt(o).name === e && U.n("Cannot add Layer with the name '" + e + "'; a Layer with the same name is already present in this Diagram.");
    }
    addLayer(t) {
      this.R2(t, null), t.Ko(this);
      const i = this.Ht;
      let e = i.count - 1;
      if (!t.isTemporary) for (; e >= 0 && i.elt(e).isTemporary; ) e--;
      return i.insertAt(e + 1, t), this.Di !== null && this.raiseChangedEvent(3, "layers", this, null, t, null, e + 1), this.L(), this.invalidateDocumentBounds(), this;
    }
    addLayerBefore(t, i) {
      this.R2(t, i), t.Ko(this);
      const e = this.Ht, s = e.indexOf(t);
      s >= 0 && (e.delete(t), this.Di !== null && this.raiseChangedEvent(4, "layers", this, t, null, s, null));
      const n = e.count;
      let o;
      for (o = 0; o < n; o++) if (e.elt(o) === i) {
        e.insertAt(o, t);
        break;
      }
      return this.Di !== null && this.raiseChangedEvent(3, "layers", this, null, t, null, o), this.L(), s < 0 && this.invalidateDocumentBounds(), this;
    }
    addLayerAfter(t, i) {
      this.R2(t, i), t.Ko(this);
      const e = this.Ht, s = e.indexOf(t);
      s >= 0 && (e.delete(t), this.Di !== null && this.raiseChangedEvent(4, "layers", this, t, null, s, null));
      const n = e.count;
      let o;
      for (o = 0; o < n; o++) if (e.elt(o) === i) {
        e.insertAt(o + 1, t);
        break;
      }
      return this.Di !== null && this.raiseChangedEvent(3, "layers", this, null, t, null, o + 1), this.L(), s < 0 && this.invalidateDocumentBounds(), this;
    }
    sl(t, i) {
      t.Ko(this), this.Ht.insertAt(i, t);
    }
    kL(t) {
      this.Ht.removeAt(t);
    }
    removeLayer(t) {
      if (U.s(t, Layer2, Diagram2, "removeLayer:layer"), t.diagram !== this && U.n("Cannot remove a Layer from another Diagram: " + t + " of " + t.diagram), t.name === "") return;
      const i = this.Ht, e = i.indexOf(t);
      if (i.delete(t)) {
        const n = t.Ft.copy().iterator;
        for (; n.next(); ) {
          const o = n.value, r = o.layerName;
          r !== t.name ? o.layerName = r : o.layerName = "";
        }
        this.Di !== null && this.raiseChangedEvent(4, "layers", this, t, null, e, null), this.L(), this.invalidateDocumentBounds();
      }
    }
    findLayer(t) {
      const i = this.layers;
      for (; i.next(); ) {
        const e = i.value;
        if (e.name === t) return e;
      }
      return null;
    }
    findRouter(t) {
      for (const i of this.fc) if (i.name === t) return i;
      return null;
    }
    addModelChangedListener(t) {
      return U.C(t, Diagram2, "addModelChangedListener:listener"), this.ro === null && (this.ro = new List2()), this.ro.add(t), this.model && this.model.addChangedListener(t), this;
    }
    removeModelChangedListener(t) {
      U.C(t, Diagram2, "removeModelChangedListener:listener"), this.ro !== null && (this.ro.delete(t), this.ro.count === 0 && (this.ro = null)), this.model.removeChangedListener(t);
    }
    addChangedListener(t) {
      return U.C(t, Diagram2, "addChangedListener:listener"), this.Kr === null && (this.Kr = new List2()), this.Kr.add(t), this;
    }
    removeChangedListener(t) {
      U.C(t, Diagram2, "removeChangedListener:listener"), this.Kr !== null && (this.Kr.delete(t), this.Kr.count === 0 && (this.Kr = null));
    }
    O2(t) {
      if (!this.skipsUndoManager && !this.model.skipsUndoManager && this.model.undoManager.handleChanged(t), t.change !== 1 && (this.isModified = true), this.Kr !== null) {
        const i = this.Kr, e = i.length;
        for (let s = 0; s < e; s++) i.elt(s)(t);
      }
    }
    raiseChangedEvent(t, i, e, s, n, o, r) {
      o === void 0 && (o = null), r === void 0 && (r = null);
      const l = new ChangedEvent2();
      l.diagram = this, l.change = t, l.propertyName = i, l.object = e, l.oldValue = s, l.oldParam = o, l.newValue = n, l.newParam = r, this.O2(l);
    }
    raiseChanged(t, i, e, s, n) {
      this.raiseChangedEvent(2, t, this, i, e, s, n);
    }
    t(t, i, e, s, n) {
      this.raiseChangedEvent(2, t, this, i, e, s, n);
    }
    get partAdded() {
      return this.N0;
    }
    set partAdded(t) {
      this.partAdded !== t && (this.N0 = t);
    }
    get partRemoved() {
      return this.C0;
    }
    set partRemoved(t) {
      this.partRemoved !== t && (this.C0 = t);
    }
    get animationManager() {
      return this.Ls;
    }
    get undoManager() {
      return this.Di.undoManager;
    }
    get skipsUndoManager() {
      return this.qo;
    }
    set skipsUndoManager(t) {
      U.i(t, "boolean", Diagram2, "skipsUndoManager"), this.qo = t, this.Di.skipsUndoManager = t;
    }
    get delaysLayout() {
      return this.z1;
    }
    set delaysLayout(t) {
      this.z1 = t;
    }
    nT(t, i) {
      if (t === null || t.diagram !== this) return;
      const e = this.be;
      try {
        this.be = true;
        const s = t.change;
        if (s === 2) {
          const n = t.object, o = t.propertyName, r = t.getValue(i);
          if (t.diagram.model.rt(n, o, r), n instanceof GraphObject2) {
            const l = n.part;
            l !== null && l.invalidateAdornments();
          }
          this.isModified = true;
        } else if (s === 3) {
          const n = t.object, o = t.newParam, r = t.newValue;
          if (n instanceof Panel2) if (typeof o == "number" && r instanceof GraphObject2) {
            i ? n.ae(o) : n.insertAt(o, r);
            const l = n.part;
            l !== null && l.invalidateAdornments();
          } else typeof o == "number" && r instanceof RowColumnDefinition2 && (r.isRow ? n.PL(o, i ? void 0 : r) : n.ML(o, i ? void 0 : r));
          else if (n instanceof Layer2) {
            const l = t.oldParam === true;
            typeof o == "number" && r instanceof Part2 && (i ? (l || (r.isSelected = false, r.isHighlighted = false, r.invalidateAdornments()), n.ae(l ? o : -1, r, l)) : n.da(o, r, l));
          } else n instanceof Diagram2 ? typeof o == "number" && r instanceof Layer2 && (i ? this.kL(o) : this.sl(r, o)) : U.n("unknown ChangeType.Insert object: " + t.toString());
          this.isModified = true;
        } else if (s === 4) {
          const n = t.object, o = t.oldParam, r = t.oldValue;
          if (n instanceof Panel2) typeof o == "number" && r instanceof GraphObject2 ? i ? n.insertAt(o, r) : n.ae(o) : typeof o == "number" && r instanceof RowColumnDefinition2 && (r.isRow ? n.PL(o, i ? r : void 0) : n.ML(o, i ? r : void 0));
          else if (n instanceof Layer2) {
            const l = t.newParam === true;
            typeof o == "number" && r instanceof Part2 && (i ? n.Ft.indexOf(r) < 0 && n.da(o, r, l) : (l || (r.isSelected = false, r.isHighlighted = false, r.invalidateAdornments()), n.ae(l ? o : -1, r, l)));
          } else n instanceof Diagram2 ? typeof o == "number" && r instanceof Layer2 && (i ? this.sl(r, o) : this.kL(o)) : U.n("unknown ChangeType.Remove object: " + t.toString());
          this.isModified = true;
        } else s === 1 || U.n("unknown ChangedEvent: " + t.toString());
      } finally {
        this.be = e;
      }
    }
    startTransaction(t) {
      return this.undoManager.startTransaction(t);
    }
    commitTransaction(t) {
      return this.undoManager.commitTransaction(t);
    }
    rollbackTransaction() {
      return this.undoManager.rollbackTransaction();
    }
    commit(t, i) {
      let e = i;
      e === void 0 && (e = "");
      const s = this.skipsUndoManager;
      e === null && (this.skipsUndoManager = true, e = ""), this.undoManager.startTransaction(e);
      let n = false;
      try {
        t(this), n = true;
      } finally {
        n ? this.undoManager.commitTransaction(e) : this.undoManager.rollbackTransaction(), this.skipsUndoManager = s;
      }
    }
    updateAllTargetBindings(t) {
      this.partManager.updateAllTargetBindings(t);
    }
    updateAllThemeBindings() {
      if (this.partManager.updateAllThemeBindings(), this.cs !== null) {
        const t = this.cs.part;
        t !== null && t.jo();
      }
    }
    setDivBackground(t) {
      this.div && (this.div.style.backgroundColor = t);
    }
    updateAllRelationshipsFromData() {
      this.partManager.updateAllRelationshipsFromData();
    }
    L0() {
      const t = this.E, i = this.lt, e = this.yt;
      t.Ki(), i !== 1 && t.lt(i), (e.x !== 0 || e.y !== 0) && t.vs(-e.x, -e.y);
    }
    NL(t, i) {
      const e = this.animationManager;
      if (this.$t || this.Rs) {
        this.lt = i, this.gh(), this.L(), this.Ta(), e.YT(t, this.lt), this.L0();
        return;
      }
      if (this.ht === null) {
        this.lt = i, this.L0();
        return;
      }
      this.$t = true;
      const n = this.viewportBounds.copy(), o = this.Pt, r = this.Mt;
      let l = this.zoomPoint.x, h = this.zoomPoint.y;
      const f = this.contentAlignment;
      isNaN(l) && (f.isSide() ? f.includesSide(Spot2.LeftSide) ? l = 0 : f.includesSide(Spot2.RightSide) && (l = o - 1) : f.isSpot() ? l = f.x * (o - 1) : l = o / 2), isNaN(h) && (f.isSide() ? f.includesSide(Spot2.TopSide) ? h = 0 : f.includesSide(Spot2.BottomSide) && (h = r - 1) : f.isSpot() ? h = f.y * (r - 1) : h = r / 2), this.scaleComputation !== null && !this.animationManager.defaultAnimation.isAnimating && (i = this.scaleComputation(this, i)), i < this.minScale && (i = this.minScale), i > this.maxScale && (i = this.maxScale);
      const a = Point2.U(this.yt.x + l / t - l / i, this.yt.y + h / t - h / i);
      this.position = a, Point2.o(a), this.lt = i, this.L0(), this.gh(), this.$t = false, this.onViewportBoundsChanged(n, this.viewportBounds, t, false), this.tn(false), e.YT(t, this.lt), this.L();
    }
    PO() {
      const t = this.Ht.h;
      for (let i = 0; i < t.length; i++) t[i].WT();
    }
    onViewportBoundsChanged(t, i, e, s) {
      if (t.equals(i)) return;
      s === void 0 && (s = false), s || this.Ta(), this.mh();
      const n = this.layout;
      n !== null && n.isViewportSized && this.autoScale === 1 && (t.width !== i.width || t.height !== i.height) && n.b();
      const o = this.currentTool;
      this.hc === true && o instanceof ToolManager2 && !this.animationManager.isTicking && (this.lastInput.documentPoint = this.transformViewToDoc(this.lastInput.viewPoint), o.gT(this)), this.$t || this.invalidateViewport(t, i), this.ph(), this.Wi.scale = e, this.Wi.position.x = t.x, this.Wi.position.y = t.y, this.Wi.bounds.c(t), this.Wi.canvasSize.width = Math.round(t.width * e), this.Wi.canvasSize.height = Math.round(t.height * e), this.Wi.newCanvasSize.width = this.Pt, this.Wi.newCanvasSize.height = this.Mt, this.Wi.isScroll = s, this.F("ViewportBoundsChanged", this.Wi, t), this.isVirtualized && this.links.each((r) => {
        r.isAvoiding && r.actualBounds.intersectsRect(i) && r.ii();
      });
    }
    ph(t) {
      const i = this.cs;
      if (i === null || !i.visible || i.part === null || i.layer === null) return;
      const e = t !== void 0 ? t : this._1;
      if (!e.isReal()) return;
      const s = e.width, n = e.height;
      if (i.scale = 1, i.angle = 0, i.layer.isViewportAligned) i.width = s * this.scale, i.height = n * this.scale, i.part.alignment = Spot2.TopLeft;
      else {
        i.Ni === null && (i.Ni = new GridPanelSettings());
        const o = i.Ni.dc;
        if (!o.isReal()) return;
        i.width = s + o.width * 2, i.height = n + o.height * 2;
        const r = Point2.a();
        G.om(e.x, e.y, 0, 0, o.width, o.height, r), r.offset(-o.width, -o.height), i.part.location = r, Point2.o(r);
      }
    }
    clearSelection(t) {
      t === void 0 && (t = false);
      const i = this.selection;
      if (i.count === 0) return;
      t || this.F("ChangingSelection", i);
      const e = i.toArray(), s = e.length;
      for (let n = 0; n < s; n++) {
        const o = e[n];
        o.isSelected = false;
      }
      i.di(), i.clear(), i.S(), t || this.F("ChangedSelection", i);
    }
    select(t) {
      t !== null && (U.s(t, Part2, Diagram2, "select:part"), t.diagram === this && (!t.isSelected || this.selection.count > 1) && (this.F("ChangingSelection", this.selection), this.clearSelection(true), t.isSelected = true, this.F("ChangedSelection", this.selection)));
    }
    selectCollection(t) {
      if (this.F("ChangingSelection", this.selection), this.clearSelection(true), Array.isArray(t)) {
        const i = t.length;
        for (let e = 0; e < i; e++) {
          const s = t[e];
          s instanceof Part2 || U.n("Diagram.selectCollection given something that is not a Part: " + s), s.isSelected = true;
        }
      } else {
        const i = t.iterator;
        for (; i.next(); ) {
          const e = i.value;
          e instanceof Part2 || U.n("Diagram.selectCollection given something that is not a Part: " + e), e.isSelected = true;
        }
      }
      this.F("ChangedSelection", this.selection);
    }
    clearHighlighteds() {
      const t = this.highlighteds;
      if (t.count > 0) {
        const i = t.toArray(), e = i.length;
        for (let s = 0; s < e; s++) {
          const n = i[s];
          n.isHighlighted = false;
        }
        t.di(), t.clear(), t.S();
      }
    }
    highlight(t) {
      t !== null && t.diagram === this && (U.s(t, Part2, Diagram2, "highlight:part"), (!t.isHighlighted || this.highlighteds.count > 1) && (this.clearHighlighteds(), t.isHighlighted = true));
    }
    highlightCollection(t) {
      const i = new GSet2().addAll(t), s = this.highlighteds.copy().removeAll(i).iterator;
      for (; s.next(); ) {
        const o = s.value;
        o.isHighlighted = false;
      }
      const n = i.iterator;
      for (; n.next(); ) {
        const o = n.value;
        o instanceof Part2 || U.n("Diagram.highlightCollection given something that is not a Part: " + o), o.isHighlighted = true;
      }
    }
    scroll(t, i, e) {
      e === void 0 && (e = 1);
      const s = i === "up" || i === "down";
      let n = 0;
      const o = Point2.a();
      if (t === "pixel") n = e;
      else if (t === "line") n = e * (s ? this.scrollVerticalLineChange : this.scrollHorizontalLineChange);
      else if (t === "page") {
        let l = s ? this.viewportBounds.height : this.viewportBounds.width;
        if (l *= this.scale, l !== 0) {
          const h = Math.max(l - (s ? this.scrollVerticalLineChange : this.scrollHorizontalLineChange), 0);
          n = e * h;
        }
      } else if (t === "document") {
        const l = this.documentBounds, h = this.viewportBounds;
        i === "up" ? this.position = o.e(h.x, l.y) : i === "left" ? this.position = o.e(l.x, h.y) : i === "down" ? this.position = o.e(h.x, l.bottom - h.height) : i === "right" && (this.position = o.e(l.right - h.width, h.y)), Point2.o(o);
        return;
      } else U.n("scrolling unit must be 'pixel', 'line', 'page', or 'document', not: " + t);
      n /= this.scale;
      const r = this.position;
      i === "up" ? this.position = o.e(r.x, r.y - n) : i === "down" ? this.position = o.e(r.x, r.y + n) : i === "left" ? this.position = o.e(r.x - n, r.y) : i === "right" ? this.position = o.e(r.x + n, r.y) : U.n("scrolling direction must be 'up', 'down', 'left', or 'right', not: " + i), Point2.o(o);
    }
    scrollToRect(t) {
      const i = this.viewportBounds;
      if (i.containsRect(t)) return;
      const e = t.center;
      e.x -= i.width / 2, e.y -= i.height / 2, this.position = e;
    }
    centerRect(t) {
      const i = this.viewportBounds, e = t.center;
      e.x -= i.width / 2, e.y -= i.height / 2, this.position = e;
    }
    transformDocToView(t) {
      return t.copy().E(this.E);
    }
    transformViewToDoc(t) {
      return t.copy().je(this.E);
    }
    JR(t) {
      return t.je(this.E);
    }
    static None = 1;
    static Uniform = 2;
    static UniformToFill = 3;
    static CycleAll = 1;
    static CycleNotDirected = 2;
    static CycleNotDirectedFast = 3;
    static CycleNotUndirected = 4;
    static CycleDestinationTree = 5;
    static CycleSourceTree = 6;
    static DocumentScroll = 1;
    static InfiniteScroll = 2;
    static TreeParentCollapsed = 1;
    static AllParentsCollapsed = 2;
    static AnyParentsCollapsed = 3;
    get opacity() {
      return this.ei;
    }
    set opacity(t) {
      const i = this.ei;
      i !== t && (U.i(t, "number", Diagram2, "opacity"), (t < 0 || t > 1) && U.G(t, "0 <= value <= 1", Diagram2, "opacity"), this.ei = t, this.t("opacity", i, t), this.L());
    }
    get validCycle() {
      return this.I1;
    }
    set validCycle(t) {
      const i = this.I1;
      i !== t && (U.W(t, CycleMode2, "CycleMode"), this.I1 = t, this.t("validCycle", i, t));
    }
    get layers() {
      return this.Ht.iterator;
    }
    get isModelReadOnly() {
      const t = this.Di;
      return t === null ? false : t.isReadOnly;
    }
    set isModelReadOnly(t) {
      const i = this.Di;
      i !== null && (i.isReadOnly = t);
    }
    get isReadOnly() {
      return this.Ho;
    }
    set isReadOnly(t) {
      const i = this.Ho;
      i !== t && (U.i(t, "boolean", Diagram2, "isReadOnly"), this.Ho = t, this.t("isReadOnly", i, t));
    }
    get isEnabled() {
      return this.Gi;
    }
    set isEnabled(t) {
      const i = this.Gi;
      i !== t && (U.i(t, "boolean", Diagram2, "isEnabled"), this.Gi = t, this.t("isEnabled", i, t));
    }
    get allowClipboard() {
      return this.X1;
    }
    set allowClipboard(t) {
      const i = this.X1;
      i !== t && (U.i(t, "boolean", Diagram2, "allowClipboard"), this.X1 = t, this.t("allowClipboard", i, t));
    }
    get allowCopy() {
      return this.Wl;
    }
    set allowCopy(t) {
      const i = this.Wl;
      i !== t && (U.i(t, "boolean", Diagram2, "allowCopy"), this.Wl = t, this.t("allowCopy", i, t));
    }
    get allowDelete() {
      return this.jl;
    }
    set allowDelete(t) {
      const i = this.jl;
      i !== t && (U.i(t, "boolean", Diagram2, "allowDelete"), this.jl = t, this.t("allowDelete", i, t));
    }
    get allowDragOut() {
      return this.Y1;
    }
    set allowDragOut(t) {
      const i = this.Y1;
      i !== t && (U.i(t, "boolean", Diagram2, "allowDragOut"), this.Y1 = t, this.t("allowDragOut", i, t));
    }
    get allowDrop() {
      return this.K1;
    }
    set allowDrop(t) {
      const i = this.K1;
      i !== t && (U.i(t, "boolean", Diagram2, "allowDrop"), this.K1 = t, this.t("allowDrop", i, t));
    }
    get allowTextEdit() {
      return this.Jl;
    }
    set allowTextEdit(t) {
      const i = this.Jl;
      i !== t && (U.i(t, "boolean", Diagram2, "allowTextEdit"), this.Jl = t, this.t("allowTextEdit", i, t));
    }
    get allowGroup() {
      return this.$l;
    }
    set allowGroup(t) {
      const i = this.$l;
      i !== t && (U.i(t, "boolean", Diagram2, "allowGroup"), this.$l = t, this.t("allowGroup", i, t));
    }
    get allowUngroup() {
      return this.Zl;
    }
    set allowUngroup(t) {
      const i = this.Zl;
      i !== t && (U.i(t, "boolean", Diagram2, "allowUngroup"), this.Zl = t, this.t("allowUngroup", i, t));
    }
    get allowInsert() {
      return this.U1;
    }
    set allowInsert(t) {
      const i = this.U1;
      i !== t && (U.i(t, "boolean", Diagram2, "allowInsert"), this.U1 = t, this.t("allowInsert", i, t));
    }
    get allowLink() {
      return this.Ql;
    }
    set allowLink(t) {
      const i = this.Ql;
      i !== t && (U.i(t, "boolean", Diagram2, "allowLink"), this.Ql = t, this.t("allowLink", i, t));
    }
    get allowRelink() {
      return this._l;
    }
    set allowRelink(t) {
      const i = this._l;
      i !== t && (U.i(t, "boolean", Diagram2, "allowRelink"), this._l = t, this.t("allowRelink", i, t));
    }
    get allowMove() {
      return this.th;
    }
    set allowMove(t) {
      const i = this.th;
      i !== t && (U.i(t, "boolean", Diagram2, "allowMove"), this.th = t, this.t("allowMove", i, t));
    }
    get allowReshape() {
      return this.ih;
    }
    set allowReshape(t) {
      const i = this.ih;
      i !== t && (U.i(t, "boolean", Diagram2, "allowReshape"), this.ih = t, this.t("allowReshape", i, t));
    }
    get allowResize() {
      return this.eh;
    }
    set allowResize(t) {
      const i = this.eh;
      i !== t && (U.i(t, "boolean", Diagram2, "allowResize"), this.eh = t, this.t("allowResize", i, t));
    }
    get allowRotate() {
      return this.nh;
    }
    set allowRotate(t) {
      const i = this.nh;
      i !== t && (U.i(t, "boolean", Diagram2, "allowRotate"), this.nh = t, this.t("allowRotate", i, t));
    }
    get allowSelect() {
      return this.oh;
    }
    set allowSelect(t) {
      const i = this.oh;
      i !== t && (U.i(t, "boolean", Diagram2, "allowSelect"), this.oh = t, this.t("allowSelect", i, t));
    }
    get allowUndo() {
      return this.G1;
    }
    set allowUndo(t) {
      const i = this.G1;
      i !== t && (U.i(t, "boolean", Diagram2, "allowUndo"), this.G1 = t, this.t("allowUndo", i, t));
    }
    get allowZoom() {
      return this.q1;
    }
    set allowZoom(t) {
      const i = this.q1;
      i !== t && (U.i(t, "boolean", Diagram2, "allowZoom"), this.q1 = t, this.t("allowZoom", i, t));
    }
    get hasVerticalScrollbar() {
      return this.rd;
    }
    set hasVerticalScrollbar(t) {
      const i = this.rd;
      i !== t && (U.i(t, "boolean", Diagram2, "hasVerticalScrollbar"), this.rd = t, this.Ta(), this.L(), this.t("hasVerticalScrollbar", i, t), this.tn(false));
    }
    get hasHorizontalScrollbar() {
      return this.od;
    }
    set hasHorizontalScrollbar(t) {
      const i = this.od;
      i !== t && (U.i(t, "boolean", Diagram2, "hasHorizontalScrollbar"), this.od = t, this.Ta(), this.L(), this.t("hasHorizontalScrollbar", i, t), this.tn(false));
    }
    get allowHorizontalScroll() {
      return this.H1;
    }
    set allowHorizontalScroll(t) {
      const i = this.H1;
      i !== t && (U.i(t, "boolean", Diagram2, "allowHorizontalScroll"), this.H1 = t, this.t("allowHorizontalScroll", i, t), this.tn(false));
    }
    get allowVerticalScroll() {
      return this.v1;
    }
    set allowVerticalScroll(t) {
      const i = this.v1;
      i !== t && (U.i(t, "boolean", Diagram2, "allowVerticalScroll"), this.v1 = t, this.t("allowVerticalScroll", i, t), this.tn(false));
    }
    get scrollHorizontalLineChange() {
      return this.W1;
    }
    set scrollHorizontalLineChange(t) {
      const i = this.W1;
      i !== t && (U.i(t, "number", Diagram2, "scrollHorizontalLineChange"), t < 0 && U.G(t, ">= 0", Diagram2, "scrollHorizontalLineChange"), this.W1 = t, this.t("scrollHorizontalLineChange", i, t));
    }
    get scrollVerticalLineChange() {
      return this.j1;
    }
    set scrollVerticalLineChange(t) {
      const i = this.j1;
      i !== t && (U.i(t, "number", Diagram2, "scrollVerticalLineChange"), t < 0 && U.G(t, ">= 0", Diagram2, "scrollVerticalLineChange"), this.j1 = t, this.t("scrollVerticalLineChange", i, t));
    }
    get lastInput() {
      return this.ya;
    }
    set lastInput(t) {
      Debug && U.s(t, InputEvent2, Diagram2, "lastInput"), this.ya = t;
    }
    get previousInput() {
      return this.tl;
    }
    set previousInput(t) {
      Debug && U.s(t, InputEvent2, Diagram2, "previousInput"), this.tl = t;
    }
    get firstInput() {
      return this.p0;
    }
    set firstInput(t) {
      Debug && U.s(t, InputEvent2, Diagram2, "firstInput"), this.p0 = t;
    }
    get currentCursor() {
      return this.R1;
    }
    set currentCursor(t) {
      if (t === "" && (t = this.f0), this.R1 !== t) {
        U.i(t, "string", Diagram2, "currentCursor");
        const e = this.ht, s = this.Tt;
        if (e === null || s === null) return;
        this.R1 = t;
        const n = e.style.cursor;
        e.style.cursor = t, s.style.cursor = t, e.style.cursor === n && (e.style.cursor = "-webkit-" + t, s.style.cursor = "-webkit-" + t, e.style.cursor === n && (e.style.cursor = "-moz-" + t, s.style.cursor = "-moz-" + t, e.style.cursor === n && (e.style.cursor = t, s.style.cursor = t)));
      }
    }
    get defaultCursor() {
      return this.f0;
    }
    set defaultCursor(t) {
      t === "" && (t = "auto");
      const i = this.f0;
      i !== t && (U.i(t, "string", Diagram2, "defaultCursor"), this.f0 = t, this.t("defaultCursor", i, t));
    }
    get click() {
      return this.Ur;
    }
    set click(t) {
      const i = this.Ur;
      i !== t && (t !== null && U.C(t, Diagram2, "click"), this.Ur = t, this.t("click", i, t));
    }
    get doubleClick() {
      return this.Gr;
    }
    set doubleClick(t) {
      const i = this.Gr;
      i !== t && (t !== null && U.C(t, Diagram2, "doubleClick"), this.Gr = t, this.t("doubleClick", i, t));
    }
    get contextClick() {
      return this.qr;
    }
    set contextClick(t) {
      const i = this.qr;
      i !== t && (t !== null && U.C(t, Diagram2, "contextClick"), this.qr = t, this.t("contextClick", i, t));
    }
    get mouseOver() {
      return this.Hr;
    }
    set mouseOver(t) {
      const i = this.Hr;
      i !== t && (t !== null && U.C(t, Diagram2, "mouseOver"), this.Hr = t, this.t("mouseOver", i, t));
    }
    get mouseHover() {
      return this.vr;
    }
    set mouseHover(t) {
      const i = this.vr;
      i !== t && (t !== null && U.C(t, Diagram2, "mouseHover"), this.vr = t, this.t("mouseHover", i, t));
    }
    get mouseHold() {
      return this.Wr;
    }
    set mouseHold(t) {
      const i = this.Wr;
      i !== t && (t !== null && U.C(t, Diagram2, "mouseHold"), this.Wr = t, this.t("mouseHold", i, t));
    }
    get mouseDragOver() {
      return this.O1;
    }
    set mouseDragOver(t) {
      const i = this.O1;
      i !== t && (t !== null && U.C(t, Diagram2, "mouseDragOver"), this.O1 = t, this.t("mouseDragOver", i, t));
    }
    get mouseDrop() {
      return this.jr;
    }
    set mouseDrop(t) {
      const i = this.jr;
      i !== t && (Debug && t !== null && U.C(t, Diagram2, "mouseDrop"), this.jr = t, this.t("mouseDrop", i, t));
    }
    get handlesDragDropForTopLevelParts() {
      return this.E1;
    }
    set handlesDragDropForTopLevelParts(t) {
      const i = this.E1;
      i !== t && (U.i(t, "boolean", Diagram2, "handlesDragDropForTopLevelParts"), this.E1 = t, this.t("handlesDragDropForTopLevelParts", i, t));
    }
    get mouseEnter() {
      return this.Jr;
    }
    set mouseEnter(t) {
      const i = this.Jr;
      i !== t && (t !== null && U.C(t, Diagram2, "mouseEnter"), this.Jr = t, this.t("mouseEnter", i, t));
    }
    get mouseLeave() {
      return this.$r;
    }
    set mouseLeave(t) {
      const i = this.$r;
      i !== t && (t !== null && U.C(t, Diagram2, "mouseLeave"), this.$r = t, this.t("mouseLeave", i, t));
    }
    get toolTip() {
      return this.Zr;
    }
    set toolTip(t) {
      const i = this.Zr;
      i !== t && (Debug && t !== null && !(t instanceof Adornment2 || t instanceof HTMLInfo2) && U.n("Diagram.toolTip must be an Adornment or HTMLInfo."), this.Zr = t, this.t("toolTip", i, t));
    }
    get contextMenu() {
      return this.Qr;
    }
    set contextMenu(t) {
      const i = this.Qr;
      i !== t && (Debug && !(t instanceof Adornment2 || t instanceof HTMLInfo2) && U.n("Diagram.contextMenu must be an Adornment or HTMLInfo."), this.Qr = t, this.t("contextMenu", i, t));
    }
    get commandHandler() {
      return this.ZM;
    }
    set commandHandler(t) {
      const i = this.ZM;
      i !== t && (U.s(t, CommandHandler2, Diagram2, "commandHandler"), i && i.doStop(), this.ZM = t, t.Ko(this), t.doStart());
    }
    get toolManager() {
      return this.jM;
    }
    set toolManager(t) {
      this.jM !== t && (U.s(t, ToolManager2, Diagram2, "toolManager"), this.jM = t, t.diagram = this);
    }
    get defaultTool() {
      return this.JM;
    }
    set defaultTool(t) {
      const i = this.JM;
      i !== t && (U.s(t, Tool2, Diagram2, "defaultTool"), this.JM = t, t.diagram = this, this.currentTool === i && (this.currentTool = t));
    }
    get currentTool() {
      return this.$M;
    }
    set currentTool(t) {
      const i = this.$M;
      i && (i.isActive && i.doDeactivate(), i.cancelWaitAfter(), i.doStop()), t === null && (t = this.defaultTool), t !== null && (U.s(t, Tool2, Diagram2, "currentTool"), this.$M = t, t.diagram = this, t.doStart());
    }
    get selection() {
      return this.jT;
    }
    get maxSelectionCount() {
      return this.Q1;
    }
    set maxSelectionCount(t) {
      const i = this.Q1;
      if (i !== t) if (U.i(t, "number", Diagram2, "maxSelectionCount"), t >= 0 && !isNaN(t)) {
        if (this.Q1 = t, this.t("maxSelectionCount", i, t), !this.undoManager.isUndoingRedoing) {
          const e = this.selection.count - t;
          if (e > 0) {
            this.F("ChangingSelection", this.selection);
            const s = this.selection.toArray();
            for (let n = 0; n < e; n++) s[n].isSelected = false;
            this.F("ChangedSelection", this.selection);
          }
        }
      } else U.G(t, ">= 0", Diagram2, "maxSelectionCount");
    }
    get nodeSelectionAdornmentTemplate() {
      return this.g0;
    }
    set nodeSelectionAdornmentTemplate(t) {
      const i = this.g0;
      i !== t && (U.s(t, Adornment2, Diagram2, "nodeSelectionAdornmentTemplate"), this.g0 = t.Yt(), this.t("nodeSelectionAdornmentTemplate", i, t));
    }
    get groupSelectionAdornmentTemplate() {
      return this.ib;
    }
    set groupSelectionAdornmentTemplate(t) {
      const i = this.ib;
      i !== t && (U.s(t, Adornment2, Diagram2, "groupSelectionAdornmentTemplate"), this.ib = t.Yt(), this.t("groupSelectionAdornmentTemplate", i, t));
    }
    get linkSelectionAdornmentTemplate() {
      return this.eb;
    }
    set linkSelectionAdornmentTemplate(t) {
      const i = this.eb;
      i !== t && (U.s(t, Adornment2, Diagram2, "linkSelectionAdornmentTemplate"), this.eb = t.Yt(), this.t("linkSelectionAdornmentTemplate", i, t));
    }
    get highlighteds() {
      return this.JT;
    }
    get isModified() {
      const t = this.undoManager;
      return t.isEnabled ? t.currentTransaction !== null ? true : this.fd && this.$s !== t.historyIndex : this.fd;
    }
    set isModified(t) {
      if (this.fd !== t) {
        U.i(t, "boolean", Diagram2, "isModified"), this.fd = t;
        const e = this.undoManager;
        !t && e.isEnabled && (this.$s = e.historyIndex), t || this.CL();
      }
    }
    CL() {
      const t = this.isModified;
      this.i2 !== t && (this.i2 = t, this.F("Modified"));
    }
    get model() {
      return this.Di;
    }
    set model(t) {
      const i = this.Di;
      if (i !== t) {
        U.s(t, Model2, Diagram2, "model"), this.currentTool.doCancel(), i && i.undoManager !== t.undoManager && i.undoManager.isInTransaction && U.n("Do not replace a Diagram.model while a transaction is in progress.");
        const e = this.lL(true);
        this.ho = false, this.nd = true, this.$s = -2, this.Er = false;
        const s = this.$t;
        this.$t = true, this.animationManager.vl("Model"), i && (this.ro !== null && this.ro.each((n) => i.removeChangedListener(n)), i.removeChangedListener(this.nc)), this.Di = t, this.partManager = this.IO(this.Di.type), this.initializePartManager(this.partManager);
        for (let n = 0; n < e.length; n++) this.add(e[n]);
        t.addChangedListener(this.t2), this.partManager.E2(), t.removeChangedListener(this.t2), t.addChangedListener(this.nc), this.ro !== null && this.ro.each((n) => t.addChangedListener(n)), this.$t = s, this.invalidateDocumentBounds(), this.$t || this.L(), i && t.undoManager.copyProperties(i.undoManager);
      }
    }
    get themeManager() {
      return this.b2;
    }
    set themeManager(t) {
      const i = this.b2;
      i !== t && (U.s(t, ThemeManager2, Model2, "themeManager"), i && i.removeDiagram(this), this.b2 = t, t !== null && t.addDiagram(this));
    }
    initializePartManager(t) {
    }
    static S2(t, i) {
      Diagram2._T.set(t, i);
    }
    static get licenseKey() {
      return Diagram2.B2.last();
    }
    static set licenseKey(t) {
      Diagram2.B2.add(t.replace(/\s/g, ""));
    }
    static get version() {
      return Diagram2.RO;
    }
    static B2 = new List2();
    static RO = "3.1.0";
    IO(t) {
      const i = Diagram2._T.get(t);
      return i !== null ? new i() : new PartManager();
    }
    get H() {
      return this._M;
    }
    set H(t) {
      this._M = t;
    }
    get d1() {
      return this.$T;
    }
    OO(t) {
      if (t.model !== this.model) return;
      const i = t.change, e = t.propertyName;
      if (i === 1 && e[0] === "S") {
        if (e === "StartingFirstTransaction") {
          const s = this, n = this.toolManager;
          n.mouseDownTools.each((o) => o.diagram = s), n.mouseMoveTools.each((o) => o.diagram = s), n.mouseUpTools.each((o) => o.diagram = s), this.routers.each((o) => o.diagram = s), !this.Rs && !this.ho && (this.sc = true, this.nd && (this.Er = true));
        } else if (e === "StartingUndo" || e === "StartingRedo") {
          const s = this.animationManager;
          this.skipsUndoManager || (s.defaultAnimation.isAnimating && s.stopAnimation(), s.getBundleAnimation().isAnimating && s.getBundleAnimation().stop()), this.F("ChangingSelection", this.selection);
        } else if (e === "StartedTransaction") {
          const s = this.animationManager;
          s.defaultAnimation.isAnimating && !this.skipsUndoManager && s.stopAnimation();
        }
        return;
      }
      if (this.H) {
        this.H = false;
        try {
          if (t.modelChange === "" && i === 1) {
            (e === "FinishedUndo" || e === "FinishedRedo") && (this.F("ChangedSelection", this.selection), this.Ri());
            const s = this.animationManager;
            e === "RolledBackTransaction" && s.stopAnimation(), this.UT(), this.sc = true, this.maybeUpdate(), (this.undoManager.transactionLevel === 0 || this.undoManager.transactionLevel === 1) && s.TM(), e === "CommittedTransaction" && this.undoManager.isJustDiscarded && (this.$s = Math.min(this.$s, this.undoManager.historyIndex - 1)), (e === "CommittedTransaction" || e === "RolledBackTransaction") && this.undoManager.Dx && U.yn(() => {
              this.isModified = false;
            }, 1);
            const n = t.isTransactionFinished;
            if (n && (this.CL(), this.d1.clear(), this.animationManager.RR()), !this.B1 && n && this.lastInput.targetDiagram) {
              this.B1 = true;
              const o = this;
              U.yn(() => {
                o.currentTool.standardMouseOver(), o.B1 = false;
              }, 10);
            }
          }
        } finally {
          this.H = true;
        }
      }
    }
    get be() {
      return this.QM;
    }
    set be(t) {
      this.QM = t;
    }
    get Yu() {
      return this.V1;
    }
    set Yu(t) {
      this.V1 = t;
    }
    pL(t) {
      const i = t.O.h;
      for (const e of i) e instanceof Picture2 && this.V2(e);
    }
    V2(t) {
      const i = t.element;
      if (i === null || !(i instanceof HTMLImageElement) || (i.ds instanceof GSet2 && i.ds.add(this), t.EO(), !i.O0)) return;
      const e = i.getAttribute("src") || "", s = this.ch.get(e);
      if (s === null) {
        Picture2.AL(t, i);
        const n = [];
        n.push(t), this.ch.set(e, n);
      } else {
        for (let n = 0; n < s.length; n++) if (s[n] === t) return;
        s.push(t);
      }
    }
    BO(t) {
      const i = t.O.h, e = i.length;
      for (let s = 0; s < e; s++) this.z2(i[s]);
    }
    z2(t) {
      if (!(t instanceof Picture2)) return;
      const i = t.element;
      if (i === null || !(i instanceof HTMLImageElement) || !i.O0) return;
      const e = i.getAttribute("src") || "", s = this.ch.get(e);
      if (s !== null) {
        for (let n = 0; n < s.length; n++) if (s[n] === t) {
          s.splice(n, 1), s.length === 0 && (this.ch.delete(e), Picture2.VO(i), i.ds instanceof GSet2 && i.ds.delete(this), Picture2.clearCache(e));
          return;
        }
      }
    }
    hL() {
      Picture2.clearCache(), this.ch.clear();
    }
    rebuildParts() {
      this.partManager.rebuildParts();
    }
    $f(t, i) {
      this.Ls.$f(t, i);
    }
    Jf(t, i) {
      this.Ls.Jf(t, i);
    }
    findPartForKey(t) {
      return this.partManager.findPartForKey(t);
    }
    findNodeForKey(t) {
      return this.partManager.findNodeForKey(t);
    }
    findLinkForKey(t) {
      return this.partManager.findLinkForKey(t);
    }
    findPartForData(t) {
      return this.partManager.findPartForData(t);
    }
    findNodeForData(t) {
      return this.partManager.findNodeForData(t);
    }
    findLinkForData(t) {
      return this.partManager.findLinkForData(t);
    }
    findNodesByExample(...t) {
      return this.partManager.findNodesByExample(...t);
    }
    findLinksByExample(...t) {
      return this.partManager.findLinksByExample(...t);
    }
    get nodeTemplate() {
      return this._r.get("");
    }
    set nodeTemplate(t) {
      const i = this._r.get("");
      i !== t && (U.s(t, Part2, Diagram2, "nodeTemplate"), this._r.set("", t), this.t("nodeTemplate", i, t), this.undoManager.isUndoingRedoing || this.rebuildParts());
    }
    get nodeTemplateMap() {
      return this._r;
    }
    set nodeTemplateMap(t) {
      const i = this._r;
      i !== t && (U.s(t, GMap2, Diagram2, "nodeTemplateMap"), this._r = t, this.t("nodeTemplateMap", i, t), this.undoManager.isUndoingRedoing || this.rebuildParts());
    }
    get groupTemplate() {
      return this.pa.get("");
    }
    set groupTemplate(t) {
      const i = this.pa.get("");
      i !== t && (U.s(t, Group2, Diagram2, "groupTemplate"), this.pa.set("", t), this.t("groupTemplate", i, t), this.undoManager.isUndoingRedoing || this.rebuildParts());
    }
    get groupTemplateMap() {
      return this.pa;
    }
    set groupTemplateMap(t) {
      const i = this.pa;
      i !== t && (U.s(t, GMap2, Diagram2, "groupTemplateMap"), this.pa = t, this.t("groupTemplateMap", i, t), this.undoManager.isUndoingRedoing || this.rebuildParts());
    }
    get linkTemplate() {
      return this.fh.get("");
    }
    set linkTemplate(t) {
      const i = this.fh.get("");
      i !== t && (U.s(t, Link2, Diagram2, "linkTemplate"), this.fh.set("", t), this.t("linkTemplate", i, t), this.undoManager.isUndoingRedoing || this.rebuildParts());
    }
    get linkTemplateMap() {
      return this.fh;
    }
    set linkTemplateMap(t) {
      const i = this.fh;
      i !== t && (U.s(t, GMap2, Diagram2, "linkTemplateMap"), this.fh = t, this.t("linkTemplateMap", i, t), this.undoManager.isUndoingRedoing || this.rebuildParts());
    }
    get isMouseCaptured() {
      return this.e2;
    }
    set isMouseCaptured(t) {
      const i = this.ht;
      if (i === null) return;
      const e = i.Nt;
      e instanceof SVGElement || (t ? (this.lastInput.bubbles = false, this.Fi(e, "pointermove", this.ka, false), this.Fi(e, "pointerdown", this.dh, false), this.Fi(e, "pointerup", this.Pa, false), this.Fi(e, "pointerout", this.Ma, false), this.Fi(e, "pointercancel", this.Na, false), this.Kt(root, "pointermove", this.ka, true), this.Kt(root, "pointerdown", this.dh, true), this.Kt(root, "pointerup", this.Pa, true), this.Kt(root, "pointerout", this.Ma, true), this.Kt(root, "pointercancel", this.Na, true), this.Fi(e, "wheel", this.Sa, false), this.Kt(root, "wheel", this.Sa, true), this.Kt(root, "selectstart", this.aa, false)) : (this.Fi(root, "pointermove", this.ka, true), this.Fi(root, "pointerdown", this.dh, true), this.Fi(root, "pointerup", this.Pa, true), this.Fi(root, "pointerout", this.Ma, true), this.Fi(root, "pointercancel", this.Na, true), this.Kt(e, "pointermove", this.ka, false), this.Kt(e, "pointerdown", this.dh, false), this.Kt(e, "pointerup", this.Pa, false), this.Kt(e, "pointerout", this.Ma, false), this.Kt(e, "pointercancel", this.Na, false), this.Fi(root, "wheel", this.Sa, true), this.Fi(root, "selectstart", this.aa, false), this.Kt(e, "wheel", this.Sa, false)), this.e2 = t);
    }
    get position() {
      return this.yt;
    }
    set position(t) {
      if (this.yt.equals(t)) return;
      const i = Point2.a().c(this.yt), e = this.viewportBounds.copy();
      if (this.yt.c(t), this.animationManager.XT(i, this.yt), !this.$t && !(this.ht === null && !this.hd.isReal())) {
        this.$t = true;
        const s = this.scale, n = this.Pt / s, o = this.Mt / s;
        this.N2(this.d0, n, o, this.ic, false), this.$t = false;
      } else this.gh(), this.L0();
      if (!this.$t) {
        const s = this.viewportBounds;
        this.onViewportBoundsChanged(e, s, this.lt, false);
      }
      Point2.o(i);
    }
    get initialPosition() {
      return this.w1;
    }
    set initialPosition(t) {
      this.w1.equals(t) || (U.s(t, Point2, Diagram2, "initialPosition"), this.w1 = t.T());
    }
    get initialScale() {
      return this.b1;
    }
    set initialScale(t) {
      this.b1 !== t && (U.i(t, "number", Diagram2, "initialScale"), this.b1 = t);
    }
    get grid() {
      return this.cs === null && (this.cs = this.fL()), this.cs;
    }
    set grid(t) {
      let i = this.cs;
      if (i !== t) {
        i === null && (this.cs = this.fL(), i = this.cs), U.s(t, Panel2, Diagram2, "grid"), t.type !== Panel2.Grid && U.n("Diagram.grid must be a Panel of type Panel.Grid");
        const e = i.panel;
        e !== null && e.remove(i), this.cs = t, t.name = "GRID", e !== null && e.add(t), this.ad = false, this.L(), this.t("grid", i, t);
      }
    }
    get viewportBounds() {
      return this._1;
    }
    gh() {
      const t = this._1, i = this.yt, e = this.lt;
      t.e(i.x, i.y, Math.max(this.Pt, 0) / e, Math.max(this.Mt, 0) / e), this.mh();
    }
    get viewSize() {
      return this.hd;
    }
    set viewSize(t) {
      const i = this.viewSize;
      if (!i.equals(t)) {
        U.s(t, Size2, Diagram2, "viewSize"), t = t.T(), this.hd = t;
        let e = 0, s = 0;
        t.isReal() ? (e = t.width, s = t.height) : this.Tt !== null && (e = this.Tt.clientWidth || 1, s = this.Tt.clientHeight || 1), this.Pt = e, this.Mt = s, this.gh(), this.invalidateDocumentBounds(), this.t("viewSize", i, t), this.L();
      }
    }
    get fixedBounds() {
      return this.M1;
    }
    set fixedBounds(t) {
      const i = this.M1;
      i.equals(t) || (U.s(t, Rect2, Diagram2, "fixedBounds"), (Debug && t.width === 1 / 0 || t.width === -1 / 0 || t.height === 1 / 0 || t.height === -1 / 0) && U.n("fixedBounds width/height must not be Infinity"), t = t.T(), this.M1 = t, this.invalidateDocumentBounds(), this.t("fixedBounds", i, t));
    }
    get scrollMargin() {
      return this.ga;
    }
    set scrollMargin(t) {
      typeof t == "number" ? t = new Margin2(t) : U.s(t, Margin2, Diagram2, "scrollMargin");
      const i = this.ga;
      i.equals(t) || (t = t.T(), this.ga = t, this.t("scrollMargin", i, t), this.Uu());
    }
    get scrollMode() {
      return this.ca;
    }
    set scrollMode(t) {
      const i = this.ca;
      i !== t && (U.W(t, ScrollMode2, "ScrollMode"), this.ca = t, t === 1 && this.tn(false), this.t("scrollMode", i, t), this.Ta(), this.L());
    }
    get scrollsPageOnFocus() {
      return this.N1;
    }
    set scrollsPageOnFocus(t) {
      const i = this.N1;
      i !== t && (U.i(t, "boolean", Diagram2, "scrollsPageOnFocus"), this.N1 = t, this.t("scrollsPageOnFocus", i, t));
    }
    get positionComputation() {
      return this.C1;
    }
    set positionComputation(t) {
      const i = this.C1;
      i !== t && (t !== null && U.C(t, Diagram2, "positionComputation"), this.C1 = t, this.tn(false), this.t("positionComputation", i, t));
    }
    get scaleComputation() {
      return this.A1;
    }
    set scaleComputation(t) {
      const i = this.A1;
      i !== t && (t !== null && U.C(t, Diagram2, "scaleComputation"), this.A1 = t, this.NL(this.scale, this.scale), this.t("scaleComputation", i, t));
    }
    get documentBounds() {
      return this.d0;
    }
    TL(t) {
      this.wa = false;
      let i = this.d0;
      i.equals(t) || (i = i.copy(), this.d0.c(t), this.tn(false), this.F("DocumentBoundsChanged", void 0, i), this.Ta(), this.L());
    }
    ensureBounds() {
      if (this.wa) {
        const t = Rect2.a();
        this.TL(this.computeBounds(t)), Rect2.o(t);
      }
    }
    get isVirtualized() {
      return this.tb;
    }
    set isVirtualized(t) {
      const i = this.tb;
      i !== t && (U.i(t, "boolean", Diagram2, "isVirtualized"), this.tb = t, this.t("isVirtualized", i, t));
    }
    get scale() {
      return this.lt;
    }
    set scale(t) {
      const i = this.lt;
      U.r(t, Diagram2, "scale"), i !== t && this.NL(i, t);
    }
    get defaultScale() {
      return this.y0;
    }
    set defaultScale(t) {
      Debug && U.r(t, Diagram2, "defaultScale"), Debug && !(t > 0) && U.n("defaultScale must be larger than zero, not: " + t), this.y0 = t;
    }
    get autoScale() {
      return this.hh;
    }
    set autoScale(t) {
      const i = this.hh;
      i !== t && (U.W(t, AutoScale2, "AutoScale"), this.hh = t, this.t("autoScale", i, t), t !== 1 && this.tn(false));
    }
    get initialAutoScale() {
      return this.Xr;
    }
    set initialAutoScale(t) {
      const i = this.Xr;
      i !== t && (U.W(t, AutoScale2, "AutoScale"), this.Xr = t, this.t("initialAutoScale", i, t));
    }
    get initialViewportSpot() {
      return this.L1;
    }
    set initialViewportSpot(t) {
      const i = this.L1;
      i !== t && (U.s(t, Spot2, Diagram2, "initialViewportSpot"), t.isSpot() || U.n("initialViewportSpot must be a specific Spot: " + t), this.L1 = t, this.t("initialViewportSpot", i, t));
    }
    get initialDocumentSpot() {
      return this.T1;
    }
    set initialDocumentSpot(t) {
      const i = this.T1;
      i !== t && (U.s(t, Spot2, Diagram2, "initialDocumentSpot"), t.isSpot() || U.n("initialViewportSpot must be a specific Spot: " + t), this.T1 = t, this.t("initialDocumentSpot", i, t));
    }
    get minScale() {
      return this.S1;
    }
    set minScale(t) {
      U.r(t, Diagram2, "minScale");
      const i = this.S1;
      i !== t && (t > 0 ? (this.S1 = t, this.t("minScale", i, t), t > this.scale && (this.scale = t)) : U.G(t, "> 0", Diagram2, "minScale"));
    }
    get maxScale() {
      return this.k1;
    }
    set maxScale(t) {
      U.r(t, Diagram2, "maxScale");
      const i = this.k1;
      i !== t && (t > 0 ? (this.k1 = t, this.t("maxScale", i, t), t < this.scale && (this.scale = t)) : U.G(t, "> 0", Diagram2, "maxScale"));
    }
    get zoomPoint() {
      return this.P1;
    }
    set zoomPoint(t) {
      this.P1.equals(t) || (U.s(t, Point2, Diagram2, "zoomPoint"), t = t.T(), this.P1 = t);
    }
    get contentAlignment() {
      return this.ic;
    }
    set contentAlignment(t) {
      const i = this.ic;
      i.equals(t) || (U.s(t, Spot2, Diagram2, "contentAlignment"), t = t.T(), this.ic = t, this.t("contentAlignment", i, t), this.tn(false));
    }
    get initialContentAlignment() {
      return this.l0;
    }
    set initialContentAlignment(t) {
      const i = this.l0;
      i.equals(t) || (U.s(t, Spot2, Diagram2, "initialContentAlignment"), t = t.T(), this.l0 = t, this.t("initialContentAlignment", i, t));
    }
    get padding() {
      return this.si;
    }
    set padding(t) {
      typeof t == "number" ? t = new Margin2(t) : U.s(t, Margin2, Diagram2, "padding");
      const i = this.si;
      i.equals(t) || (t = t.T(), this.si = t, this.invalidateDocumentBounds(), this.t("padding", i, t));
    }
    get partManager() {
      return this.a2;
    }
    set partManager(t) {
      const i = this.a2;
      i !== t && (U.s(t, PartManager, Diagram2, "partManager"), t.diagram !== null && U.n("Cannot share PartManagers between Diagrams: " + t.toString()), i && i.Ko(null), this.a2 = t, t.Ko(this));
    }
    get nodes() {
      return this.partManager.nodes.iterator;
    }
    get links() {
      return this.partManager.links.iterator;
    }
    get parts() {
      return this.partManager.parts.iterator;
    }
    findTopLevelNodesAndLinks() {
      const t = new GSet2(), i = this.nodes;
      for (; i.next(); ) {
        const s = i.value;
        s.isTopLevel && t.add(s);
      }
      const e = this.links;
      for (; e.next(); ) {
        const s = e.value;
        s.isTopLevel && t.add(s);
      }
      return t.iterator;
    }
    findTopLevelGroups() {
      return this.el.iterator;
    }
    get routers() {
      return this.fc;
    }
    doLinkRouting(t) {
      this.Go = true;
      const i = this.fc.h;
      for (let e = 0; e < i.length; e++) i[e].canRoute(t) && i[e].routeLinks(this.Yr, t);
      this.Go = false;
    }
    get layout() {
      return this.fe;
    }
    set layout(t) {
      const i = this.fe;
      i !== t && (U.s(t, Layout2, Diagram2, "layout"), this.fe = t, t.diagram = this, t.group = null, this.il = true, this.t("layout", i, t), this.requestUpdate());
    }
    layoutDiagram(t) {
      this.Ri(), t && this.xb(true), this.Rs ? this.T2(false, this.Bl || this.fc.count !== 0 && this.oo.size !== 0) : (this.sc = true, this.Tr());
    }
    xb(t) {
      const i = this.el.iterator;
      for (; i.next(); ) this.LL(i.value, t);
      this.layout && (t ? this.layout.isValidLayout = false : this.layout.b());
    }
    LL(t, i) {
      if (t === null) return;
      const e = t.La.iterator;
      for (; e.next(); ) {
        const s = e.value;
        this.LL(s, i);
      }
      t.layout !== null && (i ? t.layout.isValidLayout = false : t.layout.b());
    }
    T2(t, i) {
      if (this.z1) return;
      const e = this.H;
      this.H = true;
      const s = "Layout", n = this.undoManager.transactionLevel, o = this.layout, r = this.animationManager;
      try {
        n === 0 && (this.undoManager.Ol = true, this.startTransaction(s)), n <= 1 && !r.defaultAnimation.isAnimating && !r.Mi && (t || r.vl(s)), this.il = false;
        let l = this.el.iterator;
        for (; l.next(); ) this.pd(l.value), this.DL(l.value, t, n, i);
        let h = false;
        if (o.isValidLayout || (!t || o.isRealtime || o.isRealtime === null || n === 0 ? (o.doLayout(this), this.pd(this), h = true, o.isValidLayout = true) : this.il = true), h || this.pd(this), this.doLinkRouting(this), this.Yr.clear(), this.ma.size !== 0) {
          for (let f = 0; f < 23 && this.ma.size !== 0; f++) {
            for (l = this.el.iterator; l.next(); ) this.FL(l.value);
            const a = this.Yr;
            this.Yr = this.ma, this.ma = a, this.pd(this), this.doLinkRouting(this);
          }
          this.Yr.clear(), this.ma.clear();
        }
      } finally {
        const l = this.undoManager.Ol;
        n === 0 && (this.commitTransaction(s), this.undoManager.Ol = false), l && (n === 0 || n === 1) && r.TM(), this.il && (this.il = !o.isValidLayout), this.H = e;
      }
    }
    DL(t, i, e, s) {
      const n = t.La.iterator;
      for (; n.next(); ) this.DL(n.value, i, e, s);
      const o = t.layout;
      o !== null && !o.isValidLayout ? !i || o.isRealtime || e === 0 ? (t.Da = !t.location.isReal(), o.doLayout(t), t.invalidateLayout(32), this.gb(t), this.pd(t), this.doLinkRouting(t), o.isValidLayout = true) : (this.doLinkRouting(t), this.il = true) : s && this.doLinkRouting(t);
    }
    FL(t) {
      const i = t.La.iterator;
      for (; i.next(); ) this.FL(i.value);
      this.pd(t), this.doLinkRouting(t);
    }
    get isTreePathToChildren() {
      return this.D1;
    }
    set isTreePathToChildren(t) {
      const i = this.D1;
      if (i !== t && (U.i(t, "boolean", Diagram2, "isTreePathToChildren"), this.D1 = t, this.t("isTreePathToChildren", i, t), !this.undoManager.isUndoingRedoing)) {
        const e = this.nodes;
        for (; e.next(); ) e.value.E0();
      }
    }
    findTreeRoots() {
      const t = new List2(), i = this.nodes;
      for (; i.next(); ) {
        const e = i.value;
        e.isTopLevel && e.findTreeParentLink() === null && t.add(e);
      }
      return t.iterator;
    }
    get treeCollapsePolicy() {
      return this.F1;
    }
    set treeCollapsePolicy(t) {
      const i = this.F1;
      i !== t && (t !== 1 && t !== 2 && t !== 3 && U.n("Unknown Diagram.treeCollapsePolicy: " + t), this.F1 = t, this.t("treeCollapsePolicy", i, t));
    }
    get isCollapsingExpanding() {
      return this.WM;
    }
    set isCollapsingExpanding(t) {
      this.WM = t;
    }
    oO() {
      const t = new GMap2(), i = new GMap2();
      function e(s) {
        const n = s.toLowerCase(), o = new List2();
        t.set(s, o), t.set(n, o), i.set(s, s), i.set(n, s);
      }
      e("InitialAnimationStarting"), e("AnimationStarting"), e("AnimationFinished"), e("BackgroundSingleClicked"), e("BackgroundDoubleClicked"), e("BackgroundContextClicked"), e("ClipboardChanged"), e("ClipboardPasted"), e("DocumentBoundsChanged"), e("ExternalObjectsDropped"), e("FocusOrVirtualPointerEnabledChanged"), e("GainedFocus"), e("InitialLayoutCompleted"), e("LayoutCompleted"), e("LinkDrawn"), e("LinkRelinked"), e("LinkReshaped"), e("LostFocus"), e("Modified"), e("ObjectSingleClicked"), e("ObjectDoubleClicked"), e("ObjectContextClicked"), e("PartCreated"), e("PartResized"), e("PartRotated"), e("SelectionMoved"), e("SelectionCopied"), e("SelectionDeleting"), e("SelectionDeleted"), e("SelectionGrouped"), e("SelectionUngrouped"), e("ChangingSelection"), e("ChangedSelection"), e("SubGraphCollapsed"), e("SubGraphExpanded"), e("TextEdited"), e("ThemeChanged"), e("TreeCollapsed"), e("TreeExpanded"), e("ViewportBoundsChanged"), e("InvalidateDraw"), this.HM = t, this.vM = i;
    }
    mL(t) {
      const i = this.vM.get(t);
      return i !== null ? i : this.vM.get(t.toLowerCase());
    }
    X2(t) {
      let i = this.HM.get(t);
      if (i !== null) return i;
      const e = t.toLowerCase();
      if (i = this.HM.get(e), i !== null) return i;
      U.n("Unknown DiagramEvent name: " + t);
    }
    addDiagramListener(t, i) {
      U.i(t, "string", Diagram2, "addDiagramListener:name"), U.C(i, Diagram2, "addDiagramListener:listener");
      const e = this.X2(t);
      return e !== null && e.add(i), this;
    }
    removeDiagramListener(t, i) {
      U.i(t, "string", Diagram2, "removeDiagramListener:name"), U.C(i, Diagram2, "addDiagramListener:listener");
      const e = this.X2(t);
      e !== null && e.delete(i);
    }
    raiseDiagramEvent(t, i, e) {
      this.F(t, i, e);
    }
    F(t, i, e) {
      Debug && U.i(t, "string", Diagram2, "raiseDiagramEvent:name");
      const s = this.X2(t), n = new DiagramEvent2();
      n.diagram = this;
      const o = this.mL(t);
      o !== null && (n.name = o), i !== void 0 && (n.subject = i), e !== void 0 && (n.parameter = e);
      const r = s.length;
      if (r === 1) s.elt(0)(n);
      else if (r !== 0) {
        const l = s.toArray();
        for (let h = 0; h < r; h++) {
          const f = l[h];
          f(n);
        }
      }
    }
    isUnoccupied(t, i) {
      return this.getPositions(false, null, i || null).isUnoccupied(t.x, t.y, t.width, t.height);
    }
    computeOccupiedArea(t) {
      return this.isVirtualized ? this.viewportBounds.copy() : this.wa ? this.uL(t) : t.c(this.documentBounds);
    }
    getPositions(t, i, e) {
      let s = this.ah;
      s === null && (this.ah = s = new PositionArray(this.avoidanceCellSize));
      let n = i;
      if (s.Jo || s.Fa !== n || s.Y2 !== e) {
        if (s.K2 = Math.max(s.gc + 1, Math.floor(this.avoidanceLimit / this.avoidanceCellSize.width)), s.U2 = Math.max(s.gc + 1, Math.floor(this.avoidanceLimit / this.avoidanceCellSize.height)), n !== null && (n = this.IL(n)), n === null) {
          const o = Rect2.a();
          this.computeOccupiedArea(o), o.inflate(100, 100), s.bb(o);
          const r = this.nodes;
          for (; r.next(); ) {
            const l = r.value, h = l.layer;
            h === null || !h.visible || h.isTemporary || this.G2(l, e, o);
          }
          Rect2.o(o);
        } else {
          if (n.memberParts.count > 0) {
            const l = this.computePartsBounds(n.memberParts, false);
            l.inflate(20, 20), s.bb(l);
          }
          const o = Rect2.a(), r = n.memberParts;
          for (; r.next(); ) {
            const l = r.value;
            l instanceof Node2 && this.G2(l, e, o);
          }
          Rect2.o(o);
        }
        s.Fa = n, s.Y2 = e, s.Jo = false;
      } else t && s.RL();
      return s;
    }
    get avoidanceCellSize() {
      return this.s2;
    }
    set avoidanceCellSize(t) {
      this.ah = null, this.s2 = new Size2(Math.max(1, t.width), Math.max(1, t.height));
    }
    get avoidanceLimit() {
      return this.o2;
    }
    set avoidanceLimit(t) {
      this.o2 = Math.max(1, t);
    }
    IL(t) {
      return t.canAvoid() ? t : t.containingGroup !== null ? this.IL(t.containingGroup) : null;
    }
    G2(t, i, e) {
      if (t === i || !t.isVisible()) return;
      const s = t.canAvoid();
      if (s) {
        const n = t.getAvoidableRect(e);
        this.ah.zO(n.x, n.y, n.width, n.height);
      }
      if (t instanceof Group2 && (!s || t.avoidableMembers)) {
        const n = t.memberParts;
        for (; n.next(); ) {
          const o = n.value;
          o instanceof Node2 && this.G2(o, i, e);
        }
      }
    }
    q2(t) {
      this.ah !== null && !this.ah.Jo && (t === void 0 || t.canAvoid()) && (this.ah.Jo = true);
    }
    get autoScrollInterval() {
      return this.h0;
    }
    set autoScrollInterval(t) {
      const i = this.h0;
      U.r(t, Diagram2, "autoScrollInterval"), i !== t && (this.h0 = t, this.t("autoScrollInterval", i, t));
    }
    get autoScrollRegion() {
      return this.a0;
    }
    set autoScrollRegion(t) {
      typeof t == "number" ? t = new Margin2(t) : U.s(t, Margin2, Diagram2, "autoScrollRegion");
      const i = this.a0;
      i.equals(t) || (t = t.T(), this.a0 = t, this.invalidateDocumentBounds(), this.t("autoScrollRegion", i, t));
    }
    doAutoScroll(t) {
      this.m0.c(t);
      const i = Point2.a();
      this.computeAutoScrollPosition(this.m0, i).equalsApprox(this.position) ? this.stopAutoScroll() : this.OL(), Point2.o(i);
    }
    OL() {
      if (this.ec !== -1) return;
      const t = this.h0, i = this;
      this.ec = U.yn(() => {
        if (i.ec === -1 || (i.stopAutoScroll(), i.lastInput.event === null)) return;
        const s = Point2.a(), n = i.computeAutoScrollPosition(i.m0, s);
        if (!n.equalsApprox(i.position)) {
          i.position = n, i.lastInput.documentPoint = i.transformViewToDoc(i.m0), i.doMouseMove(), i.wa = true;
          const o = Rect2.a();
          i.computeBounds(o), o.unionRect(i.documentBounds), i.TL(o), Rect2.o(o), i.Ze = true, i.maybeUpdate(), i.OL();
        }
        Point2.o(s);
      }, t);
    }
    stopAutoScroll() {
      this.ec !== -1 && (U.Nf(this.ec), this.ec = -1);
    }
    computeAutoScrollPosition(t, i) {
      let e = this.position;
      i === void 0 && (i = new Point2()), i.c(e);
      const s = this.a0;
      if (s.top <= 0 && s.left <= 0 && s.right <= 0 && s.bottom <= 0) return i;
      const n = this.viewportBounds, o = this.scale, r = Rect2.U(0, 0, n.width * o, n.height * o), l = Point2.U(0, 0);
      if (t.x >= r.x && t.x < r.x + s.left && this.allowHorizontalScroll) {
        let h = Math.max(this.scrollHorizontalLineChange, 1);
        h = h | 0, l.x -= h, t.x < r.x + s.left / 2 && (l.x -= h), t.x < r.x + s.left / 4 && (l.x -= 4 * h);
      } else if (t.x <= r.x + r.width && t.x > r.x + r.width - s.right && this.allowHorizontalScroll) {
        let h = Math.max(this.scrollHorizontalLineChange, 1);
        h = h | 0, l.x += h, t.x > r.x + r.width - s.right / 2 && (l.x += h), t.x > r.x + r.width - s.right / 4 && (l.x += 4 * h);
      }
      if (t.y >= r.y && t.y < r.y + s.top && this.allowVerticalScroll) {
        let h = Math.max(this.scrollVerticalLineChange, 1);
        h = h | 0, l.y -= h, t.y < r.y + s.top / 2 && (l.y -= h), t.y < r.y + s.top / 4 && (l.y -= 4 * h);
      } else if (t.y <= r.y + r.height && t.y > r.y + r.height - s.bottom && this.allowVerticalScroll) {
        let h = Math.max(this.scrollVerticalLineChange, 1);
        h = h | 0, l.y += h, t.y > r.y + r.height - s.bottom / 2 && (l.y += h), t.y > r.y + r.height - s.bottom / 4 && (l.y += 4 * h);
      }
      return l.equalsApprox(Point2.wn) || (i.x = e.x + l.x / o, i.y = e.y + l.y / o), Rect2.o(r), Point2.o(l), i;
    }
    makeSvg(t) {
      this.vo.has("SVG") || this.addRenderer("SVG", new SVGSurface(this, root.document));
      const i = new SVGSurface(this, root.document, true);
      t === void 0 && (t = {});
      const e = this;
      function s(n, o) {
        const r = e.EL(n, "SVG", i), l = r !== null ? r.svg : null, h = n.svgFinished;
        return l && h && h(l), U.at(o) ? (o(l), null) : l;
      }
      return this.BL(s, t);
    }
    makeSVG(t) {
      return this.makeSvg(t);
    }
    addRenderer(t, i) {
      this.vo.set(t, i);
    }
    removeRenderer(t) {
      this.vo.delete(t);
    }
    cacheGroupExternalLinks(t) {
      this.w2 = t, t || this.nodes.each((i) => {
        i instanceof Group2 && (i.B0 = null);
      });
    }
    BL(t, i) {
      const e = i.callback;
      let s = true;
      const o = this.ch.iterator;
      for (; o.next(); ) if (!o.value[0].Ln) {
        s = false;
        break;
      }
      if (!U.at(e) || s) return t(i, e, this);
      const r = this;
      function l() {
        const a = +/* @__PURE__ */ new Date();
        for (s = true, o.reset(); o.next(); ) if (!o.value[0].Ln) {
          s = false;
          break;
        }
        if (s || a - f > h) {
          t(i, e, r);
          return;
        }
        root.requestAnimationFrame(l);
      }
      const h = i.callbackTimeout || 300, f = +/* @__PURE__ */ new Date();
      return root.requestAnimationFrame(() => l()), null;
    }
    makeImage(t) {
      return Diagram2.isUsingDOM() ? (t === void 0 && (t = {}), t.returnType = "Image", this.makeImageData(t)) : null;
    }
    makeImageData(t) {
      return t === void 0 && (t = {}), this.BL(this.XO, t);
    }
    static img = "image";
    XO(t, i, e) {
      const s = e.EL(t, "canvas", null);
      if (s === null) return null;
      const n = s.B.canvas;
      let o = null;
      if (n !== null) {
        let r = t.returnType;
        switch (r === void 0 ? r = "string" : r = r.toLowerCase(), r) {
          case Diagram2.img + "data":
            o = s.getImageData(0, 0, n.width, n.height);
            break;
          case Diagram2.img:
            const h = (t.document || document).createElement("img");
            h.src = n.toDataURL(t.type, t.details), o = h;
            break;
          case "blob": {
            const f = n;
            return U.at(i) || (o = "", U.n('Error: Diagram.makeImageData called with "returnType: toBlob", but no required "callback" function property defined.')), U.at(f.toBlob) ? (f.toBlob(i, t.type, t.details), "toBlob") : (i(null), null);
          }
          case "string":
          default:
            o = n.toDataURL(t.type, t.details);
        }
      }
      return U.at(i) ? (i(o), null) : o;
    }
    static VL = false;
    EL(t, i, e) {
      if (this.animationManager.stopAnimation(), this.maybeUpdate(), this.ht === null) return null;
      U.it(t) || U.n("properties argument must be an Object.");
      let n = false, o = t.size || null, r = t.scale || null;
      t.scale !== void 0 && isNaN(t.scale) && (r = "NaN");
      let l = t.maxSize;
      t.maxSize === void 0 && (n = true, i === "SVG" ? l = new Size2(1 / 0, 1 / 0) : l = new Size2(2e3, 2e3));
      const h = t.position || null;
      let f = t.parts || null;
      Array.isArray(f) && (f = new List2(f));
      let a = t.padding === void 0 ? 1 : t.padding;
      const c = t.background || null;
      let u = t.omitTemporary;
      u === void 0 && (u = true);
      const d = t.document || document, m = t.elementFinished || null;
      let g = t.showTemporary;
      g === void 0 && (g = !u);
      let p = t.showGrid;
      p === void 0 && (p = g), o !== null && isNaN(o.width) && isNaN(o.height) && (o = null), typeof a == "number" ? a = new Margin2(a) : a instanceof Margin2 || U.n("MakeImage padding must be a Margin or a number."), a.left = Math.max(a.left, 0), a.right = Math.max(a.right, 0), a.top = Math.max(a.top, 0), a.bottom = Math.max(a.bottom, 0), this._t.clearContextCache(true);
      const y = new CanvasSurface(null, d, void 0, true), x = y.ni;
      if (!(o || r || f || h)) return y.width = this.Pt + Math.ceil(a.left + a.right), y.height = this.Mt + Math.ceil(a.top + a.bottom), i === "SVG" ? e === null ? null : (e.resize(y.width, y.height, y.width, y.height), e.rl = d, e.yd = m, this.pb(e.ni, a, new Size2(y.width, y.height), this.lt, this.yt, f, c, g, p), e.ni) : (this.cd = false, this.pb(x, a, new Size2(y.width, y.height), this.lt, this.yt, f, c, g, p), this.cd = true, y.ni);
      const S = this.y0, b = this.documentBounds.copy();
      if (b.subtractMargin(this.si), g) {
        const T = this.Ht.h, D = T.length;
        for (let F = 0; F < D; F++) {
          const R = T[F];
          if (!R.visible || !R.isTemporary) continue;
          const I = R.Ft.h, O = I.length;
          for (let X = 0; X < O; X++) {
            const K = I[X];
            if (!K.isInDocumentBounds || !K.isVisible()) continue;
            const B = K.actualBounds;
            B.isReal() && b.unionRect(B);
          }
        }
      }
      let k = new Point2(b.x, b.y);
      if (f !== null) {
        const T = new Rect2(0, 0, 0, 0);
        let D = true;
        const F = f.iterator;
        for (F.reset(); F.next(); ) {
          const R = F.value;
          if (!(R instanceof Part2)) continue;
          const I = R.layer;
          if (I !== null && !I.visible || I !== null && !g && I.isTemporary || !R.isVisible()) continue;
          const O = R.actualBounds;
          O.isReal() && (D ? (D = false, T.c(O)) : T.unionRect(O));
        }
        b.width = T.width, b.height = T.height, k.x = T.x, k.y = T.y;
      }
      h !== null && h.isReal() && (k = h, r || (r = S));
      let P = 0, A = 0;
      a !== null && (P = a.left + a.right, A = a.top + a.bottom);
      let C = 0, M = 0;
      o !== null && (C = o.width, M = o.height, isFinite(C) && (C = Math.max(0, C - P)), isFinite(M) && (M = Math.max(0, M - A)));
      let N = 0, L = 0;
      if (o !== null && r !== null ? (r === "NaN" && (r = S), o.isReal() ? (N = C, L = M) : isNaN(M) ? (N = C, L = b.height * r) : (N = b.width * r, L = M)) : o !== null ? o.isReal() ? (r = Math.min(C / b.width, M / b.height), N = C, L = M) : isNaN(M) ? (r = C / b.width, N = C, L = b.height * r) : (r = M / b.height, N = b.width * r, L = M) : r !== null ? r === "NaN" && l.isReal() ? (r = Math.min((l.width - P) / b.width, (l.height - A) / b.height), r > S ? (r = S, N = b.width, L = b.height) : (N = l.width, L = l.height)) : (N = b.width * r, L = b.height * r) : (r = S, N = b.width, L = b.height), a !== null ? (N += P, L += A) : a = new Margin2(0), l !== null) {
        let T = l.width, D = l.height;
        i !== "SVG" && n && !Diagram2.VL && Debug && (N > T || L > D) && (U.ot("Diagram.makeImage(data): Diagram width or height is larger than the default max size. (" + Math.ceil(N) + "x" + Math.ceil(L) + " vs 2000x2000) Consider increasing the max size."), Diagram2.VL = true), isNaN(T) && (T = 2e3), isNaN(D) && (D = 2e3), isFinite(T) && (N = Math.min(N, T)), isFinite(D) && (L = Math.min(L, D));
      }
      return y.width = Math.ceil(N), y.height = Math.ceil(L), i === "SVG" ? e === null ? null : (e.resize(y.width, y.height, y.width, y.height), e.rl = d, e.yd = m, this.pb(e.ni, a, new Size2(Math.ceil(N), Math.ceil(L)), r, k, f, c, g, p), e.ni) : (this.cd = false, this.pb(x, a, new Size2(Math.ceil(N), Math.ceil(L)), r, k, f, c, g, p), this.cd = true, y.ni);
    }
    static Aa = null;
    static H2 = "5da73c80a36555d5038e4972187c3cae51fd22";
    static YO = "5da73c80a36555d503aa5c72106c30b35bb2006b9cd041b259";
    static Zw = false;
    static Yk = () => {
      if (Diagram2.H2[5] === void 0 && (Transform.prototype.De = Transform.prototype.Lu), !Diagram2.isUsingDOM()) return;
      const t = U.Le("canvas");
      t.width = 350;
      const i = t.getContext("2d"), e = U.Qi("7ca11abfd022028846"), s = "7ca11abfd7330390", n = [Diagram2.H2, U.Zw + "4ae6247590da4bb21c324ba3a84e385776", Transform.Yk + "fb236cdfda5de14c134ba1a95a2d4c7cc6f93c1387", G.za];
      i.scale(2, 2);
      const o = 8;
      for (let r = 1; r < 5; r++) i[U.Qi(s)](U.Qi(n[r - 1]), o, r * 15);
      i[e] = U.Qi("39f046ebb36e4b");
      for (let r = 1; r < 5; r++) i[U.Qi(s)](U.Qi(n[r - 1]), o, r * 15);
      (n.length !== 4 || n[0][0] !== "5" || n[3][0] !== "7") && (Transform.prototype.De = Transform.prototype.Lu), Diagram2.Aa = t;
    };
    static KO = () => {
      if (Diagram2.H2[5] === void 0 && (Transform.prototype.De = Transform.prototype.Lu), !Diagram2.isUsingDOM()) return;
      const t = U.Le("canvas"), i = t.getContext("2d"), e = U.Qi("7ca11abfd022028846"), s = "7ca11abfd7330390", n = [Diagram2.YO, G.za], o = 5;
      i.scale(2, 2);
      for (let r = 1; r < 3; r++) i[U.Qi(s)](U.Qi(n[r - 1]), o, r * 11);
      i[e] = U.Qi("39f046ebb36e4b");
      for (let r = 1; r < 3; r++) i[U.Qi(s)](U.Qi(n[r - 1]), o, r * 11);
      (n.length !== 2 || n[0][0] !== "5") && (Transform.prototype.De = Transform.prototype.Lu), Diagram2.Aa = t;
    };
  }
  class DiagramHelper {
    zL;
    XL;
    v2;
    ke;
    constructor(t) {
      if (this.zL = null, this.XL = "63ad05bbe23a1786468a4c741b6d2", this.v2 = "@onz", this.XL === this._tk) {
        this.v2 = true, this.ke = this.v2;
        return;
      }
      this.ke = null;
    }
    UO(t, i) {
      let e = "f";
      const s = root[U.Qi("76a715b2f73f148a")][U.Qi("72ba13b5")] || "", n = U.Qi;
      if (this.ke = true, !Diagram2.isUsingDOM()) return;
      let o = Diagram2[n("76a115b6ed251eaf4692")];
      if (!o) {
        const l = s[n("76ad18b4f73e")];
        for (let f = s[n("73a612b6fb191d")](n("35e7")) + 2; f < l; f++) e += s[f];
        const h = e[n("73a612b6fb191d")](n("7da71ca0ad381e90"));
        this.ke = !(h >= 0 && h < e[n("73a612b6fb191d")](n("35")));
        return;
      }
      const r = Diagram2.B2.iterator;
      for (; r.next(); ) {
        o = r.value;
        const l = n(o).split(n("39e9")), h = l.length === 7 ? 1 : 0;
        if (l.length === 1 && o.includes(n("5b8b3797c61b32a7"))) {
          if (Diagram2.KO(), !t.ht) return;
          t.w0 = t.ht.ni.B[U.Qi("7eba17a4ca3b1a8346")][U.Qi("78a118b7")](t.ht.ni.B, Diagram2.Aa, 4, 4);
        }
        if (l.length < 6) return;
        const f = n(l[1 + h]).split(".");
        if (l[4 + h] !== "7da71ca0") return;
        const a = n(U[n("6cae19")]).split(".");
        if (!(f[0] > a[0] || f[0] === a[0] && f[1] >= a[1])) continue;
        const c = "73a612b6fb191d", u = root[n("74a900bae4370f8b51")][n("6fbb13a1c2311e8a57")].toLowerCase(), d = u[n(c)](n("3aad1ab6e022098b4dc4")), m = n(l[2 + h]);
        if (d > -1) {
          const M = u[n(c)](m.toLowerCase() + "/");
          if (this.ke = !(M > -1 && M < d), !this.ke) return;
        }
        const g = s[n("76ad18b4f73e")];
        for (let M = s[n(c)](n("35e7")) + 2; M < g; M++) e += s[M];
        let p = e[n(c)](m);
        if (p < 0 && m !== n("7da71ca0ad381e90") && (p = e[n(c)](n("76a715b2ef3e149757"))), p < 0 && (p = e[n(c)](n("76a715b2ef3e149757"))), p < 0 && (p = e[n(c)](n("2bfa41fdb3784bca12"))), p < 0 && (p = s[n(c)](n("7baa19a6f76c1988428554"))), p < 0 && (p = s[n(c)](n("7ea902b2b9221e9c57c45767196566"))), this.ke = !(p >= 0 && p < e[n(c)](n("35")) || e[n(c)](n("35")) === -1), !this.ke || s[n(c)](n("7fb002b6ed25128b4da25b2e")) && (this.ke = !(s[n(c)](m) > -1), !this.ke)) return;
        const y = root[U.Qi("76a715b2f73f148a")][U.Qi("69ad17a1e03e")], x = y[n(c)](n("7fb002b6ed25128b4da25b2e"));
        if (x > -1 && (this.ke = !(y[n(c)](m) > x), !this.ke)) return;
        const S = m;
        if (S[0] !== "#") continue;
        const b = U.Le("div");
        let k = l[0 + h].replace(/[A-Za-z]/g, "");
        for (; k.length < 4; ) k += "9";
        const P = k;
        k = k.substring(k.length - 4);
        const A = parseInt(a[0]), C = parseInt(a[1]);
        if (A > 3 || A === 3 && C >= 1) {
          const M = parseInt(P) % 40 + 30, N = parseInt(S.substring(1, 5), 16);
          if (Link2.YL === M + N) {
            this.ke = false;
            return;
          }
        } else {
          let M = "";
          const N = ["gsh", "gsf"], L = ["Header", "Background", "Display", "Feedback"];
          if (M += N[parseInt(k.substring(0, 1), 10) % 2], M += L[parseInt(k.substring(0, 1), 10) % 4], b[n("79a417a0f0181a8946")] = M, root.document[n("78a712aa")]) {
            root.document[n("78a712aa")][n("7bb806b6ed32388c4a875b")](b);
            const T = root.getComputedStyle(b).getPropertyValue(n("78a704b7e62456904c9b12701b6532a8")), D = root.getComputedStyle(b).getPropertyValue(n("75b817b0ea2202"));
            if (root.document[n("78a712aa")][n("68ad1bbcf533388c4a875b")](b), !T) continue;
            const F = root[n("77a902b0eb1b1e804a8a")], R = "0." + parseInt(P, 10) % 100;
            if (D === R || T.indexOf(parseInt(S[1] + S[2], 16).toString()) !== -1 && T.indexOf(parseInt(S[3] + S[4], 16).toString()) !== -1) {
              this.ke = false;
              return;
            } else if (F && F(n("32ae19a1e0331fc94084537c067a67fa59f1386b89d006")).matches) {
              M = "." + M;
              for (let I = 0; I < root.document.styleSheets.length; I++) {
                const O = root.document.styleSheets[I].rules || root.document.styleSheets[I].cssRules;
                for (const X in O) if (M === O[X].selectorText) {
                  this.ke = false;
                  return;
                }
              }
            }
          } else this.ke = null, i && (this.ke = false);
        }
      }
    }
    Aa(t, i) {
      return i.setTransform(t.te / 2, 0, 0, t.te / 2, 0, 0), i.commitTransform(), this.ke === null && this.UO(t, true), 0 < this.ke && this !== this.zL;
    }
  }
  class DraggingInfo2 {
    W2;
    j2;
    constructor(t) {
      this.W2 = t === void 0 ? new Point2() : t, this.j2 = new Point2();
    }
    get point() {
      return this.W2;
    }
    set point(t) {
      this.W2 = t;
    }
    get shifted() {
      return this.j2;
    }
    set shifted(t) {
      this.j2 = t;
    }
  }
  class DraggingNodeInfoPair {
    Ve;
    bL;
    wb;
    constructor(t, i, e) {
      this.Ve = t, this.bL = i, this.wb = e;
    }
  }
  class DraggingOptions2 {
    isGridSnapEnabled;
    isGridSnapRealtime;
    gridSnapCellSize;
    gridSnapCellSpot;
    gridSnapOrigin;
    dragsLink;
    dragsTree;
    groupsSnapMembers;
    groupsAlwaysMove;
    dragsMembers;
    constructor(t) {
      this.Ki(), t && Object.assign(this, t);
    }
    Ki() {
      this.isGridSnapEnabled = false, this.isGridSnapRealtime = true, this.gridSnapCellSize = new Size2(NaN, NaN).S(), this.gridSnapCellSpot = Spot2.TopLeft, this.gridSnapOrigin = new Point2(NaN, NaN).S(), this.dragsLink = false, this.dragsTree = false, this.groupsSnapMembers = false, this.groupsAlwaysMove = true, this.dragsMembers = true;
    }
  }
  class Palette2 extends Diagram2 {
    constructor(t, i) {
      let e;
      return t === void 0 || typeof t == "string" || root.Element && t instanceof Element ? e = t : U.it(t) && (i = t), super(e), this.KL(), i && this.setProperties(i), this;
    }
    KL() {
      this.allowDragOut = true, this.allowMove = false, this.isReadOnly = true, this.contentAlignment = Spot2.TopCenter, this.layout = new GridLayout2();
    }
    setupRouters() {
    }
    reset() {
      super.reset(), this.KL();
    }
  }
  class Overview2 extends Diagram2 {
    Sb;
    kb;
    Pb;
    Mb;
    V0;
    mc;
    Gl;
    J2;
    $2;
    Nb;
    Z2;
    constructor(t, i) {
      let e;
      return t === void 0 || typeof t == "string" || root.Element && t instanceof Element ? e = t : U.it(t) && (i = t), super(e), this.animationManager.isEnabled = false, this.$t = true, this.Sb = null, this.od = false, this.rd = false, this.kb = true, this.Pb = true, this.Mb = 0, this.V0 = false, this.mc = null, this.setRenderingHint("drawShadows", false), this.Gl = new Part2({ selectable: true, selectionAdorned: false, selectionObjectName: "BOXSHAPE", locationObjectName: "BOXSHAPE", resizeObjectName: "BOXSHAPE", cursor: "move" }).add(new Shape2({ name: "BOXSHAPE", fill: "transparent", stroke: "magenta", strokeWidth: 2 }).theme("stroke", "overviewBox")).Yt(), this.allowCopy = false, this.allowDelete = false, this.allowDrop = false, this.allowSelect = true, this.autoScrollRegion = new Margin2(0, 0, 0, 0), this.yt.e(0, 0), this.toolManager.ti("Dragging", new OverviewDraggingTool(), this.toolManager.mouseMoveTools), this.click = () => {
        const s = this.observed;
        if (s === null) return;
        const n = s.viewportBounds, o = this.lastInput.documentPoint;
        s.position = new Point2(o.x - n.width / 2, o.y - n.height / 2);
      }, this.J2 = (s) => {
        this.invalidateDocumentBounds(), this.z0();
      }, this.$2 = (s) => {
        this.observed !== null && (this.invalidateDocumentBounds(), this.L());
      }, this.Nb = (s) => {
        this.updateDelay < 1 ? this.L() : this.V0 || (this.V0 = true, U.yn(() => this.redraw(), this.updateDelay));
      }, this.Z2 = (s) => {
        this.observed !== null && this.z0();
      }, this.autoScale = 2, this.$t = false, i && this.setProperties(i), this;
    }
    setupRouters() {
    }
    computePixelRatio() {
      return 1;
    }
    redraw() {
      this.V0 && this.updateDelay >= 1 && (this.V0 = false, this.GO()), super.redraw();
    }
    vi() {
      if (this.Tt === null && U.n("No div specified"), this.ht === null && U.n("No canvas specified"), this.ht instanceof SVGSurface || (this.box.GM(), !this.Ze)) return;
      const t = this.observed;
      if (t === null || t.animationManager.defaultAnimation.isAnimating || !t.sa) return;
      this.F0();
      const i = this.ht, e = this._t;
      if (e.clearContextCache(true), e.setTransform(1, 0, 0, 1, 0, 0), e.clearRect(0, 0, i.width, i.height), this.updateDelay < 1) this.UL();
      else if (this.mc !== null) {
        e.drawImage(this.mc.Nt, 0, 0);
        const o = this.E;
        e.scale(this.te, this.te), e.transform(o.m11, o.m12, o.m21, o.m22, o.dx, o.dy), e.commitTransform();
      }
      const s = this.Ht.h, n = s.length;
      for (let o = 0; o < n; o++) s[o].vi(e, this);
      this.rc = false, this.Ze = false;
    }
    GO() {
      const t = this.ht, i = this._t;
      if (!(t === null || i === null)) {
        if (this.F0(), this.mc === null) {
          const e = new CanvasSurface(null);
          e.width = t.width, e.height = t.height, this.mc = e;
        }
        try {
          this.ht = this.mc, this._t = this.ht.ni, this._t.clearContextCache(true), this._t.setTransform(1, 0, 0, 1, 0, 0), this._t.clearRect(0, 0, this.ht.width, this.ht.height), this.UL();
        } finally {
          this.ht = t, this._t = i;
        }
      }
    }
    UL() {
      const t = this.observed;
      if (t === null) return;
      const i = this.drawsTemporaryLayers, e = this.drawsGrid && i, s = t.grid;
      if (e && s !== null && s.visible && !(isNaN(s.width) || isNaN(s.height))) {
        const a = Rect2.a().c(this.viewportBounds).unionRect(t.viewportBounds);
        t.ph(a), Rect2.o(a), t.Ri();
      }
      const n = this.E, o = this._t;
      o.scale(this.te, this.te), o.transform(n.m11, n.m12, n.m21, n.m22, n.dx, n.dy), o.commitTransform();
      const r = this.viewportBounds, l = t.Ht.h, h = l.length, f = this.Ht.h;
      this.Is(f, f.length, this, this.viewportBounds);
      for (let a = 0; a < h; a++) l[a].GR(o, r, this, i, e);
    }
    get observed() {
      return this.Sb;
    }
    set observed(t) {
      const i = this.Sb;
      if (t !== null && U.s(t, Diagram2, Overview2, "observed"), t instanceof Overview2 && U.n("Overview.observed Diagram may not be an Overview itself: " + t), i !== t) {
        if (i !== null && this.qO(i), this.Sb = t, t !== null && this.HO(t), this.invalidateDocumentBounds(), t === null) {
          this.mc = null;
          const e = this.ht, s = this._t;
          e && s && (s.setTransform(1, 0, 0, 1, 0, 0), s.clearRect(0, 0, e.width, e.height));
        } else this.Nb(null), this.z0(), this.L();
        this.t("observed", i, t);
      }
    }
    get box() {
      return this.Gl;
    }
    set box(t) {
      const i = this.Gl;
      i !== t && (U.s(t, Part2, Overview2, "box"), t.Yt(), this.Gl = t, this.remove(i), this.add(this.Gl), this.z0(), this.t("box", i, t));
    }
    get drawsTemporaryLayers() {
      return this.kb;
    }
    set drawsTemporaryLayers(t) {
      this.kb !== t && (this.kb = t, this.redraw());
    }
    get drawsGrid() {
      return this.Pb;
    }
    set drawsGrid(t) {
      this.Pb !== t && (this.Pb = t, this.redraw());
    }
    get updateDelay() {
      return this.Mb;
    }
    set updateDelay(t) {
      t < 0 && (t = 0), this.Mb !== t && (this.Mb = t);
    }
    HO(t) {
      t !== null && (t.addDiagramListener("ViewportBoundsChanged", this.J2), t.addDiagramListener("DocumentBoundsChanged", this.$2), t.addDiagramListener("InvalidateDraw", this.Nb), t.addDiagramListener("AnimationFinished", this.Z2), this.add(this.box));
    }
    qO(t) {
      t !== null && (this.remove(this.box), t.removeDiagramListener("ViewportBoundsChanged", this.J2), t.removeDiagramListener("DocumentBoundsChanged", this.$2), t.removeDiagramListener("InvalidateDraw", this.Nb), t.removeDiagramListener("AnimationFinished", this.Z2));
    }
    z0() {
      const t = this.box, i = this.observed;
      if (i === null) return;
      this.Ze = true;
      const e = i.viewportBounds, s = t.selectionObject, n = Size2.a();
      n.e(e.width, e.height), s.desiredSize = n, Size2.o(n);
      const o = 2 / this.scale;
      s instanceof Shape2 && (s.strokeWidth = o), t.location = new Point2(e.x - o / 2, e.y - o / 2), t.isSelected = true;
    }
    computeBounds() {
      const t = this.observed;
      if (t === null) return Rect2.rm;
      const i = t.documentBounds.copy();
      return i.unionRect(t.viewportBounds), i;
    }
    invalidateViewport(t, i) {
      this.Ze !== true && (this.Ze = true, this.requestUpdate());
    }
    onViewportBoundsChanged(t, i, e, s) {
      this.$t || (this.mh(), this.L(), this.Ta(), this.invalidateDocumentBounds(), this.z0(), this.Wi.scale = e, this.Wi.position.x = t.x, this.Wi.position.y = t.y, this.Wi.bounds.c(t), this.Wi.isScroll = s, this.F("ViewportBoundsChanged", this.Wi, t));
    }
  }
  class OverviewDraggingTool extends DraggingTool2 {
    wh;
    constructor() {
      super(), this.wh = Point2.xn;
    }
    canStart() {
      if (!this.isEnabled) return false;
      const t = this.diagram;
      if (t === null || !t.allowMove || !t.allowSelect) return false;
      const i = t.observed;
      if (i === null) return false;
      const e = t.lastInput;
      if (!e.left || t.currentTool !== this && (!this.isBeyondDragSize() || e.isTouchEvent && e.timestamp - t.firstInput.timestamp < this.delay)) return false;
      if (this.findDraggablePart() === null) {
        const n = i.viewportBounds;
        this.wh = new Point2(n.width / 2, n.height / 2);
        const o = t.firstInput.documentPoint;
        i.position = new Point2(o.x - this.wh.x, o.y - this.wh.y);
      }
      return true;
    }
    doActivate() {
      this.wh = Point2.xn, super.doActivate();
    }
    doUpdateCursor(t) {
      const i = this.diagram, e = i.box;
      e !== null && e.cursor && (i.currentCursor = e.cursor);
    }
    moveParts(t, i, e) {
      e === void 0 && (e = false);
      const s = this.diagram, n = s.observed;
      if (n === null) return;
      const o = s.box;
      if (o === null) return;
      if (!this.wh.isReal()) {
        const l = s.firstInput.documentPoint, h = o.location;
        this.wh = new Point2(l.x - h.x, l.y - h.y);
      }
      const r = s.lastInput.documentPoint;
      n.position = new Point2(r.x - this.wh.x, r.y - this.wh.y);
    }
  }
  class CommandHandler2 {
    f;
    Cb = "go._clipboard";
    Ab = "go._clipboardFormat";
    Q2;
    _2;
    tN;
    iN;
    eN;
    sN;
    nN;
    oN;
    rN;
    xh;
    lN;
    Tb;
    Lb;
    Db;
    Fb;
    hN;
    $o;
    aN;
    fN;
    X0;
    cN;
    Ib;
    uN;
    Rb;
    dN;
    gN;
    wd;
    Y0;
    K0;
    mN;
    nc;
    pN;
    yN;
    wN;
    xN;
    bN;
    xd;
    SN;
    ze;
    Cs;
    Ob;
    U0;
    static bd = ["Ctrl", "Shft", "Alt", "Meta"];
    static GL = CommandHandler2.kN(230, 40, 15);
    static vO = CommandHandler2.kN(270, 40, 15);
    static WO = CommandHandler2.kN(310, 40, 15);
    constructor(t) {
      GSet2._i(this), this.f = Diagram2.zm(), this.Q2 = true, this._2 = true, this.tN = true, this.iN = false, this.eN = false, this.sN = false, this.nN = false, this.oN = "memory", this.rN = null, this.xh = null, this.lN = 1.05, this.Tb = NaN, this.Lb = Point2.xn, this.Db = NaN, this.Fb = Rect2.rm, this.hN = false, this.$o = null, this.aN = 200, this.fN = false, this.X0 = new Adornment2("Auto", { layerName: "Tool", pickable: false, selectable: false }).add(new Panel2("Spot").add(new Shape2({ name: "SHAPE", fill: null, stroke: "lime", strokeWidth: 4 }).bindObject("stroke", "adornedPart", (i) => i.isSelected ? "darkcyan" : "lime"), new Shape2({ name: "SHAPE2", stretch: 2, fill: null, stroke: "magenta", strokeWidth: 4, strokeDashArray: [4, 4] })), new Placeholder2({ padding: 4 })), this.cN = null, this.Ib = "", this.uN = "", this.Rb = U.wr, this.dN = false, this.gN = false, this.wd = new Part2({ layerName: "Tool", isInDocumentBounds: false, locationObjectName: "CIRCLE", locationSpot: Spot2.Center, pickable: false, selectable: false }).add(new Shape2("Circle", { isGeometryPositioned: true, width: 30, height: 30, fill: null, stroke: "darkcyan", strokeWidth: 6, visible: false }).bind("visible", "down"), new Shape2({ isGeometryPositioned: true, geometryString: "M15 0L15 30", stroke: "magenta" }), new Shape2({ isGeometryPositioned: true, geometryString: "M0 15L30 15", stroke: "magenta" }), new Shape2("Circle", { name: "CIRCLE", isGeometryPositioned: true, width: 20, height: 20, fill: null, stroke: "magenta", position: new Point2(5, 5) }), new Shape2({ isGeometryPositioned: true, geometry: CommandHandler2.GL, fill: null, stroke: "cyan", strokeWidth: 4 }).bind("geometry", "button", CommandHandler2.jO), new TextBlock2({ position: new Point2(12, 0), font: "bold 10pt sans-serif" }).bind("text", "clickCount", (i) => i > 1 ? i.toString() : ""), new TextBlock2({ position: new Point2(0, 16) }).bind("text", "modifiers", CommandHandler2.JO)).freezeBindings(), this.Y0 = 10, this.K0 = 1, this.mN = null, this.nc = (i) => this.$O(i), this.pN = (i) => this.ZO(i), this.yN = (i) => this.QO(i), this.wN = (i) => this._O(i), this.xN = null, this.bN = "distance", this.xd = null, this.SN = 0, this.ze = {}, this.Cs = null, this.Ob = false, this.U0 = null, this.PN(), this.wd.data = this.ze, t && Object.assign(this, t);
    }
    toString() {
      return "CommandHandler";
    }
    get diagram() {
      return this.f;
    }
    Ko(t) {
      this.f = t;
    }
    doStart() {
      const t = this.f;
      t && (t.addModelChangedListener(this.nc), t.addDiagramListener("ViewportBoundsChanged", this.pN), t.addDiagramListener("GainedFocus", this.yN), t.addDiagramListener("LostFocus", this.wN));
    }
    doStop() {
      const t = this.f;
      t && (t.removeDiagramListener("ViewportBoundsChanged", this.pN), t.removeDiagramListener("GainedFocus", this.yN), t.removeDiagramListener("LostFocus", this.wN), t.removeModelChangedListener(this.nc));
    }
    doKeyDown() {
      const t = this.f, i = t.lastInput, e = i.control || i.meta, s = i.shift, n = i.alt, o = i.commandKey;
      e && (o === "Insert" || o === "c") ? this.canCopySelection() && this.copySelection() : e && o === "x" || s && o === "Delete" ? this.canCutSelection() && this.cutSelection() : e && o === "v" || s && o === "Insert" ? this.canPasteSelection() && this.pasteSelection() : e && o === "y" || e && s && o === "z" || n && s && o === "Backspace" ? this.canRedo() && this.redo() : e && o === "z" || n && o === "Backspace" ? this.canUndo() && this.undo() : o === "Delete" || o === "Backspace" ? this.canDeleteSelection() && this.deleteSelection() : e && o === "a" ? this.canSelectAll() && this.selectAll() : o === "Escape" ? this.canStopCommand() && this.stopCommand() : this.qL.indexOf(o) >= 0 ? this.t3(o, e, s) : o === "PageUp" ? s && t.allowHorizontalScroll ? t.scroll("page", "left") : t.allowVerticalScroll && t.scroll("page", "up") : o === "PageDown" ? s && t.allowHorizontalScroll ? t.scroll("page", "right") : t.allowVerticalScroll && t.scroll("page", "down") : o === "Home" ? e && t.allowVerticalScroll ? t.scroll("document", "up") : !e && t.allowHorizontalScroll && t.scroll("document", "left") : o === "End" ? e && t.allowVerticalScroll ? t.scroll("document", "down") : !e && t.allowHorizontalScroll && t.scroll("document", "right") : o === "Space" ? this.canScrollToPart() && this.scrollToPart() : o === "Minus" || o === "NumpadSubtract" ? this.canDecreaseZoom() && this.decreaseZoom() : o === "Equal" || o === "NumpadAdd" ? this.canIncreaseZoom() && this.increaseZoom() : e && o === "Digit0" ? this.canResetZoom() && this.resetZoom() : s && o === "z" ? this.canZoomToFit() && this.zoomToFit() : e && !s && o === "g" ? this.canGroupSelection() && this.groupSelection() : e && s && o === "g" ? this.canUngroupSelection() && this.ungroupSelection() : o === "F2" ? this.canEditTextBlock() && this.editTextBlock() : o === "ContextMenu" || s && o === "F10" || e && s && o === "Backslash" ? this.canShowContextMenu() && this.showContextMenu() : i.bubbles = true;
    }
    doKeyUp() {
      const i = this.f.lastInput;
      i.bubbles = true;
    }
    stopCommand() {
      const t = this.f, i = t.currentTool;
      if (i instanceof ToolManager2) {
        if (i.currentToolTip !== null) {
          i.hideToolTip();
          return;
        }
        t.allowSelect && t.clearSelection();
      }
      i !== null && i.doCancel();
    }
    canStopCommand() {
      return true;
    }
    selectAll() {
      const t = this.f;
      t.L();
      try {
        t.currentCursor = "wait", t.F("ChangingSelection", t.selection);
        const i = t.parts;
        for (; i.next(); ) {
          const n = i.value;
          n.canSelect() && !n.layer.isTemporary && (n.isSelected = true);
        }
        const e = t.nodes;
        for (; e.next(); ) {
          const n = e.value;
          n.canSelect() && !n.layer.isTemporary && (n.isSelected = true);
        }
        const s = t.links;
        for (; s.next(); ) {
          const n = s.value;
          n.canSelect() && !n.layer.isTemporary && (n.isSelected = true);
        }
      } finally {
        t.F("ChangedSelection", t.selection), t.currentCursor = "";
      }
    }
    canSelectAll() {
      return this.f.allowSelect;
    }
    deleteSelection() {
      const t = this.f;
      try {
        t.currentCursor = "wait", t.F("ChangingSelection", t.selection), t.startTransaction("Delete"), t.F("SelectionDeleting", t.selection);
        const i = new GSet2(), e = t.selection.iterator;
        for (; e.next(); ) {
          const s = e.value;
          Part2.bh(i, s, true, this.deletesTree ? 1 / 0 : 0, this.deletesConnectedLinks ? null : false, (n) => n.canDelete());
        }
        t.removeParts(i, true), t.F("SelectionDeleted", i);
      } finally {
        t.commitTransaction("Delete"), t.F("ChangedSelection", t.selection), t.currentCursor = "";
      }
    }
    canDeleteSelection() {
      const t = this.f;
      return !(t.isReadOnly || t.isModelReadOnly || !t.allowDelete || t.selection.count === 0);
    }
    copySelection() {
      const t = this.f;
      try {
        const i = new GSet2(), e = t.selection.iterator;
        for (; e.next(); ) {
          const s = e.value;
          Part2.bh(i, s, true, this.copiesTree ? 1 / 0 : 0, this.copiesConnectedLinks, (n) => n.canCopy());
        }
        this.copyToClipboard(i);
      } finally {
      }
    }
    canCopySelection() {
      const t = this.f;
      return !(!t.allowCopy || !t.allowClipboard || t.selection.count === 0);
    }
    cutSelection() {
      this.copySelection(), this.deleteSelection();
    }
    canCutSelection() {
      const t = this.f;
      return !(t.isReadOnly || t.isModelReadOnly || !t.allowCopy || !t.allowDelete || !t.allowClipboard || t.selection.count === 0);
    }
    copyToClipboard(t) {
      const i = this.f, e = this.storageLocation === "systemClipboard";
      if (e || this.storageLocation !== "memory") try {
        if (t === null) if (e && root.navigator.clipboard) root.navigator.clipboard.writeText("");
        else {
          const n = root[this.storageLocation];
          if (!n) return;
          n.setItem(this.Cb, ""), n.setItem(this.Ab, "");
        }
        else {
          const n = new Diagram2();
          if (n.isTreePathToChildren = i.isTreePathToChildren, n.toolManager.draggingTool.dragsLink = i.toolManager.draggingTool.dragsLink, n.model = i.model.copy(), i.copyParts(t, n, false), e && root.navigator.clipboard) root.navigator.clipboard.writeText(n.model.toJson());
          else {
            const o = root[this.storageLocation];
            if (!o) return;
            o.setItem(this.Cb, n.model.toJson()), o.setItem(this.Ab, n.model.dataFormat);
          }
        }
        i.F("ClipboardChanged", t);
        return;
      } catch {
        return;
      }
      let s = null;
      if (t === null) Diagram2.rL();
      else {
        let n = null;
        try {
          n = i.copyParts(t, null, true);
        } finally {
          s = new List2(), n !== null && s.addAll(n.iteratorValues), Diagram2.A0 = s, Diagram2.ub = i.model.dataFormat;
        }
      }
      i.F("ClipboardChanged", s);
    }
    pasteFromClipboard() {
      const t = this.f;
      if (this.storageLocation !== "memory") {
        const n = new GSet2();
        try {
          const o = root[this.storageLocation];
          if (!o) return n;
          const r = o.getItem(this.Cb), l = o.getItem(this.Ab);
          if (r === null || r === "" || l !== t.model.dataFormat) return n;
          {
            const h = new Diagram2();
            h.model = Model2.fromJson(r);
            const f = new GSet2();
            f.addAll(h.parts).addAll(h.nodes).addAll(h.links);
            const a = t.copyParts(f, t, false);
            return new GSet2().addAll(a.iteratorValues);
          }
        } catch {
          return n;
        }
      }
      const i = new GSet2(), e = Diagram2.A0;
      if (e === null || Diagram2.ub !== t.model.dataFormat) return i;
      let s = null;
      try {
        s = t.copyParts(e, t, false);
      } finally {
        if (s !== null) {
          const n = s.iterator;
          for (; n.next(); ) {
            const o = n.value, r = n.key;
            o.location.isReal() || (r.location.isReal() ? o.location = r.location : !o.position.isReal() && r.position.isReal() && (o.position = r.position)), i.add(o);
          }
        }
      }
      return i;
    }
    pasteSelectionAsync(t) {
      return __async(this, null, function* () {
        const i = this.f;
        if (root.navigator.clipboard === void 0) {
          U.ot('Cannot paste with storageLocation "clipboard", window.isSecureContext may be false.');
          return;
        }
        try {
          i.currentCursor = "wait", i.F("ChangingSelection", i.selection), i.startTransaction("Paste");
          let e = null;
          const s = yield root.navigator.clipboard.readText();
          try {
            const o = s;
            if (!(o === null || o === "")) {
              const r = new Diagram2();
              r.model = Model2.fromJson(o);
              const l = new GSet2();
              l.addAll(r.parts).addAll(r.nodes).addAll(r.links);
              const h = i.copyParts(l, i, false);
              e = new GSet2().addAll(h.iteratorValues);
            }
          } catch {
          }
          if (e === null) return;
          e.count > 0 && i.clearSelection(true);
          const n = e.iterator;
          for (; n.next(); ) {
            const o = n.value;
            o.isSelected = true;
          }
          if (t) {
            const o = i.computePartsBounds(i.selection);
            if (o.isReal()) {
              const r = this.computeEffectiveCollection(i.selection, i.gd);
              i.Ox(r, new Point2(t.x - o.centerX, t.y - o.centerY), i.gd, false);
            }
          }
          i.F("ClipboardPasted", e);
        } finally {
          i.commitTransaction("Paste"), i.F("ChangedSelection", i.selection), i.currentCursor = "";
        }
      });
    }
    pasteSelection(t) {
      if (this.storageLocation === "systemClipboard") {
        this.pasteSelectionAsync(t);
        return;
      }
      const i = this.f;
      try {
        i.currentCursor = "wait", i.F("ChangingSelection", i.selection), i.startTransaction("Paste");
        const e = this.pasteFromClipboard();
        e.count > 0 && i.clearSelection(true);
        const s = e.iterator;
        for (; s.next(); ) {
          const n = s.value;
          n.isSelected = true;
        }
        if (t) {
          const n = i.computePartsBounds(i.selection);
          if (n.isReal()) {
            const o = this.computeEffectiveCollection(i.selection, i.gd);
            i.Ox(o, new Point2(t.x - n.centerX, t.y - n.centerY), i.gd, false);
          }
        }
        i.F("ClipboardPasted", e);
      } finally {
        i.commitTransaction("Paste"), i.F("ChangedSelection", i.selection), i.currentCursor = "";
      }
    }
    canPasteSelection(t) {
      const i = this.f;
      if (i.isReadOnly || i.isModelReadOnly || !i.allowInsert || !i.allowClipboard) return false;
      if (this.storageLocation === "systemClipboard") return true;
      if (this.storageLocation !== "memory") try {
        const e = root[this.storageLocation];
        if (!e) return false;
        const s = e.getItem(this.Cb), n = e.getItem(this.Ab);
        return !(s === null || s === "" || n !== i.model.dataFormat);
      } catch {
        return false;
      }
      return !(Diagram2.A0 === null || Diagram2.A0.count === 0 || Diagram2.ub !== i.model.dataFormat);
    }
    undo() {
      this.f.undoManager.undo();
    }
    canUndo() {
      const t = this.f;
      return t.isReadOnly || t.isModelReadOnly ? false : t.allowUndo && t.undoManager.canUndo();
    }
    redo() {
      this.f.undoManager.redo();
    }
    canRedo() {
      const t = this.f;
      return t.isReadOnly || t.isModelReadOnly ? false : t.allowUndo && t.undoManager.canRedo();
    }
    decreaseZoom(t) {
      t === void 0 && (t = 1 / this.zoomFactor), U.r(t, CommandHandler2, "decreaseZoom:factor");
      const i = this.f;
      if (i.autoScale !== 1) return;
      const e = i.scale * t;
      e < i.minScale || e > i.maxScale || (i.scale = e);
    }
    canDecreaseZoom(t) {
      t === void 0 && (t = 1 / this.zoomFactor), U.r(t, CommandHandler2, "canDecreaseZoom:factor");
      const i = this.f;
      if (i.autoScale !== 1) return false;
      const e = i.scale * t;
      return e < i.minScale || e > i.maxScale ? false : i.allowZoom;
    }
    increaseZoom(t) {
      t === void 0 && (t = this.zoomFactor), U.r(t, CommandHandler2, "increaseZoom:factor");
      const i = this.f;
      if (i.autoScale !== 1) return;
      const e = i.scale * t;
      e < i.minScale || e > i.maxScale || (i.scale = e);
    }
    canIncreaseZoom(t) {
      t === void 0 && (t = this.zoomFactor), U.r(t, CommandHandler2, "canIncreaseZoom:factor");
      const i = this.f;
      if (i.autoScale !== 1) return false;
      const e = i.scale * t;
      return e < i.minScale || e > i.maxScale ? false : i.allowZoom;
    }
    resetZoom(t) {
      t === void 0 && (t = this.defaultScale), U.r(t, CommandHandler2, "resetZoom:newscale");
      const i = this.f;
      t < i.minScale || t > i.maxScale || (i.scale = t);
    }
    canResetZoom(t) {
      t === void 0 && (t = this.defaultScale), U.r(t, CommandHandler2, "canResetZoom:newscale");
      const i = this.f;
      return t < i.minScale || t > i.maxScale ? false : i.allowZoom;
    }
    zoomToFit(t) {
      const i = this.f, e = i.animationManager;
      e.stopAnimation(), i.redraw();
      const s = i.position.copy(), n = i.scale;
      if (e.vl("Zoom To Fit"), !t && this.isZoomToFitRestoreEnabled && n === this.Db && !isNaN(this.Tb) && this.Lb.isReal() && i.documentBounds.equals(this.Fb)) i.scale = this.Tb, i.position = this.Lb, this.Db = NaN, this.Fb = Rect2.rm;
      else {
        if (this.Tb = n, this.Lb = s, t) {
          const o = t.copy();
          if (o.width > 0 && o.height > 0) {
            const r = i.viewportBounds, l = r.width * n, h = r.height * n, f = Math.min(l / o.width, h / o.height), a = l / f, c = h / f;
            o.width < a && (o.x -= (a - o.width) / 2), o.height < c && (o.y -= (c - o.height) / 2);
          }
          i.zoomToRect(o, 2);
        } else i.zoomToFit();
        this.Db = i.scale, this.Fb = i.documentBounds.copy();
      }
      e.TM();
    }
    canZoomToFit(t) {
      return this.f.allowZoom;
    }
    t3(t, i, e) {
      const s = this.f;
      t === "ArrowUp" ? s.allowVerticalScroll && (i ? s.scroll("pixel", "up") : s.scroll("line", "up")) : t === "ArrowDown" ? s.allowVerticalScroll && (i ? s.scroll("pixel", "down") : s.scroll("line", "down")) : t === "ArrowLeft" ? s.allowHorizontalScroll && (i ? s.scroll("pixel", "left") : s.scroll("line", "left")) : t === "ArrowRight" && s.allowHorizontalScroll && (i ? s.scroll("pixel", "right") : s.scroll("line", "right"));
    }
    scrollToPart(t) {
      t === void 0 && (t = null), t !== null && U.s(t, Part2, CommandHandler2, "part");
      const i = this.f;
      if (i.ensureBounds(), t === null) {
        try {
          this.$o !== null && (this.$o.next() ? t = this.$o.value : this.$o = null);
        } catch {
          this.$o = null;
        }
        t === null && (i.highlighteds.count > 0 ? this.$o = i.highlighteds.iterator : i.selection.count > 0 && (this.$o = i.selection.iterator), this.$o !== null && this.$o.next() && (t = this.$o.value));
      }
      if (t !== null) {
        const e = i.animationManager;
        e.vl("Scroll To Part");
        const s = this.scrollToPartPause;
        if (s > 0) {
          const n = this.pc(t, [t]);
          if (n.length === 1) i.startTransaction(), i.centerRect(t.actualBounds), i.commitTransaction("Scroll To Part");
          else {
            const o = () => {
              i.startTransaction();
              let l = n.pop();
              for (; n.length > 0 && l instanceof Node2 && l.isTreeExpanded && (!(l instanceof Group2) || l.isSubGraphExpanded); ) l = n.pop();
              n.length > 0 ? (l instanceof Part2 && i.scrollToRect(l.actualBounds), l instanceof Node2 && !l.isTreeExpanded && (l.isTreeExpanded = true), l instanceof Group2 && !l.isSubGraphExpanded && (l.isSubGraphExpanded = true)) : (l instanceof Part2 && i.centerRect(l.actualBounds), i.removeDiagramListener("LayoutCompleted", r)), i.commitTransaction("Scroll To Part");
            }, r = () => {
              U.yn(o, (e.isEnabled ? e.duration : 0) + s);
            };
            i.addDiagramListener("LayoutCompleted", r), o();
          }
        } else {
          const n = i.position.copy();
          i.centerRect(t.actualBounds), n.equalsApprox(i.position) && e.stopAnimation();
        }
      }
    }
    pc(t, i) {
      if (t.isVisible()) return i;
      if (t instanceof Adornment2) {
        const e = t.adornedPart;
        e !== null && this.pc(e, i);
      } else if (t instanceof Link2) {
        const e = t.fromNode;
        e !== null && this.pc(e, i);
        const s = t.toNode;
        s !== null && this.pc(s, i);
      } else {
        if (t instanceof Node2) {
          const s = t.labeledLink;
          s !== null && this.pc(s, i);
          const n = t.findTreeParentNode();
          n !== null && (!n.isTreeExpanded && !n.wasTreeExpanded && i.push(n), this.pc(n, i));
        }
        const e = t.containingGroup;
        e !== null && (!e.isSubGraphExpanded && !e.wasSubGraphExpanded && i.push(e), this.pc(e, i));
      }
      return i;
    }
    canScrollToPart(t) {
      if (t === void 0 && (t = null), t !== null && !(t instanceof Part2)) return false;
      const i = this.f;
      return i.selection.count === 0 && i.highlighteds.count === 0 ? false : i.allowHorizontalScroll && i.allowVerticalScroll;
    }
    collapseTree(t) {
      t === void 0 && (t = null);
      const i = this.f, e = "Collapse Tree";
      try {
        i.startTransaction(e), i.animationManager.vl(e);
        const n = new List2();
        if (t !== null && t.isTreeExpanded) t.collapseTree(), n.add(t);
        else if (t === null) {
          const o = i.selection.iterator;
          for (; o.next(); ) {
            const r = o.value;
            r instanceof Node2 && r.isTreeExpanded && (r.collapseTree(), n.add(r));
          }
        }
        i.F("TreeCollapsed", n);
      } finally {
        i.commitTransaction(e);
      }
    }
    canCollapseTree(t) {
      t === void 0 && (t = null);
      const i = this.f;
      if (i.isReadOnly) return false;
      if (t !== null) {
        if (!(t instanceof Node2) || !t.isTreeExpanded) return false;
        if (t.findTreeChildrenLinks().count > 0) return true;
      } else {
        const e = i.selection.iterator;
        for (; e.next(); ) {
          const s = e.value;
          if (s instanceof Node2) {
            if (!s.isTreeExpanded) continue;
            if (s.findTreeChildrenLinks().count > 0) return true;
          }
        }
      }
      return false;
    }
    expandTree(t) {
      t === void 0 && (t = null);
      const i = this.f, e = "Expand Tree";
      try {
        i.startTransaction(e), i.animationManager.vl(e);
        const n = new List2();
        if (t !== null && !t.isTreeExpanded) t.expandTree(), n.add(t);
        else if (t === null) {
          const o = i.selection.iterator;
          for (; o.next(); ) {
            const r = o.value;
            r instanceof Node2 && (r.isTreeExpanded || (r.expandTree(), n.add(r)));
          }
        }
        i.F("TreeExpanded", n);
      } finally {
        i.commitTransaction(e);
      }
    }
    canExpandTree(t) {
      t === void 0 && (t = null);
      const i = this.f;
      if (i.isReadOnly) return false;
      if (t !== null) {
        if (!(t instanceof Node2) || t.isTreeExpanded) return false;
        if (t.findTreeChildrenLinks().count > 0) return true;
      } else {
        const e = i.selection.iterator;
        for (; e.next(); ) {
          const s = e.value;
          if (s instanceof Node2) {
            if (s.isTreeExpanded) continue;
            if (s.findTreeChildrenLinks().count > 0) return true;
          }
        }
      }
      return false;
    }
    groupSelection() {
      const t = this.f, i = t.model;
      if (!i.Ia()) return;
      const e = this.archetypeGroupData;
      if (e === null) return;
      let s = null;
      try {
        t.currentCursor = "wait", t.F("ChangingSelection", t.selection), t.startTransaction("Group");
        const n = new List2(), o = t.selection.iterator;
        for (; o.next(); ) {
          const f = o.value;
          f.Oe() && f.canGroup() && n.add(f);
        }
        const r = new List2(), l = n.iterator;
        for (; l.next(); ) {
          const f = l.value;
          let a = false;
          const c = n.iterator;
          for (; c.next(); ) {
            const u = c.value;
            if (f.isMemberOf(u)) {
              a = true;
              break;
            }
          }
          a || r.add(f);
        }
        const h = r.first();
        if (h !== null) {
          let f = h.containingGroup;
          if (f !== null) for (; f !== null; ) {
            let a = false;
            const c = r.iterator;
            for (; c.next(); ) if (!c.value.isMemberOf(f)) {
              a = true;
              break;
            }
            if (a) f = f.containingGroup;
            else break;
          }
          if (e instanceof Group2) e.Yt(), s = e.copy(), s !== null && t.add(s);
          else if (i.isGroupForData(e)) {
            const a = i.copyNodeData(e);
            i.addNodeData(a), s = t.findNodeForData(a);
          }
          if (s !== null) {
            f !== null && this.isValidMember(f, s) && (s.containingGroup = f);
            const a = r.iterator;
            for (; a.next(); ) {
              const c = a.value;
              this.isValidMember(s, c) && (c.containingGroup = s);
            }
            t.clearSelection(true), s.isSelected = true;
          }
        }
        t.F("SelectionGrouped", s);
      } finally {
        t.commitTransaction("Group"), t.F("ChangedSelection", t.selection), t.currentCursor = "";
      }
    }
    canGroupSelection() {
      const t = this.f;
      if (t.isReadOnly || t.isModelReadOnly || !t.allowInsert || !t.allowGroup || !t.model.Ia() || this.archetypeGroupData === null) return false;
      const e = t.selection.iterator;
      for (; e.next(); ) {
        const s = e.value;
        if (s.Oe() && s.canGroup()) return true;
      }
      return false;
    }
    MN(t) {
      const i = U.ft();
      if (Array.isArray(t)) t.forEach((n) => {
        n instanceof Link2 || n instanceof Part2 && i.push(n);
      });
      else {
        const n = t.iterator;
        for (; n.next(); ) {
          const o = n.value;
          o instanceof Link2 || o instanceof Part2 && i.push(o);
        }
      }
      const e = new GSet2(), s = i.length;
      for (let n = 0; n < s; n++) {
        const o = i[n];
        let r = true;
        for (let l = 0; l < s; l++) if (o.isMemberOf(i[l])) {
          r = false;
          break;
        }
        r && e.add(o);
      }
      return U.et(i), e;
    }
    isValidMember(t, i) {
      if (i === null || t === i || i instanceof Link2) return false;
      let e;
      return t !== null && (t === i || t.isMemberOf(i) || (e = t.memberValidation, e !== null && !e(t, i)) || t.data === null && i.data !== null || t.data !== null && i.data === null) ? false : (e = this.memberValidation, e !== null ? e(t, i) : true);
    }
    ungroupSelection(t) {
      t === void 0 && (t = null);
      const i = this.f, e = i.model;
      if (e.Ia()) try {
        i.currentCursor = "wait", i.F("ChangingSelection", i.selection), i.startTransaction("Ungroup");
        const s = new List2();
        if (t !== null) s.add(t);
        else {
          const o = i.selection.iterator;
          for (; o.next(); ) {
            const r = o.value;
            r instanceof Group2 && r.canUngroup() && s.add(r);
          }
        }
        const n = new List2();
        if (s.count > 0) {
          i.clearSelection(true);
          const o = s.iterator;
          for (; o.next(); ) {
            const r = o.value;
            r.expandSubGraph();
            const l = r.containingGroup, h = l !== null && l.data !== null ? e.getKeyForNodeData(l.data) : void 0;
            n.addAll(r.memberParts);
            const f = n.iterator;
            for (; f.next(); ) {
              const a = f.value;
              if (a.isSelected = true, a instanceof Link2) continue;
              const c = a.data;
              c !== null ? e.setGroupForData(c, h) : a.containingGroup = l;
            }
            i.remove(r);
          }
        }
        i.F("SelectionUngrouped", s, n);
      } finally {
        i.commitTransaction("Ungroup"), i.F("ChangedSelection", i.selection), i.currentCursor = "";
      }
    }
    canUngroupSelection(t) {
      t === void 0 && (t = null);
      const i = this.f;
      if (i.isReadOnly || i.isModelReadOnly || !i.allowDelete || !i.allowUngroup || !i.model.Ia()) return false;
      if (t !== null) {
        if (!(t instanceof Group2)) return false;
        if (t.canUngroup()) return true;
      } else {
        const s = i.selection.iterator;
        for (; s.next(); ) {
          const n = s.value;
          if (n instanceof Group2 && n.canUngroup()) return true;
        }
      }
      return false;
    }
    addTopLevelParts(t, i) {
      const e = this.MN(t);
      let s = true;
      const n = e.iterator;
      for (; n.next(); ) {
        const o = n.value;
        o.containingGroup !== null && (!i || this.isValidMember(null, o) ? o.containingGroup = null : s = false);
      }
      return s;
    }
    collapseSubGraph(t) {
      t === void 0 && (t = null);
      const i = this.f, e = "Collapse SubGraph";
      try {
        i.startTransaction(e), i.animationManager.vl(e);
        const n = new List2();
        if (t !== null && t.isSubGraphExpanded) t.collapseSubGraph(), n.add(t);
        else if (t === null) {
          const o = i.selection.iterator;
          for (; o.next(); ) {
            const r = o.value;
            r instanceof Group2 && r.isSubGraphExpanded && (r.collapseSubGraph(), n.add(r));
          }
        }
        i.F("SubGraphCollapsed", n);
      } finally {
        i.commitTransaction(e);
      }
    }
    canCollapseSubGraph(t) {
      t === void 0 && (t = null);
      const i = this.f;
      if (i.isReadOnly) return false;
      if (t !== null) return !(!(t instanceof Group2) || !t.isSubGraphExpanded);
      {
        const e = i.selection.iterator;
        for (; e.next(); ) {
          const s = e.value;
          if (s instanceof Group2 && s.isSubGraphExpanded) return true;
        }
      }
      return false;
    }
    expandSubGraph(t) {
      t === void 0 && (t = null);
      const i = this.f, e = "Expand SubGraph", s = new List2();
      try {
        if (i.startTransaction(e), i.animationManager.vl(e), t !== null && !t.isSubGraphExpanded) t.expandSubGraph(), s.add(t);
        else if (t === null) {
          const o = i.selection.iterator;
          for (; o.next(); ) {
            const r = o.value;
            r instanceof Group2 && (r.isSubGraphExpanded || (r.expandSubGraph(), s.add(r)));
          }
        }
        i.F("SubGraphExpanded", s);
      } finally {
        for (const n of s) this.HL(i, n);
        t && this.HL(i, t), i.commitTransaction(e);
      }
    }
    HL(t, i) {
      for (const e of i.memberParts) e instanceof Node2 && t.Jf(e, i);
    }
    canExpandSubGraph(t) {
      t === void 0 && (t = null);
      const i = this.f;
      if (i.isReadOnly) return false;
      if (t !== null) return !(!(t instanceof Group2) || t.isSubGraphExpanded);
      {
        const e = i.selection.iterator;
        for (; e.next(); ) {
          const s = e.value;
          if (s instanceof Group2 && !s.isSubGraphExpanded) return true;
        }
      }
      return false;
    }
    editTextBlock(t) {
      t === void 0 && (t = null), t !== null && U.s(t, TextBlock2, CommandHandler2, "editTextBlock");
      const i = this.f, e = i.toolManager.findTool("TextEditing");
      if (e !== null) {
        if (t === null) {
          let s = null;
          const n = i.selection.iterator;
          for (; n.next(); ) {
            const o = n.value;
            if (o.canEdit()) {
              s = o;
              break;
            }
          }
          if (s === null) return;
          t = s.findInVisualTree((o) => o instanceof TextBlock2 && o.editable);
        }
        t !== null && (i.currentTool = null, e.textBlock = t, i.currentTool = e);
      }
    }
    canEditTextBlock(t) {
      t === void 0 && (t = null);
      const i = this.f;
      if (i.isReadOnly || i.isModelReadOnly || !i.allowTextEdit || i.toolManager.findTool("TextEditing") === null) return false;
      if (t !== null) {
        if (!(t instanceof TextBlock2)) return false;
        const e = t.part;
        if (e !== null && e.canEdit()) return true;
      } else {
        const e = i.selection.iterator;
        for (; e.next(); ) {
          const s = e.value;
          if (s.canEdit() && (t = s.findInVisualTree((n) => n instanceof TextBlock2 && n.editable), t !== null)) return true;
        }
      }
      return false;
    }
    showContextMenu(t) {
      const i = this.f, e = i.toolManager.findTool("ContextMenu");
      if (e === null) return;
      t === void 0 && (t = null), t === null && (i.selection.count > 0 ? t = i.selection.first() : t = i);
      const s = e.findObjectWithContextMenu(t);
      if (s !== null) {
        const n = i.lastInput;
        let o;
        if (s instanceof GraphObject2 ? o = s.getDocumentPoint(Spot2.Center) : i.viewportBounds.containsPoint(n.documentPoint) ? o = Point2.xn : o = i.viewportBounds.center, o.isReal()) {
          const r = new InputEvent2();
          r.diagram = i, r.viewPoint = i.transformDocToView(o), r.documentPoint = o, r.button = 2, r.up = true, i.lastInput = r;
        }
        i.currentTool = e, e.openMenu(false, s);
      }
    }
    canShowContextMenu(t) {
      const i = this.f, e = i.toolManager.findTool("ContextMenu");
      return !(e === null || (t === void 0 && (t = null), t === null && (i.selection.count > 0 ? t = i.selection.first() : t = i), e.findObjectWithContextMenu(t) === null));
    }
    downloadSvg(t) {
      const i = this.f, e = { scale: 1, background: i.div ? i.div.style.backgroundColor : "white", name: this.i3("svg") };
      t && Object.assign(e, t);
      const s = i.makeSvg(e);
      if (s !== null) {
        const n = new XMLSerializer().serializeToString(s);
        this.e3(e.name, "image/svg+xml", n);
      }
    }
    downloadSVG(t) {
      this.downloadSvg(t);
    }
    canDownloadSvg(t) {
      return this.f !== null;
    }
    e3(t, i, e) {
      let s = null, n = null;
      try {
        const o = new Blob([e], { type: i });
        s = root.URL.createObjectURL(o), n = U.Le("a"), n.style.display = "none", n.href = s, n.download = t, root.document.body.appendChild(n), requestAnimationFrame(() => {
          try {
            n !== null && n.click();
          } finally {
            s !== null && root.URL.revokeObjectURL(s), n !== null && root.document.body.removeChild(n);
          }
        });
      } catch {
        s !== null && root.URL.revokeObjectURL(s), n !== null && root.document.body.removeChild(n);
      }
    }
    i3(t) {
      const i = "." + t;
      let e = this.diagram.model.name;
      return e ? e.endsWith(i) && (e = e.substring(0, e.length - i.length)) : e = "diagram", e += i, e;
    }
    get copiesClipboardData() {
      return this.Q2;
    }
    set copiesClipboardData(t) {
      this.Q2 = !!t;
    }
    get copiesConnectedLinks() {
      return this._2;
    }
    set copiesConnectedLinks(t) {
      this._2 = !!t;
    }
    get deletesConnectedLinks() {
      return this.tN;
    }
    set deletesConnectedLinks(t) {
      this.tN = !!t;
    }
    get copiesTree() {
      return this.iN;
    }
    set copiesTree(t) {
      this.iN = !!t;
    }
    get deletesTree() {
      return this.eN;
    }
    set deletesTree(t) {
      this.eN = !!t;
    }
    get copiesParentKey() {
      return this.sN;
    }
    set copiesParentKey(t) {
      this.sN = !!t;
    }
    get copiesGroupKey() {
      return this.nN;
    }
    set copiesGroupKey(t) {
      this.nN = !!t;
    }
    get storageLocation() {
      return this.oN;
    }
    set storageLocation(t) {
      t || (t = "memory"), t !== "memory" && t !== "sessionStorage" && t !== "localStorage" && t !== "systemClipboard" && U.n("Invalid new value for CommandHandler.storageLocation: " + t), this.oN = t;
    }
    get archetypeGroupData() {
      return this.rN;
    }
    set archetypeGroupData(t) {
      t !== null && U.Oo(t, CommandHandler2, "archetypeGroupData");
      const i = this.f;
      if (Debug && t !== null && i) {
        const e = i.model;
        e.Ia() && !(t instanceof Group2) && !e.isGroupForData(t) && U.n("CommandHandler.archetypeGroupData must be either a Group or a data object for which GraphLinksModel.isGroupForNodeData is true: " + t);
      }
      this.rN = t;
    }
    get memberValidation() {
      return this.xh;
    }
    set memberValidation(t) {
      t !== null && U.C(t, CommandHandler2, "memberValidation"), this.xh = t;
    }
    get defaultScale() {
      return this.diagram.defaultScale;
    }
    set defaultScale(t) {
      this.diagram.defaultScale = t;
    }
    get zoomFactor() {
      return this.lN;
    }
    set zoomFactor(t) {
      U.r(t, CommandHandler2, "zoomFactor"), t > 1 || U.n("zoomFactor must be larger than 1.0, not: " + t), this.lN = t;
    }
    get isZoomToFitRestoreEnabled() {
      return this.hN;
    }
    set isZoomToFitRestoreEnabled(t) {
      this.hN = !!t;
    }
    get scrollToPartPause() {
      return this.aN;
    }
    set scrollToPartPause(t) {
      this.aN = t;
    }
    computeEffectiveCollection(t, i) {
      const e = this.f, s = e.toolManager.findTool("Dragging"), n = e.currentTool === s;
      i === void 0 && (i = e.R0());
      const o = new GMap2();
      if (t === null) return o;
      let r = t.iterator;
      for (; r.next(); ) {
        const l = r.value;
        e.ol(o, l, n, i);
      }
      if (e.draggedLink !== null && i.dragsLink) return o;
      for (r = t.iterator; r.next(); ) {
        const l = r.value;
        if (l instanceof Link2) {
          const h = l.fromNode;
          if (h !== null && !o.has(h)) o.delete(l);
          else {
            const f = l.toNode;
            f !== null && !o.has(f) && o.delete(l);
          }
        }
      }
      return o;
    }
    static getModifierNames() {
      return CommandHandler2.bd;
    }
    static setModifierNames(t) {
      CommandHandler2.bd = t;
    }
    static JO(t) {
      let i = "";
      return t & 1 && (i += CommandHandler2.bd[0] || ""), t & 4 && (i += CommandHandler2.bd[1] || ""), t & 2 && (i += CommandHandler2.bd[2] || ""), t & 8 && (i += CommandHandler2.bd[3] || ""), i;
    }
    static jO(t) {
      return t === 1 ? CommandHandler2.vO : t === 2 ? CommandHandler2.WO : CommandHandler2.GL;
    }
    static kN(t, i, e) {
      var s = new Point2(e, 0).rotate(t - i / 2), n = new Geometry2().add(new PathFigure2(-e, -e)).add(new PathFigure2(e, e)).add(new PathFigure2(s.x, s.y).add(new PathSegment2(5, t - i / 2, i, 0, 0, e, e)));
      return n.offset(e, e), n;
    }
    $O(t) {
      t.isTransactionFinished && this.updateFocusBox();
    }
    ZO(t) {
      if (t.subject.scale === this.diagram.scale) return;
      const i = 4 / this.diagram.scale, e = this.focusBox.findObject("SHAPE");
      e !== null && (e.strokeWidth = i);
      const s = this.focusBox.findObject("SHAPE2");
      s !== null && (s.strokeWidth = i, s.strokeDashArray = [i, i]);
      const n = this.focusBox.placeholder;
      n !== null && (n.padding = i);
    }
    QO(t) {
      this.focus === null ? U.yn(() => {
        this.focus = this.findFirstFocus();
      }, 500) : this.onFocusChanged(this.focus, this.focus);
    }
    _O(t) {
      this.isVirtualPointerShown = false;
    }
    get isFocusEnabled() {
      return this.fN;
    }
    set isFocusEnabled(t) {
      t = !!t;
      const i = this.isFocusEnabled;
      t !== i && (t || (this.isVirtualPointerShown = false, this.xN = this.focus, this.focus = null), this.fN = t, t && (this.focus = this.xN, this.updateFocusBox()));
    }
    get focusBox() {
      return this.X0;
    }
    set focusBox(t) {
      if (!(t instanceof Adornment2)) return;
      const i = this.X0;
      if (t !== i && (this.X0 = t, i.adornedObject !== null)) {
        const e = i.adornedPart;
        e !== null && e.removeAdornment("Focus"), t.adornedObject = i.adornedObject, e !== null && e.addAdornment("Focus", t);
      }
    }
    get focus() {
      return this.X0.adornedObject;
    }
    set focus(t) {
      const i = this.focus;
      if (t !== i) {
        const e = this.f;
        if (!e || !this.isFocusEnabled || t !== null && t.diagram !== e) return;
        e.currentTool instanceof ContextMenuTool2 || this.cancelVirtualPointer();
        const s = this.focusBox.adornedPart;
        s && s.removeAdornment("Focus"), t === null ? (this.xd = null, this.virtualPointerLocation = e.viewportBounds.center, this.focusBox.adornedObject = null) : (this.virtualPointerLocation = t.getDocumentPoint(Spot2.Center), this.focusBox.adornedObject = t, this.updateFocusBox()), this.onFocusChanged(i, t);
      }
    }
    onFocusChanged(t, i) {
      const e = this.f;
      if (e && (this.focusChanged !== null ? this.focusChanged(t, i, this) : this.s3(this.describe(t, i)), i !== null && i.part !== null)) {
        const s = i.getDocumentBounds();
        e.viewportBounds.containsRect(s) || (i instanceof Part2 ? e.commandHandler.scrollToPart(i) : e.scrollToRect(s));
      }
    }
    get focusChanged() {
      return this.cN;
    }
    set focusChanged(t) {
      t !== null && U.C(t, CommandHandler2, "focusChanged"), this.cN = t;
    }
    get liveElementId() {
      return this.Ib || this.uN;
    }
    set liveElementId(t) {
      const i = this.Ib;
      t !== i && (this.Ib = t, this.NN());
    }
    NN() {
      const t = this.diagram;
      if (!t || !Diagram2.isUsingDOM()) return;
      const i = t.ht?.Nt;
      if (!i) return;
      const e = this.liveElementId, s = root.document.getElementById(e);
      this.isUsingAriaLive ? (i.removeAttribute("aria-labelledby"), s && s.setAttribute("aria-live", "polite")) : (e && i.setAttribute("aria-labelledby", e), s && s.removeAttribute("aria-live"));
    }
    get isUsingAriaLive() {
      return this.Rb;
    }
    set isUsingAriaLive(t) {
      const i = this.Rb;
      t !== i && (this.Rb = t, this.NN());
    }
    s3(t) {
      const i = this.diagram;
      if (!i || !Diagram2.isUsingDOM() || !i.div) return;
      let e = this.liveElementId;
      if (!e) {
        const n = U.Le("span"), o = n.style;
        for (o.opacity = "0", o.position = "absolute", o.right = "-9999px", o.bottom = "-9999px", o.width = "0px", o.height = "0px", o.overflow = "hidden", o.border = "0", e = (i.div.id || "diagram") + "_aria"; root.document.getElementById(e); ) e += Math.floor(Math.random() * 10);
        n.id = e, this.uN = e, i.div.appendChild(n), this.NN();
      }
      const s = root.document.getElementById(e);
      s && (s.textContent = t);
    }
    describe(t, i) {
      let e = "";
      i instanceof Node2 ? i instanceof Group2 ? e = "Group" : e = "Node" : i instanceof Link2 ? e = "Link" : i instanceof Part2 ? e = "Part" : i && (i.click ? e = "button" : i instanceof TextBlock2 && i.editable && (e = "editable"), i.portId !== null && (e && (e += " "), e += "port", i.portId && (e += " " + i.portId)));
      const s = this.CN(i);
      s && (e += " " + s);
      const n = i;
      if (t && n instanceof Link2 && n.fromNode && n.toNode) {
        if (t instanceof Node2 && t.part === n.fromNode || t instanceof Link2 && t.fromNode === n.fromNode) {
          e += " to " + this.CN(n.toNode, true);
          const o = n.toPort?.portId;
          o && (e += " port " + o);
        } else if (t instanceof Node2 && t.part === n.toNode || t instanceof Link2 && t.toNode === n.toNode) {
          e += " from " + this.CN(n.fromNode, true);
          const o = n.fromPort?.portId;
          o && (e += " port " + o);
        }
      }
      return e;
    }
    CN(t, i) {
      if (i === void 0 && (i = false), !t) return "";
      if (t instanceof TextBlock2 && t.text) return t.text;
      if (t instanceof Panel2) {
        let e = "";
        return t instanceof Part2 && t.text && (e = t.text), i && e || t.walkVisualTreeFrom(t, (s, n) => {
          n.isVisibleObject() && n instanceof TextBlock2 && n.text && (!i || !e) && e !== n.text && (e += " " + n.text);
        }), e;
      }
      return "";
    }
    updateFocusBox() {
      const t = this.focus;
      if (t === null) return;
      if (t.diagram !== null && (t instanceof Part2 ? t.isVisible() : t.isVisibleObject() && t.part?.isVisible())) this.focusBox.adornedObject = t, t.part?.addAdornment("Focus", this.focusBox);
      else {
        let e = null;
        if (t instanceof Part2 || (e = t.part), e instanceof Part2 && e.isVisible()) this.focus = e;
        else {
          if (e instanceof Node2 && !e.isVisible()) {
            const s = e.findTreeParentNode();
            if (s !== null) e = s;
            else {
              const n = e.labeledLink;
              n !== null && (e = n);
            }
          }
          for (; e instanceof Part2 && !e.isVisible(); ) e = e.containingGroup;
          e instanceof Part2 && e.isVisible() ? this.focus = e : this.focus = null;
        }
      }
    }
    findFirstFocus() {
      const t = this.f;
      if (t === null || !t.isEnabled) return null;
      if (this.focus !== null) return this.focus;
      if (this.isFocusEnabled) if (t.selection.count > 0) this.focus = t.selection.first();
      else {
        const i = this.vL(t.isTreePathToChildren).first();
        if (i !== null) return i;
      }
      return null;
    }
    get isVirtualPointerEnabled() {
      return this.dN;
    }
    set isVirtualPointerEnabled(t) {
      t = !!t;
      const i = this.isVirtualPointerEnabled;
      if (t !== i && (this.dN = t, t)) {
        const e = this.U0;
        e && (this.U0 = null, e.commandHandler.Cs = null, e.commandHandler.cancelVirtualPointer());
      }
    }
    get isVirtualPointerShown() {
      return this.gN;
    }
    set isVirtualPointerShown(t) {
      t = !!t;
      const i = this.isVirtualPointerShown;
      if (t !== i) {
        const e = this.f;
        if (!e || !this.isVirtualPointerEnabled) return;
        this.gN = t;
        const s = this.focus;
        t ? this.virtualPointerBox.diagram === null && (this.virtualPointerLocation.isReal() || (s !== null ? this.virtualPointerLocation = s.getDocumentPoint(Spot2.Center) : this.virtualPointerLocation = e.viewportBounds.center), e.add(this.virtualPointerBox), this.Sh()) : this.virtualPointerBox.diagram !== null && (e.remove(this.virtualPointerBox), this.Sh());
      }
    }
    cancelVirtualPointer() {
      const t = this.f;
      t && (this.PN(), this.isVirtualPointerShown = false, t.currentTool.doCancel(), this.isVirtualPointerDown = false, this.AN());
    }
    AN() {
      const t = this.Cs;
      if (t !== null) {
        this.Cs = null;
        const i = t.commandHandler;
        i.Cs = null, i.U0 = null, i.isVirtualPointerShown = false, i.isVirtualPointerDown = false, i.PN(), this.Ob && (i.isVirtualPointerEnabled = false), this.Ob = false;
      }
    }
    PN() {
      this.ze.button = 0, this.ze.modifiers = 0, this.ze.clickCount = 1, this.ze.down = false, this.Sh();
    }
    Sh() {
      this.virtualPointerChanged !== null && this.virtualPointerChanged(this.virtualPointerBox, this), this.updateVirtualPointer();
    }
    updateVirtualPointer() {
      const t = this.virtualPointerBox.diagram;
      t && (this.virtualPointerBox.scale = 1 / t.scale), this.virtualPointerBox.updateTargetBindings();
    }
    get virtualPointerBox() {
      return this.wd;
    }
    set virtualPointerBox(t) {
      if (!(t instanceof Part2)) return;
      const i = this.wd;
      t !== i && (i !== null && (t.location = i.location, i.diagram !== null && i.diagram.remove(i)), this.wd = t, this.isVirtualPointerShown && this.diagram && (this.diagram.add(t), t.data = i.data), this.Sh());
    }
    get virtualPointerChanged() {
      return this.mN;
    }
    set virtualPointerChanged(t) {
      t !== null && U.C(t, CommandHandler2, "virtualPointerChanged"), this.mN = t;
    }
    get virtualPointerLocation() {
      return this.virtualPointerBox.location;
    }
    set virtualPointerLocation(t) {
      this.virtualPointerLocation.equals(t) || this.WL(t.x, t.y);
    }
    get isVirtualPointerDown() {
      return this.virtualPointerBox.data ? this.virtualPointerBox.data.down : false;
    }
    set isVirtualPointerDown(t) {
      t = !!t;
      const i = this.isVirtualPointerDown;
      if (t !== i) {
        const e = this.f;
        if (!e || !this.isVirtualPointerEnabled || (this.virtualPointerBox.data === null && (this.wd.data = this.ze), this.virtualPointerBox.data.down = t, this.Sh(), !this.isVirtualPointerShown)) return;
        const s = e.lastInput, n = new InputEvent2();
        n.diagram = e, this.jL(n, t), t ? n.down = true : n.up = true, n.clickCount = 1, n.button = this.ze.button, n.modifiers = this.ze.modifiers, t && (e.firstInput = n.copy()), this.Sd(n, true), t || this.ze.clickCount === 2 && (n.clickCount = 2, n.down = true, n.up = false, this.Sd(n, true), n.down = false, n.up = true, this.Sd(n, true), this.JL(1)), e.lastInput = s;
      }
    }
    get virtualPointerShiftMove() {
      return this.Y0;
    }
    set virtualPointerShiftMove(t) {
      this.Y0 = t;
    }
    get virtualPointerControlMove() {
      return this.K0;
    }
    set virtualPointerControlMove(t) {
      this.K0 = t;
    }
    G0(t, i) {
      this.WL(this.virtualPointerLocation.x + t, this.virtualPointerLocation.y + i);
    }
    WL(t, i) {
      this.virtualPointerBox.moveTo(t, i, true);
      const e = this.f;
      if (!e || !this.isVirtualPointerEnabled || !this.isVirtualPointerShown) return;
      e.ensureBounds();
      const s = e.lastInput, n = new InputEvent2();
      n.diagram = e, this.jL(n, this.isVirtualPointerDown), n.button = this.ze.button, n.modifiers = this.ze.modifiers, this.Sd(n, true), e.lastInput = s, this.isVirtualPointerDown && (e.remove(this.virtualPointerBox), e.add(this.virtualPointerBox)), this.Sh();
    }
    jL(t, i) {
      const e = this.f;
      if (e) {
        if (t.targetDiagram = e, t.documentPoint = this.virtualPointerLocation, e.allowDragOut) {
          const s = e.div.getBoundingClientRect(), n = e.transformDocToView(this.virtualPointerLocation), o = s.x + n.x, r = s.y + n.y;
          let l = root.document.elementFromPoint(o, r) || null;
          l instanceof HTMLCanvasElement && (l = l.parentElement), l !== null && l.shadowRoot && (l = l.shadowRoot.elementFromPoint(o, r) || null, l instanceof HTMLCanvasElement && (l = l.parentElement));
          let h = null;
          if (l instanceof HTMLElement && (h = Diagram2.Qe.get(l)) && h !== e && h.div) {
            const f = h.div.getBoundingClientRect(), a = new Point2(n.x - (f.x - s.x), n.y - (f.y - s.y));
            this.Cs !== null && this.Cs !== h && this.AN(), t.targetDiagram = h, t.viewPoint = a, t.documentPoint = h.transformViewToDoc(a), t.viewPoint = h.transformDocToView(t.documentPoint), this.Cs = h;
            const c = h.commandHandler;
            this.Ob = !c.isVirtualPointerEnabled, c.isVirtualPointerEnabled = true, c.isVirtualPointerDown = i, c.virtualPointerLocation = t.documentPoint, c.isVirtualPointerShown = true, c.U0 = e;
            return;
          }
        }
        this.Cs !== null && this.AN(), t.viewPoint = e.transformDocToView(t.documentPoint);
      }
    }
    Sd(t, i) {
      this.doVirtualPointerEvent(t, i);
    }
    doVirtualPointerEvent(t, i) {
      const e = this.f;
      e && (t.timestamp = Date.now(), e.lastInput = t, i && (t.up ? e.doMouseUp() : t.down ? e.doMouseDown() : e.doMouseMove()), this.onVirtualPointerEvent(t, i));
    }
    onVirtualPointerEvent(t, i) {
      const e = this.f;
      e && (t.up ? this.isVirtualPointerDown && !e.viewportBounds.containsPoint(this.virtualPointerLocation) && (this.virtualPointerLocation = this.focus instanceof GraphObject2 ? this.focus.getDocumentPoint(Spot2.Center) : e.viewportBounds.center) : t.down);
    }
    doVirtualFocusKeyDown() {
      const t = this.f;
      if (!t) return false;
      const i = t.lastInput, e = i.commandKey;
      if (this.isVirtualPointerEnabled && (e === "ShiftLeft" || e === "ShiftRight")) return this.isVirtualPointerShown = true, true;
      if (this.qL.indexOf(e) >= 0) if (i.shift && this.isVirtualPointerShown) {
        const s = this.Eb(e), n = i.control || i.meta ? this.K0 : this.Y0;
        s === 270 ? this.G0(0, -n) : s === 90 ? this.G0(0, n) : s === 180 ? this.G0(-n, 0) : this.G0(n, 0);
      } else this.o3();
      else if (i.shift && this.isVirtualPointerShown && (e === "Numpad1" || e === "Numpad2" || e === "Numpad3" || e === "Numpad4" || e === "Numpad6" || e === "Numpad7" || e === "Numpad8" || e === "Numpad9")) {
        const s = i.control || i.meta ? this.K0 : this.Y0;
        let n = 0;
        e === "Numpad1" || e === "Numpad4" || e === "Numpad7" ? n = -s : (e === "Numpad3" || e === "Numpad6" || e === "Numpad9") && (n = s);
        let o = 0;
        e === "Numpad7" || e === "Numpad8" || e === "Numpad9" ? o = -s : (e === "Numpad1" || e === "Numpad2" || e === "Numpad3") && (o = s), this.G0(n, o);
      } else if (e === "Enter" || e === "NumpadEnter" || e === "Numpad5") i.shift && this.isVirtualPointerShown ? this.isVirtualPointerDown = !this.isVirtualPointerDown : this.r3();
      else if (e === "Escape") this.l3();
      else if (e === "Space") this.h3();
      else if (e === "ContextMenu" || i.shift && e === "F10" || (i.control || i.meta) && i.shift && e === "Backslash") this.a3();
      else if (i.shift && e === "c") this.Bb(1);
      else if (i.shift && e === "a") this.Bb(2);
      else if (i.shift && e === "KeyS") this.Bb(4);
      else if (i.shift && e === "KeyM") this.Bb(8);
      else if (i.shift && e === "Digit1") this.Vb(0);
      else if (i.shift && e === "Digit2") this.Vb(1);
      else if (i.shift && e === "Digit3") this.Vb(2);
      else if (i.shift && e === "Numpad0") {
        const s = this.ze.button;
        this.Vb(s === 2 ? 0 : 2);
      } else if (i.shift && (e === "KeyD" || e === "NumpadDecimal")) {
        const s = this.ze.clickCount;
        this.JL(s === 2 ? 1 : 2);
      } else if (i.shift && e === "KeyF") {
        const s = this.nextFocusFormula;
        this.nextFocusFormula = s === "distance" ? "linear" : "distance";
      } else if (i.shift && e === "y") this.isUsingAriaLive = !this.isUsingAriaLive;
      else return false;
      return true;
    }
    doVirtualFocusKeyUp() {
      const t = this.f;
      if (!t) return false;
      const e = t.lastInput.commandKey;
      return this.isVirtualPointerEnabled && (e === "ShiftLeft" || e === "ShiftRight") && (this.isVirtualPointerShown = false), true;
    }
    Eb(t) {
      switch (t) {
        case "ArrowDown":
          return 90;
        case "ArrowLeft":
          return 180;
        case "ArrowUp":
          return 270;
        default:
          return 0;
      }
    }
    qL = ["ArrowRight", "ArrowDown", "ArrowLeft", "ArrowUp"];
    Bb(t) {
      const i = this.ze.modifiers;
      this.ze.modifiers = i & t ? i & ~t : i | t, this.Sh();
    }
    JL(t) {
      this.ze.clickCount = t, this.Sh();
    }
    Vb(t) {
      this.ze.button = t, this.Sh();
    }
    o3() {
      const t = this.f;
      if (!t) return;
      const i = t.lastInput, e = this.focus;
      if (e === null) {
        const s = this.vL(t.isTreePathToChildren).first();
        s !== null && (this.focus = s);
      } else if (e instanceof Link2) this.f3(e);
      else if (e instanceof Node2) this.c3(e);
      else {
        e instanceof Part2 && (this.xd = null);
        const s = this.Eb(i.commandKey);
        s === 270 ? this.focus = this.findNextFocus(270) : s === 90 ? this.focus = this.findNextFocus(90) : s === 180 ? this.focus = this.findNextFocus(180) : this.focus = this.findNextFocus(0);
      }
    }
    f3(t) {
      const i = this.f;
      if (!i) return;
      const e = i.lastInput, s = this.Eb(e.commandKey);
      let n = null;
      const o = this.xd;
      if (o !== null) {
        const r = this.SN;
        if (s === r) n = t.getOtherNode(o);
        else if (s === G.Yi(r + 180)) n = o;
        else {
          let l = r === 0 || r === 180 ? 90 : 0, h = r === 0 || r === 180 ? 270 : 180;
          if (s === l) {
            const f = this.TN(o, r, true), a = f.indexOf(t);
            a >= 0 && a < f.count - 1 && (this.focus = f.elt(a + 1));
          } else if (s === h) {
            const f = this.TN(o, r, true), a = f.indexOf(t);
            a > 0 && (this.focus = f.elt(a - 1));
          }
        }
      } else {
        const r = t.fromNode, l = t.toNode;
        if (!r || !l) return;
        s === 270 ? n = r.location.y < l.location.y ? r : l : s == 90 ? n = r.location.y > l.location.y ? r : l : s === 180 ? n = r.location.x < l.location.x ? r : l : n = r.location.x > l.location.x ? r : l;
      }
      for (; n !== null && !n.isVisible(); ) n = n.containingGroup;
      n !== null && (this.focus = n);
    }
    c3(t) {
      const i = this.f;
      if (!i) return;
      const e = i.lastInput, s = this.Eb(e.commandKey);
      if (e.control || e.meta) {
        const n = this.TN(t, s, true).first();
        n && (this.xd = t, this.SN = s, this.focus = n);
      } else this.xd = null, this.focus = this.findNextFocus(s);
    }
    TN(t, i, e) {
      if (t === null) return new List2();
      const s = t.actualBounds;
      if (!s.isReal()) return new List2();
      const n = /* @__PURE__ */ new Set();
      (t instanceof Group2 ? t.findExternalLinksConnected() : t.findLinksConnected()).each((l) => {
        if (!l.isVisible()) return;
        let h = null;
        if (l.fromNode === t ? h = l.toNode : l.toNode === t ? h = l.fromNode : t instanceof Group2 && (l.fromNode?.isMemberOf(t) ? h = l.toNode : l.toNode?.isMemberOf(t) && (h = l.fromNode)), h === null || h.isMemberOf(t)) return;
        for (; h !== null && !h.isVisible(); ) h = h.containingGroup;
        if (h === null) return;
        const f = h.location;
        if (f.isReal() && !(i === 270 && (h !== t ? f.y >= s.top : l.midPoint.y >= s.top))) {
          {
            if (i === 90 && (h !== t ? f.y <= s.bottom : l.midPoint.y <= s.bottom)) return;
            if (i === 180 && (h !== t ? f.x >= s.left : l.midPoint.x >= s.left)) return;
            if (i === 0 && (h !== t ? f.x <= s.right : l.midPoint.x <= s.right)) return;
          }
          e && l.actualBounds.isReal() ? n.add(l) : n.add(h);
        }
      });
      const r = new List2(n);
      return i === 90 || i === 270 ? r.sort((l, h) => l.actualBounds.centerX - h.actualBounds.centerX) : r.sort((l, h) => l.actualBounds.centerY - h.actualBounds.centerY), r;
    }
    findNextFocus(t) {
      t = G.Yi(t);
      const i = this.focus, e = i instanceof Node2 ? i.location : i.getDocumentPoint(Spot2.Center);
      let s = 1 / 0, n = i;
      const o = (r, l, h, f) => {
        if (this.nextFocusFormula === "linear") {
          let a = 1 / 0;
          t === 0 && h > e.x || t === 180 && h < e.x ? a = Math.abs(h - e.x) : (t === 90 && f > e.y || t === 270 && f < e.y) && (a = Math.abs(f - e.y)), a < s && (s = a, n = r);
        } else {
          if (t === 0 && (l.right < e.x || (l.centerX - e.x) ** 2 > s)) return;
          if (t === 90 && (l.bottom < e.y || (l.centerY - e.y) ** 2 > s)) return;
          if (t === 180 && (l.x > e.x || (e.x - l.centerX) ** 2 > s)) return;
          if (t === 270 && (l.y > e.y || (e.y - l.centerY) ** 2 > s)) return;
          const a = e.direction(h, f), c = G._I(t, a);
          if (t === 90 || t === 270 ? c <= 45 : c < 45) {
            const u = e.distanceSquared(h, f);
            u < s && (s = u, n = r);
          }
        }
      };
      if (i instanceof Part2 && i.diagram !== null) {
        const r = i.containingGroup;
        r !== null ? r.memberParts.each((l) => {
          l === i || l instanceof Link2 || !l.isVisible() || o(l, l.actualBounds, l.location.x, l.location.y);
        }) : (i.diagram.nodes.each((l) => {
          l === i || !l.isTopLevel || !l.isVisible() || o(l, l.actualBounds, l.location.x, l.location.y);
        }), i.diagram.parts.each((l) => {
          l === i || !l.isTopLevel || !l.isVisible() || o(l, l.actualBounds, l.location.x, l.location.y);
        }));
      } else if (i.part !== null) {
        const r = new Rect2();
        this.LN(i.part).each((l) => {
          l !== i && (l.getDocumentBounds(r), o(l, r, r.centerX, r.centerY));
        });
      }
      return n;
    }
    get nextFocusFormula() {
      return this.bN;
    }
    set nextFocusFormula(t) {
      this.bN = t;
    }
    r3() {
      const t = this.f;
      if (!t) return;
      const i = t.currentTool;
      if (i instanceof ContextMenuTool2) {
        const n = i.currentObject;
        this.zb(this.focus), i.maybeStopTool(this.focus), t.currentTool instanceof ContextMenuTool2 || (this.focus = n);
        return;
      }
      const e = this.focus, s = t.lastInput;
      if (e === null) s.control || s.meta ? this.zb(null) : this.focus = this.findFirstFocus();
      else if (e instanceof Part2) if (s.control || s.meta) this.zb(e);
      else {
        const n = this.LN(e);
        if (n.count > 0) this.focus = n.first();
        else if (e instanceof Link2 && e.isLabeledLink) {
          const o = e.labelNodes.first();
          o !== null && o.isVisible() && (this.focus = o);
        } else if (e instanceof Group2 && e.isSubGraphExpanded) {
          const o = e.memberParts.first();
          o !== null && o.isVisible() && (this.focus = o);
        }
      }
      else this.zb(e);
    }
    vL(t) {
      const i = new List2(), e = this.f;
      if (!e) return i;
      let s = 0;
      for (; i.count === 0 && s < e.nodes.count; ) {
        const n = e.nodes;
        for (; n.next(); ) {
          const o = n.value;
          o.isTopLevel && o.isVisible() && (t ? o.findNodesInto() : o.findNodesOutOf()).count === s && i.add(o);
        }
        s++;
      }
      return i;
    }
    LN(t) {
      return t instanceof Part2 ? this.Tn(t, new List2()) : new List2();
    }
    Tn(t, i) {
      return !(t instanceof Part2) && t.isVisibleObject() && t.isEnabledObject() && (t.contextMenu || t.click || t instanceof TextBlock2 && t.editable || t.part instanceof Node2 && t.portId !== null && (t.portId !== "" || t.part.ports.count > 1) || t.toolTip) && i.add(t), t instanceof Panel2 && t.elements.each((e) => this.Tn(e, i)), i;
    }
    zb(t) {
      const i = this.f;
      if (!i) return;
      const e = i.lastInput, s = t instanceof GraphObject2 ? t : i;
      if (s.click) {
        const n = new InputEvent2();
        n.diagram = i, n.documentPoint = t instanceof GraphObject2 ? t.getDocumentPoint(Spot2.Center) : i.viewportBounds.center, n.viewPoint = i.transformDocToView(n.documentPoint), n.button = 0, n.clickCount = 1, n.targetObject = t, this.Sd(n, false), s instanceof GraphObject2 ? s.click(n, s) : s.click(n), i.lastInput = e;
      } else s instanceof TextBlock2 && s.editable ? this.editTextBlock(s) : this.$L(t);
    }
    l3() {
      const t = this.f;
      if (!t) return;
      const i = t.currentTool;
      if (i instanceof ToolManager2 && i.currentToolTip !== null) {
        i.hideToolTip();
        return;
      } else if (i instanceof ContextMenuTool2) {
        const e = i.currentObject;
        i.doKeyDown(), this.focus = e;
        return;
      }
      if (this.focus instanceof Part2) {
        const e = this.focus;
        e instanceof Node2 && e.labeledLink !== null ? this.focus = e.labeledLink : e.containingGroup !== null ? this.focus = e.containingGroup : this.focus = null;
      } else if (this.focus instanceof GraphObject2) {
        const e = this.focus.part;
        if (e instanceof Link2 && e.isLabeledLink) {
          const s = e.labelNodes.first();
          if (s !== null && s.isVisible()) {
            this.focus = s;
            return;
          }
        } else if (e instanceof Group2 && e.isSubGraphExpanded) {
          const s = e.memberParts.first();
          if (s !== null && s.isVisible()) {
            this.focus = s;
            return;
          }
        }
        this.focus = e;
      } else this.cancelVirtualPointer(), this.stopCommand();
    }
    h3() {
      const t = this.f;
      if (!t) return;
      if (t.lastInput.shift && this.isVirtualPointerShown) {
        const e = t.findPartAt(this.virtualPointerLocation);
        e !== null && (e === this.focus ? this.ZL() : this.focus = e);
      } else this.ZL();
    }
    ZL() {
      const t = this.f;
      if (!t) return;
      const i = t.lastInput, e = this.focus;
      if (e instanceof Part2) {
        let s = e.part;
        if (i.control || i.meta) {
          for (t.raiseDiagramEvent("ChangingSelection", t.selection); s !== null && !s.canSelect(); ) s = s.containingGroup;
          s !== null && (s.isSelected = !s.isSelected), t.raiseDiagramEvent("ChangedSelection", t.selection);
        } else if (i.shift) {
          if (s !== null && !s.isSelected) {
            for (t.raiseDiagramEvent("ChangingSelection", t.selection); s !== null && !s.canSelect(); ) s = s.containingGroup;
            s !== null && (s.isSelected = true), t.raiseDiagramEvent("ChangedSelection", t.selection);
          }
        } else if (s !== null && !s.isSelected) {
          for (; s !== null && !s.canSelect(); ) s = s.containingGroup;
          s !== null && t.select(s);
        }
      }
      this.$L(e), this.onFocusChanged(e, e);
    }
    $L(t) {
      const i = this.f;
      if (!i) return;
      i.toolManager.hideToolTip();
      const e = i.lastInput;
      let s = t instanceof GraphObject2 ? t : i;
      for (; s instanceof GraphObject2 && !s.toolTip; ) s = s.panel;
      if (s && s.toolTip) {
        const n = new InputEvent2();
        n.diagram = i, n.documentPoint = t !== null ? t.getDocumentPoint(Spot2.Center) : i.viewportBounds.center, n.viewPoint = i.transformDocToView(n.documentPoint), n.targetObject = t, this.Sd(n, false), i.toolManager.showToolTip(s.toolTip, t), i.lastInput = e;
      }
    }
    a3() {
      const t = this.f;
      if (!t) return;
      const i = this.focus;
      if (this.canShowContextMenu(i)) {
        this.showContextMenu(i);
        const e = t.toolManager.contextMenuTool.currentContextMenu;
        if (e instanceof Adornment2) {
          const s = this.LN(e);
          s.count > 0 && (this.focus = s.first());
        }
      }
    }
  }
  var Stretch2 = ((w) => (w[w.None = 0] = "None", w[w.Default = 1] = "Default", w[w.Vertical = 4] = "Vertical", w[w.Horizontal = 5] = "Horizontal", w[w.Fill = 2] = "Fill", w))(Stretch2 || {}), Orientation2 = ((w) => (w[w.None = 0] = "None", w[w.Along = 21] = "Along", w[w.Plus90 = 22] = "Plus90", w[w.Minus90 = 23] = "Minus90", w[w.Opposite = 24] = "Opposite", w[w.Upright = 25] = "Upright", w[w.Plus90Upright = 26] = "Plus90Upright", w[w.Minus90Upright = 27] = "Minus90Upright", w[w.Upright45 = 28] = "Upright45", w))(Orientation2 || {}), Flip2 = ((w) => (w[w.None = 0] = "None", w[w.Vertical = 1] = "Vertical", w[w.Horizontal = 2] = "Horizontal", w[w.Both = 3] = "Both", w))(Flip2 || {});
  class GraphObject2 {
    l;
    q0;
    H0;
    kh;
    k;
    Ph;
    wt;
    yt;
    ce;
    ei;
    v0;
    en;
    It;
    gs;
    ll;
    Mh;
    Ci;
    Ra;
    lt;
    vt;
    hl;
    Oi;
    ji;
    kd;
    pi;
    Pd;
    Xt;
    ui;
    al;
    Xb;
    Nh;
    yc;
    constructor() {
      GSet2._i(this), this.l = 30723, this.ei = 1, this.v0 = "", this.en = null, this.It = null, this.yt = new Point2(NaN, NaN).S(), this.gs = Size2.ix, this.ll = new Transform(), this.Mh = new Transform(), this.Ci = null, this.Ra = 1, this.lt = 1, this.vt = 0, this.hl = Margin2.lm, this.ce = new Rect2(NaN, NaN, NaN, NaN).S(), this.Oi = new Rect2(NaN, NaN, NaN, NaN).S(), this.ji = new Rect2(0, 0, NaN, NaN).S(), this.kd = null, this.q0 = null, this.wt = null, this.pi = Spot2.Default, this.Pd = Spot2.Default, this.H0 = 0, this.kh = 0, this.Xt = null, this.k = null, this.Ph = null, this.ui = null, this.Xb = null, this.Nh = null, this.al = null, this.yc = null;
    }
    cloneProtected(t) {
      t.l = (this.l | 2048 | 4096) & -32769, t.ei = this.ei, t.v0 = this.v0, t.It = this.It, t.yt.c(this.yt), t.gs = this.gs.T(), this.Ci !== null ? t.Ci = this.Ci.copy() : t.Ci = null, t.lt = this.lt, t.vt = this.vt, t.hl = this.hl.T(), t.ce.c(this.ce), t.Oi.c(this.Oi), t.ji.c(this.ji), t.q0 = this.q0, this.wt !== null && (t.wt = this.wt.copy()), t.pi = this.pi.T(), t.Pd = this.Pd.T(), t.H0 = this.H0, t.kh = this.kh, this.Xt !== null && (t.Xt = this.Xt.copy()), this.k !== null && (this.k.wi ? t.k = this.k : t.k = this.k.copy()), this.Ph !== null && (t.Ph = this.Ph.slice()), this.ui !== null && (t.ui = this.ui.copy());
    }
    addCopyProperty(t) {
      let i = this.Ph;
      if (!Array.isArray(i)) i = [], this.Ph = i;
      else for (let e = 0; e < i.length; e++) if (i[e] === t) return;
      i.push(t);
    }
    Zo(t) {
      t.kd = null, t.al = null, t.g();
    }
    clone() {
      const t = new this.constructor();
      if (this.cloneProtected(t), this.Ph !== null) for (let i = 0; i < this.Ph.length; i++) {
        const e = this.Ph[i];
        t[e] = this[e];
      }
      return t;
    }
    copy() {
      return this.clone();
    }
    iM() {
      const t = this.Ei;
      if (t !== null) {
        this.Ei = null;
        for (const i of t) i.Md() && (i.isToData ? this.themeData(i.targetProperty, i.sourceProperty, i.themeSource, i.converter, i.themeConverter) : i.isToObject ? this.themeObject(i.targetProperty, i.sourceProperty, i.themeSource, i.converter, i.themeConverter, i.sourceName) : i.isToModel ? this.themeModel(i.targetProperty, i.sourceProperty, i.themeSource, i.converter, i.themeConverter) : this.theme(i.targetProperty, i.sourceProperty, i.themeSource, i.converter, i.themeConverter));
      }
      return this;
    }
    gi(t) {
      t in Orientation2 ? this.segmentOrientation = t : t in Stretch2 ? this.stretch = t : U.xr(this, t);
    }
    toString() {
      return U.$n(this.constructor) + "#" + GSet2.Ps(this);
    }
    static None = 0;
    static Default = 1;
    static Fill = 2;
    static Vertical;
    static Horizontal;
    static Uniform = 6;
    static UniformToFill = 7;
    static FlipVertical = 1;
    static FlipHorizontal = 2;
    static FlipBoth = 3;
    Ch() {
      this.k !== null && (this.k.wi = true);
    }
    jt() {
      return this.k === null ? this.k = new GraphObjectTemplateSettings() : this.k.wi && (this.k = this.k.copy()), this.k;
    }
    _e() {
      if (this.wt === null) {
        const t = new LinkSettings();
        t.Oa = Spot2.None, t.Ea = Spot2.None, t.Ba = 10, t.Va = 10, t.za = 0, t.Xa = 0, this.wt = t;
      }
      return this.wt;
    }
    raiseChangedEvent(t, i, e, s, n, o, r) {
      const l = this.part;
      if (l !== null) {
        l.wc(t, i, e, s, n, o, r), e === this && t === 2 && this.xc() && this.Ya(l, i);
        const h = this.diagram;
        if (this.Os !== null && h !== null && h.sa && !h.undoManager.isUndoingRedoing && !h.animationManager.Gu) {
          const f = this.Os.get(i);
          if (f !== null && h.animationManager.isEnabled && !h.animationManager.isTicking) {
            this.yc === null && (this.yc = new GMap2());
            let a = h.undoManager.transactionLevel === 0;
            if (f.startCondition === 2 ? a = true : f.startCondition === 3 && (a = false), a) {
              const c = new Animation2();
              f.YR(c);
              const u = this.yc.get(f);
              u !== null && u.stop(), this.yc.set(f, c), c.a1 = this, c.EM = f, c.add(this, i, s, n), c.start();
            } else h.animationManager.getBundleAnimation().add(this, i, s, n);
          }
        }
        if (this instanceof Panel2 && e === l && l.DN() && l.data !== null) {
          const f = this.O.h, a = f.length;
          for (let c = 0; c < a; c++) {
            const u = f[c];
            u instanceof Panel2 && u.Tn((d) => {
              d.data !== null && d.DN() && d.updateTargetBindings(i);
            });
          }
        }
      }
    }
    BR(t) {
      this.yc && this.yc.delete(t);
    }
    jo() {
      if (this.diagram === null) return;
      if (this.findBindingPanel() === null && this.Ei !== null) {
        const i = this.diagram.model, e = this.Ei.iterator;
        for (; e.next(); ) {
          const s = e.value;
          if (!s.isToTheme) continue;
          let n = null;
          const o = s.sourceName;
          s.isToObject && (n = this.QL(o));
          let r = this;
          const l = s.targetId;
          l !== -1 && (r = this.W0(l), r === null) || (o === "/" ? n = r.part : o === "." ? n = r : o === ".." && (n = r.panel), s.updateTarget(r, n, void 0, i));
        }
      }
    }
    Ya(t, i) {
      const e = this.findBindingPanel();
      if (e !== null) {
        const s = t.diagram, n = this.Ei.iterator;
        for (; n.next(); ) {
          const o = n.value;
          let r = null;
          if (o.isToObject) {
            if (r = o._L(e, this), r === null) continue;
            o.updateSource(this, r, i, null);
          } else if (o.isToModel) s !== null && !s.be && o.updateSource(this, s.model.modelData, i, e);
          else if (!o.isToTheme) {
            const l = e.data;
            if (l === null) continue;
            s !== null && !s.be && o.updateSource(this, l, i, e);
          }
          if (r === this) {
            const l = o.targetId, h = e.W0(l);
            h !== null && o.updateTarget(h, r, i, s?.model);
          }
        }
      }
    }
    W0(t) {
      return this.ao === t ? this : null;
    }
    QL(t) {
      let i;
      return t === "" ? i = this : t === "/" ? i = this : t === "." ? i = this : t === ".." ? i = this : (i = this.part.findObject(t), i === null && Debug && U.ot("Binding error: missing GraphObject named " + t + " in " + this.part.toString())), i;
    }
    get ao() {
      return this.k !== null ? this.k.ao : -1;
    }
    set ao(t) {
      this.ao !== t && (this.k === null && (this.k = new GraphObjectTemplateSettings()), this.k.ao = t);
    }
    get Ei() {
      return this.k !== null ? this.k.Ei : null;
    }
    set Ei(t) {
      this.Ei !== t && (this.k === null && (this.k = new GraphObjectTemplateSettings()), this.k.Ei = t);
    }
    get fo() {
      return this.k !== null ? this.k.fo : null;
    }
    set fo(t) {
      this.fo !== t && (this.k === null && (this.k = new GraphObjectTemplateSettings()), this.k.fo = t);
    }
    raiseChanged(t, i, e) {
      this.raiseChangedEvent(2, t, this, i, e);
    }
    t(t, i, e) {
      this.raiseChangedEvent(2, t, this, i, e);
    }
    co(t, i, e, s) {
      const n = this.ce;
      if (n.e(t, i, e, s), this.lt !== 1 || this.vt !== 0) {
        this.Ci === null && (this.Ci = new Transform());
        const o = this.Ci;
        o.Ki(), this.j0(o, t, i, e, s), o.hm(n);
      }
    }
    tD(t, i, e) {
      return this.pickable === false ? false : (e.Af(this.E), i ? this.intersectsRect(t, e) : this.containedInRect(t, e));
    }
    iD(t, i, e) {
      if (this.pickable === false) return false;
      const s = this.naturalBounds, n = t.distanceSquaredPoint(i);
      return e ? Point2.distanceLineSegmentSquared(t.x, t.y, 0, 0, 0, s.height) <= n || Point2.distanceLineSegmentSquared(t.x, t.y, 0, s.height, s.width, s.height) <= n || Point2.distanceLineSegmentSquared(t.x, t.y, s.width, s.height, s.width, 0) <= n || Point2.distanceLineSegmentSquared(t.x, t.y, s.width, 0, 0, 0) <= n : t.distanceSquared(0, 0) <= n && t.distanceSquared(0, s.height) <= n && t.distanceSquared(s.width, 0) <= n && t.distanceSquared(s.width, s.height) <= n;
    }
    Dn() {
      return true;
    }
    containsPoint(t) {
      Debug && U.s(t, Point2, GraphObject2, "containsPoint:p");
      const i = Point2.a();
      i.c(t), this.E.St(i);
      const e = this.actualBounds;
      if (!e.isReal()) return Point2.o(i), false;
      const s = this.diagram;
      if (s !== null && s.b0) {
        const o = s.getInputOption("extraTouchThreshold"), r = s.getInputOption("extraTouchArea"), l = r / 2, h = this.naturalBounds, f = this.getDocumentScale() * s.scale, a = 1 / f;
        if (h.width * f < o && h.height * f < o) {
          const c = Rect2.contains(e.x - l * a, e.y - l * a, e.width + r * a, e.height + r * a, i.x, i.y);
          return Point2.o(i), c;
        }
      }
      let n = false;
      return (this instanceof Adornment2 || this instanceof Shape2 ? Rect2.contains(e.x - 5, e.y - 5, e.width + 10, e.height + 10, i.x, i.y) : e.containsPoint(i)) && (this.ui && !this.ui.containsPoint(i) ? n = false : this.It !== null && this.ji.containsPoint(t) ? n = true : n = this.Ah(t)), Point2.o(i), n;
    }
    Ah(t) {
      const i = this.naturalBounds;
      return Rect2.contains(0, 0, i.width, i.height, t.x, t.y);
    }
    containsRect(t) {
      if (this.angle === 0) return this.actualBounds.containsRect(t);
      const i = this.naturalBounds, e = Rect2.U(0, 0, i.width, i.height), s = this.E;
      let n = false;
      const o = Point2.U(t.x, t.y);
      return e.containsPoint(s.De(o)) && (o.e(t.x, t.bottom), e.containsPoint(s.De(o)) && (o.e(t.right, t.bottom), e.containsPoint(s.De(o)) && (o.e(t.right, t.y), e.containsPoint(s.De(o)) && (n = true)))), Point2.o(o), Rect2.o(e), n;
    }
    containedInRect(t, i) {
      if (Debug && U.s(t, Rect2, GraphObject2, "containedInRect:r"), i === void 0) return t.containsRect(this.actualBounds);
      const e = this.naturalBounds, s = i;
      let n = false;
      const o = Point2.U(0, 0);
      return t.containsPoint(s.St(o)) && (o.e(0, e.height), t.containsPoint(s.St(o)) && (o.e(e.width, e.height), t.containsPoint(s.St(o)) && (o.e(e.width, 0), t.containsPoint(s.St(o)) && (n = true)))), Point2.o(o), n;
    }
    intersectsRect(t, i) {
      if (Debug && U.s(t, Rect2, GraphObject2, "intersectsRect:r"), i === void 0 && (i = this.E, this.angle === 0)) return t.intersectsRect(this.actualBounds);
      const e = this.naturalBounds, s = i, n = Point2.U(0, 0), o = Point2.U(0, e.height), r = Point2.U(e.width, e.height), l = Point2.U(e.width, 0);
      let h = false;
      if (t.containsPoint(s.St(n)) || t.containsPoint(s.St(o)) || t.containsPoint(s.St(r)) || t.containsPoint(s.St(l))) h = true;
      else {
        const f = Rect2.U(0, 0, e.width, e.height), a = Point2.U(t.x, t.y);
        f.containsPoint(s.De(a)) ? h = true : (a.e(t.x, t.bottom), f.containsPoint(s.De(a)) ? h = true : (a.e(t.right, t.bottom), f.containsPoint(s.De(a)) ? h = true : (a.e(t.right, t.y), f.containsPoint(s.De(a)) && (h = true)))), Point2.o(a), Rect2.o(f), h || (G.mx(t, n, o) || G.mx(t, o, r) || G.mx(t, r, l) || G.mx(t, l, n)) && (h = true);
      }
      return Point2.o(n), Point2.o(o), Point2.o(r), Point2.o(l), h;
    }
    getDocumentPoint(t, i) {
      if (i === void 0 && (i = new Point2()), t instanceof Spot2) {
        const e = t;
        Debug && e.isNoSpot() && U.n("getDocumentPoint:s Spot must be specific: " + e.toString());
        const s = this.naturalBounds;
        return i.e(e.x * s.width + e.offsetX, e.y * s.height + e.offsetY), this._s.St(i), i;
      } else return i.set(t), this._s.St(i), i;
    }
    getDocumentBounds(t) {
      t === void 0 && (t = new Rect2());
      const i = this.naturalBounds, e = this._s, s = Point2.U(0, 0).E(e);
      return t.e(s.x, s.y, 0, 0), s.e(i.width, 0).E(e), t.ai(s.x, s.y, 0, 0), s.e(i.width, i.height).E(e), t.ai(s.x, s.y, 0, 0), s.e(0, i.height).E(e), t.ai(s.x, s.y, 0, 0), Point2.o(s), t;
    }
    getDocumentAngle() {
      return this._s.$I();
    }
    getDocumentScale() {
      if (this.J0() === false) return this.Ra;
      const t = this.lt;
      return this.panel !== null ? t * this.panel.getDocumentScale() : t;
    }
    getLocalPoint(t, i) {
      return i === void 0 && (i = new Point2()), i.c(t), this._s.De(i), i;
    }
    getNearestIntersectionPoint(t, i, e) {
      return this.bc(t.x, t.y, i.x, i.y, e);
    }
    bc(t, i, e, s, n) {
      const o = this.E, r = 1 / (o.m11 * o.m22 - o.m12 * o.m21), l = o.m22 * r, h = -o.m12 * r, f = -o.m21 * r, a = o.m11 * r, c = r * (o.m21 * o.dy - o.m22 * o.dx), u = r * (o.m12 * o.dx - o.m11 * o.dy), d = t * l + i * f + c, m = t * h + i * a + u, g = e * l + s * f + c, p = e * h + s * a + u;
      n.e(0, 0);
      const y = this.naturalBounds, x = G.Dl(0, 0, y.width, y.height, d, m, g, p, n);
      return n.E(o), x;
    }
    gt(t, i, e, s) {
      if (this.Wo() === false) return;
      const n = this.hl, o = n.right + n.left, r = n.top + n.bottom;
      t = Math.max(t - o, 0), i = Math.max(i - r, 0), e = e || 0, s = s || 0, e = Math.max(e - o, 0), s = Math.max(s - r, 0);
      const l = this.angle;
      let h = 0;
      const f = this.desiredSize, a = this.$0();
      l === 90 || l === 270 ? (t = isFinite(f.height) ? f.height + a : t, i = isFinite(f.width) ? f.width + a : i) : (t = isFinite(f.width) ? f.width + a : t, i = isFinite(f.height) ? f.height + a : i);
      let c = e || 0, u = s || 0;
      const d = this instanceof Panel2;
      switch (this.sn(true)) {
        case 0:
          c = 0, u = 0, d && (t = 1 / 0, i = 1 / 0);
          break;
        case 2:
          isFinite(t) && t > e && (c = t), isFinite(i) && i > s && (u = i);
          break;
        case 5:
          isFinite(t) && t > e && (c = t), u = 0, d && (i = 1 / 0);
          break;
        case 4:
          isFinite(i) && i > s && (u = i), c = 0, d && (t = 1 / 0);
          break;
      }
      const g = this.maxSize, p = this.minSize;
      c > g.width && p.width < g.width && (c = g.width), u > g.height && p.height < g.height && (u = g.height), e = Math.max(c, p.width), s = Math.max(u, p.height), g.width < e && (e = Math.min(p.width, e)), g.height < s && (s = Math.min(p.height, s)), t = Math.min(g.width, t), i = Math.min(g.height, i), t = Math.max(e, t), i = Math.max(s, i), (l === 90 || l === 270) && (h = t, t = i, i = h, h = e, e = s, s = h), this.ce.di(), this.Nd(t, i, e, s), this.ce.S(), this.ce.isReal() || U.n("Non-real measuredBounds has been set. Object " + this + ", measuredBounds: " + this.ce.toString()), this.Se(false);
    }
    Nd(t, i, e, s) {
    }
    nn() {
      return false;
    }
    Ut(t, i, e, s, n) {
      this.Sc();
      const o = Rect2.a();
      o.c(this.Oi), this.Oi.di(), this.us() === false ? this.Oi.e(t, i, e, s) : this.Th(t, i, e, s), this.Oi.S(), n === void 0 ? this.ui = null : this.ui = n;
      let r = false;
      if (n !== void 0) r = true;
      else {
        let l = this.panel;
        if (l !== null && l.fl() && (l = l.panel), l !== null) {
          const h = l.ji, f = this.measuredBounds, a = i + f.height, c = t + f.width;
          if (r = !(0 <= t + 0.05 && c <= h.width + 0.05 && 0 <= i + 0.05 && a <= h.height + 0.05), this instanceof TextBlock2) {
            const u = this.naturalBounds;
            (this.Z0 > u.height || this.xi > u.width) && (r = true);
          }
        }
      }
      r ? this.l |= 256 : this.l &= -257, this.Oi.isReal() || U.n("Non-real actualBounds has been set. Object " + this + ", actualBounds: " + this.Oi.toString()), this.Cd(o, this.Oi), this.uo(false), Rect2.o(o);
    }
    Th(t, i, e, s) {
    }
    commonArrange(t, i, e, s) {
      if (this.Oi.e(t, i, e, s), this.desiredSize.isReal()) return;
      const n = this.ce, o = this.hl, r = o.right + o.left, l = o.top + o.bottom, h = n.width + r, f = n.height + l;
      e += r, s += l;
      let a = this.sn(true);
      switch (h === e && f === s && (a = 0), a) {
        case 0:
          (h > e || f > s) && (this.Se(true), this.gt(h > e ? e : h, f > s ? s : f, 0, 0));
          break;
        case 2:
          this.Se(true), this.gt(e, s, 0, 0);
          break;
        case 5:
          this.Se(true), this.gt(e, f, 0, 0);
          break;
        case 4:
          this.Se(true), this.gt(h, s, 0, 0);
          break;
      }
    }
    Cd(t, i) {
      const e = this.part;
      e !== null && e.diagram !== null && ((e.selectionObject === this || e.resizeObject === this || e.rotateObject === this) && e.FN(true), this.L(), !t.equalsApproxClose(i) && (e.Lh(), this.Q0(e)));
    }
    Q0(t) {
      this.portId !== null && (t.FN(true), t instanceof Node2 && t.invalidateConnectedLinks(void 0, this));
    }
    get shadowVisible() {
      return this.k !== null ? this.k._0 : null;
    }
    set shadowVisible(t) {
      const i = this.shadowVisible;
      i !== t && (Debug && t !== null && U.i(t, "boolean", GraphObject2, "shadowVisible"), this.jt()._0 = t, this.ts(true), this.L(), this.t("shadowVisible", i, t));
    }
    u3(t, i) {
      const e = this.naturalBounds, s = this.Mh, n = s.m11, o = s.m21, r = s.dx, l = s.m12, h = s.m22, f = s.dy;
      let a = 0, c = 0, u = a, d = c;
      a = u * n + d * o + r, c = u * l + d * h + f;
      let m = a, g = c, p = 0, y = 0;
      u = e.width + i, d = 0, a = u * n + d * o + r, c = u * l + d * h + f;
      let x = Math.min(m, a), S = Math.min(g, c);
      p = Math.max(m + p, a) - x, y = Math.max(g + y, c) - S, m = x, g = S, u = e.width + i, d = e.height + i, a = u * n + d * o + r, c = u * l + d * h + f, x = Math.min(m, a), S = Math.min(g, c), p = Math.max(m + p, a) - x, y = Math.max(g + y, c) - S, m = x, g = S, u = 0, d = e.height + i, a = u * n + d * o + r, c = u * l + d * h + f, x = Math.min(m, a), S = Math.min(g, c), p = Math.max(m + p, a) - x, y = Math.max(g + y, c) - S, m = x, g = S;
      const b = t.viewportBounds, k = b.x, P = b.y, A = b.width, C = b.height;
      return m > A + k || k > p + m || g > C + P || P > y + g;
    }
    vi(t, i) {
      if (this.d3(t, i) || !this.visible) return;
      const e = this.opacity;
      if (e === 0) return;
      let s = 1;
      e !== 1 && (s = t.globalAlpha, t.globalAlpha = s * e);
      let n = "";
      this.filter !== "" && (n = t.filter, t.filter = this.filter);
      const o = this.E, r = this.panel;
      this.J0() === true && this.Yb();
      const l = this.part;
      let h = false, f = 0;
      if (l && i.getRenderingHint("drawShadows") && (h = l.isShadowed, h)) {
        const g = l.shadowOffset;
        f = Math.max(g.y, g.x) * i.scale * i.te;
      }
      const a = this instanceof Panel2 && this.fl(), c = this.Oi;
      if (a && (this.eD(h, t, false, r), this.g3(t, i), this.sD(h, t, false, r), this.nD(h, t, false)), a || !a && (c.width === 0 || c.height === 0 || isNaN(c.x) || isNaN(c.y))) {
        e !== 1 && (t.globalAlpha = s), this.filter !== "" && (t.filter = n);
        return;
      }
      const u = this.nn();
      if (!i.xa && u && this.u3(i, f)) {
        e !== 1 && (t.globalAlpha = s), this.filter !== "" && (t.filter = n);
        return;
      }
      let d = (this.l & 256) !== 0;
      if (t.clipInsteadOfFill && (d = false), this instanceof TextBlock2 && (t.font = this.font), d) {
        const g = r.Dn() ? r.naturalBounds : r.actualBounds;
        let p = Math.max(c.x, g.x), y = Math.max(c.y, g.y), x = Math.min(c.right, g.right) - p, S = Math.min(c.bottom, g.bottom) - y;
        const b = this.ui;
        if (b !== null && (p = b.x, y = b.y, x = b.width, S = b.height), p > c.width + c.x || c.x > g.width + g.x) {
          e !== 1 && (t.globalAlpha = s), this.filter !== "" && (t.filter = n);
          return;
        }
        t.save(), t.beginPath(), t.rect(p, y, x, S), t.clip();
      }
      if (u) {
        if (!l.isVisible()) {
          e !== 1 && (t.globalAlpha = s), this.filter !== "" && (t.filter = n);
          return;
        }
        if (h) {
          const g = l.shadowOffset;
          t.shadowsSet(g.x * i.scale * this.scale * i.te, g.y * i.scale * this.scale * i.te, l.shadowBlur), t.shadowsOn(), t.shadowColor = l.shadowColor;
        }
      }
      const m = this.naturalBounds;
      if (t.transform(o.m11, o.m12, o.m21, o.m22, o.dx, o.dy), this.eD(h, t, u, r), this.It !== null && (t.commitTransform(), this.Kb(t, m, c)), this.sD(h, t, u, r), this.Dh(t, i), this.nD(h, t, u), d && (t.restore(), t.clearContextCache(this instanceof Panel2)), !o.Xk()) {
        const g = 1 / (o.m11 * o.m22 - o.m12 * o.m21);
        t.transform(o.m22 * g, -o.m12 * g, -o.m21 * g, o.m11 * g, g * (o.m21 * o.dy - o.m22 * o.dx), g * (o.m12 * o.dx - o.m11 * o.dy));
      }
      e !== 1 && (t.globalAlpha = s), this.filter !== "" && (t.filter = n);
    }
    eD(t, i, e, s) {
      t && this.shadowVisible === true ? i.shadowsOn() : t && this.shadowVisible === false && i.shadowsOff(), t && this.Ub(s) && this.shadowVisible === null && i.shadowsOff();
    }
    sD(t, i, e, s) {
      t && (this.It !== null || this.Ub(s)) ? (this.Gb(true), this.shadowVisible === null && i.shadowsOff()) : this.Gb(false);
    }
    nD(t, i, e) {
      t && this.IN() === true && i.shadowsOn(), e && t && i.shadowsOff();
    }
    m3(t, i, e) {
      const s = this.part;
      let n = false;
      s && t.getRenderingHint("drawShadows") && (n = s.isShadowed), i.clipInsteadOfFill && (n = false), this.nn() && n && i.shadowsOn(), n && this.shadowVisible === true ? i.shadowsOn() : n && this.shadowVisible === false && i.shadowsOff();
      const o = this.panel;
      if (n && this.Ub(o) && this.shadowVisible === null && i.shadowsOff(), i.cl) {
        const r = t.computePixelRatio(), l = `drop-shadow(${i.shadowOffsetX / r}px ${i.shadowOffsetY / r}px ${i.shadowBlur / r / 2}px ${i.shadowColor})`;
        this.background !== null && e.It.setAttributeNS(null, "filter", l);
      }
      return n && (this.It !== null || this.Ub(o)) ? (this.Gb(true), this.shadowVisible === null && i.shadowsOff()) : this.Gb(false), n;
    }
    p3(t, i, e, s) {
      if (e.cl) {
        const n = i.computePixelRatio(), o = `drop-shadow(${e.shadowOffsetX / n}px ${e.shadowOffsetY / n}px ${e.shadowBlur / n / 2}px ${e.shadowColor})`;
        this.RN(t, o);
      }
      s && this.IN() === true && e.shadowsOn(), this.nn() && e.shadowsOff();
    }
    Ub(t) {
      return t === null ? false : (t.fl() && (t = t.panel), t.IN() || (t.type === Panel2.Auto || t.type === Panel2.Spot) && t.findMainElement() !== this);
    }
    RN(t, i) {
    }
    Kb(t, i, e) {
      const s = this.$0(), n = i.x, o = i.y, r = i.width + s, l = i.height + s;
      this.Cn(t, this.It, true, false, i, e), this.It instanceof Brush2 && this.It.type === 3 ? (t.beginPath(), t.rect(n - s / 2, o - s / 2, r, l), t.fillContext(this.It, false, null)) : t.fillRect(n - s / 2, o - s / 2, r, l);
    }
    oD(t, i) {
      let e = t.y3(this);
      const s = t.Nh !== null ? t.Nh : t.svg;
      if (s !== null && e !== -1) if (e === 0) this.rD(t, i, s);
      else {
        for (; e !== 0 && !t.elt(e - 1).isVisibleObject(); ) e--;
        if (e === 0) this.rD(t, i, s);
        else {
          const n = t.elt(e - 1).svg;
          n !== null ? n.after(i) : s.appendChild(i);
        }
      }
    }
    rD(t, i, e) {
      if (e.It) e.It.after(i);
      else if (t.type === Panel2.Table) {
        const s = e.getElementsByClassName("gojs-ts"), n = s.length !== 0 ? s[0] : null;
        n !== null && n.after(i);
      } else e.prepend(i);
    }
    d3(t, i) {
      if (!(t instanceof SVGContext)) return false;
      if (!this.visible || this.opacity === 0) return this.svg !== null && this.svg.parentNode !== null && this.svg.remove(), true;
      const e = this.Oi;
      if (this.nn() && (!this.isVisible() || e.width === 0 || e.height === 0 || isNaN(e.x) || isNaN(e.y))) return this.svg !== null && this.svg.parentNode !== null && this.svg.remove(), true;
      const s = this.panel, n = this.Ad(t);
      if (this.kc(t, i, n)) return this.lD(this.svg), this.svg.parentElement !== null ? (this.nn() && (t.lastDrawnPart = this.svg), true) : (this.nn() ? (t.lastDrawnPart !== null ? t.lastDrawnPart.after(this.svg) : t.diagramGroup.prepend(this.svg), t.lastDrawnPart = this.svg) : s && this.oD(s, this.svg), true);
      if (this.ts(false), this.nn() && this.isShadowed) {
        const m = this.shadowOffset;
        t.shadowsSet(m.x * i.scale * this.scale * i.te, m.y * i.scale * this.scale * i.te, this.shadowBlur), t.shadowsOn(), t.shadowColor = this.shadowColor;
      }
      this instanceof TextBlock2 && (t.font = this.font), t.currentElement = null;
      const o = this.E, r = this instanceof Panel2, l = this instanceof Panel2 ? this.fl() : false, h = this.svg;
      if (this.J0() === true && this.Yb(), t.setCurrentTransform(1, 0, 0, 1, 0, 0), t.outerGroup = false, n) if (t.outerGroup = true, r && l) t.newGroup(1, 0, 0, 1, 0, 0), this.svg = t.lastCreatedElement;
      else if (r && this.isClipping) {
        const m = this.findMainElement();
        let g = 0, p = 0;
        m !== null && (g = m.actualBounds.x, p = m.actualBounds.y), t.newGroup(o.m11, o.m12, o.m21, o.m22, o.dx + g, o.dy + p), this.svg = t.lastCreatedElement, m !== null && t.createOrUpdateClipGroup(this, m.actualBounds), t.currentElement = t.lastCreatedElement;
      } else r ? (t.newGroup(o.m11, o.m12, o.m21, o.m22, o.dx, o.dy), this.svg = t.lastCreatedElement) : t.newGroup(1, 0, 0, 1, 0, 0);
      const f = this.naturalBounds;
      r || t.setCurrentTransform(o.m11, o.m12, o.m21, o.m22, o.dx, o.dy), this.background !== null && (r ? (l && t.setCurrentTransform(o.m11, o.m12, o.m21, o.m22, o.dx, o.dy), this.Kb(t, f, e), l && t.setCurrentTransform(1, 0, 0, 1, 0, 0)) : (t.setCurrentTransform(o.m11, o.m12, o.m21, o.m22, o.dx, o.dy), this.Kb(t, f, e)), t.currentElement.It = t.lastCreatedElement, t.currentElement.prepend(t.lastCreatedElement));
      const a = this.m3(i, t, t.currentElement);
      this.Dh(t, i), r && t.endGroup(), t.outerGroup && t.endGroup();
      const c = t.surface.yd, u = r ? this.svg : t.currentElement;
      if (h !== null && h.parentNode !== null && u !== h && (this.panel === null || h.parentNode === this.panel.svg)) {
        const m = this.svg.getAttribute("filter");
        return m !== null && u.setAttribute("filter", m), this.filter !== "" && u.setAttributeNS(null, "filter", this.filter), h.replaceWith(u), this.svg = u, u !== null && this.tp(t, s, e, u), true;
      }
      if (this.svg = u, c !== null && u === null && t.dummyGroup(), u === null) return true;
      this.tp(t, s, e, u), this.p3(u, i, t, a);
      const d = this.nn() ? this.opacity * t.globalAlpha : this.opacity;
      if (d !== 1 && u.setAttributeNS(null, "opacity", d.toString()), this.filter !== "" && u.setAttributeNS(null, "filter", this.filter), this.nn()) {
        if (h !== null && u !== h && h.parentNode === t.diagramGroup) {
          const m = h.getAttribute("filter");
          m !== null && u.setAttribute("filter", m), h.replaceWith(u);
        } else t.lastDrawnPart ? t.lastDrawnPart.after(u) : t.diagramGroup.prepend(u);
        t.lastDrawnPart = u;
      } else s !== null && this.oD(s, u);
      return c !== null && c(this, u), this.lD(u), true;
    }
    lD(t) {
      const i = this, e = t.dataset;
      i instanceof GraphObject2 && (i.portId !== null && (e.portId = i.portId), i instanceof Panel2 && (isNaN(i.itemIndex) || (e.itemIndex = i.itemIndex.toString()), i instanceof Part2 && (e.className = U.$n(i), i.key !== void 0 && (e.key = i.key.toString()), i.containingGroup !== null && (e.group = i.containingGroup.key.toString()), i instanceof Link2 && (i.fromNode !== null && i.fromNode.key !== void 0 && (e.fromKey = i.fromNode.key.toString()), i.fromPortId !== "" && (e.fromPortId = i.fromPortId), i.toNode !== null && i.toNode.key !== void 0 && (e.toKey = i.toNode.key.toString()), i.toPortId !== "" && (e.toPortId = i.toPortId)))));
    }
    tp(t, i, e, s) {
      let n = (this.l & 256) !== 0;
      if (t.clipInsteadOfFill && (n = false), !n) {
        s.removeAttributeNS(null, "clip-path");
        return;
      }
      const o = i.Dn() ? i.naturalBounds : i.actualBounds;
      let r = Math.max(e.x, o.x), l = Math.max(e.y, o.y), h = Math.min(e.right, o.right) - r, f = Math.min(e.bottom, o.bottom) - l;
      const a = this.ui;
      a !== null && (r = a.x, l = a.y, h = a.width, f = a.height);
      const c = Rect2.U(r, l, Math.max(h, 0), Math.max(f, 0));
      if (this instanceof Panel2) {
        const u = Transform.a();
        u.set(this.E), u.cx(), u.hm(c), Transform.o(u);
      }
      s.setAttributeNS(null, "clip-path", `path('      M ${c.x},${c.y}       L ${c.width + c.x} ${c.y}       L ${c.width + c.x} ${c.height + c.y}       L ${c.x} ${c.height + c.y} z') view-box`), Rect2.o(c);
    }
    w3() {
      if (this.svg === null) return;
      const t = this.svg.innerHTML.match(/url\(#((CLIP|GRAD).+?)\)/g), i = this.svg.ownerDocument;
      if (t !== null) for (const e of t) {
        const s = i.getElementById(e.split("#")[1].slice(0, -1));
        s !== null && s.remove();
      }
      this.svg.remove();
    }
    g3(t, i) {
      const e = this.Oi, s = this.ji, n = this.It;
      n !== null && t.commitTransform(), n !== null && (this.Cn(t, n, true, false, s, e), n instanceof Brush2 && n.type === 3 ? (t.beginPath(), t.rect(e.x, e.y, e.width, e.height), t.fillContext(n, false, null)) : t.fillRect(e.x, e.y, e.width, e.height)), this.Dh(t, i);
    }
    Dh(t, i) {
    }
    Pc() {
      this.ts(true);
    }
    kc(t, i, e) {
      const s = this.svg;
      if (this.x3()) {
        if (this.Pc(), this.ts(false), s === null) return false;
        const a = s.getAttribute("clip-path");
        if (a !== null && a.includes("url")) {
          const u = t.svg.getElementById(a.split("#")[1].slice(0, -1));
          u !== null && u.remove();
        }
        return s.getAttribute("filter") && s.removeAttribute("filter"), false;
      }
      if (s === null) return false;
      if (!this.visible) return s.remove(), false;
      if (s.nodeName !== "g" && e || s.nodeName === "g" && !e) return false;
      const n = this.E, o = "matrix(" + n.m11 + ", " + n.m12 + ", " + n.m21 + ", " + n.m22 + ", " + n.dx + ", " + n.dy + ")", r = this instanceof Panel2, l = r ? this.fl() : false;
      if (!(r && l)) if (this instanceof Picture2) {
        const a = this.qb;
        t.setCurrentTransform(n.m11, n.m12, n.m21, n.m22, n.dx, n.dy), a !== null && t.amendImageTransform(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7]), e ? s.lastElementChild.setAttributeNS(null, "transform", t.getCurrentTransform()) : s.setAttributeNS(null, "transform", t.getCurrentTransform());
      } else if (e && !r) if (this instanceof Shape2) {
        const a = s.getElementsByTagName("path");
        for (let c = 0; c < a.length; c++) a[c].setAttributeNS(null, "transform", o);
      } else if (this instanceof TextBlock2) {
        const a = s.getElementsByTagName("text"), c = typeof this.stroke == "string" ? this.stroke : null;
        for (let u = 0; u < a.length; u++) a[u].setAttributeNS(null, "transform", o), c && a[u].setAttributeNS(null, "fill", c);
      } else (s.lastElementChild || s).setAttributeNS(null, "transform", o);
      else if (r && this.isClipping && this.Nh) {
        const a = this.findMainElement(), c = a !== null ? a.actualBounds.x : 0, u = a !== null ? a.actualBounds.y : 0;
        this.Nh.setAttributeNS(null, "transform", "matrix(1,0,0,1," + -c + ", " + -u + ")"), s.setAttributeNS(null, "transform", "matrix(" + n.m11 + ", " + n.m12 + ", " + n.m21 + ", " + n.m22 + ", " + (n.dx + c) + ", " + (n.dy + u) + ")");
      } else s.setAttributeNS(null, "transform", o);
      const h = this.nn() ? this.opacity * t.globalAlpha : this.opacity;
      h === 1 ? s.removeAttribute("opacity") : s.setAttributeNS(null, "opacity", h.toString()), t.setCurrentTransform(1, 0, 0, 1, 0, 0);
      const f = this.Nh ? this.Nh : this.Xb;
      if (this.background !== null || f.It !== void 0) {
        const a = f.It;
        if (this.background === null) t.removeOldGradient(this, f.It, "fill"), f.It.remove(), f.It = void 0;
        else {
          if ((l || e && !(this instanceof Panel2)) && t.setCurrentTransform(n.m11, n.m12, n.m21, n.m22, n.dx, n.dy), this.Kb(t, this.naturalBounds, this.actualBounds), f.It) {
            t.removeOldGradient(this, f.It, "fill");
            const c = f.It.getAttribute("filter");
            c !== null && t.lastCreatedElement.setAttribute("filter", c), f.It.replaceWith(t.lastCreatedElement);
          } else f.prepend(t.lastCreatedElement);
          f.It = t.lastCreatedElement;
        }
        a && t.removeOldGradient(this, a, "fill");
      }
      return this.tp(t, this.panel, this.actualBounds, s), true;
    }
    Ad(t) {
      if (this.background !== null) return true;
      let i = (this.l & 256) !== 0;
      return t.clipInsteadOfFill && (i = false), !!i;
    }
    static zB(t, i, e, s, n, o, r) {
      let l = 1e-3;
      const h = o.length;
      t.moveTo(i, e);
      let f = s - i;
      const a = n - e;
      f === 0 && (f = 1e-3);
      const c = a / f;
      let u = Math.sqrt(f * f + a * a), d = 0, m = true;
      l = o[d % h];
      let g = r !== 0;
      for (; u >= 0.1; ) {
        if (g) {
          for (l = o[d++ % h], l -= r; l < 0; ) l += o[d++ % h], m = !m;
          g = false;
        } else l = o[d++ % h];
        l > u && (l = u);
        let p = Math.sqrt(l * l / (1 + c * c));
        f < 0 && (p = -p), i += p, e += c * p, m ? t.lineTo(i, e) : t.moveTo(i, e), u -= l, m = !m;
      }
    }
    Cn(t, i, e, s, n, o) {
      let r = 1, l = 1;
      if (typeof i == "string") {
        e ? t.fillStyle = i : t.strokeStyle = i;
        return;
      } else if (i.type === 1) {
        e ? t.fillStyle = i.color : t.strokeStyle = i.color;
        return;
      }
      let h;
      const f = this.$0();
      r = n.width, l = n.height, s ? (r = o.width, l = o.height) : e || (r += f, l += f);
      const a = t instanceof CanvasSurfaceContext;
      if (a && i.Fn && (i.type === 4 || i.Mc === r && i.Hb === l)) h = i.Fn;
      else {
        let c = 0, u = 0, d = 0, m = 0, g = 0, p = 0, y = 0, x = 0;
        if (s ? (y = o.x, x = o.y) : e || (y -= f / 2, x -= f / 2), c = i.start.x * r + i.start.offsetX + y, u = i.start.y * l + i.start.offsetY + x, d = i.end.x * r + i.end.offsetX + y, m = i.end.y * l + i.end.offsetY + x, i.type === 2) h = t.createLinearGradient(c, u, d, m);
        else if (i.type === 3) p = isNaN(i.endRadius) ? Math.max(r, l) / 2 : i.endRadius, isNaN(i.startRadius) ? (g = 0, p = Math.max(r, l) / 2) : g = i.startRadius, h = t.createRadialGradient(c, u, g, d, m, p);
        else if (i.type === 4) try {
          h = t.createPattern(i.pattern, "repeat");
        } catch {
          h = null;
        }
        else U.Ti(i.type, "Brush type");
        if (i.type !== 4) {
          const S = i.colorStops;
          if (S !== null) {
            const b = S.iterator;
            for (; b.next(); ) h.addColorStop(b.key, b.value);
          }
        }
        if (a && (i.Fn = h, h !== null && (i.Mc = r, i.Hb = l), h === null && i.type === 4 && i.Mc !== -1)) {
          i.Mc = -1;
          const S = this.diagram;
          S !== null && i.Mc === -1 && U.yn(() => {
            S.redraw();
          }, 600);
        }
      }
      e ? t.fillStyle = h : t.strokeStyle = h;
    }
    isContainedBy(t) {
      return t instanceof Panel2 ? this.b3(this, t) : false;
    }
    b3(t, i) {
      if (t === i || i === null) return false;
      let e = t.panel;
      for (; e !== null; ) {
        if (e === i) return true;
        e = e.panel;
      }
      return false;
    }
    isVisibleObject() {
      if (!this.visible) return false;
      const t = this.panel;
      return t !== null ? t.isVisibleObject() : true;
    }
    isEnabledObject() {
      let t = this instanceof Panel2 ? this : this.panel;
      for (; t !== null && t.isEnabled; ) t = t.panel;
      return t === null;
    }
    get enabledChanged() {
      return this.k !== null ? this.k.ip : null;
    }
    set enabledChanged(t) {
      const i = this.enabledChanged;
      i !== t && (t !== null && U.C(t, GraphObject2, "enabledChanged"), this.jt().ip = t, this.t("enabledChanged", i, t));
    }
    Yb() {
      if (this.vb() === true) {
        const t = this.ll;
        if (t.Ki(), !this.Oi.isReal() || !this.ce.isReal()) {
          this.Td(false);
          return;
        }
        if (t.vs(this.Oi.x - this.ce.x, this.Oi.y - this.ce.y), this.scale !== 1 || this.angle !== 0) {
          const i = this.naturalBounds;
          this.j0(t, i.x, i.y, i.width, i.height);
        }
        this.Td(false), this.Ka(true);
      }
      if (this.J0() === true) {
        const t = this.panel;
        if (t === null) this.Mh.set(this.ll), this.Ra = this.scale;
        else if (t._s !== null) {
          const i = this.Mh;
          i.Ki(), t.Dn() ? i.Af(t.Mh) : t.panel !== null && i.Af(t.panel.Mh), i.Af(this.ll), this.Ra = this.scale * t.Ra;
        }
        this.Ka(false);
      }
    }
    j0(t, i, e, s, n) {
      if (this.lt !== 1 && t.lt(this.lt), this.vt === 0) return;
      const o = Point2.a();
      o.setSpot(i, e, s, n, Spot2.Center), t.Ns(this.vt, o.x, o.y), Point2.o(o);
    }
    g(t) {
      if (this.Wo()) return;
      t === void 0 && (t = false), this.Se(true), this.uo(true);
      const i = this.panel;
      i !== null && !t && i.g();
    }
    Nc() {
      this.Wo() || (this.Se(true), this.uo(true));
    }
    Cc(t) {
      if (this.us()) return;
      const i = this.panel;
      !t && i !== null && i.g(), this.uo(true);
    }
    Sc() {
      this.vb() === false && (this.Td(true), this.Ka(true));
    }
    ON() {
      this.Ka(true);
    }
    L() {
      const t = this.part;
      t !== null && t.L();
    }
    sn(t) {
      const i = this.stretch, e = this.panel;
      if (e === null) return this.Qo(i === 1 ? 0 : i, t);
      if (e.type === Panel2.Table) return this.ep(e.getRowDefinition(this.row), e.getColumnDefinition(this.column), t);
      if (e.type === Panel2.Auto && e.findMainElement() === this) return this.Qo(2, t);
      if (i === 1) {
        if (e.type === Panel2.Spot && e.findMainElement() === this) return this.Qo(2, t);
        const s = e.defaultStretch;
        return s === 1 ? this.Qo(0, t) : this.Qo(s, t);
      }
      return this.Qo(i, t);
    }
    ep(t, i, e) {
      const s = this.stretch;
      if (s !== 1) return this.Qo(s, e);
      let n = null, o = null;
      switch (t.stretch) {
        case 1:
        case 5:
          break;
        case 4:
          o = true;
          break;
        case 2:
          o = true;
          break;
      }
      switch (i.stretch) {
        case 1:
        case 4:
          break;
        case 5:
          n = true;
          break;
        case 2:
          n = true;
          break;
      }
      const r = this.panel.defaultStretch;
      return n === null && (n = r === 5 || r === 2), o === null && (o = r === 4 || r === 2), n === true && o === true ? this.Qo(2, e) : n === true ? this.Qo(5, e) : o === true ? this.Qo(4, e) : this.Qo(0, e);
    }
    Qo(t, i) {
      if (i) return t;
      if (t === 0) return 0;
      const e = this.desiredSize;
      if (e.isReal()) return 0;
      const s = !isNaN(e.width), n = !isNaN(e.height), o = this.angle;
      if (s) if (o !== 90 && o !== 270) {
        if (t === 5) return 0;
        if (t === 2) return 4;
      } else {
        if (t === 4) return 0;
        if (t === 2) return 5;
      }
      if (n) if (o !== 90 && o !== 270) {
        if (t === 4) return 0;
        if (t === 2) return 5;
      } else {
        if (t === 5) return 0;
        if (t === 2) return 4;
      }
      return t;
    }
    get segmentOrientation() {
      return this.Xt !== null ? this.Xt.sp : 0;
    }
    set segmentOrientation(t) {
      const i = this.segmentOrientation;
      i !== t && (Debug && U.W(t, Orientation2, "Orientation"), this.Xt === null && (this.Xt = new LinkElementSettings()), this.Xt.sp = t, this.g(), this.t("segmentOrientation", i, t), t === 0 && (this.angle = 0));
    }
    S3() {
      this.segmentOrientation = 21;
    }
    get segmentIndex() {
      return this.Xt !== null ? this.Xt.np : -1 / 0;
    }
    set segmentIndex(t) {
      Debug && U.i(t, "number", GraphObject2, "segmentIndex"), t = Math.round(t);
      const i = this.segmentIndex;
      i !== t && (this.Xt === null && (this.Xt = new LinkElementSettings()), this.Xt.np = t, this.g(), this.t("segmentIndex", i, t));
    }
    get segmentFraction() {
      return this.Xt !== null ? this.Xt.op : 0;
    }
    set segmentFraction(t) {
      Debug && U.r(t, GraphObject2, "segmentFraction"), t < 0 ? t = 0 : t > 1 && (t = 1);
      const i = this.segmentFraction;
      i !== t && (this.Xt === null && (this.Xt = new LinkElementSettings()), this.Xt.op = t, this.g(), this.t("segmentFraction", i, t));
    }
    get segmentOffset() {
      return this.Xt !== null ? this.Xt.rp : Point2.wn;
    }
    set segmentOffset(t) {
      const i = this.segmentOffset;
      i.equals(t) || (Debug && U.s(t, Point2, GraphObject2, "segmentOffset"), t = t.T(), this.Xt === null && (this.Xt = new LinkElementSettings()), this.Xt.rp = t, this.g(), this.t("segmentOffset", i, t));
    }
    get stretch() {
      return this.k !== null ? this.k.go : 1;
    }
    set stretch(t) {
      const i = this.stretch;
      i !== t && (Debug && U.W(t, Stretch2, "Stretch"), this.jt().go = t, this.g(), this.t("stretch", i, t));
    }
    get name() {
      return this.k !== null ? this.k.At : "";
    }
    set name(t) {
      const i = this.name;
      i !== t && (Debug && U.i(t, "string", GraphObject2, "name"), this.jt().At = t, this.part !== null && this.part.lp(), this.t("name", i, t));
    }
    get opacity() {
      return this.ei;
    }
    set opacity(t) {
      Debug && U.r(t, GraphObject2, "opacity"), t < 0 ? t = 0 : t > 1 && (t = 1);
      const i = this.opacity;
      if (i !== t) {
        this.ei = t, this.t("opacity", i, t);
        const e = this.diagram, s = this.part;
        e !== null && s !== null && e.L(s.ua(s.actualBounds));
      }
    }
    get filter() {
      return this.v0;
    }
    set filter(t) {
      const i = this.filter;
      if (i !== t) {
        Debug && U.i(t, "string", GraphObject2, "filter"), this.v0 = t, this.ts(true), this.t("filter", i, t);
        const e = this.diagram, s = this.part;
        e !== null && s !== null && e.L(s.ua(s.actualBounds));
      }
    }
    get visible() {
      return (this.l & 1) !== 0;
    }
    set visible(t) {
      const i = (this.l & 1) !== 0;
      if (i !== t) {
        Debug && U.i(t, "boolean", GraphObject2, "visible"), this.l = this.l ^ 1, this.Pc(), this.t("visible", i, t);
        const e = this.panel;
        e !== null ? e.g() : this.nn() && this.Hi(t), this.L(), this.hD();
      }
    }
    get pickable() {
      return (this.l & 2) !== 0;
    }
    set pickable(t) {
      const i = (this.l & 2) !== 0;
      i !== t && (Debug && U.i(t, "boolean", GraphObject2, "pickable"), this.l = this.l ^ 2, this.t("pickable", i, t));
    }
    get fromLinkableDuplicates() {
      return (this.l & 4) !== 0;
    }
    set fromLinkableDuplicates(t) {
      const i = (this.l & 4) !== 0;
      i !== t && (Debug && U.i(t, "boolean", GraphObject2, "fromLinkableDuplicates"), this.l = this.l ^ 4, this.t("fromLinkableDuplicates", i, t));
    }
    get fromLinkableSelfNode() {
      return (this.l & 8) !== 0;
    }
    set fromLinkableSelfNode(t) {
      const i = (this.l & 8) !== 0;
      i !== t && (Debug && U.i(t, "boolean", GraphObject2, "fromLinkableSelfNode"), this.l = this.l ^ 8, this.t("fromLinkableSelfNode", i, t));
    }
    get toLinkableDuplicates() {
      return (this.l & 16) !== 0;
    }
    set toLinkableDuplicates(t) {
      const i = (this.l & 16) !== 0;
      i !== t && (Debug && U.i(t, "boolean", GraphObject2, "toLinkableDuplicates"), this.l = this.l ^ 16, this.t("toLinkableDuplicates", i, t));
    }
    get toLinkableSelfNode() {
      return (this.l & 32) !== 0;
    }
    set toLinkableSelfNode(t) {
      const i = (this.l & 32) !== 0;
      i !== t && (Debug && U.i(t, "boolean", GraphObject2, "toLinkableSelfNode"), this.l = this.l ^ 32, this.t("toLinkableSelfNode", i, t));
    }
    get isPanelMain() {
      return (this.l & 64) !== 0;
    }
    set isPanelMain(t) {
      const i = (this.l & 64) !== 0;
      i !== t && (Debug && U.i(t, "boolean", GraphObject2, "isPanelMain"), this.l = this.l ^ 64, this.g(), this.t("isPanelMain", i, t));
    }
    get isActionable() {
      return (this.l & 128) !== 0;
    }
    set isActionable(t) {
      const i = (this.l & 128) !== 0;
      i !== t && (Debug && U.i(t, "boolean", GraphObject2, "isActionable"), this.l = this.l ^ 128, this.t("isActionable", i, t));
    }
    get background() {
      return this.It;
    }
    set background(t) {
      const i = this.background;
      i !== t && (t !== null && Brush2.Ld(t, "GraphObject.background"), t instanceof Brush2 && t.S(), this.It = t, this.L(), this.t("background", i, t));
    }
    IN() {
      return (this.l & 512) !== 0;
    }
    Gb(t) {
      t ? this.l |= 512 : this.l &= -513;
    }
    xc() {
      return (this.l & 1024) !== 0;
    }
    EN(t) {
      t ? this.l |= 1024 : this.l &= -1025;
    }
    vb() {
      return (this.l & 2048) !== 0;
    }
    Td(t) {
      t ? this.l |= 2048 : this.l &= -2049;
    }
    J0() {
      return (this.l & 4096) !== 0;
    }
    Ka(t) {
      t ? this.l |= 4096 : this.l &= -4097;
    }
    Wo() {
      return (this.l & 8192) !== 0;
    }
    Se(t) {
      t ? this.l |= 8192 : this.l &= -8193;
    }
    us() {
      return (this.l & 16384) !== 0;
    }
    uo(t) {
      t ? this.l |= 16384 : this.l &= -16385;
    }
    x3() {
      return (this.l & 32768) !== 0;
    }
    ts(t) {
      t ? this.l |= 32768 : this.l &= -32769;
    }
    get part() {
      if (this.nn()) return this;
      if (this.al !== null) return this.al;
      let t = this;
      for (t = t.panel; t; ) {
        if (t instanceof Part2) return this.al = t, t;
        t = t.panel;
      }
      return null;
    }
    get svg() {
      return this.Xb;
    }
    set svg(t) {
      this.Xb = t;
    }
    tc() {
      this.svg = null;
    }
    get panel() {
      return this.en;
    }
    Ua(t) {
      this.en = t, this.svg !== null && this.svg.remove();
    }
    get layer() {
      const t = this.part;
      return t !== null ? t.layer : null;
    }
    get diagram() {
      const t = this.part;
      return t !== null ? t.diagram : null;
    }
    get position() {
      return this.yt;
    }
    set position(t) {
      Debug && U.s(t, Point2, GraphObject2, "position");
      const i = t.x, e = t.y, s = this.position, n = s.x, o = s.y;
      n !== i && (!isNaN(n) || !isNaN(i)) || o !== e && (!isNaN(o) || !isNaN(e)) ? (t = t.copy(), this.BN(t, n, o) && this.t("position", new Point2(n, o), t.copy())) : this.VN();
    }
    VN() {
    }
    BN(t, i, e) {
      return this.yt = t, this.Cc(), true;
    }
    Gf(t, i, e) {
      this.yt.x === t && this.yt.y === i || (this.yt.e(t, i), this.Sc());
    }
    get actualBounds() {
      return this.Oi;
    }
    get scale() {
      return this.lt;
    }
    set scale(t) {
      const i = this.scale;
      i !== t && (Debug && U.r(t, GraphObject2, "scale"), t <= 0 && U.n("GraphObject.scale for " + this + " must be greater than zero, not: " + t), this.lt = t, this.g(), this.t("scale", i, t));
    }
    get angle() {
      return this.vt;
    }
    set angle(t) {
      const i = this.angle;
      if (i !== t) {
        if (Debug && U.r(t, GraphObject2, "angle"), t = t % 360, t < 0 && (t += 360), i === t) return;
        this.vt = t, this.hD(), this.g(), this.t("angle", i, t);
      }
    }
    get desiredSize() {
      return this.gs;
    }
    set desiredSize(t) {
      Debug && U.s(t, Size2, GraphObject2, "desiredSize");
      const i = t.width, e = t.height, s = this.desiredSize, n = s.width, o = s.height;
      if ((n !== i && (!isNaN(n) || !isNaN(i)) || o !== e && (!isNaN(o) || !isNaN(e))) && (t = t.T(), this.gs = t, this.g(), this instanceof Shape2 && this.ie(), this.t("desiredSize", s, t), this.xc())) {
        const r = this.part;
        r !== null && (this.Ya(r, "width"), this.Ya(r, "height"));
      }
    }
    get width() {
      return this.gs.width;
    }
    set width(t) {
      const i = this.gs.width;
      if (i !== t && (!isNaN(i) || !isNaN(t))) {
        Debug && U.i(t, "number", GraphObject2, "width");
        const e = this.gs, s = new Size2(t, this.gs.height).S();
        if (this.gs = s, this.g(), this instanceof Shape2 && this.ie(), this.t("desiredSize", e, s), this.xc()) {
          const n = this.part;
          n !== null && this.Ya(n, "width");
        }
      }
    }
    get height() {
      return this.gs.height;
    }
    set height(t) {
      const i = this.gs.height;
      if (i !== t && (!isNaN(i) || !isNaN(t))) {
        Debug && U.i(t, "number", GraphObject2, "height");
        const e = this.gs, s = new Size2(this.gs.width, t).S();
        if (this.gs = s, this.g(), this instanceof Shape2 && this.ie(), this.t("desiredSize", e, s), this.xc()) {
          const n = this.part;
          n !== null && this.Ya(n, "height");
        }
      }
    }
    get minSize() {
      return this.k !== null ? this.k.Fr : Size2.ia;
    }
    set minSize(t) {
      const i = this.minSize;
      i.equals(t) || (Debug && U.s(t, Size2, GraphObject2, "minSize"), t = t.copy(), isNaN(t.width) && (t.width = 0), isNaN(t.height) && (t.height = 0), t.S(), this.jt().Fr = t, this.g(), this.t("minSize", i, t));
    }
    get maxSize() {
      return this.k !== null ? this.k.Ir : Size2.tx;
    }
    set maxSize(t) {
      const i = this.maxSize;
      i.equals(t) || (Debug && U.s(t, Size2, GraphObject2, "maxSize"), t = t.copy(), isNaN(t.width) && (t.width = 1 / 0), isNaN(t.height) && (t.height = 1 / 0), t.S(), this.jt().Ir = t, this.g(), this.t("maxSize", i, t));
    }
    get measuredBounds() {
      return this.ce;
    }
    get naturalBounds() {
      return this.ji;
    }
    $0() {
      return 0;
    }
    get margin() {
      return this.hl;
    }
    set margin(t) {
      typeof t == "number" ? t = new Margin2(t) : Debug && U.s(t, Margin2, GraphObject2, "margin");
      const i = this.hl;
      i.equals(t) || (t = t.T(), this.hl = t, this.g(), this.t("margin", i, t));
    }
    get E() {
      return this.vb() === true && this.Yb(), this.ll;
    }
    get _s() {
      return this.J0() === true && this.Yb(), this.Mh;
    }
    trigger(t, i, e) {
      let s = null;
      return typeof t == "string" ? s = new AnimationTrigger2(t, i, e) : s = t, s.Re = this, this.Os === null && (this.Os = new GMap2()), this.Os.set(s.propertyName, s), this;
    }
    get Os() {
      return this.k !== null ? this.k.Os : null;
    }
    set Os(t) {
      this.Os !== t && (this.jt().Os = t);
    }
    get Dr() {
      return this.k !== null ? this.k.Dr : 0;
    }
    set Dr(t) {
      this.Dr !== t && (this.jt().Dr = t);
    }
    get alignment() {
      return this.pi;
    }
    set alignment(t) {
      const i = this.alignment;
      i.equals(t) || (Debug && U.s(t, Spot2, GraphObject2, "alignment"), t.isNoSpot() && !t.isDefault() && U.n("GraphObject.alignment for " + this + " must be a real Spot or Spot.Default, not: " + t), t = t.T(), this.pi = t, this.Cc(), this.t("alignment", i, t));
    }
    get column() {
      return this.kh;
    }
    set column(t) {
      Debug && U.r(t, GraphObject2, "column"), t = Math.round(t);
      const i = this.column;
      i !== t && (t < 0 && U.G(t, ">= 0", GraphObject2, "column"), this.kh = t, this.g(), this.t("column", i, t), this.svg !== null && this.svg.remove());
    }
    get columnSpan() {
      return this.k !== null ? this.k.hp : 1;
    }
    set columnSpan(t) {
      Debug && U.i(t, "number", GraphObject2, "columnSpan"), t = Math.round(t);
      const i = this.columnSpan;
      i !== t && (t < 1 && U.G(t, ">= 1", GraphObject2, "columnSpan"), this.jt().hp = t, this.g(), this.t("columnSpan", i, t));
    }
    get row() {
      return this.H0;
    }
    set row(t) {
      Debug && U.r(t, GraphObject2, "row"), t = Math.round(t);
      const i = this.row;
      i !== t && (t < 0 && U.G(t, ">= 0", GraphObject2, "row"), this.H0 = t, this.g(), this.t("row", i, t), this.svg !== null && this.svg.remove());
    }
    get rowSpan() {
      return this.k !== null ? this.k.ap : 1;
    }
    set rowSpan(t) {
      Debug && U.i(t, "number", GraphObject2, "rowSpan"), t = Math.round(t);
      const i = this.rowSpan;
      i !== t && (t < 1 && U.G(t, ">= 1", GraphObject2, "rowSpan"), this.jt().ap = t, this.g(), this.t("rowSpan", i, t));
    }
    get spanAllocation() {
      return this.k !== null ? this.k.fp : null;
    }
    set spanAllocation(t) {
      const i = this.spanAllocation;
      i !== t && (t !== null && U.C(t, GraphObject2, "spanAllocation"), this.jt().fp = t, this.g(), this.t("spanAllocation", i, t));
    }
    get alignmentFocus() {
      return this.Pd;
    }
    set alignmentFocus(t) {
      const i = this.alignmentFocus;
      i.equals(t) || (Debug && U.s(t, Spot2, GraphObject2, "alignmentFocus"), Debug && t.isNoSpot() && !t.isDefault() && !(t.isNone() && this instanceof Node2) && U.n("GraphObject.alignmentFocus must be a real Spot or Spot.Default, not: " + t), t = t.T(), this.Pd = t, this.g(), this.t("alignmentFocus", i, t));
    }
    get portId() {
      return this.q0;
    }
    set portId(t) {
      const i = this.portId;
      if (i !== t) {
        Debug && t !== null && U.i(t, "string", GraphObject2, "portId");
        const e = this.part;
        e !== null && !(e instanceof Node2) && U.n("Cannot set portID on a Link: " + t);
        const s = e;
        i !== null && s !== null && s.zN(this), this.q0 = t, t !== null && s !== null && (s.In = true, s.aD(this)), this.t("portId", i, t);
      }
    }
    Ga() {
      const t = this.part;
      if (t instanceof Node2 && (this.portId !== null || this === t.port)) {
        const i = t.diagram;
        i !== null && !i.undoManager.isUndoingRedoing && t.invalidateConnectedLinks(void 0, this);
      }
    }
    hD() {
      const t = this.diagram;
      t === null || t.undoManager.isUndoingRedoing || (this instanceof Panel2 ? this instanceof Node2 ? this.invalidateConnectedLinks() : this.walkVisualTreeFrom(this, (i) => {
        i.Ga();
      }) : this.Ga());
    }
    get toSpot() {
      return this.wt !== null ? this.wt.Ea : Spot2.None;
    }
    set toSpot(t) {
      const i = this.toSpot;
      i.equals(t) || (Debug && U.s(t, Spot2, GraphObject2, "toSpot"), t = t.T(), this._e().Ea = t, this.t("toSpot", i, t), this.Ga());
    }
    get toEndSegmentLength() {
      return this.wt !== null ? this.wt.Va : 10;
    }
    set toEndSegmentLength(t) {
      const i = this.toEndSegmentLength;
      i !== t && (Debug && U.i(t, "number", GraphObject2, "toEndSegmentLength"), t < 0 && U.G(t, ">= 0", GraphObject2, "toEndSegmentLength"), this._e().Va = t, this.t("toEndSegmentLength", i, t), this.Ga());
    }
    get toShortLength() {
      return this.wt !== null ? this.wt.Xa : 0;
    }
    set toShortLength(t) {
      const i = this.toShortLength;
      i !== t && (Debug && U.i(t, "number", GraphObject2, "toShortLength"), this._e().Xa = t, this.t("toShortLength", i, t), this.Ga());
    }
    get toLinkable() {
      return this.wt !== null ? this.wt.cp : null;
    }
    set toLinkable(t) {
      const i = this.toLinkable;
      i !== t && (Debug && t !== null && U.i(t, "boolean", GraphObject2, "toLinkable"), this._e().cp = t, this.t("toLinkable", i, t));
    }
    get toMaxLinks() {
      return this.wt !== null ? this.wt.dp : 1 / 0;
    }
    set toMaxLinks(t) {
      const i = this.toMaxLinks;
      i !== t && (Debug && U.i(t, "number", GraphObject2, "toMaxLinks"), t < 0 && U.G(t, ">= 0", GraphObject2, "toMaxLinks"), this._e().dp = t, this.t("toMaxLinks", i, t));
    }
    get fromSpot() {
      return this.wt !== null ? this.wt.Oa : Spot2.None;
    }
    set fromSpot(t) {
      const i = this.fromSpot;
      i.equals(t) || (Debug && U.s(t, Spot2, GraphObject2, "fromSpot"), t = t.T(), this._e().Oa = t, this.t("fromSpot", i, t), this.Ga());
    }
    get fromEndSegmentLength() {
      return this.wt !== null ? this.wt.Ba : 10;
    }
    set fromEndSegmentLength(t) {
      const i = this.fromEndSegmentLength;
      i !== t && (Debug && U.i(t, "number", GraphObject2, "fromEndSegmentLength"), t < 0 && U.G(t, ">= 0", GraphObject2, "fromEndSegmentLength"), this._e().Ba = t, this.t("fromEndSegmentLength", i, t), this.Ga());
    }
    get fromShortLength() {
      return this.wt !== null ? this.wt.za : 0;
    }
    set fromShortLength(t) {
      const i = this.fromShortLength;
      i !== t && (Debug && U.i(t, "number", GraphObject2, "fromShortLength"), this._e().za = t, this.t("fromShortLength", i, t), this.Ga());
    }
    get fromLinkable() {
      return this.wt !== null ? this.wt.gp : null;
    }
    set fromLinkable(t) {
      const i = this.fromLinkable;
      i !== t && (Debug && t !== null && U.i(t, "boolean", GraphObject2, "fromLinkable"), this._e().gp = t, this.t("fromLinkable", i, t));
    }
    get fromMaxLinks() {
      return this.wt !== null ? this.wt.mp : 1 / 0;
    }
    set fromMaxLinks(t) {
      const i = this.fromMaxLinks;
      i !== t && (Debug && U.i(t, "number", GraphObject2, "fromMaxLinks"), t < 0 && U.G(t, ">= 0", GraphObject2, "fromMaxLinks"), this._e().mp = t, this.t("fromMaxLinks", i, t));
    }
    get cursor() {
      return this.k !== null ? this.k.Xl : "";
    }
    set cursor(t) {
      const i = this.cursor;
      i !== t && (U.i(t, "string", GraphObject2, "cursor"), this.jt().Xl = t, this.t("cursor", i, t));
    }
    get click() {
      return this.k !== null ? this.k.Ur : null;
    }
    set click(t) {
      const i = this.click;
      i !== t && (t !== null && U.C(t, GraphObject2, "click"), this.jt().Ur = t, this.t("click", i, t));
    }
    get doubleClick() {
      return this.k !== null ? this.k.Gr : null;
    }
    set doubleClick(t) {
      const i = this.doubleClick;
      i !== t && (t !== null && U.C(t, GraphObject2, "doubleClick"), this.jt().Gr = t, this.t("doubleClick", i, t));
    }
    get contextClick() {
      return this.k !== null ? this.k.qr : null;
    }
    set contextClick(t) {
      const i = this.contextClick;
      i !== t && (t !== null && U.C(t, GraphObject2, "contextClick"), this.jt().qr = t, this.t("contextClick", i, t));
    }
    get mouseEnter() {
      return this.k !== null ? this.k.Jr : null;
    }
    set mouseEnter(t) {
      const i = this.mouseEnter;
      i !== t && (t !== null && U.C(t, GraphObject2, "mouseEnter"), this.jt().Jr = t, this.t("mouseEnter", i, t));
    }
    get mouseLeave() {
      return this.k !== null ? this.k.$r : null;
    }
    set mouseLeave(t) {
      const i = this.mouseLeave;
      i !== t && (t !== null && U.C(t, GraphObject2, "mouseLeave"), this.jt().$r = t, this.t("mouseLeave", i, t));
    }
    get mouseOver() {
      return this.k !== null ? this.k.Hr : null;
    }
    set mouseOver(t) {
      const i = this.mouseOver;
      i !== t && (t !== null && U.C(t, GraphObject2, "mouseOver"), this.jt().Hr = t, this.t("mouseOver", i, t));
    }
    get mouseHover() {
      return this.k !== null ? this.k.vr : null;
    }
    set mouseHover(t) {
      const i = this.mouseHover;
      i !== t && (t !== null && U.C(t, GraphObject2, "mouseHover"), this.jt().vr = t, this.t("mouseHover", i, t));
    }
    get mouseHold() {
      return this.k !== null ? this.k.Wr : null;
    }
    set mouseHold(t) {
      const i = this.mouseHold;
      i !== t && (t !== null && U.C(t, GraphObject2, "mouseHold"), this.jt().Wr = t, this.t("mouseHold", i, t));
    }
    get mouseDragEnter() {
      return this.k !== null ? this.k.pp : null;
    }
    set mouseDragEnter(t) {
      const i = this.mouseDragEnter;
      i !== t && (t !== null && U.C(t, GraphObject2, "mouseDragEnter"), this.jt().pp = t, this.t("mouseDragEnter", i, t));
    }
    get mouseDragLeave() {
      return this.k !== null ? this.k.yp : null;
    }
    set mouseDragLeave(t) {
      const i = this.mouseDragLeave;
      i !== t && (t !== null && U.C(t, GraphObject2, "mouseDragLeave"), this.jt().yp = t, this.t("mouseDragLeave", i, t));
    }
    get mouseDrop() {
      return this.k !== null ? this.k.jr : null;
    }
    set mouseDrop(t) {
      const i = this.mouseDrop;
      i !== t && (t !== null && U.C(t, GraphObject2, "mouseDrop"), this.jt().jr = t, this.t("mouseDrop", i, t));
    }
    get actionDown() {
      return this.k !== null ? this.k.wp : null;
    }
    set actionDown(t) {
      const i = this.actionDown;
      i !== t && (t !== null && U.C(t, GraphObject2, "actionDown"), this.jt().wp = t, this.t("actionDown", i, t));
    }
    get actionMove() {
      return this.k !== null ? this.k.xp : null;
    }
    set actionMove(t) {
      const i = this.actionMove;
      i !== t && (t !== null && U.C(t, GraphObject2, "actionMove"), this.jt().xp = t, this.t("actionMove", i, t));
    }
    get actionUp() {
      return this.k !== null ? this.k.bp : null;
    }
    set actionUp(t) {
      const i = this.actionUp;
      i !== t && (t !== null && U.C(t, GraphObject2, "actionUp"), this.jt().bp = t, this.t("actionUp", i, t));
    }
    get actionCancel() {
      return this.k !== null ? this.k.Sp : null;
    }
    set actionCancel(t) {
      const i = this.actionCancel;
      i !== t && (t !== null && U.C(t, GraphObject2, "actionCancel"), this.jt().Sp = t, this.t("actionCancel", i, t));
    }
    get toolTip() {
      return this.k !== null ? this.k.Zr : null;
    }
    set toolTip(t) {
      const i = this.toolTip;
      i !== t && (Debug && t !== null && !(t instanceof Adornment2 || t instanceof HTMLInfo2) && U.n("GraphObject.toolTip must be an Adornment or HTMLInfo."), this.jt().Zr = t, this.t("toolTip", i, t));
    }
    get contextMenu() {
      return this.k !== null ? this.k.Qr : null;
    }
    set contextMenu(t) {
      const i = this.contextMenu;
      i !== t && (Debug && !(t instanceof Adornment2 || t instanceof HTMLInfo2) && U.n("GraphObject.contextMenu must be an Adornment or HTMLInfo."), this.jt().Qr = t, this.t("contextMenu", i, t));
    }
    findBindingPanel() {
      let t = this instanceof Panel2 ? this : this.panel;
      for (; t !== null; ) {
        if (t.XN()) return t;
        t = t.panel;
      }
      return null;
    }
    bind(t, i, e, s) {
      return this.Ac(t, i, e, s), this;
    }
    bindTwoWay(t, i, e, s) {
      return this.Ac(t, i, e, s).makeTwoWay(), this;
    }
    bindModel(t, i, e, s) {
      return this.Ac(t, i, e, s).ofModel(), this;
    }
    bindObject(t, i, e, s, n) {
      return this.Ac(t, i, e, s).ofObject(n), this;
    }
    theme(t, i, e, s, n) {
      return this.Fh(t, i, e, s, n), this;
    }
    themeData(t, i, e, s, n) {
      return this.Fh(t, i, e, s, n).ofData(), this;
    }
    themeObject(t, i, e, s, n, o) {
      return this.Fh(t, i, e, s, n).ofObject(o), this;
    }
    themeModel(t, i, e, s, n) {
      return this.Fh(t, i, e, s, n).ofModel(), this;
    }
    Ac(t, i, e, s) {
      let n = null;
      return typeof t == "string" ? n = new Binding2(t, i, e, s) : n = t, this.kp(n), n;
    }
    Fh(t, i, e, s, n) {
      let o = null;
      return typeof t == "string" ? o = new ThemeBinding2(t, i, e, s, n) : o = t, this.kp(o), o;
    }
    kp(t) {
      t.Re = this;
      const i = this.findBindingPanel();
      i !== null && i.fD() && U.n("Cannot add a Binding to a template that has already been copied: " + t), this.Ei === null && (this.Ei = new List2()), this.Ei.add(t);
    }
    set(t) {
      if (!t) return this;
      if (Debug) for (const i in t) (i.startsWith("_") || i.indexOf(".") !== -1) && U.n("Property with underscore or period passed to GraphObject.set. Did you mean to use GraphObject.attach?");
      return Object.assign(this, t), this;
    }
    attach(t) {
      return GraphObject2.YN(this, t), this;
    }
    apply(t, ...i) {
      return t.apply(this, [this, ...i]), this;
    }
    setProperties(t) {
      return Diagram2.I0(this, t), this;
    }
    static make(t, ...i) {
      let e = arguments, s = null, n = null;
      if (U.at(t)) n = t;
      else if (typeof t == "string") {
        const r = GraphObject2.Wb.get(t);
        U.at(r) ? (e = Array.prototype.slice.call(e), s = r(e), U.it(s) || U.n('GraphObject.make invoked object builder "' + t + '", but it did not return an Object')) : n = root.go[t];
      }
      s === null && ((n == null || !n.constructor) && U.n("GraphObject.make requires a class function or GoJS class name or name of an object builder, not: " + t), s = new n());
      let o = 1;
      if (s instanceof Diagram2 && e.length > 1) {
        const r = s, l = e[1];
        (typeof l == "string" || l instanceof HTMLDivElement) && (r.P2(l), o++);
      }
      for (let r = o; r < e.length; r++) {
        const l = e[r];
        l === void 0 ? U.n("Undefined value at argument " + r + " for object being constructed by GraphObject.make: " + s) : s && GraphObject2.YN(s, l);
      }
      return s;
    }
    static YN(t, i) {
      if (typeof i == "number") GraphObject2.k3(t, i);
      else if (typeof i == "string") GraphObject2.P3(t, i);
      else if (i instanceof GraphObject2) t instanceof Panel2 || U.n("A GraphObject can only be added to a Panel, not to: " + t), t.add(i);
      else if (i instanceof RowColumnDefinition2) {
        let e = null;
        i.isRow && U.at(t.getRowDefinition) ? e = t.getRowDefinition(i.index) : !i.isRow && U.at(t.getColumnDefinition) && (e = t.getColumnDefinition(i.index)), e instanceof RowColumnDefinition2 ? e.jb(i) : U.n("A RowColumnDefinition can only be added to an object that implements getRowDefinition/getColumnDefinition, not to: " + t);
      } else if (i instanceof PanelLayout2) {
        const e = t;
        e.type = i;
      } else if (i instanceof Binding2) t instanceof GraphObject2 || t instanceof RowColumnDefinition2 ? t.bind(i) : U.n("A Binding can only be applied to a GraphObject or RowColumnDefinition, not to: " + t);
      else if (i instanceof AnimationTrigger2) t instanceof GraphObject2 ? t.trigger(i) : U.n("An AnimationTrigger can only be applied to a GraphObject, not to: " + t);
      else if (i instanceof PathFigure2) t instanceof Geometry2 && t.type === 4 ? t.figures.add(i) : U.n("A PathFigure can only be added to a Path Geometry, not to: " + t);
      else if (i instanceof PathSegment2) t instanceof PathFigure2 ? t.segments.add(i) : U.n("A PathSegment can only be added to a PathFigure, not to: " + t);
      else if (i instanceof Layout2) t instanceof Diagram2 || t instanceof Group2 ? t.layout = i : U.n("A Layout can only be assigned to a Diagram or a Group, not to: " + t);
      else if (Array.isArray(i)) for (let e = 0; e < i.length; e++) {
        const s = i[e];
        GraphObject2.YN(t, s);
      }
      else U.it(i) ? GraphObject2.M3(t, i) : U.n('Unknown initializer "' + i + '" for object being constructed by GraphObject.make: ' + t);
    }
    static P3(t, i) {
      if (t instanceof TextBlock2) t.text = i;
      else if (t instanceof Shape2) t.figure = i;
      else if (t instanceof Picture2) t.source = i;
      else if (t instanceof Panel2) {
        const e = PanelLayout2.ms.get(i);
        e !== null ? t.type = e : Debug && U.n("Unknown Panel type as an argument to GraphObject.make: " + i + ". If building from source, you may need to call Panel.definePanelLayout.");
      } else if (t instanceof Brush2) {
        const e = U.ta(BrushType2, i);
        e !== null ? t.type = e : U.n("Unknown Brush type as an argument to GraphObject.make: " + i);
      } else if (t instanceof Geometry2) {
        const e = U.ta(GeometryType2, i);
        e !== null ? t.type = e : Debug && U.n("Unknown Geometry type as an argument to GraphObject.make: " + i);
      } else if (t instanceof PathSegment2) {
        const e = U.ta(SegmentType2, i);
        e !== null ? t.type = e : Debug && U.n("Unknown PathSegment type as an argument to GraphObject.make: " + i);
      } else Debug && U.n("Unable to use a string as an argument to GraphObject.make: " + i);
    }
    static k3(t, i) {
      U.at(t.gi) ? t.gi(i) : U.xr(t, i);
    }
    static M3(t, i) {
      if (t instanceof Brush2) {
        const e = new PropertyCollection();
        for (const s in i) {
          const n = parseFloat(s);
          isNaN(n) ? e[s] = i[s] : t.addColorStop(n, i[s]);
        }
        Diagram2.I0(t, e);
      } else if (t instanceof RowColumnDefinition2) {
        if (i.row !== void 0) {
          const s = i.row;
          (s == null || s === 1 / 0 || isNaN(s) || s < 0) && U.n("Must specify non-negative integer row for RowColumnDefinition " + i + ", not: " + s), t.isRow = true, t.index = s;
        } else if (i.column !== void 0) {
          const s = i.column;
          (s == null || s === 1 / 0 || isNaN(s) || s < 0) && U.n("Must specify non-negative integer column for RowColumnDefinition " + i + ", not: " + s), t.isRow = false, t.index = s;
        }
        const e = new PropertyCollection();
        for (const s in i) s === "row" || s === "column" || (e[s] = i[s]);
        Diagram2.I0(t, e);
      } else Diagram2.I0(t, i);
    }
    static build(t, i, ...e) {
      const s = GraphObject2.Wb.get(t);
      if (U.at(s)) {
        const n = s([t].concat(e));
        if (n instanceof GraphObject2) return i && n.setProperties(i), n;
      }
      U.n('GraphObject.build invoked object builder "' + t + '", but it did not return an Object');
    }
    static defineBuilder(t, i) {
      U.i(t, "string", GraphObject2, "defineBuilder:name"), U.C(i, GraphObject2, "defineBuilder:func");
      const e = t.toLowerCase();
      Debug && (t === "" || e === "none" || t === e) && U.n("Shape.defineFigureGenerator name must not be empty or None or all-lower-case: " + t), GraphObject2.Wb.set(t, i);
    }
    static isBuilderDefined(t) {
      return GraphObject2.Wb.has(t);
    }
    static takeBuilderArgument(t, i, e) {
      e === void 0 && (e = null);
      const s = t[1];
      return (U.at(e) ? e(s) : typeof s == "string") ? (t.splice(1, 1), s) : (i === void 0 && U.n("no " + (U.at(e) ? "satisfactory" : "string") + " argument for GraphObject builder " + t[0]), i);
    }
    static Wb = new GMap2();
  }
  GraphObject2.Vertical = 4, GraphObject2.Horizontal = 5, GraphObject2.defineBuilder("Button", (w) => {
    const t = "#f5f5f5", i = "#737373", e = "#d4d4d4", s = "#737373", n = "#a3a3a3", o = 2.76142374915397, r = 2.761423749153969, l = new Panel2(Panel2.Auto, { isActionable: true, enabledChanged: (h, f) => {
      if (h instanceof Panel2) {
        const a = h.findObject("ButtonBorder");
        if (a !== null) if (h._buttonFillNormal === void 0 && (h._buttonFillNormal = a.fill), f) {
          let c = null;
          h.layer !== null && h.diagram !== null && h.isVisibleObject() && (c = h.layer.findObjectAt(h.diagram.lastInput.documentPoint)), c === h || c !== null && c.isContainedBy(h) ? a.fill = h._buttonFillOver : a.fill = h._buttonFillNormal;
        } else a.fill = h._buttonFillDisabled;
      }
    }, cursor: "pointer" }).attach({ _buttonFillNormal: void 0, _buttonStrokeNormal: void 0, _buttonFillOver: e, _buttonStrokeOver: s, _buttonFillDisabled: n }).add(new Shape2("RoundedRectangle", { name: "ButtonBorder", spot1: new Spot2(0, 0, o, r), spot2: new Spot2(1, 1, -o, -r), parameter1: 2, fill: t, stroke: i }));
    return l.mouseEnter = (h, f, a) => {
      if (!f.isEnabledObject() || !(f instanceof Panel2)) return;
      const c = f.findObject("ButtonBorder");
      c instanceof Shape2 && (f._buttonFillNormal === void 0 && (f._buttonFillNormal = c.fill), c.fill = f._buttonFillOver, f._buttonStrokeNormal === void 0 && (f._buttonStrokeNormal = c.stroke), c.stroke = f._buttonStrokeOver);
    }, l.mouseLeave = (h, f, a) => {
      if (!f.isEnabledObject() || !(f instanceof Panel2)) return;
      const c = f.findObject("ButtonBorder");
      c instanceof Shape2 && (f._buttonFillNormal !== void 0 && (c.fill = f._buttonFillNormal), f._buttonStrokeNormal !== void 0 && (c.stroke = f._buttonStrokeNormal));
    }, l;
  }), GraphObject2.defineBuilder("TreeExpanderButton", (w) => {
    const t = GraphObject2.build("Button");
    return t.attach({ _treeExpandedFigure: "MinusLine", _treeCollapsedFigure: "PlusLine", visible: false }), t.add(new Shape2("MinusLine", { name: "ButtonIcon", stroke: "#0a0a0a", strokeWidth: 2, desiredSize: Size2.Tu }).bindObject("figure", "isTreeExpanded", (i, e) => {
      const s = e.panel;
      return i ? s._treeExpandedFigure : s._treeCollapsedFigure;
    })), t.bindObject("visible", "isTreeLeaf", (i) => !i), t.click = (i, e) => {
      let s = e.part;
      if (s instanceof Adornment2 && (s = s.adornedPart), !(s instanceof Node2)) return;
      const n = s.diagram;
      if (n === null) return;
      const o = n.commandHandler;
      if (s.isTreeExpanded) {
        if (!o.canCollapseTree(s)) return;
      } else if (!o.canExpandTree(s)) return;
      i.handled = true, s.isTreeExpanded ? o.collapseTree(s) : o.expandTree(s);
    }, t;
  }), GraphObject2.defineBuilder("SubGraphExpanderButton", (w) => {
    const t = GraphObject2.build("Button");
    return t.attach({ _subGraphExpandedFigure: "MinusLine", _subGraphCollapsedFigure: "PlusLine" }), t.add(new Shape2("MinusLine", { name: "ButtonIcon", stroke: "#0a0a0a", strokeWidth: 2, desiredSize: Size2.Tu }).bindObject("figure", "isSubGraphExpanded", (i, e) => {
      const s = e.panel;
      return i ? s._subGraphExpandedFigure : s._subGraphCollapsedFigure;
    })), t.click = (i, e) => {
      let s = e.part;
      if (s instanceof Adornment2 && (s = s.adornedPart), !(s instanceof Group2)) return;
      const n = s.diagram;
      if (n === null) return;
      const o = n.commandHandler;
      if (s.isSubGraphExpanded) {
        if (!o.canCollapseSubGraph(s)) return;
      } else if (!o.canExpandSubGraph(s)) return;
      i.handled = true, s.isSubGraphExpanded ? o.collapseSubGraph(s) : o.expandSubGraph(s);
    }, t;
  }), GraphObject2.defineBuilder("ToolTip", (w) => new Adornment2(Panel2.Auto, { isShadowed: true, shadowColor: "rgba(0, 0, 0, .4)", shadowOffset: new Point2(0, 2), mouseOver: (t, i) => {
    const e = t.diagram.toolManager;
    e.extendToolTip(e.toolTipDuration);
  } }).add(new Shape2("RoundedRectangle", { name: "Border", parameter1: 1, fill: "#f5f5f5", strokeWidth: 0, spot1: new Spot2(0, 0, 4, 6), spot2: new Spot2(1, 1, -4, -4) }))), GraphObject2.defineBuilder("ContextMenu", (w) => new Adornment2(Panel2.Vertical, { background: "#f5f5f5", isShadowed: true, shadowColor: "rgba(0, 0, 0, .4)", shadowOffset: new Point2(0, 2) }).bindObject("background", "", (t) => t.adornedPart !== null && t.hasPlaceholder() ? null : "#f5f5f5")), GraphObject2.defineBuilder("ContextMenuButton", (w) => {
    const t = GraphObject2.build("Button");
    t.stretch = 5;
    const i = t.findObject("ButtonBorder");
    return i instanceof Shape2 && (i.figure = "Rectangle", i.strokeWidth = 0, i.spot1 = new Spot2(0, 0, 4, 6), i.spot2 = new Spot2(1, 1, -4, -4)), t;
  }), GraphObject2.defineBuilder("PanelExpanderButton", (w) => {
    const t = GraphObject2.takeBuilderArgument(w, "COLLAPSIBLE"), i = GraphObject2.build("Button");
    i.attach({ _buttonExpandedFigure: "M0 0 M0 6 L4 2 8 6 M8 8", _buttonCollapsedFigure: "M0 0 M0 2 L4 6 8 2 M8 8", "ButtonBorder.fill": "rgba(0, 0, 0, 0)", _buttonFillNormal: "rgba(0, 0, 0, 0)", "ButtonBorder.stroke": null, _buttonStrokeNormal: null, _buttonFillOver: "rgba(0, 0, 0, .2)", _buttonStrokeOver: null }), i.add(new Shape2({ name: "ButtonIcon", strokeWidth: 2 }).bindObject("geometryString", "visible", (s) => s ? i._buttonExpandedFigure : i._buttonCollapsedFigure, void 0, t));
    const e = i.findObject("ButtonBorder");
    return e instanceof Shape2 && (e.stroke = null, e.fill = "rgba(0, 0, 0, 0)"), i.click = (s, n) => {
      if (!(n instanceof Panel2)) return;
      const o = n.diagram;
      if (o === null || o.isReadOnly) return;
      let r = n.findBindingPanel();
      if (r === null && (r = n.part), r !== null) {
        const l = r.findObject(t);
        l !== null && (s.handled = true, o.startTransaction("Collapse/Expand Panel"), l.visible = !l.visible, o.commitTransaction("Collapse/Expand Panel"));
      }
    }, i;
  }), GraphObject2.defineBuilder("CheckBoxButton", (w) => {
    const t = GraphObject2.takeBuilderArgument(w), i = GraphObject2.build("Button", { desiredSize: new Size2(14, 14) });
    i.attach({ "ButtonBorder.spot1": new Spot2(0, 0, 1, 1), "ButtonBorder.spot2": new Spot2(1, 1, -1, -1) });
    const e = new Shape2({ name: "ButtonIcon", geometryString: "M0 0 M0 8.85 L4.9 13.75 16.2 2.45 M16.2 16.2", strokeWidth: 2, stretch: 2, geometryStretch: 6, visible: false });
    return t !== "" && e.bindTwoWay("visible", t), i.add(e), i.click = (s, n) => {
      if (!(n instanceof Panel2)) return;
      const o = s.diagram;
      if (o === null || o.isReadOnly || t !== "" && o.model.isReadOnly) return;
      s.handled = true;
      const r = n.findObject("ButtonIcon");
      o.startTransaction("checkbox"), r !== null && (r.visible = !r.visible), U.at(n._doClick) && n._doClick(s, n), o.commitTransaction("checkbox");
    }, i;
  }), GraphObject2.defineBuilder("CheckBox", (w) => {
    const t = GraphObject2.takeBuilderArgument(w), i = GraphObject2.build("CheckBoxButton", { name: "Button", isActionable: false, margin: new Margin2(0, 1, 0, 0) }, t), e = new Panel2("Horizontal", { isActionable: true, cursor: i.cursor, margin: new Margin2(1), mouseEnter: i.mouseEnter, mouseLeave: i.mouseLeave, click: i.click }).attach({ _buttonFillNormal: i._buttonFillNormal, _buttonStrokeNormal: i._buttonStrokeNormal, _buttonFillOver: i._buttonFillOver, _buttonStrokeOver: i._buttonStrokeOver, _buttonFillDisabled: i._buttonFillDisabled, _buttonClick: i.click });
    return e.add(i), i.mouseEnter = null, i.mouseLeave = null, i.click = null, e;
  }), GraphObject2.defineBuilder("AutoRepeatButton", (w) => {
    const t = GraphObject2.takeBuilderArgument(w, 50, (r) => typeof r == "number"), i = GraphObject2.takeBuilderArgument(w, 500, (r) => typeof r == "number");
    function e(r, l) {
      n(r, l), l.click && (l.Dd = U.yn(() => s(r, l), i));
    }
    function s(r, l) {
      l.Dd && U.Nf(l.Dd), l.click && (l.Dd = U.yn(() => {
        l.click && (l.click(r, l), s(r, l));
      }, t));
    }
    function n(r, l) {
      l.Dd && (U.Nf(l.Dd), l.Dd = void 0);
    }
    const o = GraphObject2.build("Button");
    return o.actionDown = (r, l) => e(r, l), o.actionUp = (r, l) => n(r, l), o.actionCancel = (r, l) => n(r, l), o;
  }), GraphObject2.defineBuilder("ToggleSwitch", function(w) {
    const t = GraphObject2.takeBuilderArgument(w);
    t || U.n("ToggleSwitch must be data-bound to a property name, not: " + t);
    const i = GraphObject2.takeBuilderArgument(w, false, (f) => typeof f == "boolean"), e = "gray", s = "transparent", n = "white", h = new Panel2("Auto", { width: i ? 15 : 28, height: i ? 28 : 15 }).attach({ _buttonFillOff: e, _buttonBorderOff: s, _buttonIconFillOff: n, _buttonFillOn: "green", _buttonBorderOn: "transparent", _buttonIconFillOn: "white" }).add(new Shape2("Capsule", { name: "ButtonBorder", fill: e, stroke: s, strokeWidth: 1 }).bind("fill", t, (f, a) => f ? a.panel._buttonFillOn : a.panel._buttonFillOff).bind("stroke", t, (f, a) => f ? a.panel._buttonBorderOn : a.panel._buttonBorderOff)).add(new Shape2("Circle", { name: "ButtonIcon", width: 11, height: 11, fill: n, stroke: null, alignment: i ? Spot2.Bottom : Spot2.Left }).bind("fill", t, (f, a) => f ? a.panel._buttonIconFillOn : a.panel._buttonIconFillOff).bind("alignment", t, (f) => f ? i ? Spot2.Top : Spot2.Right : i ? Spot2.Bottom : Spot2.Left));
    return h.click = function(f, a) {
      if (!a.isEnabledObject()) return;
      const c = f.diagram;
      if (c === null || c.isReadOnly || t !== "" && c.model.isReadOnly) return;
      f.handled = true;
      const u = a.findBindingPanel();
      u !== null && (c.startTransaction("toggle switch"), c.model.set(u.data, t, !u.data[t]), typeof a._doClick == "function" && a._doClick(f, a), c.commitTransaction("toggle switch"));
    }, h;
  }), GraphObject2.defineBuilder("Toggle", function(w) {
    const t = GraphObject2.takeBuilderArgument(w), i = GraphObject2.build("ToggleSwitch", { name: "Button" }, t), e = new Panel2("Horizontal", { cursor: i.cursor, margin: 1, mouseEnter: i.mouseEnter, mouseLeave: i.mouseLeave, click: i.click }).attach({ _buttonClick: i.click }).add(i);
    return i.mouseEnter = null, i.mouseLeave = null, i.click = null, e;
  });
  class GraphObjectTemplateSettings {
    wi;
    At;
    ao;
    Ei;
    fo;
    Es;
    Xl;
    Ur;
    Gr;
    qr;
    Jr;
    $r;
    Hr;
    vr;
    Wr;
    pp;
    yp;
    jr;
    wp;
    xp;
    bp;
    Sp;
    Zr;
    Qr;
    ip;
    fp;
    Os;
    Fr;
    Ir;
    go;
    ap;
    hp;
    Dr;
    _0;
    Pp;
    Mp;
    constructor() {
      this.wi = false, this.At = "", this.ao = -1, this.Ei = null, this.fo = null, this.Es = null, this.Xl = "", this.Ur = null, this.Gr = null, this.qr = null, this.Jr = null, this.$r = null, this.Hr = null, this.vr = null, this.Wr = null, this.pp = null, this.yp = null, this.jr = null, this.wp = null, this.xp = null, this.bp = null, this.Sp = null, this.Zr = null, this.Qr = null, this.ip = null, this.fp = null, this.Os = null, this.Fr = Size2.ia, this.Ir = Size2.tx, this.go = 1, this.ap = 1, this.hp = 1, this.Dr = 0, this._0 = null, this.Pp = null, this.Mp = "category";
    }
    copy() {
      const t = new GraphObjectTemplateSettings();
      return t.At = this.At, t.ao = this.ao, t.Ei = this.Ei, t.Es = this.Es, t.Xl = this.Xl, t.Ur = this.Ur, t.Gr = this.Gr, t.qr = this.qr, t.Jr = this.Jr, t.$r = this.$r, t.Hr = this.Hr, t.vr = this.vr, t.Wr = this.Wr, t.pp = this.pp, t.yp = this.yp, t.jr = this.jr, t.wp = this.wp, t.xp = this.xp, t.bp = this.bp, t.Sp = this.Sp, t.Zr = this.Zr, t.Qr = this.Qr, t.ip = this.ip, t.fp = this.fp, t.Os = this.Os, t.Fr = this.Fr.T(), t.Ir = this.Ir.T(), t.go = this.go, t.ap = this.ap, t.hp = this.hp, t.Dr = this.Dr, t._0 = this._0, t.Pp = this.Pp, t.Mp = this.Mp, t;
    }
  }
  class STransform {
    m;
    constructor() {
      this.m = [1, 0, 0, 1, 0, 0];
    }
    copy() {
      const t = new STransform();
      return t.m[0] = this.m[0], t.m[1] = this.m[1], t.m[2] = this.m[2], t.m[3] = this.m[3], t.m[4] = this.m[4], t.m[5] = this.m[5], t;
    }
    translate(t, i) {
      this.m[4] += this.m[0] * t + this.m[2] * i, this.m[5] += this.m[1] * t + this.m[3] * i;
    }
    scale(t, i) {
      this.m[0] *= t, this.m[1] *= t, this.m[2] *= i, this.m[3] *= i;
    }
    rotate(t, i, e) {
      if (t = G.Yi(t), t === 0) return;
      this.translate(i, e);
      let s = 0, n = 0;
      if (t === 90) s = 0, n = 1;
      else if (t === 180) s = -1, n = 0;
      else if (t === 270) s = 0, n = -1;
      else {
        const f = t * Math.PI / 180;
        s = Math.cos(f), n = Math.sin(f);
      }
      const o = this.m[0] * s + this.m[2] * n, r = this.m[1] * s + this.m[3] * n, l = this.m[0] * -n + this.m[2] * s, h = this.m[1] * -n + this.m[3] * s;
      this.m[0] = o, this.m[1] = r, this.m[2] = l, this.m[3] = h, this.translate(-i, -e);
    }
  }
  class SGradient {
    type;
    x1;
    y1;
    r1;
    x2;
    y2;
    r2;
    colors;
    pattern;
    constructor(t) {
      this.type = t, this.x1 = 0, this.y1 = 0, this.r1 = 0, this.x2 = 0, this.y2 = 0, this.r2 = 0, this.colors = [], this.pattern = null;
    }
    addColorStop(t, i) {
      this.colors.push({ offset: t, color: i });
    }
  }
  class SVGSurface {
    Nt;
    ni;
    rl;
    yd;
    KN;
    constructor(t, i, e) {
      const s = i === void 0 ? root.document : i;
      this.rl = s, this.KN = "http://www.w3.org/2000/svg";
      const n = "http://www.w3.org/2000/xmlns/";
      s !== void 0 && (this.Nt = this.makeElement("svg", { width: "1px", height: "1px", viewBox: "0 0 1 1" }), this.style.display = "block", this.style.letterSpacing = "normal", this.style.wordSpacing = "normal", e || (this.style.position = "absolute"), this.Nt.setAttributeNS(n, "xmlns", this.KN), this.Nt.setAttributeNS(n, "xmlns:xlink", "http://www.w3.org/1999/xlink")), this.yd = null, this.ni = new SVGContext(this, e);
    }
    resize(t, i, e, s) {
      return this.width !== t || this.height !== i ? (this.width = t, this.height = i, this.style.width = e + "px", this.style.height = s + "px", this.Nt.setAttributeNS(null, "width", e + "px"), this.Nt.setAttributeNS(null, "height", s + "px"), this.Nt.setAttributeNS(null, "viewBox", "0 0 " + e + " " + s), this.ni.UN.firstElementChild.setAttributeNS(null, "width", e + "px"), this.ni.UN.firstElementChild.setAttributeNS(null, "height", s + "px"), true) : false;
    }
    makeElement(t, i, e) {
      const s = this.rl.createElementNS(this.KN, t);
      if (U.it(i)) for (const n in i) s.setAttributeNS(n === "href" ? "http://www.w3.org/1999/xlink" : "", n, i[n]);
      return e !== void 0 && (s.textContent = e), s;
    }
    getBoundingClientRect() {
      return this.Nt.getBoundingClientRect();
    }
    focus() {
      this.Nt.focus();
    }
    get width() {
      return this.Nt.width.baseVal.value;
    }
    set width(t) {
      this.Nt.setAttribute("width", t + "px");
    }
    get height() {
      return this.Nt.height.baseVal.value;
    }
    set height(t) {
      this.Nt.setAttribute("height", t + "px");
    }
    dispose() {
      this.rl = null;
    }
    get style() {
      return this.Nt.style;
    }
  }
  class SVGContext {
    Tc;
    Lc;
    Rn;
    Bi;
    is;
    fillStyle;
    font;
    globalAlpha;
    lineCap;
    lineDashOffset;
    lineJoin;
    lineWidth;
    miterLimit;
    shadowBlur;
    shadowColor;
    shadowOffsetX;
    shadowOffsetY;
    strokeStyle;
    textAlign;
    imageSmoothingEnabled;
    clipInsteadOfFill;
    lastCreatedElement;
    Dc;
    Fc;
    surface;
    svg;
    UN;
    cD;
    Jb;
    _o;
    Ih;
    qa;
    currentElement;
    clipPathGroup;
    diagramGroup;
    lastDrawnPart;
    currentPath;
    outerGroup;
    pathAttributes;
    cl;
    Vr;
    filter;
    letterSpacing;
    wordSpacing;
    partClipRect;
    constructor(t, i) {
      if (this.surface = t, this.svg = t.Nt, this.Dc = [], this.Fc = [], this.fillStyle = "#000000", this.font = "10px sans-serif", this.globalAlpha = 1, this.lineCap = "butt", this.lineDashOffset = 0, this.lineJoin = "miter", this.lineWidth = 1, this.miterLimit = 10, this.shadowBlur = 0, this.shadowColor = "rgba(0, 0, 0, 0)", this.shadowOffsetX = 0, this.shadowOffsetY = 0, this.cl = false, this.strokeStyle = "#000000", this.textAlign = "start", this.clipInsteadOfFill = false, this.Tc = 0, this.Lc = 0, this.Rn = 0, this.lastCreatedElement = null, this.currentElement = null, this.Bi = [], this.pathAttributes = {}, this.Jb = false, this._o = null, this.Ih = 0, this.cD = {}, this.Vr = !!i, this.filter = "", this.partClipRect = null, this.is = new STransform(), this.letterSpacing = "0px", this.wordSpacing = "0px", t.rl === null || t.rl === void 0) return;
      this.clipPathGroup = this.newGroup2(), this.diagramGroup = this.newGroup2("gojs-diagram"), this.lastDrawnPart = null, this.currentPath = null;
      const e = GSet2.Qw++, s = this.makeElement("clipPath", { id: "mainClip" + e }), n = { x: 0, y: 0, width: t.width, height: t.height };
      s.appendChild(this.makeElement("rect", n)), this.UN = s, this.svg.appendChild(this.clipPathGroup), this.clipPathGroup.appendChild(this.diagramGroup), this.svg.appendChild(s), this.clipPathGroup.setAttributeNS(null, "clip-path", "url(#mainClip" + e + ")");
    }
    setDiagramPosScale(t, i, e, s, n, o) {
      this.diagramGroup === void 0 ? this.newGroup(t, i, e, s, n, o) : this.diagramGroup.setAttribute("transform", "matrix(" + t + ", " + i + ", " + e + ", " + s + ", " + n + ", " + o + ")");
    }
    resetInnerSVG() {
      this.diagramGroup !== null && (this.diagramGroup.innerHTML = "");
    }
    arc(t, i, e, s, n, o, r, l) {
      const h = 2 * Math.PI, f = 1e-6, a = h - f, c = e * Math.cos(s), u = e * Math.sin(s), d = t + c, m = i + u, g = o ? 0 : 1;
      let p = o ? s - n : n - s;
      (Math.abs(r - d) > f || Math.abs(l - m) > f) && this.Bi.push(["L", d, +m]), p < 0 && (p = p % h + h), p > a ? (this.Bi.push(["A", e, e, 0, 1, g, t - c, i - u]), this.Bi.push(["A", e, e, 0, 1, g, d, m])) : p > f && this.Bi.push(["A", e, e, 0, +(p >= Math.PI), g, t + e * Math.cos(n), i + e * Math.sin(n)]);
    }
    beginPath() {
      this.Bi = [], this.pathAttributes = { stroke: "none", fill: "none" };
    }
    endPath(t) {
      this.N3(this.Bi, this.is, t || 0);
    }
    bezierCurveTo(t, i, e, s, n, o) {
      this.Bi.push(["C", t, i, e, s, n, o]);
    }
    clearRect(t, i, e, s) {
    }
    clip() {
      this.pathAttributes.clipPath = true;
    }
    closePath() {
      this.Bi.push(["z"]);
    }
    createLinearGradient(t, i, e, s) {
      const n = new SGradient("linear");
      return n.x1 = t, n.y1 = i, n.x2 = e, n.y2 = s, n;
    }
    createPattern(t, i) {
      let e = "";
      t instanceof HTMLCanvasElement && (e = t.toDataURL()), t instanceof HTMLImageElement && (e = t.getAttribute("src"));
      const s = this.cD;
      if (s[e]) return "url(#" + s[e] + ")";
      const n = "PATTERN" + GSet2.Qw++, o = { width: t.width, height: t.height, id: n, patternUnits: "userSpaceOnUse" }, r = { x: 0, y: 0, width: t.width, height: t.height, href: e }, l = this.makeElement("pattern", o);
      return l.appendChild(this.makeElement(Diagram2.img, r)), this.svg.appendChild(l), s[e] = n, "url(#" + n + ")";
    }
    createRadialGradient(t, i, e, s, n, o) {
      const r = new SGradient("radial");
      return r.x1 = t, r.y1 = i, r.r1 = e, r.x2 = s, r.y2 = n, r.r2 = o, r;
    }
    amendImageTransform(t, i, e, s, n, o, r, l) {
      const h = r / e, f = l / s;
      (n !== 0 || o !== 0) && this.is.translate(n, o), (h !== 1 || f !== 1) && this.is.scale(h, f), (t !== 0 || i !== 0) && this.is.translate(-t, -i);
    }
    drawImage(t, i, e, s, n, o, r, l, h) {
      let f = "";
      t instanceof HTMLCanvasElement && (f = t.toDataURL()), t instanceof HTMLImageElement && (f = t.getAttribute("src"));
      const a = t instanceof HTMLImageElement ? t.naturalWidth : t.width, c = t instanceof HTMLImageElement ? t.naturalHeight : t.height;
      s === void 0 && (o = i, r = e, l = s = a, h = n = c), s = s || 0, n = n || 0, o = o || 0, r = r || 0, l = l || 0, h = h || 0, this.amendImageTransform(i, e, s, n, o, r, l, h);
      const u = { x: 0, y: 0, width: a || s, height: c || n, href: f };
      !G.q(s, l) || !G.q(n, h) ? u.preserveAspectRatio = "none" : f.toLowerCase().indexOf(".svg") === -1 && f.toLowerCase().indexOf("data:image/svg") === -1 && (u.preserveAspectRatio = "xMidYMid slice"), (i !== 0 || e !== 0 || s !== a || n !== c) && (s += i, n += e, u["clip-path"] = `path('M ${i},${e} L ${s} ${e} L ${s} ${n} L ${i} ${n} z')`), this.processCommon(Diagram2.img, u, this.is), this.Fd(Diagram2.img, u);
    }
    fill(t, i) {
      t && (this.pathAttributes["fill-rule"] = "evenodd"), this.setFill(this.pathAttributes);
    }
    fillContext(t, i, e) {
      this.clipInsteadOfFill ? this.clip() : this.fill(i, e);
    }
    createOrUpdateClipGroup(t, i) {
      const e = this.newGroup(1, 0, 0, 1, -i.x, -i.y);
      e.setAttributeNS(null, "class", "spotClip"), t.Nh = e;
    }
    fillRect(t, i, e, s) {
      this.addRect("fill", [t, i, e, s], this.is);
    }
    fillBackground(t, i, e, s) {
      const n = { x: t, y: i, width: e, height: s };
      this.processCommon("fill", n, this.is), this.setFill(n), this.svg.prepend(this.makeElement("rect", n));
    }
    fillText(t, i, e) {
      this.addText("fill", [t, i, e], this.is);
    }
    lineTo(t, i) {
      this.Bi.push(["L", t, i]);
    }
    moveTo(t, i) {
      this.Bi.push(["M", t, i]);
    }
    quadraticCurveTo(t, i, e, s) {
      this.Bi.push(["Q", t, i, e, s]);
    }
    rect(t, i, e, s) {
      this.Bi.push(["M", t, i], ["L", t + e, i], ["L", t + e, i + s], ["L", t, i + s], ["z"]);
    }
    restore() {
      this.is = this.Dc.pop(), this.Bi = this.Dc.pop();
      const t = this.Dc.pop();
      this.fillStyle = t.fillStyle, this.font = t.font, this.globalAlpha = t.globalAlpha, this.lineCap = t.lineCap, this.lineDashOffset = t.lineDashOffset, this.lineJoin = t.lineJoin, this.lineWidth = t.lineWidth, this.miterLimit = t.miterLimit, this.shadowBlur = t.shadowBlur, this.shadowColor = t.shadowColor, this.shadowOffsetX = t.shadowOffsetX, this.shadowOffsetY = t.shadowOffsetY, this.strokeStyle = t.strokeStyle, this.textAlign = t.textAlign, this.partClipRect = t.partClipRect, this.letterSpacing = t.letterSpacing, this.wordSpacing = t.wordSpacing;
    }
    save() {
      const t = { fillStyle: this.fillStyle, font: this.font, globalAlpha: this.globalAlpha, lineCap: this.lineCap, lineDashOffset: this.lineDashOffset, lineJoin: this.lineJoin, lineWidth: this.lineWidth, miterLimit: this.miterLimit, shadowBlur: this.shadowBlur, shadowColor: this.shadowColor, shadowOffsetX: this.shadowOffsetX, shadowOffsetY: this.shadowOffsetY, strokeStyle: this.strokeStyle, textAlign: this.textAlign, partClipRect: this.partClipRect };
      this.Dc.push(t);
      const i = [];
      for (let e = 0; e < this.Bi.length; e++) i.push(this.Bi[e]);
      this.Dc.push(i), this.Dc.push(this.is.copy());
    }
    setTransform(t, i, e, s, n, o) {
      t === 1 && i === 0 && e === 0 && s === 1 && n === 0 && o === 0 || this.newGroup(t, i, e, s, n, o);
    }
    setCurrentTransform(t, i, e, s, n, o) {
      this.is.m = [t, i, e, s, n, o];
    }
    getCurrentTransform() {
      const t = this.is.m;
      return "matrix(" + t[0] + ", " + t[1] + ", " + t[2] + ", " + t[3] + ", " + t[4] + ", " + t[5] + ")";
    }
    scale(t, i) {
      this.is.scale(t, i);
    }
    translate(t, i) {
      this.is.translate(t, i);
    }
    transform(t, i, e, s, n, o) {
    }
    commitTransform() {
    }
    stroke() {
      this.setStroke(this.pathAttributes);
    }
    strokeContext() {
      this.clipInsteadOfFill || this.stroke();
    }
    strokeRect(t, i, e, s) {
      this.addRect("stroke", [t, i, e, s], this.is);
    }
    makeElement(t, i, e) {
      return this.surface.makeElement(t, i, e);
    }
    Fd(t, i, e) {
      const s = this.makeElement(t, i, e);
      return this.currentElement !== null ? this.currentElement.appendChild(s) : this.currentElement = s, this.lastCreatedElement = s, s;
    }
    processCommon(t, i, e) {
      if (t === "fill" ? this.setFill(i) : t === "stroke" && this.setStroke(i), e !== null) {
        const s = e.m;
        i.transform = "matrix(" + s[0] + ", " + s[1] + ", " + s[2] + ", " + s[3] + ", " + s[4] + ", " + s[5] + ")";
      }
    }
    setFill(t) {
      if (this.fillStyle instanceof SGradient) {
        t.fill = this.addGradient(this.fillStyle, "fill");
        return;
      }
      if (/^rgba\(/.test(this.fillStyle)) {
        const e = /^\s*rgba\s*\(([^,\s]+)\s*,\s*([^,\s]+)\s*,\s*([^,\s]+)\s*,\s*([^,\s]+)\)\s*$/i.exec(this.fillStyle);
        t.fill = "rgb(" + e[1] + "," + e[2] + "," + e[3] + ")", t["fill-opacity"] = e[4];
      } else t.fill = this.fillStyle;
    }
    setFillOrStrokeInPlace(t, i) {
      const e = i ? "fill" : "stroke";
      if (this.fillStyle instanceof SGradient) {
        t.setAttributeNS(null, "fill", this.addGradient(this.fillStyle, e));
        return;
      }
      if (/^rgba\(/.test(this.fillStyle)) {
        const n = /^\s*rgba\s*\(([^,\s]+)\s*,\s*([^,\s]+)\s*,\s*([^,\s]+)\s*,\s*([^,\s]+)\)\s*$/i.exec(this.fillStyle);
        t.setAttributeNS(null, e, "rgb(" + n[1] + "," + n[2] + "," + n[3] + ")"), t.setAttributeNS(null, e + "-opacity", n[4]);
      } else t.setAttributeNS(null, e, this.fillStyle);
    }
    setStroke(t) {
      if (this.strokeStyle instanceof SGradient) t.stroke = this.addGradient(this.strokeStyle, "stroke");
      else if (/^rgba\(/.test(this.strokeStyle)) {
        const e = /^\s*rgba\s*\(([^,\s]+)\s*,\s*([^,\s]+)\s*,\s*([^,\s]+)\s*,\s*([^,\s]+)\)\s*$/i.exec(this.strokeStyle);
        t.stroke = "rgb(" + e[1] + "," + e[2] + "," + e[3] + ")", t["stroke-opacity"] = e[4];
      } else t.stroke = this.strokeStyle;
      t["stroke-width"] = this.lineWidth, t["stroke-linecap"] = this.lineCap, t["stroke-linejoin"] = this.lineJoin, t["stroke-miterlimit"] = this.miterLimit, this.Jb && (t["stroke-dasharray"] = this._o.toString(), t["stroke-dashoffset"] = this.Ih);
    }
    addGradient(t, i) {
      let e = "";
      const s = this.currentPath !== null ? this.currentPath.getAttribute(i) : null;
      if (s !== null && s.indexOf("GRAD") !== -1) {
        e = s.split("#")[1].slice(0, -1);
        const l = this.svg.getElementById(e);
        l !== null && l.remove();
      } else e = "GRAD" + GSet2.Qw++;
      let n;
      if (t.type === "linear") {
        const l = { x1: t.x1, x2: t.x2, y1: t.y1, y2: t.y2, id: e, gradientUnits: "userSpaceOnUse" };
        n = this.makeElement("linearGradient", l);
      } else if (t.type === "radial") {
        const l = { x1: t.x1, x2: t.x2, y1: t.y1, y2: t.y2, r1: t.r1, r2: t.r2, id: e };
        n = this.makeElement("radialGradient", l);
      } else U.n("invalid gradient");
      const o = t.colors.sort((l, h) => l.offset > h.offset ? 1 : -1), r = o.length;
      for (let l = 0; l < r; l++) {
        const h = o[l], f = h.color;
        n.appendChild(this.makeElement("stop", { offset: h.offset, "stop-color": f }));
      }
      return this.svg.appendChild(n), "url(#" + e + ")";
    }
    addRect(t, i, e) {
      const s = { x: i[0], y: i[1], width: i[2], height: i[3] };
      this.processCommon(t, s, e), this.Fd("rect", s);
    }
    addText(t, i, e) {
      let s = this.textAlign;
      s === "left" ? s = "start" : s === "right" ? s = "end" : s === "center" && (s = "middle");
      const n = { x: i[1], y: i[2], style: "font: " + this.font, "text-anchor": s };
      n["letter-spacing"] = this.letterSpacing, n["word-spacing"] = this.wordSpacing, this.processCommon(t, n, e), this.Fd("text", n, i[0]);
    }
    N3(t, i, e) {
      const s = this.C3(t), n = this.pathAttributes;
      if (n.clipPath) {
        this.Fc.length > 1 && this.Fc[this.Fc.length - 2].setAttributeNS(null, "clip-path", 'path("' + s + '") view-box');
        return;
      }
      if (n.d = s, this.processCommon("", n, i), this.currentPath !== null) {
        const r = this.currentPath;
        if (r.nodeName !== "g") for (const l in n) l !== "transform" && r.setAttributeNS(null, l, n[l]);
        else {
          const l = r.getElementsByTagName("path");
          for (const h in n) h !== "transform" && l[e].setAttributeNS(null, h, n[h]);
        }
      } else this.Fd("path", n);
    }
    C3(t) {
      const i = [];
      for (let e = 0; e < t.length; e++) {
        const s = t[e].slice(), n = [s.shift()];
        if (n[0] === "A") n.push(s.shift() + "," + s.shift(), s.shift(), s.shift() + "," + s.shift(), s.shift() + "," + s.shift());
        else for (; s.length; ) n.push(s.shift() + "," + s.shift());
        i.push(n.join(" "));
      }
      return i.join(" ");
    }
    newGroup(t, i, e, s, n, o) {
      const r = new STransform();
      r.m = [t, i, e, s, n, o];
      const l = {};
      this.processCommon("g", l, r);
      const h = this.Fd("g", l);
      return this.Fc.push(h), h;
    }
    newGroup2(t) {
      const i = {};
      t && (i.class = t);
      const e = this.Fd("g", i);
      return this.Fc.push(e), e;
    }
    endGroup() {
      return this.Fc.pop();
    }
    dummyGroup() {
      return this.newGroup2(), this.endGroup();
    }
    shadowsSet(t, i, e) {
      this.Tc = t, this.Lc = i, this.Rn = e;
    }
    shadowsOff() {
      this.cl = false, this.shadowOffsetX = 0, this.shadowOffsetY = 0, this.shadowBlur = 0;
    }
    shadowsOn() {
      this.cl = true, this.shadowOffsetX = this.Tc, this.shadowOffsetY = this.Lc, this.shadowBlur = this.Rn;
    }
    enableDash(t, i) {
      this.Jb = true, this._o = t, this.Ih = i;
    }
    disableDash() {
      this.Jb = false;
    }
    clearContextCache(t) {
    }
    setImageSmoothingEnabled(t) {
    }
    rotate(t) {
      this.is.rotate(t * 57.2958, 0, 0);
    }
    getImageData(t, i, e, s) {
      return null;
    }
    measureText(t) {
      return null;
    }
    removeOldGradient(t, i, e) {
      const s = i.getAttribute(e);
      if (s === null) return;
      const n = s.split("#");
      if (n.length === 1) return;
      const o = this.svg.getElementById(n[1].slice(0, -1));
      if (o !== null) {
        const r = new RegExp(o.id, "g");
        this.svg.innerHTML.match(r).length === 1 && o.remove();
      }
    }
    removePartFromView(t) {
      t.svg !== null && t.svg.parentNode === this.diagramGroup && t.svg.remove();
    }
  }
  class CanvasSurface {
    Nt;
    ni;
    rl;
    yd;
    constructor(t, i, e, s) {
      const n = i === void 0 ? root.document : i;
      this.rl = n, this.yd = null;
      const o = n.createElement("canvas");
      o.tabIndex = 0, this.Nt = o, this.ni = new CanvasSurfaceContext(o, e, s), t && Diagram2.Qe.set(o, t);
    }
    resize(t, i, e, s) {
      return this.width !== t || this.height !== i ? (this.width = t, this.height = i, this.style.width = e + "px", this.style.height = s + "px", true) : false;
    }
    toDataURL(t, i) {
      return this.Nt.toDataURL(t, i);
    }
    getBoundingClientRect() {
      return this.Nt.getBoundingClientRect();
    }
    focus() {
      this.Nt.focus();
    }
    get width() {
      return this.Nt.width;
    }
    set width(t) {
      this.Nt.width = t;
    }
    get height() {
      return this.Nt.height;
    }
    set height(t) {
      this.Nt.height = t;
    }
    dispose() {
      Diagram2.Qe.delete(this.Nt), this.rl = null;
    }
    get style() {
      return this.Nt.style;
    }
  }
  class CanvasSurfaceContext {
    B;
    $b;
    Zb;
    Qb;
    clipInsteadOfFill;
    Tc;
    Lc;
    Rn;
    qa;
    cl;
    Vr;
    constructor(t, i, e) {
      t.getContext || U.n("Browser does not support HTML Canvas Element"), this.B = t.getContext("2d", i), this.$b = "", this.Zb = "", this.Qb = "", this.clipInsteadOfFill = false, this.Tc = 0, this.Lc = 0, this.Rn = 0, this.cl = false, this.qa = new Transform(), this.Vr = !!e;
    }
    createOrUpdateClipGroup(t, i) {
    }
    setImageSmoothingEnabled(t) {
      this.B.imageSmoothingEnabled = t;
    }
    get fillStyle() {
      return this.B.fillStyle;
    }
    set fillStyle(t) {
      this.Qb !== t && (this.B.fillStyle = t, this.Qb = t);
    }
    get font() {
      return this.B.font;
    }
    set font(t) {
      this.$b !== t && (this.B.font = t, this.$b = t);
    }
    get globalAlpha() {
      return this.B.globalAlpha;
    }
    set globalAlpha(t) {
      this.B.globalAlpha = t;
    }
    get lineCap() {
      return this.B.lineCap;
    }
    set lineCap(t) {
      this.B.lineCap = t;
    }
    get lineDashOffset() {
      return this.B.lineDashOffset;
    }
    set lineDashOffset(t) {
      this.B.lineDashOffset = t;
    }
    get lineJoin() {
      return this.B.lineJoin;
    }
    set lineJoin(t) {
      this.B.lineJoin = t;
    }
    get lineWidth() {
      return this.B.lineWidth;
    }
    set lineWidth(t) {
      this.B.lineWidth = t;
    }
    get miterLimit() {
      return this.B.miterLimit;
    }
    set miterLimit(t) {
      this.B.miterLimit = t;
    }
    get shadowBlur() {
      return this.B.shadowBlur;
    }
    set shadowBlur(t) {
      this.B.shadowBlur = t;
    }
    get shadowColor() {
      return this.B.shadowColor;
    }
    set shadowColor(t) {
      this.B.shadowColor = t;
    }
    get shadowOffsetX() {
      return this.B.shadowOffsetX;
    }
    set shadowOffsetX(t) {
      this.B.shadowOffsetX = t;
    }
    get shadowOffsetY() {
      return this.B.shadowOffsetY;
    }
    set shadowOffsetY(t) {
      this.B.shadowOffsetY = t;
    }
    get strokeStyle() {
      return this.B.strokeStyle;
    }
    set strokeStyle(t) {
      this.Zb !== t && (this.B.strokeStyle = t, this.Zb = t);
    }
    get textAlign() {
      return this.B.textAlign;
    }
    set textAlign(t) {
      this.B.textAlign = t;
    }
    get imageSmoothingEnabled() {
      return this.B.imageSmoothingEnabled;
    }
    set imageSmoothingEnabled(t) {
      this.B.imageSmoothingEnabled = t;
    }
    get filter() {
      return this.B.filter;
    }
    set filter(t) {
      t === "" ? this.B.filter = "none" : this.B.filter = t;
    }
    get letterSpacing() {
      return this.B.letterSpacing;
    }
    set letterSpacing(t) {
      this.B.letterSpacing = t;
    }
    get wordSpacing() {
      return this.B.wordSpacing;
    }
    set wordSpacing(t) {
      this.B.wordSpacing = t;
    }
    arc(t, i, e, s, n, o, r, l) {
      this.B.arc(t, i, e, s, n, o);
    }
    beginPath() {
      this.B.beginPath();
    }
    endPath() {
    }
    bezierCurveTo(t, i, e, s, n, o) {
      this.B.bezierCurveTo(t, i, e, s, n, o);
    }
    clearRect(t, i, e, s) {
      this.commitTransform(), this.B.clearRect(t, i, e, s);
    }
    clip(t) {
      t ? this.B.clip(t) : this.B.clip();
    }
    closePath() {
      this.B.closePath();
    }
    createLinearGradient(t, i, e, s) {
      return this.B.createLinearGradient(t, i, e, s);
    }
    createPattern(t, i) {
      return this.B.createPattern(t, i);
    }
    createRadialGradient(t, i, e, s, n, o) {
      return this.B.createRadialGradient(t, i, e, s, n, o);
    }
    drawImage(t, i, e, s, n, o, r, l, h) {
      s === void 0 ? this.B.drawImage(t, i, e) : this.B.drawImage(t, i, e, s, n, o, r, l, h);
    }
    fill(t, i) {
      i ? this.B.fill(i, t ? "evenodd" : "nonzero") : this.B.fill(t ? "evenodd" : "nonzero");
    }
    fillRect(t, i, e, s) {
      this.B.fillRect(t, i, e, s);
    }
    fillBackground(t, i, e, s) {
      this.B.fillRect(t, i, e, s);
    }
    fillText(t, i, e) {
      this.B.fillText(t, i, e);
    }
    getImageData(t, i, e, s) {
      return this.B.getImageData(t, i, e, s);
    }
    lineTo(t, i) {
      this.B.lineTo(t, i);
    }
    measureText(t) {
      return this.B.measureText(t);
    }
    moveTo(t, i) {
      this.B.moveTo(t, i);
    }
    quadraticCurveTo(t, i, e, s) {
      this.B.quadraticCurveTo(t, i, e, s);
    }
    rect(t, i, e, s) {
      this.B.rect(t, i, e, s);
    }
    restore() {
      this.B.restore();
    }
    save() {
      this.commitTransform(), this.B.save();
    }
    rotate(t) {
      this.qa.Ns(t * 57.2958, 0, 0);
    }
    setTransform(t, i, e, s, n, o) {
      this.qa.setTo(t, i, e, s, n, o);
    }
    scale(t, i) {
      this.qa.lt(t, i);
    }
    translate(t, i) {
      this.qa.vs(t, i);
    }
    stroke(t) {
      t ? this.B.stroke(t) : this.B.stroke();
    }
    transform(t, i, e, s, n, o) {
      if (t === 1 && i === 0 && e === 0 && s === 1 && n === 0 && o === 0) return;
      const r = this.qa, l = r.m11 * t + r.m21 * i, h = r.m12 * t + r.m22 * i, f = r.m11 * e + r.m21 * s, a = r.m12 * e + r.m22 * s;
      r.dx = r.m11 * n + r.m21 * o + r.dx, r.dy = r.m12 * n + r.m22 * o + r.dy, r.m11 = l, r.m12 = h, r.m21 = f, r.m22 = a;
    }
    commitTransform() {
      const t = this.qa;
      this.B.setTransform(t.m11, t.m12, t.m21, t.m22, t.dx, t.dy);
    }
    fillContext(t, i, e) {
      this.radialFill(t, i, e) || this.fillOrClip(i, e);
    }
    radialFill(t, i, e) {
      if (!(t instanceof Brush2) || t.type !== 3) return false;
      const s = t.Mc, n = t.Hb;
      return n > s ? (this.scale(s / n, 1), this.translate((n - s) / 2, 0)) : s > n && (this.scale(1, n / s), this.translate(0, (s - n) / 2)), this.fillOrClip(i, e), n > s ? (this.translate(-(n - s) / 2, 0), this.scale(1 / (s / n), 1)) : s > n && (this.translate(0, -(s - n) / 2), this.scale(1, 1 / (n / s))), true;
    }
    strokeContext() {
      this.clipInsteadOfFill || this.stroke();
    }
    fillOrClip(t, i) {
      this.clipInsteadOfFill ? this.clip(i) : this.fill(t, i);
    }
    shadowsSet(t, i, e) {
      this.Tc = t, this.Lc = i, this.Rn = e;
    }
    shadowsOff() {
      this.cl = false, this.shadowOffsetX = 0, this.shadowOffsetY = 0, this.shadowBlur = 0;
    }
    shadowsOn() {
      this.cl = true, this.shadowOffsetX = this.Tc, this.shadowOffsetY = this.Lc, this.shadowBlur = this.Rn;
    }
    enableDash(t, i) {
      const e = this.B;
      e.setLineDash !== void 0 && (e.setLineDash(t), e.lineDashOffset = i);
    }
    disableDash() {
      const t = this.B;
      t.setLineDash !== void 0 && (t.setLineDash(CanvasSurfaceContext.EmptyArray), t.lineDashOffset = 0);
    }
    clearContextCache(t) {
      t && (this.$b = ""), this.Zb = "", this.Qb = "";
    }
    removePartFromView(t) {
    }
    static EmptyArray = Object.freeze([]);
  }
  var BrushType2 = ((w) => (w[w.Solid = 1] = "Solid", w[w.Linear = 2] = "Linear", w[w.Radial = 3] = "Radial", w[w.Pattern = 4] = "Pattern", w))(BrushType2 || {}), ColorSpace2 = ((w) => (w[w.Lab = 1] = "Lab", w[w.HSL = 2] = "HSL", w[w.Oklch = 3] = "Oklch", w))(ColorSpace2 || {});
  class ColorNumbers {
    n0;
    n1;
    n2;
    n3;
    constructor() {
      this.n0 = 0, this.n1 = 0, this.n2 = 0, this.n3 = 0;
    }
  }
  class Brush2 {
    u;
    tt;
    Ha;
    ci;
    Ds;
    Np;
    Cp;
    tr;
    Ap;
    Fn;
    Mc;
    Hb;
    constructor(t, i) {
      if (GSet2._i(this), this.u = false, t === void 0) this.tt = 1, this.Ha = "black";
      else if (typeof t == "string") {
        const s = U.ta(BrushType2, t);
        s !== null ? (this.tt = s, this.Ha = "black") : (this.tt = 1, Debug && !Brush2.isValidColor(t) && U.n('Color "' + t + '" is not a valid color string for Brush constructor'), this.Ha = t);
      } else Object.keys(BrushType2).hasOwnProperty(t) ? (Debug && U.W(t, BrushType2, "BrushType"), this.tt = t, this.Ha = "black") : typeof t == "object" && (this.tt = 1, i = t);
      const e = this.tt;
      if (e === 2 ? (this.ci = Spot2.TopCenter, this.Ds = Spot2.BottomCenter) : e === 3 ? (this.ci = Spot2.Center, this.Ds = Spot2.Center) : (this.ci = Spot2.None, this.Ds = Spot2.None), this.Np = 0, this.Cp = NaN, this.tr = null, this.Ap = null, this.Fn = null, this.Mc = 0, this.Hb = 0, i) {
        const s = {};
        for (const n in i) isFinite(parseFloat(n)) ? this.addColorStop(parseFloat(n), i[n]) : s[n] = i[n];
        Object.assign(this, s);
      }
    }
    copy() {
      const t = new Brush2();
      return t.tt = this.tt, t.Ha = this.Ha, t.ci = this.ci.T(), t.Ds = this.Ds.T(), t.Np = this.Np, t.Cp = this.Cp, this.tr !== null && (t.tr = this.tr.copy()), t.Ap = this.Ap, t;
    }
    S() {
      return this.u = true, this.tr !== null && this.tr.S(), this;
    }
    gi(t) {
      t in BrushType2 ? this.type = t : U.xr(this, t);
    }
    toString() {
      let t = "Brush(";
      if (this.type === 1) t += this.color;
      else if (this.type === 2 ? t += "Linear " : this.type === 3 ? t += "Radial " : this.type === 4 ? t += "Pattern " : t += "(unknown) ", t += this.start + " " + this.end, this.colorStops !== null) {
        const i = this.colorStops.iterator;
        for (; i.next(); ) {
          const e = i.key, s = i.value;
          t += " " + e + ":" + s;
        }
      }
      return t += ")", t;
    }
    addColorStop(t, i) {
      return this.u && U.D(this), (typeof t != "number" || !isFinite(t) || t > 1 || t < 0) && U.G(t, "0 <= loc <= 1", Brush2, "addColorStop:loc"), U.i(i, "string", Brush2, "addColorStop:color"), Debug && !Brush2.isValidColor(i) && U.n('Color "' + i + '" is not a valid color string for Brush.addColorStop'), this.tr === null && (this.tr = new GMap2()), this.tr.set(t, i), this.tt === 1 && (this.type = 2), this.Fn = null, this;
    }
    get type() {
      return this.tt;
    }
    set type(t) {
      this.u && U.D(this, t), Debug && U.W(t, BrushType2, "BrushType"), this.tt = t, this.start.isNoSpot() && (t === 2 ? this.start = Spot2.TopCenter : t === 3 && (this.start = Spot2.Center)), this.end.isNoSpot() && (t === 2 ? this.end = Spot2.BottomCenter : t === 3 && (this.end = Spot2.Center)), this.Fn = null;
    }
    get color() {
      return this.Ha;
    }
    set color(t) {
      this.u && U.D(this, t), Debug && !Brush2.isValidColor(t) && U.n('Color "' + t + '" is not a valid color string for Brush.color'), this.Ha = t, this.Fn = null;
    }
    get start() {
      return this.ci;
    }
    set start(t) {
      this.u && U.D(this, t), Debug && U.s(t, Spot2, Brush2, "start"), this.ci = t.T(), this.Fn = null;
    }
    get end() {
      return this.Ds;
    }
    set end(t) {
      this.u && U.D(this, t), Debug && U.s(t, Spot2, Brush2, "end"), this.Ds = t.T(), this.Fn = null;
    }
    get startRadius() {
      return this.Np;
    }
    set startRadius(t) {
      this.u && U.D(this, t), Debug && U.r(t, Brush2, "startRadius"), t < 0 && U.G(t, ">= zero", Brush2, "startRadius"), this.Np = t, this.Fn = null;
    }
    get endRadius() {
      return this.Cp;
    }
    set endRadius(t) {
      this.u && U.D(this, t), Debug && U.r(t, Brush2, "endRadius"), t < 0 && U.G(t, ">= zero", Brush2, "endRadius"), this.Cp = t, this.Fn = null;
    }
    get colorStops() {
      return this.tr;
    }
    set colorStops(t) {
      this.u && U.D(this, t), Debug && U.s(t, GMap2, Brush2, "colorStops"), this.tr = t, this.Fn = null;
    }
    get pattern() {
      return this.Ap;
    }
    set pattern(t) {
      this.u && U.D(this, t), this.Ap = t, this.Fn = null;
    }
    static randomColor(t, i) {
      t === void 0 && (t = 128), Debug && (U.r(t, Brush2, "randomColor:min"), (t < 0 || t > 255) && U.G(t, "0 <= min <= 255", Brush2, "randomColor:min")), i === void 0 && (i = Math.max(t, 255)), Debug && (U.r(i, Brush2, "randomColor:max"), (i < t || i > 255) && U.G(i, "min <= max <= 255", Brush2, "randomColor:max"));
      const e = Math.abs(i - t);
      let s = Math.floor(t + Math.random() * e).toString(16), n = Math.floor(t + Math.random() * e).toString(16), o = Math.floor(t + Math.random() * e).toString(16);
      return s.length < 2 && (s = "0" + s), n.length < 2 && (n = "0" + n), o.length < 2 && (o = "0" + o), "#" + s + n + o;
    }
    static isValidColor(t) {
      return root.CSS ? root.CSS.supports("color", t) : true;
    }
    static lighten(t) {
      return Brush2.lightenBy(t);
    }
    lightenBy(t, i) {
      this.u && U.D(this);
      const e = t === void 0 || typeof t != "number" ? 0.2 : t, s = i === void 0 ? 3 : i;
      if (this.type === 1) Brush2.Uo(this.color), this.color = Brush2.Id(e, s);
      else if ((this.type === 2 || this.type === 3) && this.colorStops !== null) {
        const n = this.colorStops.iterator;
        for (; n.next(); ) Brush2.Uo(n.value), this.addColorStop(n.key, Brush2.Id(e, s));
      }
      return this;
    }
    static lightenBy(t, i, e) {
      const s = i === void 0 || typeof i != "number" ? 0.2 : i, n = e === void 0 ? 3 : e;
      return Brush2.Uo(t), Brush2.Id(s, n);
    }
    static darken(t) {
      return Brush2.darkenBy(t);
    }
    darkenBy(t, i) {
      this.u && U.D(this);
      const e = t === void 0 || typeof t != "number" ? 0.2 : t, s = i === void 0 ? 3 : i;
      if (this.type === 1) Brush2.Uo(this.color), this.color = Brush2.Id(-e, s);
      else if ((this.type === 2 || this.type === 3) && this.colorStops !== null) {
        const n = this.colorStops.iterator;
        for (; n.next(); ) Brush2.Uo(n.value), this.addColorStop(n.key, Brush2.Id(-e, s));
      }
      return this;
    }
    static darkenBy(t, i, e) {
      const s = i === void 0 || typeof i != "number" ? 0.2 : i, n = e === void 0 ? 3 : e;
      return Brush2.Uo(t), Brush2.Id(-s, n);
    }
    static mix(t, i, e) {
      Brush2.Uo(t);
      const s = Brush2.v.n0, n = Brush2.v.n1, o = Brush2.v.n2, r = Brush2.v.n3;
      Brush2.Uo(i), e === void 0 && (e = 0.5);
      const l = Math.round((Brush2.v.n0 - s) * e + s), h = Math.round((Brush2.v.n1 - n) * e + n), f = Math.round((Brush2.v.n2 - o) * e + o), a = Math.round((Brush2.v.n3 - r) * e + r);
      return `rgba(${l}, ${h}, ${f}, ${a})`;
    }
    isDark() {
      if (this.type === 1) return Brush2.isDark(this.color);
      if ((this.type === 2 || this.type === 3) && this.colorStops !== null) {
        const t = this.colorStops;
        if (this.type === 3) {
          const l = t.first();
          return l ? Brush2.isDark(l.value) : false;
        }
        if (t.get(0.5) !== null) return Brush2.isDark(t.get(0.5));
        if (t.count === 2) {
          const l = t.toArray();
          return Brush2.isDark(Brush2.mix(l[0].value, l[1].value));
        }
        const i = t.iterator;
        let e = -1, s = -1, n = 1, o = 1;
        for (; i.next(); ) {
          const l = i.key, h = Math.abs(0.5 - i.key);
          n > o && h < n ? (e = l, n = h) : o >= n && h < o && (s = l, o = h);
        }
        if (e > s) {
          let l = e;
          e = s, s = l, l = n, n = o, o = l;
        }
        const r = s - e;
        return Brush2.isDark(Brush2.mix(t.get(e), t.get(s), 1 - o / r));
      }
      return false;
    }
    static isDark(t) {
      return t ? t instanceof Brush2 ? t.isDark() : (Brush2.Uo(t), (299 * Brush2.v.n0 + 587 * Brush2.v.n1 + 114 * Brush2.v.n2) / 1e3 < 128) : false;
    }
    static Id(t, i) {
      switch (i) {
        case 1:
          return Brush2.A3(), Brush2.mo.n0 = Math.min(100, Math.max(0, Brush2.mo.n0 + 100 * t)), Brush2.T3(), "rgba(" + Brush2.v.n0 + ", " + Brush2.v.n1 + ", " + Brush2.v.n2 + ", " + Brush2.v.n3 + ")";
        case 2:
          return Brush2.XM(), Brush2.qi.n2 = Math.min(100, Math.max(0, Brush2.qi.n2 + 100 * t)), "hsla(" + Brush2.qi.n0 + ", " + Brush2.qi.n1 + "%, " + Brush2.qi.n2 + "%, " + Brush2.qi.n3 + ")";
        case 3:
          return Brush2.L3(), Brush2.po.n0 = Math.min(100, Math.max(0, Brush2.po.n0 + 100 * t)), Brush2.D3(), "rgba(" + Brush2.v.n0 + ", " + Brush2.v.n1 + ", " + Brush2.v.n2 + ", " + Brush2.v.n3 + ")";
        default:
          U.n("Unknown color space: " + i);
      }
    }
    static Uo(t) {
      Brush2.Tp === false && (Brush2.Tp = true, Brush2.ps = Diagram2.isUsingDOM() ? new CanvasSurface(null, void 0, { willReadFrequently: true }).ni : null);
      const i = Brush2.ps;
      if (i === null) return;
      i.clearRect(0, 0, 1, 1), i.fillStyle = "#000000";
      const e = i.fillStyle;
      if (i.fillStyle = t, i.fillStyle !== e) {
        i.fillRect(0, 0, 1, 1);
        const s = i.getImageData(0, 0, 1, 1).data;
        Brush2.v.n0 = s[0], Brush2.v.n1 = s[1], Brush2.v.n2 = s[2], Brush2.v.n3 = s[3] / 255;
      } else {
        i.fillStyle = "#FFFFFF";
        const s = i.fillStyle;
        i.fillStyle = t, i.fillStyle === s && Debug && U.n('Color "' + t + '" is not a valid color string for RGBA color conversion'), Brush2.v.n0 = 0, Brush2.v.n1 = 0, Brush2.v.n2 = 0, Brush2.v.n3 = 1;
      }
    }
    static XM() {
      const t = Brush2.v.n0 / 255, i = Brush2.v.n1 / 255, e = Brush2.v.n2 / 255, s = Math.max(t, i, e), n = Math.min(t, i, e), o = s - n;
      let r, l;
      const h = (s + n) / 2;
      if (o === 0) r = l = 0;
      else {
        switch (s) {
          case t:
            r = (i - e) / o % 6;
            break;
          case i:
            r = (e - t) / o + 2;
            break;
          case e:
            r = (t - i) / o + 4;
            break;
          default:
            r = 0;
            break;
        }
        r *= 60, r < 0 && (r += 360), l = o / (1 - Math.abs(2 * h - 1));
      }
      Brush2.qi.n0 = Math.round(r), Brush2.qi.n1 = Math.round(l * 100), Brush2.qi.n2 = Math.round(h * 100), Brush2.qi.n3 = Brush2.v.n3;
    }
    static XB() {
      const t = Brush2.qi.n0, i = Brush2.qi.n1 / 100, e = Brush2.qi.n2 / 100;
      let s, n, o;
      const r = (1 - Math.abs(2 * e - 1)) * i, l = t / 60, h = r * (1 - Math.abs(l % 2 - 1));
      l >= 0 && l < 1 ? (s = r, n = h, o = 0) : l >= 1 && l < 2 ? (s = h, n = r, o = 0) : l >= 2 && l < 3 ? (s = 0, n = r, o = h) : l >= 3 && l < 4 ? (s = 0, n = h, o = r) : l >= 4 && l < 5 ? (s = h, n = 0, o = r) : (s = r, n = 0, o = h);
      const f = e - 0.5 * r;
      s += f, n += f, o += f, Brush2.v.n0 = Math.round(s * 255), Brush2.v.n1 = Math.round(n * 255), Brush2.v.n2 = Math.round(o * 255), Brush2.v.n3 = Brush2.qi.n3;
    }
    static A3() {
      Brush2.uD(), Brush2.F3();
    }
    static T3() {
      Brush2.I3(), Brush2.dD();
    }
    static GN(t) {
      return t /= 255, t <= 0.04045 ? t / 12.92 : Math.pow((t + 0.055) / 1.055, 2.4);
    }
    static qN(t) {
      return t <= 31308e-7 ? t * 12.92 : 1.055 * Math.pow(t, 1 / 2.4) - 0.055;
    }
    static uD() {
      const t = Brush2.GN(Brush2.v.n0), i = Brush2.GN(Brush2.v.n1), e = Brush2.GN(Brush2.v.n2);
      Brush2.Ot.n0 = 0.4124564 * t + 0.3575761 * i + 0.1804375 * e, Brush2.Ot.n1 = 0.2126729 * t + 0.7151522 * i + 0.072175 * e, Brush2.Ot.n2 = 0.0193339 * t + 0.119192 * i + 0.9503041 * e, Brush2.Ot.n3 = Brush2.v.n3;
    }
    static dD() {
      const t = 3.2404542 * Brush2.Ot.n0 + -1.5371385 * Brush2.Ot.n1 + -0.4985314 * Brush2.Ot.n2, i = -0.969266 * Brush2.Ot.n0 + 1.8760108 * Brush2.Ot.n1 + 0.041556 * Brush2.Ot.n2, e = 0.0556434 * Brush2.Ot.n0 + -0.2040259 * Brush2.Ot.n1 + 1.0572252 * Brush2.Ot.n2;
      Brush2.v.n0 = Brush2.qN(t) * 255, Brush2.v.n1 = Brush2.qN(i) * 255, Brush2.v.n2 = Brush2.qN(e) * 255, Brush2.v.n3 = Brush2.Ot.n3, Brush2.v.n0 = Math.round(Brush2.v.n0), Brush2.v.n0 > 255 ? Brush2.v.n0 = 255 : Brush2.v.n0 < 0 && (Brush2.v.n0 = 0), Brush2.v.n1 = Math.round(Brush2.v.n1), Brush2.v.n1 > 255 ? Brush2.v.n1 = 255 : Brush2.v.n1 < 0 && (Brush2.v.n1 = 0), Brush2.v.n2 = Math.round(Brush2.v.n2), Brush2.v.n2 > 255 ? Brush2.v.n2 = 255 : Brush2.v.n2 < 0 && (Brush2.v.n2 = 0);
    }
    static HN = 216 / 24389;
    static _b = 24389 / 27;
    static Rd = [95.047, 100, 108.883];
    static vN(t) {
      return t > Brush2.HN ? Math.pow(t, 1 / 3) : (Brush2._b * t + 16) / 116;
    }
    static F3() {
      const t = Brush2.vN(Brush2.Ot.n0 * 100 / Brush2.Rd[0]), i = Brush2.vN(Brush2.Ot.n1 * 100 / Brush2.Rd[1]), e = Brush2.vN(Brush2.Ot.n2 * 100 / Brush2.Rd[2]);
      Brush2.mo.n0 = 116 * i - 16, Brush2.mo.n1 = 500 * (t - i), Brush2.mo.n2 = 200 * (i - e), Brush2.mo.n3 = Brush2.Ot.n3;
    }
    static gD(t) {
      const i = t * t * t;
      return i > Brush2.HN ? i : (116 * t - 16) / Brush2._b;
    }
    static I3() {
      const t = (Brush2.mo.n0 + 16) / 116, i = Brush2.mo.n1 / 500 + t, e = t - Brush2.mo.n2 / 200;
      Brush2.Ot.n0 = Brush2.Rd[0] / 100 * Brush2.gD(i), Brush2.Ot.n1 = Brush2.Rd[1] / 100 * (Brush2.mo.n0 > Brush2._b * Brush2.HN ? Math.pow(t, 3) : Brush2.mo.n0 / Brush2._b), Brush2.Ot.n2 = Brush2.Rd[2] / 100 * Brush2.gD(e), Brush2.Ot.n3 = Brush2.mo.n3;
    }
    static R3() {
      let t = 0.8190224 * Brush2.Ot.n0 + 0.3619062 * Brush2.Ot.n1 + -0.1288737 * Brush2.Ot.n2, i = 0.03298366 * Brush2.Ot.n0 + 0.9292868 * Brush2.Ot.n1 + 0.03614466 * Brush2.Ot.n2, e = 0.04817719 * Brush2.Ot.n0 + 0.2642395 * Brush2.Ot.n1 + 0.6335478 * Brush2.Ot.n2;
      t = Math.cbrt(t), i = Math.cbrt(i), e = Math.cbrt(e), Brush2.yi.n0 = 0.2104542 * t + 0.7936177 * i + -4072046e-9 * e, Brush2.yi.n1 = 1.977998 * t + -2.428592 * i + 0.4505937 * e, Brush2.yi.n2 = 0.02590403 * t + 0.7827717 * i + -0.8086757 * e, Brush2.yi.n3 = Brush2.Ot.n3, Brush2.yi.n0 *= 100;
    }
    static O3() {
      Brush2.yi.n0 /= 100;
      let t = 0.9999999 * Brush2.yi.n0 + 0.3963377 * Brush2.yi.n1 + 0.2158037 * Brush2.yi.n2, i = 1.000000009 * Brush2.yi.n0 + -0.1055613 * Brush2.yi.n1 + -0.06385417 * Brush2.yi.n2, e = 1.00000005 * Brush2.yi.n0 + -0.08948418 * Brush2.yi.n1 + -1.291485 * Brush2.yi.n2;
      t = t ** 3, i = i ** 3, e = e ** 3, Brush2.Ot.n0 = 1.2268798 * t + -0.5578149 * i + 0.281391 * e, Brush2.Ot.n1 = -0.04057576 * t + 1.112286 * i + -0.07171106 * e, Brush2.Ot.n2 = -0.07637294 * t + -0.4214933 * i + 1.586924 * e, Brush2.Ot.n3 = Brush2.yi.n3;
    }
    static E3() {
      const t = Math.atan2(Brush2.yi.n2, Brush2.yi.n1) * 180 / Math.PI;
      Brush2.po.n0 = Brush2.yi.n0, Brush2.po.n1 = Math.sqrt(Brush2.yi.n1 ** 2 + Brush2.yi.n2 ** 2), Brush2.po.n2 = t >= 0 ? t : t + 360, Brush2.po.n3 = Brush2.yi.n3;
    }
    static B3() {
      Brush2.yi.n0 = Brush2.po.n0, Brush2.yi.n1 = Brush2.po.n1 * Math.cos(Brush2.po.n2 * Math.PI / 180), Brush2.yi.n2 = Brush2.po.n1 * Math.sin(Brush2.po.n2 * Math.PI / 180), Brush2.yi.n3 = Brush2.po.n3;
    }
    static L3() {
      Brush2.uD(), Brush2.R3(), Brush2.E3();
    }
    static D3() {
      Brush2.B3(), Brush2.O3(), Brush2.dD();
    }
    static Ld(t, i) {
      typeof t == "string" ? Debug && !Brush2.isValidColor(t) && U.n('Color "' + t + '" is not a valid color string for ' + i) : t instanceof Brush2 || U.n("Value for " + i + " must be a color string or a Brush, not " + t);
    }
    static Solid = 1;
    static Linear = 2;
    static Radial = 3;
    static Pattern = 4;
    static Lab = 1;
    static HSL = 2;
    static ps = null;
    static Tp = false;
    static v = new ColorNumbers();
    static qi = new ColorNumbers();
    static Ot = new ColorNumbers();
    static mo = new ColorNumbers();
    static yi = new ColorNumbers();
    static po = new ColorNumbers();
  }
  class PanelLayout2 {
    At = "Base";
    static ms = new GMap2();
    static On(t, i) {
      i.name = t, PanelLayout2.ms.set(t, i);
    }
    get name() {
      return this.At;
    }
    set name(t) {
      this.At = t;
    }
    constructor() {
    }
    get classType() {
      return Panel2;
    }
    measure(t, i, e, s, n, o, r) {
    }
    measureElement(t, i, e, s, n) {
      t.gt(i, e, s, n);
    }
    arrange(t, i, e) {
    }
    arrangeElement(t, i, e, s, n, o) {
      t.Ut(i, e, s, n, o);
    }
    remeasureObject(t) {
      t.Nc();
    }
    vi(t, i, e) {
    }
  }
  class PanelLayoutPosition extends PanelLayout2 {
    constructor() {
      super();
    }
    measure(t, i, e, s, n, o, r) {
      const l = s.length, h = t.ir();
      for (let f = 0; f < l; f++) {
        const a = s[f];
        if (!a.visible && a !== h) continue;
        const c = a.margin, u = c.right + c.left, d = c.top + c.bottom;
        a.gt(i, e, o, r);
        const m = a.measuredBounds, g = Math.max(m.width + u, 0), p = Math.max(m.height + d, 0);
        let y = a.position.x, x = a.position.y;
        if (isFinite(y) || (y = 0), isFinite(x) || (x = 0), a instanceof Shape2 && a.isGeometryPositioned) {
          const S = a.strokeWidth / 2;
          y -= S, x -= S;
        }
        n.ai(y, x, g, p);
      }
    }
    arrange(t, i, e) {
      const s = i.length, n = t.padding, o = e.x - n.left, r = e.y - n.top;
      for (let l = 0; l < s; l++) {
        const h = i[l], f = h.measuredBounds, a = h.margin, c = h.position.x, u = h.position.y;
        let d = isNaN(c) ? -o : c - o, m = isNaN(u) ? -r : u - r;
        if (h instanceof Shape2 && h.isGeometryPositioned) {
          const g = h.strokeWidth / 2;
          d -= g, m -= g;
        }
        h.visible && h.Ut(d + a.left, m + a.top, f.width, f.height);
      }
    }
  }
  PanelLayout2.On("Position", new PanelLayoutPosition());
  class PanelLayoutHorizontal extends PanelLayout2 {
    constructor() {
      super();
    }
    measure(t, i, e, s, n, o, r) {
      const l = s.length, h = U.ft(), f = t.ir();
      for (let c = 0; c < l; c++) {
        const u = s[c];
        if (!u.visible && u !== f) continue;
        const d = u.sn(false);
        if (d !== 0 && d !== 5) {
          h.push(u);
          continue;
        }
        u.gt(1 / 0, e, 0, r);
        const m = u.margin, g = u.measuredBounds, p = Math.max(g.width + m.right + m.left, 0), y = Math.max(g.height + m.top + m.bottom, 0);
        n.Zn(n.width + p, Math.max(n.height, y));
      }
      const a = h.length;
      t.desiredSize.height ? e = Math.min(t.desiredSize.height, t.maxSize.height) : n.height !== 0 && (e = Math.min(n.height, t.maxSize.height));
      for (let c = 0; c < a; c++) {
        const u = h[c];
        if (!u.visible && u !== f) continue;
        const d = u.margin, m = d.right + d.left, g = d.top + d.bottom;
        u.gt(1 / 0, e, 0, r);
        const p = u.measuredBounds, y = Math.max(p.width + m, 0), x = Math.max(p.height + g, 0);
        n.width += y, n.height = Math.max(n.height, x);
      }
      U.et(h);
    }
    arrange(t, i, e) {
      const s = i.length, n = t.padding, o = n.top, r = t.isOpposite;
      let l = r ? e.width : n.left;
      for (let h = 0; h < s; h++) {
        const f = o, a = i[h];
        if (!a.visible) continue;
        const c = a.measuredBounds, u = a.margin, d = u.top + u.bottom, m = o + n.bottom;
        let g = c.height;
        const p = a.sn(false);
        (isNaN(a.desiredSize.height) && p === 2 || p === 4) && (g = Math.max(e.height - d - m, 0));
        const y = g + d + m;
        let x = a.alignment;
        x.isDefault() && (x = t.defaultAlignment), x.isSpot() || (x = Spot2.Center), r && (l -= c.width + u.left + u.right), a.Ut(l + x.offsetX + u.left, f + x.offsetY + u.top + (e.height * x.y - y * x.y), c.width, g), r || (l += c.width + u.left + u.right);
      }
    }
  }
  PanelLayout2.On("Horizontal", new PanelLayoutHorizontal());
  class PanelLayoutVertical extends PanelLayout2 {
    constructor() {
      super();
    }
    measure(t, i, e, s, n, o, r) {
      const l = s.length, h = U.ft(), f = t.ir();
      for (let c = 0; c < l; c++) {
        const u = s[c];
        if (!u.visible && u !== f) continue;
        const d = u.sn(false);
        if (d !== 0 && d !== 4) {
          h.push(u);
          continue;
        }
        u.gt(i, 1 / 0, o, 0);
        const m = u.margin, g = u.measuredBounds, p = Math.max(g.width + m.right + m.left, 0), y = Math.max(g.height + m.top + m.bottom, 0);
        n.Zn(Math.max(n.width, p), n.height + y);
      }
      const a = h.length;
      t.desiredSize.width ? i = Math.min(t.desiredSize.width, t.maxSize.width) : n.width !== 0 && (i = Math.min(n.width, t.maxSize.width));
      for (let c = 0; c < a; c++) {
        const u = h[c];
        if (!u.visible && u !== f) continue;
        const d = u.margin, m = d.right + d.left, g = d.top + d.bottom;
        u.gt(i, 1 / 0, o, 0);
        const p = u.measuredBounds, y = Math.max(p.width + m, 0), x = Math.max(p.height + g, 0);
        n.width = Math.max(n.width, y), n.height += x;
      }
      U.et(h);
    }
    arrange(t, i, e) {
      const s = i.length, n = t.padding, o = n.left, r = t.isOpposite;
      let l = r ? e.height : n.top;
      for (let h = 0; h < s; h++) {
        const f = o, a = i[h];
        if (!a.visible) continue;
        const c = a.measuredBounds, u = a.margin, d = u.left + u.right, m = o + n.right;
        let g = c.width;
        const p = a.sn(false);
        (isNaN(a.desiredSize.width) && p === 2 || p === 5) && (g = Math.max(e.width - d - m, 0));
        const y = g + d + m;
        let x = a.alignment;
        x.isDefault() && (x = t.defaultAlignment), x.isSpot() || (x = Spot2.Center), r && (l -= c.height + u.bottom + u.top), a.Ut(f + x.offsetX + u.left + (e.width * x.x - y * x.x), l + x.offsetY + u.top, g, c.height), r || (l += c.height + u.bottom + u.top);
      }
    }
  }
  PanelLayout2.On("Vertical", new PanelLayoutVertical());
  class PanelLayoutSpot extends PanelLayout2 {
    constructor() {
      super();
    }
    static mD = false;
    measure(t, i, e, s, n, o, r) {
      const l = s.length;
      if (l === 0) return;
      const h = t.findMainElement();
      let f = h.margin, a = 0, c = 0;
      const u = f.right + f.left, d = f.top + f.bottom;
      h.gt(i, e, o, r);
      let m = h.measuredBounds, g = m.width, p = m.height, y = Math.max(g + u, 0), x = Math.max(p + d, 0);
      const S = t.isClipping;
      S && h.$0() !== 0 && !PanelLayoutSpot.mD && (PanelLayoutSpot.mD = true, U.ot("Main Shape for Spot Panel with isClipping = true must have a zero strokeWidth: " + t.toString()));
      const b = Rect2.U(-f.left, -f.top, y, x);
      let k = Rect2.U(0, 0, g, p);
      this.WN(h, k, true), g = k.width, p = k.height;
      let P = true;
      const A = t.ir();
      let C;
      for (let M = 0; M < l; M++) {
        const N = s[M];
        let L = i, T = e;
        if (N === h || !N.visible && N !== A) continue;
        f = N.margin;
        let D = f.left, F = f.top;
        switch (a = f.right + f.left, c = f.top + f.bottom, C = N.sn(false), C) {
          case 2:
            L = g, T = p, a = 0, c = 0, D = 0, F = 0;
            break;
          case 5:
            L = g, a = 0, D = 0;
            break;
          case 4:
            T = p, c = 0, F = 0;
            break;
        }
        N.gt(L, T, 0, 0), m = N.measuredBounds, y = Math.max(m.width + a, 0), x = Math.max(m.height + c, 0);
        let R = N.alignment;
        R.isDefault() && (R = t.defaultAlignment), R.isSpot() || (R = Spot2.Center);
        let I = N.alignmentFocus;
        I.isDefault() && (I = Spot2.Center);
        let O = null;
        N instanceof Panel2 && N.yo !== "" && (O = N.findObject(N.yo), O === N && (O = null));
        let X = k.x - D, K = k.y - F;
        if (O !== null) {
          N.Ut(0, 0, m.width, m.height);
          const B = O.actualBounds, Y = Point2.U(B.x + (I.x * B.width - I.offsetX), B.y + (I.y * B.height - I.offsetY));
          for (O = O.panel; O !== null && O !== N; ) O.E.St(Y), O = O.panel;
          X += R.x * g + R.offsetX - Y.x, K += R.y * p + R.offsetY - Y.y, Point2.o(Y);
        } else X += R.x * g + R.offsetX - (I.x * m.width + I.offsetX), K += R.y * p + R.offsetY - (I.y * m.height + I.offsetY);
        P ? (P = false, n.e(X, K, y, x)) : n.ai(X, K, y, x);
      }
      switch (P ? n.c(b) : S ? n.intersect(k.x, k.y, k.width, k.height) : n.ai(b.x, b.y, b.width, b.height), Rect2.o(b), Rect2.o(k), C = h.stretch, C === 1 && (C = h.sn(false)), C) {
        case 0:
          return;
        case 2:
          if (!isFinite(i) && !isFinite(e)) return;
          break;
        case 5:
          if (!isFinite(i)) return;
          break;
        case 4:
          if (!isFinite(e)) return;
          break;
      }
      m = h.measuredBounds, g = m.width, p = m.height, y = Math.max(g + u, 0), x = Math.max(p + d, 0), f = h.margin, k = Rect2.U(-f.left, -f.top, y, x), this.WN(h, k, true), g = k.width, p = k.height;
      for (let M = 0; M < l; M++) {
        const N = s[M];
        if (N === h || !N.visible && N !== A) continue;
        f = N.margin, a = f.right + f.left, c = f.top + f.bottom, m = N.measuredBounds, y = Math.max(m.width + a, 0), x = Math.max(m.height + c, 0);
        let L = N.alignment;
        L.isDefault() && (L = t.defaultAlignment), L.isSpot() || (L = Spot2.Center);
        let T = N.alignmentFocus;
        T.isDefault() && (T = Spot2.Center), P ? (P = false, n.e(L.x * g + L.offsetX - (T.x * m.width + T.offsetX) - f.left, L.y * p + L.offsetY - (T.y * m.height + T.offsetY) - f.top, y, x)) : n.ai(L.x * g + L.offsetX - (T.x * m.width + T.offsetX) - f.left, L.y * p + L.offsetY - (T.y * m.height + T.offsetY) - f.top, y, x);
      }
      P ? n.c(b) : S ? n.intersect(k.x, k.y, k.width, k.height) : n.ai(b.x, b.y, b.width, b.height), Rect2.o(k);
    }
    arrange(t, i, e) {
      const s = i.length;
      if (s === 0) return;
      const n = t.findMainElement(), o = n.measuredBounds, r = o.width, l = o.height, h = t.padding, f = h.left, a = h.top;
      let c = f - e.x, u = a - e.y;
      n.Ut(c, u, r, l);
      const d = Rect2.U(0, 0, r, l);
      this.WN(n, d, false);
      for (let m = 0; m < s; m++) {
        const g = i[m];
        if (g === n) continue;
        const p = g.measuredBounds, y = p.width, x = p.height;
        let S = g.alignment;
        S.isDefault() && (S = t.defaultAlignment), S.isSpot() || (S = Spot2.Center);
        let b = g.alignmentFocus;
        b.isDefault() && (b = Spot2.Center);
        let k = null;
        if (g instanceof Panel2 && g.yo !== "" && (k = g.findObject(g.yo), k === g && (k = null)), k !== null) {
          const P = k.actualBounds, A = Point2.U(P.x + (b.x * P.width - b.offsetX), P.y + (b.y * P.height - b.offsetY));
          for (k = k.panel; k !== null && k !== g; ) k.E.St(A), k = k.panel;
          c = S.x * d.width + S.offsetX - A.x, u = S.y * d.height + S.offsetY - A.y, Point2.o(A);
        } else c = S.x * d.width + S.offsetX - (b.x * y + b.offsetX), u = S.y * d.height + S.offsetY - (b.y * x + b.offsetY);
        c += d.x - e.x, u += d.y - e.y, g.visible && g.Ut(f + c, a + u, y, x);
      }
      Rect2.o(d);
    }
    WN(t, i, e) {
      let s = null;
      if (t instanceof Panel2 && t.yo !== "" && (s = t.findObject(t.yo), s === t && (s = null)), s !== null) for (e && t.Ut(0, 0, i.width, i.height), i.c(s.actualBounds), s = s.panel; s !== null && s !== t; ) s.E.hm(i), s = s.panel;
    }
  }
  PanelLayout2.On("Spot", new PanelLayoutSpot());
  class PanelLayoutAuto extends PanelLayout2 {
    constructor() {
      super();
    }
    measure(t, i, e, s, n, o, r) {
      const l = s.length;
      if (l === 0) return;
      const h = t.findMainElement();
      let f = h.margin, a = i, c = e;
      const u = f.right + f.left, d = f.top + f.bottom;
      h.gt(i, e, o, r);
      let m = h.measuredBounds, g = 0, p = null;
      h instanceof Shape2 && (p = h, g = p.strokeWidth * p.scale);
      let y = Math.max(m.width + u, 0), x = Math.max(m.height + d, 0), S = t.jN(h);
      const b = S.x * y + S.offsetX, k = S.y * x + S.offsetY;
      let P = t.JN(h);
      const A = P.x * y + P.offsetX, C = P.y * x + P.offsetY;
      isFinite(i) && (a = Math.max(Math.abs(b - A) - g, 0)), isFinite(e) && (c = Math.max(Math.abs(k - C) - g, 0));
      let M = 0, N = 0;
      o > 0 && (M = Math.max(Math.abs(S.x * o + S.offsetX - (P.x * o + P.offsetX)) - g, 0)), r > 0 && (N = Math.max(Math.abs(S.y * r + S.offsetY - (P.y * r + P.offsetY)) - g, 0));
      const L = Size2.a();
      L.e(0, 0);
      const T = t.ir();
      for (let I = 0; I < l; I++) {
        const O = s[I];
        if (O === h || !O.visible && O !== T) continue;
        f = O.margin;
        const X = f.right + f.left, K = f.top + f.bottom;
        O.gt(a, c, M, N), m = O.measuredBounds, y = Math.max(m.width + X, 0), x = Math.max(m.height + K, 0), L.e(Math.max(y, L.width), Math.max(x, L.height));
      }
      if (l === 1) {
        m = h.measuredBounds, n.width = y, n.height = x, Size2.o(L);
        return;
      }
      S = t.jN(h), P = t.JN(h);
      let D = 0, F = 0;
      P.x !== S.x && P.y !== S.y && (D = L.width / Math.abs(P.x - S.x), F = L.height / Math.abs(P.y - S.y)), Size2.o(L), g = 0, p !== null && (g = p.strokeWidth * p.scale, p.nM() === 6 && (D = F = Math.max(D, F))), D += Math.abs(S.offsetX) + Math.abs(P.offsetX) + g, F += Math.abs(S.offsetY) + Math.abs(P.offsetY) + g;
      let R = h.stretch;
      switch (R === 1 && (R = h.sn(false)), R) {
        case 0:
          o = 0, r = 0;
          break;
        case 2:
          isFinite(i) && (D = i), isFinite(e) && (F = e);
          break;
        case 5:
          isFinite(i) && (D = i), r = 0;
          break;
        case 4:
          o = 0, isFinite(e) && (F = e);
          break;
      }
      h.Nc(), h.gt(D, F, o, r), n.width = h.measuredBounds.width + u, n.height = h.measuredBounds.height + d;
    }
    arrange(t, i, e) {
      const s = i.length;
      if (s === 0) return;
      const n = t.findMainElement(), o = n.measuredBounds, r = Rect2.a();
      r.e(0, 0, 1, 1);
      let l = n.margin;
      const h = l.left, f = l.top, a = t.padding, c = a.left, u = a.top;
      let d = h, m = f, g = o.width, p = o.height;
      n.Ut(c + d, u + m, g, p);
      const y = t.jN(n), x = t.JN(n), S = 0 + y.x * o.width + y.offsetX, b = 0 + y.y * o.height + y.offsetY, k = 0 + x.x * o.width + x.offsetX, P = 0 + x.y * o.height + x.offsetY;
      r.x = S, r.y = b, r.ai(k, P, 0, 0), r.x += h + c, r.y += f + u;
      for (let A = 0; A < s; A++) {
        const C = i[A];
        if (C === n) continue;
        const M = C.measuredBounds;
        l = C.margin;
        const N = Math.max(M.width + l.right + l.left, 0), L = Math.max(M.height + l.top + l.bottom, 0);
        let T = C.alignment;
        T.isDefault() && (T = t.defaultAlignment), T.isSpot() || (T = Spot2.Center), d = r.width * T.x + T.offsetX - N * T.x + l.left + r.x, m = r.height * T.y + T.offsetY - L * T.y + l.top + r.y, g = r.width, p = r.height, C.visible && (Rect2.contains(r.x, r.y, r.width, r.height, d, m, M.width, M.height) ? C.Ut(d, m, M.width, M.height) : C.Ut(d, m, M.width, M.height, new Rect2(r.x, r.y, r.width, r.height)));
      }
      Rect2.o(r);
    }
  }
  PanelLayout2.On("Auto", new PanelLayoutAuto());
  class PanelLayoutTable extends PanelLayout2 {
    constructor() {
      super(), this.name = "Table";
    }
    measure(t, i, e, s, n, o, r) {
      let l = s.length;
      const h = U.ft(), f = U.ft();
      for (let q = 0; q < l; q++) {
        const E = s[q], v = E instanceof Panel2 ? E : null;
        if (v !== null && v.fl() && E.visible) {
          Debug && (v.desiredSize.isReal() && U.n(v.toString() + " TableRow/TableColumn Panels cannot set a desiredSize: " + v.desiredSize.toString()), v.minSize.equals(Size2.ia) || U.n(v.toString() + " TableRow/TableColumn Panels cannot set a minSize: " + v.minSize.toString()), v.maxSize.equals(Size2.tx) || U.n(v.toString() + " TableRow/TableColumn Panels cannot set a maxSize: " + v.maxSize.toString())), f.push(v);
          const Q = v.O.h, nt = Q.length;
          for (let it = 0; it < nt; it++) {
            const et = Q[it];
            v.type === Panel2.TableRow ? et.row = E.row : v.type === Panel2.TableColumn && (et.column = E.column), h.push(et);
          }
        } else h.push(E);
      }
      l = h.length, l === 0 && (t.getRowDefinition(0), t.getColumnDefinition(0));
      const a = [];
      for (let q = 0; q < l; q++) {
        const E = h[q];
        E.visible && (E.Se(true), E.uo(true), a[E.row] || (a[E.row] = []), a[E.row][E.column] || (a[E.row][E.column] = []), a[E.row][E.column].push(E));
      }
      U.et(h);
      const c = U.ft(), u = U.ft(), d = U.ft(), m = { count: 0 }, g = { count: 0 };
      let p = i, y = e;
      const x = t.es, S = t.ss;
      let b;
      l = x.length;
      for (let q = 0; q < l; q++) b = x[q], b !== void 0 && (b.actual = 0, b.Vi = 0);
      l = S.length;
      for (let q = 0; q < l; q++) b = S[q], b !== void 0 && (b.actual = 0, b.Vi = 0);
      let k = a.length, P = 0;
      for (let q = 0; q < k; q++) a[q] && (P = Math.max(P, a[q].length));
      const A = Math.min(t.topIndex, k - 1), C = Math.min(t.leftIndex, P - 1);
      let M = 0, N;
      k = a.length;
      const L = t.ir();
      for (let q = 0; q < k; q++) {
        if (!a[q]) continue;
        P = a[q].length;
        const E = t.getRowDefinition(q);
        E.actual = 0, E.Vi = 0;
        for (let v = 0; v < P; v++) {
          if (!a[q][v]) continue;
          const Q = t.getColumnDefinition(v);
          c[v] === void 0 && (Q.actual = 0, Q.Vi = 0, c[v] = true);
          const nt = a[q][v], it = nt.length;
          for (let et = 0; et < it; et++) {
            const st = nt[et];
            if (!st.visible && st !== L) continue;
            const ut = st.rowSpan > 1, lt = st.columnSpan > 1;
            (ut || lt) && !(q < A) && !(v < C) && u.push(st);
            const at = st.margin, ot = at.right + at.left, rt = at.top + at.bottom;
            N = st.ep(E, Q, false);
            const ft = st.desiredSize, _ = !isNaN(ft.width), dt = !isNaN(ft.height);
            if (N !== 0 && !(_ && dt) && !(q < A) && !(v < C) && (!lt && m[v] === void 0 && (N === 2 || N === 5) && (m[v] = -1, m.count++), !ut && g[q] === void 0 && (N === 2 || N === 4) && (g[q] = -1, g.count++), !ut && !lt && d.push(st)), st.gt(1 / 0, 1 / 0, 0, 0), q < A || v < C) continue;
            const ct = st.measuredBounds, gt = Math.max(ct.width + ot, 0), mt = Math.max(ct.height + rt, 0);
            if (st.rowSpan === 1 && (N === 0 || N === 5)) {
              b = t.getRowDefinition(q);
              const pt = b.computeEffectiveSpacing(), yt = b.$ === 0;
              M = Math.max(mt - b.actual, 0), M + (yt ? pt : 0) > y && (M = Math.max(y - pt, 0)), b.Vi = b.Vi + M, b.actual = b.$ + M, y = Math.max(y - (M + (yt ? pt : 0)), 0);
            }
            if (st.columnSpan === 1 && (N === 0 || N === 4)) {
              b = t.getColumnDefinition(v);
              const pt = b.computeEffectiveSpacing(), yt = b.$ === 0;
              M = Math.max(gt - b.actual, 0), M + (yt ? pt : 0) > p && (M = Math.max(p - pt, 0)), b.Vi = b.Vi + M, b.actual = b.$ + M, p = Math.max(p - (M + (yt ? pt : 0)), 0);
            }
            (ut || lt) && st.Nc();
          }
        }
      }
      U.et(c);
      let T = 0, D = 0;
      l = t.columnCount;
      for (let q = 0; q < l; q++) {
        const E = S[q];
        E !== void 0 && (T += isNaN(E.Pe) ? E.Vi : E.Pe, E.Vi !== 0 && (T += E.computeEffectiveSpacing()));
      }
      l = t.rowCount;
      for (let q = 0; q < l; q++) {
        const E = x[q];
        E !== void 0 && (D += isNaN(E.Pe) ? E.Vi : E.Pe, E.Vi !== 0 && (D += E.computeEffectiveSpacing()));
      }
      p = Math.max(i - T, 0), y = Math.max(e - D, 0);
      let F = y, R = p;
      l = d.length;
      for (let q = 0; q < l; q++) {
        const E = d[q], v = t.getRowDefinition(E.row), Q = t.getColumnDefinition(E.column), nt = E.measuredBounds, it = E.margin, et = it.right + it.left, st = it.top + it.bottom;
        Q.Vi === 0 && m[E.column] !== void 0 ? m[E.column] = Math.max(nt.width + et, m[E.column]) : m[E.column] = null, v.Vi === 0 && g[E.row] !== void 0 ? g[E.row] = Math.max(nt.height + st, g[E.row]) : g[E.row] = null;
      }
      let I = 0, O = 0, X;
      for (X in g) X !== "count" && (I += g[X]);
      for (X in m) X !== "count" && (O += m[X]);
      const K = Size2.a();
      for (let q = 0; q < l; q++) {
        const E = d[q];
        if (!E.visible && E !== L) continue;
        const v = t.getRowDefinition(E.row), Q = t.getColumnDefinition(E.column);
        let nt = 0;
        isFinite(Q.width) ? nt = Q.width : (isFinite(p) && m[E.column] !== null ? O === 0 ? nt = Q.actual + p : nt = m[E.column] / O * R : m[E.column] !== null ? nt = p : nt = Q.actual || p, nt = Math.max(0, nt - Q.computeEffectiveSpacing()));
        let it = 0;
        switch (isFinite(v.height) ? it = v.height : (isFinite(y) && g[E.row] !== null ? I === 0 ? it = v.actual + y : it = g[E.row] / I * F : g[E.row] !== null ? it = y : it = v.actual || y, it = Math.max(0, it - v.computeEffectiveSpacing())), K.e(Math.max(Q.minimum, Math.min(nt, Q.maximum)), Math.max(v.minimum, Math.min(it, v.maximum))), N = E.ep(v, Q, false), N) {
          case 5:
            K.height = Math.max(K.height, v.actual + y);
            break;
          case 4:
            K.width = Math.max(K.width, Q.actual + p);
            break;
        }
        const et = E.margin, st = et.right + et.left, ut = et.top + et.bottom;
        E.Nc();
        let lt = Q.minimum, at = v.minimum;
        const ot = E.measuredBounds;
        ot.width === 0 && m[E.column] !== null && (lt = Math.max(lt, m[E.column])), ot.height === 0 && g[E.row] !== null && (at = Math.max(lt, g[E.row])), E.gt(K.width, K.height, lt, at);
        const rt = E.measuredBounds;
        let ft = Math.max(rt.width + st, 0), _ = Math.max(rt.height + ut, 0);
        isFinite(p) && (ft = Math.min(ft, K.width)), isFinite(y) && (_ = Math.min(_, K.height));
        let dt = 0;
        dt = v.actual, v.actual = Math.max(v.actual, _), v.Vi = Math.max(v.Vi, _), M = v.actual - dt, y = Math.max(y - M, 0), g[E.row] === null && (F = Math.max(F - M, 0)), dt = Q.actual, Q.actual = Math.max(Q.actual, ft), Q.Vi = Math.max(Q.Vi, ft), M = Q.actual - dt, p = Math.max(p - M, 0), m[E.column] === null && (R = Math.max(R - M, 0));
      }
      U.et(d);
      const B = Size2.a(), Y = U.ft(), z = U.ft();
      if (l = u.length, l !== 0) for (let q = 0; q < k; q++) {
        if (!a[q]) continue;
        P = a[q].length;
        const E = t.getRowDefinition(q);
        Y[q] = E.actual;
        for (let v = 0; v < P; v++) {
          if (!a[q][v]) continue;
          const Q = t.getColumnDefinition(v);
          z[v] = Q.actual;
        }
      }
      for (let q = 0; q < l; q++) {
        const E = u[q];
        if (!E.visible && E !== L) continue;
        const v = t.getRowDefinition(E.row), Q = t.getColumnDefinition(E.column);
        switch (K.e(Math.max(Q.minimum, Math.min(i, Q.maximum)), Math.max(v.minimum, Math.min(e, v.maximum))), N = E.ep(v, Q, false), N) {
          case 2:
            z[Q.index] !== 0 && (K.width = Math.min(K.width, z[Q.index])), Y[v.index] !== 0 && (K.height = Math.min(K.height, Y[v.index]));
            break;
          case 5:
            z[Q.index] !== 0 && (K.width = Math.min(K.width, z[Q.index]));
            break;
          case 4:
            Y[v.index] !== 0 && (K.height = Math.min(K.height, Y[v.index]));
            break;
        }
        isFinite(Q.width) && (K.width = Q.width), isFinite(v.height) && (K.height = v.height), B.e(0, 0);
        let nt = Q.minimum, it = v.minimum;
        for (let _ = 1; _ < E.rowSpan && !(E.row + _ >= t.rowCount); _++) {
          if (b = t.getRowDefinition(E.row + _), M = 0, N === 2 || N === 4) {
            if (b.$ === 0) continue;
            M = Math.max(b.minimum, b.$ === 0 ? b.maximum : Math.min(b.$, b.maximum));
          } else M = Math.max(b.minimum, isNaN(b.Pe) ? b.maximum : Math.min(b.Pe, b.maximum));
          B.height += M, it += b.minimum;
        }
        for (let _ = 1; _ < E.columnSpan && !(E.column + _ >= t.columnCount); _++) {
          if (b = t.getColumnDefinition(E.column + _), M = 0, N === 2 || N === 5) {
            if (b.$ === 0) continue;
            M = Math.max(b.minimum, b.$ === 0 ? b.maximum : Math.min(b.$, b.maximum));
          } else M = Math.max(b.minimum, isNaN(b.Pe) ? b.maximum : Math.min(b.Pe, b.maximum));
          B.width += M, nt += b.minimum;
        }
        K.width += B.width, K.height += B.height;
        const et = E.margin, st = et.right + et.left, ut = et.top + et.bottom;
        E.gt(K.width, K.height, nt, it);
        const lt = E.measuredBounds, at = Math.max(lt.width + st, 0), ot = Math.max(lt.height + ut, 0);
        let rt = 0;
        for (let _ = 0; _ < E.rowSpan && !(E.row + _ >= t.rowCount); _++) b = t.getRowDefinition(E.row + _), rt += b.total || 0;
        if (rt < ot) {
          let _ = ot - rt;
          const dt = ot - rt;
          if (E.spanAllocation !== null) {
            const ht = E.spanAllocation;
            for (let ct = 0; ct < E.rowSpan && !(_ <= 0 || E.row + ct >= t.rowCount); ct++) {
              b = t.getRowDefinition(E.row + ct);
              const gt = b.$ || 0, mt = ht(E, b, dt);
              Debug && typeof mt != "number" && U.n(E + " spanAllocation does not return a number: " + mt), b.actual = Math.min(b.maximum, gt + mt), b.$ !== gt && (_ -= b.$ - gt);
            }
          }
          for (; _ > 0 && b !== void 0; ) {
            const ht = b.$ || 0;
            if (isNaN(b.height) && b.maximum > ht && (b.actual = Math.min(b.maximum, ht + _), b.$ !== ht && (_ -= b.$ - ht)), b.index === 0) break;
            b = t.getRowDefinition(b.index - 1);
          }
        }
        let ft = 0;
        for (let _ = 0; _ < E.columnSpan && !(E.column + _ >= t.columnCount); _++) b = t.getColumnDefinition(E.column + _), ft += b.total || 0;
        if (ft < at) {
          let _ = at - ft;
          const dt = at - ft;
          if (E.spanAllocation !== null) {
            const ht = E.spanAllocation;
            for (let ct = 0; ct < E.columnSpan && !(_ <= 0 || E.column + ct >= t.columnCount); ct++) {
              b = t.getColumnDefinition(E.column + ct);
              const gt = b.$ || 0, mt = ht(E, b, dt);
              Debug && typeof mt != "number" && U.n(E + " spanAllocation does not return a number: " + mt), b.actual = Math.min(b.maximum, gt + mt), b.$ !== gt && (_ -= b.$ - gt);
            }
          }
          for (; _ > 0 && b !== void 0; ) {
            const ht = b.$ || 0;
            if (isNaN(b.width) && b.maximum > ht && (b.actual = Math.min(b.maximum, ht + _), b.$ !== ht && (_ -= b.$ - ht)), b.index === 0) break;
            b = t.getColumnDefinition(b.index - 1);
          }
        }
      }
      U.et(u), Size2.o(B), Size2.o(K), Y !== void 0 && U.et(Y), z !== void 0 && U.et(z);
      let H = 0, W = 0;
      const j = t.desiredSize, Z = t.maxSize;
      N = t.sn(true), T = 0, D = 0;
      let V = 0, $ = 0;
      l = t.columnCount;
      for (let q = 0; q < l; q++) if (S[q] !== void 0) {
        if (b = t.getColumnDefinition(q), isFinite(b.width)) {
          V += b.width, V += b.computeEffectiveSpacing();
          continue;
        } else if (b.tS() === 2) {
          V += b.$, V += b.computeEffectiveSpacing();
          continue;
        }
        b.$ !== 0 && (T += b.$, T += b.computeEffectiveSpacing());
      }
      isFinite(j.width) ? H = Math.min(j.width, Z.width) : N !== 0 && isFinite(i) ? H = i : H = T, H = Math.max(H, isFinite(i) ? Math.min(o, i) : o), H = Math.max(H - V, 0);
      const J = T === 0 ? 1 : Math.max(H / T, 1);
      for (let q = 0; q < l; q++) S[q] !== void 0 && (b = t.getColumnDefinition(q), !isFinite(b.width) && b.tS() !== 2 && (b.actual = b.$ * J), b.position = n.width, b.$ !== 0 && (n.width += b.$, n.width += b.computeEffectiveSpacing()));
      l = t.rowCount;
      for (let q = 0; q < l; q++) if (x[q] !== void 0) {
        if (b = t.getRowDefinition(q), isFinite(b.height)) {
          $ += b.height, $ += b.computeEffectiveSpacing();
          continue;
        } else if (b.tS() === 2) {
          $ += b.$, $ += b.computeEffectiveSpacing();
          continue;
        }
        b.$ !== 0 && (D += b.$, D += b.computeEffectiveSpacing());
      }
      isFinite(j.height) ? W = Math.min(j.height, Z.height) : N !== 0 && isFinite(e) ? W = e : W = D, W = Math.max(W, isFinite(e) ? Math.min(r, e) : r), W = Math.max(W - $, 0);
      const tt = D === 0 ? 1 : Math.max(W / D, 1);
      for (let q = 0; q < l; q++) x[q] !== void 0 && (b = t.getRowDefinition(q), !isFinite(b.height) && b.tS() !== 2 && (b.actual = b.$ * tt), b.position = n.height, b.$ !== 0 && (n.height += b.$, n.height += b.computeEffectiveSpacing()));
      l = f.length;
      for (let q = 0; q < l; q++) {
        const E = f[q];
        let v = 0, Q = 0;
        E.type === Panel2.TableRow ? (v = n.width, b = t.getRowDefinition(E.row), Q = b.actual) : (b = t.getColumnDefinition(E.column), v = b.actual, Q = n.height), E.measuredBounds.e(0, 0, v, Q), E.Se(false);
      }
      U.et(f), t.Rh = a;
    }
    arrange(t, i, e) {
      const s = i.length, n = t.padding, o = n.left, r = n.top, l = t.Rh;
      if (l === null) return;
      let h = 0, f = 0;
      const a = l.length;
      let c = 0;
      for (let C = 0; C < a; C++) l[C] && (c = Math.max(c, l[C].length));
      const u = t.es, d = t.ss;
      let m = 0, g = 0, p = Math.min(t.topIndex, a - 1);
      if (u.length > 0) {
        for (; p !== a && (u[p] === void 0 || u[p].$ === 0); ) p++;
        p = Math.max(Math.min(p, a - 1), 0), m = -u[p].position;
      }
      let y = Math.min(t.leftIndex, c - 1);
      if (d.length > 0) {
        for (; y !== c && (d[y] === void 0 || d[y].$ === 0); ) y++;
        y = Math.max(Math.min(y, c - 1), 0), g = -d[y].position;
      }
      let x = 0, S = 0;
      for (; x !== a && u[x] === void 0; ) x++;
      for (; S !== a && d[S] === void 0; ) S++;
      const b = t.part;
      let k = t.getRowDefinition(x), P = t.getColumnDefinition(S);
      for (let C = 0; C < i.length; C++) {
        const M = i[C];
        if (!(M instanceof Panel2 && M.visible && M.fl())) continue;
        M.type === Panel2.TableRow ? (k = t.getRowDefinition(M.row), P = t.getColumnDefinition(S)) : (k = t.getRowDefinition(x), P = t.getColumnDefinition(M.column)), f = k.position + m + r, k.$ !== 0 && (f += k.computeEffectiveSpacingTop(Math.max(x, p))), h = P.position + g + o, P.$ !== 0 && (h += P.computeEffectiveSpacingTop(Math.max(S, y)));
        const N = M.measuredBounds;
        M.Sc(), M.actualBounds.di();
        const L = M.actualBounds, T = Rect2.U(L.x, L.y, L.width, L.height);
        if (L.x = M.type === Panel2.TableRow ? o : h, L.y = M.type === Panel2.TableColumn ? r : f, L.width = N.width, L.height = N.height, M.actualBounds.S(), M.uo(false), T.equalsApproxClose(L)) {
          Rect2.o(T);
          continue;
        }
        b !== null && (b.Lh(), M.Q0(b)), Rect2.o(T);
      }
      const A = Size2.a();
      for (let C = 0; C < a; C++) {
        if (!l[C]) continue;
        c = l[C].length;
        const M = t.getRowDefinition(C);
        f = M.position + m + r, M.$ !== 0 && (f += M.computeEffectiveSpacingTop(Math.max(x, p)));
        for (let N = 0; N < c; N++) {
          if (!l[C][N]) continue;
          const L = t.getColumnDefinition(N);
          h = L.position + g + o, L.$ !== 0 && (h += L.computeEffectiveSpacingTop(Math.max(S, y)));
          const T = l[C][N], D = T.length;
          for (let F = 0; F < D; F++) {
            const R = T[F], I = R.measuredBounds;
            A.e(0, 0);
            for (let ot = 1; ot < R.rowSpan && !(C + ot >= t.rowCount); ot++) {
              const rt = t.getRowDefinition(C + ot);
              rt.$ !== 0 && (A.height += rt.total);
            }
            for (let ot = 1; ot < R.columnSpan && !(N + ot >= t.columnCount); ot++) {
              const rt = t.getColumnDefinition(N + ot);
              rt.$ !== 0 && (A.width += rt.total);
            }
            const O = L.$ + A.width, X = M.$ + A.height;
            let K = h, B = f;
            const Y = O, z = X, H = h, W = f;
            let j = O, Z = X;
            h + O > e.width && (j = Math.max(e.width - h, 0)), f + X > e.height && (Z = Math.max(e.height - f, 0));
            let V = R.alignment, $ = 0, J = 0, tt = 0, q = 0;
            if (V.isDefault()) {
              V = t.defaultAlignment, V.isSpot() || (V = Spot2.Center), $ = V.x, J = V.y, tt = V.offsetX, q = V.offsetY;
              const ot = L.alignment, rt = M.alignment;
              ot.isSpot() && ($ = ot.x, tt = ot.offsetX), rt.isSpot() && (J = rt.y, q = rt.offsetY);
            } else $ = V.x, J = V.y, tt = V.offsetX, q = V.offsetY;
            (isNaN($) || isNaN(J)) && ($ = 0.5, J = 0.5, tt = 0, q = 0);
            let E = I.width, v = I.height;
            const Q = R.margin, nt = Q.left + Q.right, it = Q.top + Q.bottom, et = R.ep(M, L, false);
            isNaN(R.desiredSize.width) && (et === 2 || et === 5) && (E = Math.max(O - nt, 0)), isNaN(R.desiredSize.height) && (et === 2 || et === 4) && (v = Math.max(X - it, 0));
            const st = R.maxSize, ut = R.minSize;
            E = Math.min(st.width, E), v = Math.min(st.height, v), E = Math.max(ut.width, E), v = Math.max(ut.height, v);
            const lt = E + nt, at = v + it;
            K += Y * $ - lt * $ + tt + Q.left, B += z * J - at * J + q + Q.top, R.visible && (Rect2.contains(H, W, j, Z, K, B, I.width, I.height) ? R.Ut(K, B, E, v) : R.Ut(K, B, E, v, new Rect2(H, W, j, Z)));
          }
        }
      }
      Size2.o(A);
      for (let C = 0; C < s; C++) {
        const M = i[C], N = M instanceof Panel2 ? M : null;
        if (N !== null && N.fl()) {
          const L = M.actualBounds;
          M.naturalBounds.di(), M.naturalBounds.e(0, 0, L.width, L.height), M.naturalBounds.S();
        }
      }
    }
  }
  PanelLayout2.On("Table", new PanelLayoutTable());
  class PanelLayoutTableRow extends PanelLayout2 {
    constructor() {
      super();
    }
    measure(t, i, e, s, n, o, r) {
    }
    arrange(t, i, e) {
    }
  }
  PanelLayout2.On("TableRow", new PanelLayoutTableRow());
  class PanelLayoutTableColumn extends PanelLayout2 {
    constructor() {
      super();
    }
    measure(t, i, e, s, n, o, r) {
    }
    arrange(t, i, e) {
    }
  }
  PanelLayout2.On("TableColumn", new PanelLayoutTableColumn());
  class PanelLayoutViewbox extends PanelLayout2 {
    constructor() {
      super();
    }
    measure(t, i, e, s, n, o, r) {
      s.length !== 1 && U.n("Viewbox Panel must contain exactly one GraphObject.");
      const h = s[0];
      h.lt = 1, h.Nc(), h.gt(1 / 0, 1 / 0, o, r);
      let f = h.measuredBounds;
      const a = h.margin, c = a.right + a.left, u = a.top + a.bottom;
      if (isFinite(i) || isFinite(e)) {
        const d = h.scale, m = f.width, g = f.height, p = Math.max(i - c, 0), y = Math.max(e - u, 0);
        let x = 1;
        t.viewboxStretch === 6 ? (m !== 0 && g !== 0 && (x = Math.min(p / m, y / g)), x === 0 && (x = 1e-4), h.lt *= x) : (m !== 0 && g !== 0 && (x = Math.max(p / m, y / g)), x === 0 && (x = 1e-4), h.lt *= x), d !== h.scale && (h.Se(true), h.gt(1 / 0, 1 / 0, o, r));
      }
      f = h.measuredBounds, n.width = isFinite(i) ? i : Math.max(f.width + c, 0), n.height = isFinite(e) ? e : Math.max(f.height + u, 0);
    }
    arrange(t, i, e) {
      const s = i[0], n = s.measuredBounds, o = s.margin, r = o.right + o.left, l = o.top + o.bottom, h = Math.max(n.width + r, 0), f = Math.max(n.height + l, 0);
      let a = s.alignment;
      a.isDefault() && (a = t.defaultAlignment), a.isSpot() || (a = Spot2.Center), s.Ut(e.width * a.x - h * a.x + a.offsetX, e.height * a.y - f * a.y + a.offsetY, n.width, n.height);
    }
  }
  PanelLayout2.On("Viewbox", new PanelLayoutViewbox());
  class PanelLayoutGrid extends PanelLayout2 {
    constructor() {
      super();
    }
    measure(t, i, e, s, n, o, r) {
      t.Ni === null && (t.Ni = new GridPanelSettings()), this.V3(t), this.z3(t);
    }
    arrange(t, i, e) {
    }
    vi(t, i, e) {
      const s = t.naturalBounds;
      i.save(), i.beginPath(), i.rect(0, 0, s.width, s.height), i.clip(), i.endPath(), this.X3(t, i, e), i.restore(), i.clearContextCache(false);
    }
    X3(t, i, e) {
      let s = t.getDocumentScale() * e.scale;
      s <= 0 && (s = 1);
      const n = t.gridCellSize, o = n.width, r = n.height, l = t.naturalBounds, h = t.actualBounds, f = l.width, a = l.height, c = Math.ceil(f / o), u = Math.ceil(a / r), d = t.gridOrigin, m = d.x, g = d.y, p = t.Ni.Lp, y = t.O.h, x = y.length;
      for (let S = 0; S < x; S++) {
        const b = y[S];
        if (!b.visible) continue;
        const k = b.interval || 1, P = Math.abs(k);
        if (o * P * s < 2) continue;
        let A = b.segmentIndex;
        (!isFinite(A) || isNaN(A)) && (A = 0), A < 0 && (A = P - Math.min(-A, P)), A = Math.round(A % P);
        const C = b.opacity;
        let M = 1;
        if (C !== 1) {
          if (C === 0) continue;
          M = i.globalAlpha, i.globalAlpha = M * C;
        }
        const N = p[S];
        let L = false;
        const T = b.strokeDashArray;
        if (T !== null && (L = true, i.enableDash(T, b.strokeDashOffset)), b.stroke !== null && b.strokeWidth > 0 && (b.figure === "LineV" || b.figure === "LineH")) {
          if (i.lineWidth = b.strokeWidth, t.Cn(i, b.stroke, false, false, l, h), i.beginPath(), b.figure === "LineV") {
            const D = Math.floor((m - o) / o);
            for (let F = D; F <= D + c; F++) {
              const R = F * o + m;
              0 <= R && R <= f && this.iS(F, k, A, N) && (i.moveTo(R, 0), i.lineTo(R, a));
            }
          } else if (b.figure === "LineH") {
            const D = Math.floor((g - r) / r);
            for (let F = D; F <= D + u; F++) {
              const R = F * r + g;
              0 <= R && R <= a && this.iS(F, k, A, N) && (i.moveTo(0, R), i.lineTo(f, R));
            }
          }
          i.stroke(), i.endPath();
        } else if (b.fill !== null) {
          if (t.Cn(i, b.fill, true, false, l, h), b.figure === "BarV") {
            let D = b.width;
            isNaN(D) && (D = o);
            const F = Math.floor((m - o) / o);
            for (let R = F; R <= F + c; R++) {
              const I = R * o + m;
              0 <= I + D && I <= f && this.iS(R, k, A, N) && i.fillRect(I, 0, D, a);
            }
          } else if (b.figure === "BarH") {
            let D = b.height;
            isNaN(D) && (D = r);
            const F = Math.floor((g - r) / r);
            for (let R = F; R <= F + u; R++) {
              const I = R * r + g;
              0 <= I + D && I <= a && this.iS(R, k, A, N) && i.fillRect(0, I, f, D);
            }
          }
        }
        L && i.disableDash(), C !== 1 && (i.globalAlpha = M);
      }
    }
    iS(t, i, e, s) {
      if (i < 0) return t % i === e;
      if (t % i !== e) return false;
      const n = s.length;
      for (let o = 0; o < n; o++) {
        const r = s[o];
        if (t % r === e) return false;
      }
      return true;
    }
    z3(t) {
      const i = [], e = t.O.h, s = e.length;
      for (let n = 0; n < s; n++) {
        const o = e[n], r = [];
        if (i.push(r), !o.visible) continue;
        const l = o.interval;
        if (l < 0) continue;
        const h = o.figure, f = this.$N(h);
        for (let a = 0; a < s; a++) {
          if (a === n) continue;
          const c = e[a];
          if (!c.visible) continue;
          const u = c.figure;
          if (this.$N(u) !== f) continue;
          const d = c.interval;
          d > l && r.push(d);
        }
      }
      t.Ni.Lp = i;
    }
    $N(t) {
      return t === "LineV" || t === "BarV";
    }
    V3(t) {
      let i = 1, e = 1;
      const s = t.O.h, n = s.length;
      for (let l = 0; l < n; l++) {
        const h = s[l], f = Math.abs(h.interval);
        f < 2 || (this.$N(h.figure) ? e = e * f / G.JA(e, f) : i = i * f / G.JA(i, f));
      }
      const o = t.gridCellSize, r = t.Ni;
      r.dc.isReal() ? r.dc.e(e * o.width, i * o.height) : r.dc = new Size2(e * o.width, i * o.height);
    }
  }
  PanelLayout2.On("Grid", new PanelLayoutGrid());
  class PanelLayoutLink extends PanelLayout2 {
    constructor() {
      super();
    }
    measure(t, i, e, s, n, o, r) {
      const l = s.length;
      if (!(t instanceof Adornment2 || t instanceof Link2)) return;
      let h = null, f = null;
      if (t instanceof Link2 && (h = t), t instanceof Adornment2 && (f = t, h = f.adornedPart, t.Ic === null && (t.Ic = [])), !(h instanceof Link2)) return;
      const a = h;
      if (l === 0) {
        t.naturalBounds.Zn(0, 0), t.measuredBounds.e(0, 0, 0, 0);
        return;
      }
      const c = t instanceof Adornment2 ? null : h.path, u = h.routeBounds, d = t.er;
      d.e(0, 0, u.width, u.height);
      const m = a.points, g = h.pointsCount;
      f !== null ? f.Od(false) : h !== null && h.Od(false);
      const p = u.width, y = u.height, x = t.Ic;
      if (x.length = 0, c !== null) {
        this.measureLinkPath(t, p, y, c);
        const P = c.measuredBounds;
        d.unionRect(P), x.push(P);
      }
      const S = Transform.a(), b = Point2.a(), k = Point2.a();
      for (let P = 0; P < l; P++) {
        const A = s[P];
        if (A === c) continue;
        let C = A.measuredBounds;
        if (A.isPanelMain && A instanceof Shape2) {
          this.measureLinkPath(t, p, y, A), C = A.measuredBounds, d.unionRect(C), x.push(C);
          continue;
        }
        if (g < 2) {
          A.gt(1 / 0, 1 / 0, 0, 0), C = A.measuredBounds, d.unionRect(C), x.push(C);
          continue;
        }
        const M = A.segmentIndex, N = A.segmentFraction;
        let L = A.alignmentFocus;
        L.isNoSpot() && (L = Spot2.Center);
        const T = A.segmentOrientation, D = A.segmentOffset;
        let F = 0, R = 0, I = 0, O = 0;
        if (isNaN(M)) {
          const V = a.xt, $ = U.ft();
          V.getPointAndAngleAlongPath(N, $);
          const J = Point2.U($[0], $[1]);
          O = $[2], T !== 0 && (I = a.computeAngle(A, T, O), A.vt = I, A.Se(true), A.uo(true)), F = J.x, R = J.y, Point2.o(J), U.et($);
        } else if (M < -g || M >= g) {
          const V = Point2.a();
          a.ZN(V), O = a.midAngle, T !== 0 && (I = a.computeAngle(A, T, O), A.vt = I, A.Se(true), A.uo(true)), F = V.x - u.x, R = V.y - u.y, Point2.o(V);
        } else {
          let V, $, J = 0;
          if (M >= 0 ? (V = m.elt(M), $ = M < g - 1 ? m.elt(M + 1) : V) : (J = g + M, V = m.elt(J), $ = J > 0 ? m.elt(J - 1) : V), V.equalsApprox($)) {
            let tt, q;
            M >= 0 ? (tt = M > 0 ? m.elt(M - 1) : V, q = M < g - 2 ? m.elt(M + 2) : $) : (tt = J < g - 1 ? m.elt(J + 1) : V, q = J > 1 ? m.elt(J - 2) : $);
            const E = tt.distanceSquaredPoint(V), v = $.distanceSquaredPoint(q);
            E > v + 10 ? O = M >= 0 ? tt.directionPoint(V) : V.directionPoint(tt) : v > E + 10 ? O = M >= 0 ? $.directionPoint(q) : q.directionPoint($) : O = M >= 0 ? tt.directionPoint(q) : q.directionPoint(tt);
          } else O = M >= 0 ? V.directionPoint($) : $.directionPoint(V);
          T !== 0 && (I = a.computeAngle(A, T, O), A.vt = I, A.Se(true), A.uo(true)), F = V.x + ($.x - V.x) * N - u.x, R = V.y + ($.y - V.y) * N - u.y;
        }
        A.gt(1 / 0, 1 / 0, 0, 0), C = A.measuredBounds;
        const X = A.naturalBounds;
        let K = 0;
        A instanceof Shape2 && (K = A.strokeWidth);
        const B = X.width + K, Y = X.height + K;
        S.Ki(), S.vs(-C.x, -C.y), S.lt(A.scale, A.scale), S.Ns(T === 0 ? A.angle : O, B / 2, Y / 2), (T === 22 || T === 26) && S.Ns(90, B / 2, Y / 2), (T === 23 || T === 27) && S.Ns(-90, B / 2, Y / 2), T === 28 && (O > 45 && O < 135 || O > 225 && O < 315) && S.Ns(-O, B / 2, Y / 2);
        const z = new Rect2(0, 0, B, Y);
        b.setRectSpot(z, L), S.St(b);
        const H = -b.x + K / 2 * A.scale, W = -b.y + K / 2 * A.scale;
        k.c(D);
        const j = isNaN(D.x), Z = isNaN(D.y);
        if (j || Z) {
          const V = B / 2 + Link2.eS, $ = Y / 2 + Link2.eS, J = O >= 45 && O <= 135, tt = O >= 225 && O <= 315;
          T === 0 && (J || tt) ? (k.x = Z ? V : D.y, k.y = j ? $ : D.x, J ? M >= 0 || isNaN(M) && N < 0.5 || j && (k.y = -$) : tt && ((M >= 0 || isNaN(M) && N < 0.5) && j && (k.y = -$), Z && (k.x = -V))) : (j && (M >= 0 || isNaN(M) && N < 0.5 ? k.x = V : k.x = -V), Z && (k.y = -$), k.rotate(O));
        } else k.rotate(O);
        F += k.x, R += k.y, z.e(F + H, R + W, C.width, C.height), x.push(z), d.unionRect(z);
      }
      if (h !== null) {
        const P = h.labelNodes;
        for (; P.next(); ) P.value.gt(1 / 0, 1 / 0);
      }
      t.er = d, t.position.e(u.x + d.x, u.y + d.y), n.Zn(d.width || 0, d.height || 0), Transform.o(S), Point2.o(b), Point2.o(k);
    }
    arrange(t, i, e) {
      const s = i.length;
      if (!(t instanceof Adornment2 || t instanceof Link2)) return;
      let n = t, o = null;
      t instanceof Adornment2 && (o = t, n = o.adornedPart);
      const r = t, l = t instanceof Adornment2 ? null : n.path, h = t.Ic;
      if (h.length !== 0) {
        let u = 0;
        if (l !== null && u < h.length) {
          const d = h[u];
          u++, l.Ut(d.x - r.er.x, d.y - r.er.y, d.width, d.height);
        }
        for (let d = 0; d < s; d++) {
          const m = i[d];
          if (m !== l && u < h.length) {
            const g = h[u];
            u++, m.Ut(g.x - r.er.x, g.y - r.er.y, g.width, g.height);
          }
        }
      }
      const f = n.points, a = f.count;
      if (a >= 2 && r instanceof Link2) {
        const u = r.labelNodes;
        for (; u.next(); ) {
          const d = u.value;
          r.Y3(d, a, f);
        }
      }
      o !== null ? o.Od(false) : n.Od(false);
      const c = t.pD(Point2.a());
      t.location.e(t.position.x + c.x, t.position.y + c.y), Point2.o(c);
    }
    measureLinkPath(t, i, e, s) {
      if (s.Wo() === false) return;
      let n = s.strokeWidth;
      if (n === 0 && t instanceof Adornment2 && t.type === Panel2.Link && t.adornedObject instanceof Shape2 && (n = t.adornedObject.strokeWidth), n = n * s.lt, t instanceof Link2 && t.xt !== null) {
        const o = t.geometry.bounds;
        s.co(o.x - n / 2, o.y - n / 2, o.width + n, o.height + n);
      } else if (t instanceof Adornment2 && t.adornedPart.xt !== null) {
        const o = t.adornedPart.xt.bounds;
        s.co(o.x - n / 2, o.y - n / 2, o.width + n, o.height + n);
      } else s.co(-(n / 2), -(n / 2), i + n, e + n);
      s.K3(), s.Se(false);
    }
  }
  PanelLayout2.On("Link", new PanelLayoutLink());
  class PanelLayoutGraduated extends PanelLayout2 {
    constructor() {
      super();
    }
    measure(t, i, e, s, n, o, r) {
      const l = t.findMainElement();
      if (!(l instanceof Shape2)) return;
      t.ns = [];
      const h = l.margin, f = h.right + h.left, a = h.top + h.bottom;
      l.gt(i, e, o, r);
      const c = l.measuredBounds, u = c.width, d = c.height, m = Math.max(u + f, 0), g = Math.max(d + a, 0), p = new Rect2(-h.left, -h.top, m, g);
      t.ns.push(p), n.c(p), this.determineGraduatedMarks(t, l);
      const y = t.Bs;
      if (y === null) return;
      const x = s.length;
      for (let S = 0; S < x; S++) {
        const b = s[S], k = y[S];
        !b.visible || b === l || k.length === 0 || (b instanceof Shape2 ? this.measureGraduatedTicks(t, b, k, n) : b instanceof TextBlock2 && this.measureGraduatedLabels(t, b, k, n), b.Se(false));
      }
    }
    arrange(t, i, e) {
      if (t.ns === null) return;
      const s = t.findMainElement(), n = t.Bs;
      if (n === null) return;
      const o = t.ns;
      let r = 0, l = o[r];
      r++, s !== null && s.Ut(l.x - e.x, l.y - e.y, l.width, l.height);
      const h = i.length;
      for (let f = 0; f < h; f++) {
        const a = i[f], c = n[f];
        !a.visible || a === s || c.length === 0 || (l = o[r], r++, a.Ut(l.x - e.x, l.y - e.y, l.width, l.height));
      }
      t.ns = null;
    }
    measureGraduatedTicks(t, i, e, s) {
      let n = i.alignmentFocus;
      n.isNoSpot() && (n = Spot2.TopCenter);
      const o = i.angle;
      i.vt = 0, i.gt(1 / 0, 1 / 0, 0, 0), i.vt = o;
      const r = i.measuredBounds, l = r.width, h = r.height, f = Rect2.U(0, 0, l, h), a = Point2.a();
      a.setRectSpot(f, n), Rect2.o(f);
      const c = -a.x, u = -a.y, d = new Rect2(), m = e.length;
      for (let g = 0; g < m; g++) {
        const p = e[g], y = p.pt.x, x = p.pt.y, S = p.angle;
        for (let b = 0; b < 4; b++) {
          switch (b) {
            case 0:
              a.e(c, u);
              break;
            case 1:
              a.e(c + l, u);
              break;
            case 2:
              a.e(c, u + h);
              break;
            case 3:
              a.e(c + l, u + h);
              break;
          }
          a.rotate(S + i.angle), a.offset(y, x), g === 0 && b === 0 ? d.e(a.x, a.y, 0, 0) : d.unionPoint(a), a.offset(-y, -x), a.rotate(-S - i.angle);
        }
      }
      Point2.o(a), t.ns !== null && t.ns.push(d), s.ai(d.x, d.y, d.width, d.height);
    }
    measureGraduatedLabels(t, i, e, s) {
      t.Ee === null && (t.Ee = new TextBlock2());
      const n = t.Ee;
      this.yD(i, n);
      let o = i.alignmentFocus;
      o.isNoSpot() && (o = Spot2.TopCenter);
      const r = i.segmentOrientation, l = i.segmentOffset, h = new Rect2();
      let f = 0, a = 0, c = 0, u = 0, d = 0;
      const m = e.length;
      for (let g = 0; g < m; g++) {
        const p = e[g];
        f = p.pt.x, a = p.pt.y, c = p.angle, u = i.angle, d = i.angle, r !== 0 && (r === 21 || r === 25 ? d = c + i.angle : d = c, u = Link2.computeAngle(r, d)), n.vt = u, n.text = p.text || "", n.gt(1 / 0, 1 / 0, 0, 0);
        const y = n.measuredBounds, x = n.naturalBounds, S = x.width, b = x.height, k = Transform.a();
        k.Ki(), k.vs(-y.x, -y.y), k.lt(n.scale, n.scale), k.Ns(d, S / 2, b / 2), (r === 22 || r === 26) && k.Ns(90, S / 2, b / 2), (r === 23 || r === 27) && k.Ns(-90, S / 2, b / 2), r === 28 && (c > 45 && c < 135 || c > 225 && c < 315) && k.Ns(-c, S / 2, b / 2);
        const P = Rect2.U(0, 0, S, b), A = Point2.a();
        A.setRectSpot(P, o), k.St(A);
        const C = -A.x, M = -A.y, N = Point2.a();
        N.c(l), isNaN(N.x) && (N.x = S / 2 + 3), isNaN(N.y) && (N.y = -(b / 2 + 3)), N.rotate(c), f += N.x + C, a += N.y + M;
        const L = new Rect2(f, a, y.width, y.height), T = new Rect2(y.x, y.y, y.width, y.height), D = new Rect2(x.x, x.y, x.width, x.height);
        p.labelAngle = u, p.lineCount = n.lineCount, p.lines = n.getMetrics(), p.actualBounds = L, p.measuredBounds = T, p.naturalBounds = D, g === 0 ? h.c(L) : h.unionRect(L), Point2.o(N), Point2.o(A), Rect2.o(P), Transform.o(k);
      }
      t.ns !== null && t.ns.push(h), s.ai(h.x, h.y, h.width, h.height);
    }
    determineGraduatedMarks(t, i) {
      const e = i.geometry, s = i.strokeWidth, n = e.flattenedSegments, o = e.flattenedLengths, r = e.flattenedTotalLength, l = n.length;
      let h = 0, f = 0;
      const a = U.ft();
      for (let x = 0; x < l; x++) {
        const S = n[x], b = [];
        h = 0, f = 0;
        const k = S.length;
        for (let P = 0; P < k; P += 2) {
          const A = S[P], C = S[P + 1];
          if (P === 0) {
            h = A, f = C;
            continue;
          }
          let M = Math.atan2(C - f, A - h) * 180 / Math.PI;
          M < 0 && (M += 360), b.push(M), h = A, f = C;
        }
        a.push(b);
      }
      const c = this.U3(t), u = t.O.h, d = u.length;
      let m = 0, g = 0, p = r;
      t.Bs = [];
      let y;
      for (let x = 0; x < d; x++) {
        const S = u[x];
        if (y = [], !S.visible || S === i) {
          t.Bs.push(y);
          continue;
        }
        const b = Math.abs(S.interval), k = t.graduatedTickUnit;
        if (k * b * r / t.graduatedRange < 2 && S.graduatedSkip === null) {
          t.Bs.push(y);
          continue;
        }
        let P = o[0][0], A = 0, C = 0;
        g = r * S.graduatedStart - 1e-4, p = r * S.graduatedEnd + 1e-4;
        const M = k * b;
        let N = t.graduatedTickBase;
        if (N < t.graduatedMin) {
          let F = (t.graduatedMin - N) / M;
          F = F % 1 === 0 ? F : Math.floor(F + 1), N += F * M;
        } else if (N > t.graduatedMin + M) {
          const F = Math.floor((N - t.graduatedMin) / M);
          N -= F * M;
        }
        const L = c[x], T = N, D = t.graduatedMax * 1e-6;
        for (let F = 1; N <= t.graduatedMax + D; F++) {
          if (this.G3(t, N - t.graduatedTickBase, L) && (N > t.graduatedMax && (N = t.graduatedMax), (S.graduatedSkip === null || S instanceof TextBlock2 && !S.graduatedSkip(N, S) || S instanceof Shape2 && !S.graduatedSkip(N, S)) && (m = (N - t.graduatedMin) * r / t.graduatedRange, m > r && (m = r), g <= m && m <= p))) {
            let R = a[A][C], I = o[A][C];
            for (; A < o.length; ) {
              for (; m > P && C < o[A].length - 1; ) C++, R = a[A][C], I = o[A][C], P += I;
              if (m <= P) break;
              A++, C = 0, R = a[A][C], I = o[A][C], P += I;
            }
            const O = n[A], X = O[C * 2], K = O[C * 2 + 1], B = O[C * 2 + 2], Y = O[C * 2 + 3], z = (m - (P - I)) / I, H = new Point2(X + (B - X) * z + s / 2 - e.bounds.x, K + (Y - K) * z + s / 2 - e.bounds.y);
            if (H.scale(i.scale, i.scale), R = this.q3(R, z, O, a[A], C), S instanceof TextBlock2) {
              let W = "";
              S.graduatedFunction !== null ? (W = S.graduatedFunction(N, S), W = W != null ? W.toString() : "") : W = (+N.toFixed(2)).toString(), W !== "" && y.push({ pt: H, angle: R, text: W });
            } else y.push({ pt: H, angle: R });
          }
          N = T + F * M;
        }
        t.Bs.push(y);
      }
      U.et(a);
    }
    q3(t, i, e, s, n) {
      if (i < 0.5005 && i > 0.4995) return t;
      let o = t;
      if (i < 0.5 ? n > 0 ? o = s[n - 1] : G.q(e[0], e[e.length - 2]) && G.q(e[1], e[e.length - 1]) && (o = s[s.length - 1]) : i > 0.5 && (n + 1 < s.length ? o = s[n + 1] : G.q(e[0], e[e.length - 2]) && G.q(e[1], e[e.length - 1]) && (o = s[0])), t !== o) {
        let r = Math.abs(t - o);
        if (r > 180 && (t < o ? t += 360 : o += 360, r = Math.abs(t - o)), i < 5e-4 || i > 0.9995) return (t + o) / 2 % 360;
        if (r < 10) {
          const l = 1 - Math.abs(0.5 - i);
          return (t * l + o * (1 - l)) % 360;
        }
      }
      return t;
    }
    U3(t) {
      if (t.ys === null) {
        const i = [], e = t.O.h, s = e.length;
        for (let n = 0; n < s; n++) {
          const o = e[n], r = [];
          if (i.push(r), !o.visible) continue;
          const l = o.interval;
          if (!(l < 0)) for (let h = 0; h < s; h++) {
            if (h === n) continue;
            const f = e[h];
            if (!f.visible || o.constructor !== f.constructor) continue;
            const a = f.interval;
            a > l && r.push(a);
          }
        }
        t.ys = i;
      }
      return t.ys;
    }
    G3(t, i, e) {
      const s = e.length;
      for (let n = 0; n < s; n++) {
        const o = e[n] * t.graduatedTickUnit, r = i % o, l = t.graduatedTickUnit * 1e-6;
        if (r < l && r > -l) return false;
      }
      return true;
    }
    vi(t, i, e) {
      const s = e.xa;
      e.xa = true;
      const n = t.naturalBounds, o = n.width, r = n.height, l = i instanceof SVGContext;
      i.save(), i.beginPath(), i.rect(-1, -1, o + 1, r + 1), i.clip(), i.endPath();
      const h = t.findMainElement();
      h.vi(i, e);
      let f = t.getDocumentScale() * e.scale;
      f <= 0 && (f = 1);
      const a = h.actualBounds, c = t.O.h, u = t.Bs, d = c.length;
      for (let m = 0; m < d; m++) {
        const g = c[m], p = u[m], y = p.length;
        if (!(!g.visible || g === h || p.length === 0)) {
          if (g instanceof Shape2) {
            if (t.graduatedTickUnit * g.interval * h.geometry.flattenedTotalLength / t.graduatedRange * f < 2 && g.graduatedSkip === null) continue;
            const x = g.measuredBounds, S = g.strokeWidth * g.scale;
            let b = g.alignmentFocus;
            b.isNoSpot() && (b = Spot2.TopCenter);
            for (let k = 0; k < y; k++) {
              const P = p[k].pt, A = p[k].angle;
              this.H3(g, P, a, A, x, S, b), g.vi(i, e), l && (t.svg.appendChild(g.svg), g.svg = null), g.ll.Ki();
            }
          } else if (g instanceof TextBlock2) {
            t.Ee === null && (t.Ee = new TextBlock2());
            const x = t.Ee;
            this.yD(g, x), x.QN = true;
            for (let S = 0; S < y; S++) {
              const b = p[S];
              if (b.actualBounds && b.measuredBounds && b.naturalBounds) {
                x.v3(b);
                const k = b.actualBounds;
                x.Ut(k.x, k.y, k.width, k.height), this.W3(x, a, k, b.measuredBounds, b.naturalBounds), x.al = g.part, x.en = g.panel, x.vi(i, e), x.en = null, x.al = null, l && (t.svg.appendChild(x.svg), x.svg = null);
              }
            }
          }
        }
      }
      e.xa = s, i.restore(), i.clearContextCache(true);
    }
    H3(t, i, e, s, n, o, r) {
      const l = t.ll;
      l.Ki(), l.vs(i.x + e.x, i.y + e.y), l.Ns(s + t.angle, 0, 0), l.vs(-n.width * r.x + r.offsetX + o / 2, -n.height * r.y + r.offsetY + o / 2), l.lt(t.scale, t.scale), t.Td(false), t.Mh.set(t.ll), t.Ra = t.scale, t.Ka(false);
    }
    W3(t, i, e, s, n) {
      const o = t.ll;
      o.Ki(), o.vs(e.x + i.x, e.y + i.y), o.vs(-s.x, -s.y), t.j0(o, n.x, n.y, n.width, n.height), t.Td(false), t.Mh.set(t.ll), t.Ra = t.scale, t.Ka(false);
    }
    yD(t, i) {
      i.j3(t);
    }
  }
  PanelLayout2.On("Graduated", new PanelLayoutGraduated());
  var ViewboxStretch2 = ((w) => (w[w.Uniform = 6] = "Uniform", w[w.UniformToFill = 7] = "UniformToFill", w))(ViewboxStretch2 || {});
  class Panel2 extends GraphObject2 {
    tt;
    O;
    si;
    Ed;
    eo;
    ul;
    yo;
    er;
    _N;
    V;
    Bd;
    ct;
    Ni;
    oi;
    Vd;
    Oh;
    on;
    constructor(t, i) {
      if (super(), t === void 0) this.tt = Panel2.Position;
      else if (typeof t == "string") {
        const e = PanelLayout2.ms.get(t);
        e !== null ? this.tt = e : U.n("PanelLayout not loaded: " + t);
      } else t instanceof PanelLayout2 ? this.tt = t : (this.tt = Panel2.Position, t && (i = t));
      this.l |= 4194304 | (this.tt === Panel2.Grid ? 1048576 : 0), this.O = new List2(), this.si = Margin2.lm, this.Ed = Spot2.Default, this.eo = 1, this.ul = null, this.yo = "", this.er = new Rect2(NaN, NaN, NaN, NaN), this._N = null, this.V = null, this.Bd = 6, this.Ni = null, this.ct = null, this.oi = null, this.Vd = NaN, this.Oh = null, this.on = null, i && Object.assign(this, i);
    }
    cloneProtected(t) {
      super.cloneProtected(t), t.tt = this.tt, t.si = this.si.T(), t.Ed = this.Ed.T(), t.eo = this.eo, t.yo = this.yo, t.er.c(this.er), this.V !== null && (t.V = this.V.copy(t)), t.Bd = this.Bd, this.ct !== null && (t.ct = this.ct.copy()), this.Ni !== null && (t.Ni = this.Ni.copy()), t.oi = this.oi, t.Vd = this.Vd, t.Oh = this.Oh;
    }
    Zo(t) {
      super.Zo(t), t.O = this.O;
      const i = t.O.h, e = i.length;
      for (let s = 0; s < e; s++) {
        const n = i[s];
        n.en = t;
      }
      t.ul = null;
    }
    copy() {
      const t = super.copy(), i = this.O.h, e = i.length;
      for (let s = 0; s < e; s++) {
        const o = i[s].copy();
        t.J3(o);
      }
      return t;
    }
    toString() {
      return "Panel(" + this.type.name + ")#" + GSet2.Ps(this);
    }
    get type() {
      return this.tt;
    }
    set type(t) {
      const i = this.tt;
      i !== t && (Debug && U.s(t, PanelLayout2, "PanelLayout"), this.tt = t, this.Rc = this.tt === Panel2.Grid, this.g(), this.t("type", i, t));
    }
    get elements() {
      return this.O.iterator;
    }
    get naturalBounds() {
      return this.ji;
    }
    get padding() {
      return this.si;
    }
    set padding(t) {
      typeof t == "number" ? (t < 0 && U.G(t, ">= 0", Panel2, "padding"), t = new Margin2(t)) : (U.s(t, Margin2, Panel2, "padding"), t.left < 0 && U.G(t.left, ">= 0", Panel2, "padding:value.left"), t.right < 0 && U.G(t.right, ">= 0", Panel2, "padding:value.right"), t.top < 0 && U.G(t.top, ">= 0", Panel2, "padding:value.top"), t.bottom < 0 && U.G(t.bottom, ">= 0", Panel2, "padding:value.bottom"));
      const i = this.si;
      i.equals(t) || (t = t.T(), this.si = t, this.g(), this.t("padding", i, t));
    }
    get defaultAlignment() {
      return this.Ed;
    }
    set defaultAlignment(t) {
      const i = this.Ed;
      i.equals(t) || (Debug && U.s(t, Spot2, Panel2, "defaultAlignment"), t = t.T(), this.Ed = t, this.g(), this.t("defaultAlignment", i, t));
    }
    get defaultStretch() {
      return this.eo;
    }
    set defaultStretch(t) {
      const i = this.eo;
      i !== t && (Debug && U.W(t, Stretch2, "Stretch"), this.eo = t, this.g(), this.t("defaultStretch", i, t));
    }
    get defaultSeparatorPadding() {
      return this.V !== null ? this.V.Dp : Margin2.lm;
    }
    set defaultSeparatorPadding(t) {
      typeof t == "number" ? t = new Margin2(t) : Debug && U.s(t, Margin2, Panel2, "defaultSeparatorPadding");
      const i = this.defaultSeparatorPadding;
      i.equals(t) || (t = t.T(), this.V === null && (this.V = new TablePanelSettings()), this.V.Dp = t, this.g(), this.t("defaultSeparatorPadding", i, t));
    }
    get defaultRowSeparatorStroke() {
      return this.V !== null ? this.V.Fp : null;
    }
    set defaultRowSeparatorStroke(t) {
      const i = this.defaultRowSeparatorStroke;
      i !== t && (t === null || typeof t == "string" || t instanceof Brush2) && (t instanceof Brush2 && t.S(), this.V === null && (this.V = new TablePanelSettings()), this.V.Fp = t, this.L(), this.t("defaultRowSeparatorStroke", i, t));
    }
    get defaultRowSeparatorStrokeWidth() {
      return this.V !== null ? this.V.Ip : 1;
    }
    set defaultRowSeparatorStrokeWidth(t) {
      const i = this.defaultRowSeparatorStrokeWidth;
      i !== t && isFinite(t) && t >= 0 && (this.V === null && (this.V = new TablePanelSettings()), this.V.Ip = t, this.g(), this.t("defaultRowSeparatorStrokeWidth", i, t));
    }
    get defaultRowSeparatorDashArray() {
      return this.V !== null ? this.V.Rp : null;
    }
    set defaultRowSeparatorDashArray(t) {
      const i = this.defaultRowSeparatorDashArray;
      if (i !== t) {
        if (t !== null && !Array.isArray(t) && U.Ti(t, "Array", Panel2, "defaultRowSeparatorDashArray:value"), t !== null) {
          const e = t.length;
          let s = 0;
          for (let n = 0; n < e; n++) {
            const o = t[n];
            (typeof o != "number" || !(o >= 0) || !isFinite(o)) && U.n("defaultRowSeparatorDashArray value " + o + " at index " + n + " must be a positive number or zero."), s += o;
          }
          if (s === 0) {
            if (i === null) return;
            t = null;
          }
        }
        this.V === null && (this.V = new TablePanelSettings()), this.V.Rp = t, this.L(), this.t("defaultRowSeparatorDashArray", i, t);
      }
    }
    get defaultColumnSeparatorStroke() {
      return this.V !== null ? this.V.Op : null;
    }
    set defaultColumnSeparatorStroke(t) {
      const i = this.defaultColumnSeparatorStroke;
      i !== t && (t === null || typeof t == "string" || t instanceof Brush2) && (t instanceof Brush2 && t.S(), this.V === null && (this.V = new TablePanelSettings()), this.V.Op = t, this.L(), this.t("defaultColumnSeparatorStroke", i, t));
    }
    get defaultColumnSeparatorStrokeWidth() {
      return this.V !== null ? this.V.Ep : 1;
    }
    set defaultColumnSeparatorStrokeWidth(t) {
      const i = this.defaultColumnSeparatorStrokeWidth;
      i !== t && isFinite(t) && t >= 0 && (this.V === null && (this.V = new TablePanelSettings()), this.V.Ep = t, this.g(), this.t("defaultColumnSeparatorStrokeWidth", i, t));
    }
    get defaultColumnSeparatorDashArray() {
      return this.V !== null ? this.V.Bp : null;
    }
    set defaultColumnSeparatorDashArray(t) {
      const i = this.defaultColumnSeparatorDashArray;
      if (i !== t) {
        if (t !== null && !Array.isArray(t) && U.Ti(t, "Array", Panel2, "defaultColumnSeparatorDashArray:value"), t !== null) {
          const e = t.length;
          let s = 0;
          for (let n = 0; n < e; n++) {
            const o = t[n];
            (typeof o != "number" || !(o >= 0) || !isFinite(o)) && U.n("defaultColumnSeparatorDashArray value " + o + " at index " + n + " must be a positive number or zero."), s += o;
          }
          if (s === 0) {
            if (i === null) return;
            t = null;
          }
        }
        this.V === null && (this.V = new TablePanelSettings()), this.V.Bp = t, this.L(), this.t("defaultColumnSeparatorDashArray", i, t);
      }
    }
    get Rh() {
      return this.V !== null ? this.V.Rh : null;
    }
    set Rh(t) {
      this.V === null && (this.V = new TablePanelSettings()), this.V.Rh = t;
    }
    get viewboxStretch() {
      return this.Bd;
    }
    set viewboxStretch(t) {
      const i = this.Bd;
      i !== t && (Debug && U.W(t, ViewboxStretch2, "ViewboxStretch"), this.Bd = t, this.g(), this.t("viewboxStretch", i, t));
    }
    get gridCellSize() {
      return this.Ni !== null ? this.Ni.zd : Size2.zA;
    }
    set gridCellSize(t) {
      this.Ni === null && (this.Ni = new GridPanelSettings());
      const i = this.Ni.zd;
      if (!i.equals(t)) {
        (!t.isReal() || t.width === 0 || t.height === 0) && U.n("Invalid Panel.gridCellSize: " + t), this.Ni.zd = t.T();
        const e = this.diagram;
        e !== null && this === e.grid && e.ph(), this.L(), this.t("gridCellSize", i, t);
      }
    }
    get gridOrigin() {
      return this.Ni !== null ? this.Ni.Xd : Point2.wn;
    }
    set gridOrigin(t) {
      this.Ni === null && (this.Ni = new GridPanelSettings());
      const i = this.Ni.Xd;
      if (!i.equals(t)) {
        t.isReal() || U.n("Invalid Panel.gridOrigin: " + t), this.Ni.Xd = t.T();
        const e = this.diagram;
        e !== null && this === e.grid && e.ph(), this.L(), this.t("gridOrigin", i, t);
      }
    }
    get graduatedMin() {
      return this.ct !== null ? this.ct.Vp : 0;
    }
    set graduatedMin(t) {
      const i = this.graduatedMin;
      if (i !== t && (Debug && U.r(t, Panel2, "graduatedMin"), this.ct === null && (this.ct = new GradPanelSettings()), this.ct.Vp = t, this.g(), this.t("graduatedMin", i, t), this.xc())) {
        const e = this.part;
        e !== null && this.Ya(e, "graduatedRange");
      }
    }
    get graduatedMax() {
      return this.ct !== null ? this.ct.zp : 100;
    }
    set graduatedMax(t) {
      const i = this.graduatedMax;
      if (i !== t && (Debug && U.r(t, Panel2, "graduatedMax"), this.ct === null && (this.ct = new GradPanelSettings()), this.ct.zp = t, this.g(), this.t("graduatedMax", i, t), this.xc())) {
        const e = this.part;
        e !== null && this.Ya(e, "graduatedRange");
      }
    }
    get graduatedRange() {
      return this.graduatedMax - this.graduatedMin;
    }
    get graduatedTickUnit() {
      return this.ct !== null ? this.ct.Xp : 10;
    }
    set graduatedTickUnit(t) {
      const i = this.graduatedTickUnit;
      i !== t && t > 0 && (Debug && U.r(t, Panel2, "graduatedTickUnit"), this.ct === null && (this.ct = new GradPanelSettings()), this.ct.Xp = t, this.g(), this.t("graduatedTickUnit", i, t));
    }
    get graduatedTickBase() {
      return this.ct !== null ? this.ct.Yp : 0;
    }
    set graduatedTickBase(t) {
      const i = this.graduatedTickBase;
      i !== t && (Debug && U.r(t, Panel2, "graduatedTickBase"), this.ct === null && (this.ct = new GradPanelSettings()), this.ct.Yp = t, this.g(), this.t("graduatedTickBase", i, t));
    }
    get Bs() {
      return this.ct !== null ? this.ct.Bs : null;
    }
    set Bs(t) {
      this.ct !== null ? this.ct.Bs = t : t !== null && (this.ct = new GradPanelSettings(), this.ct.Bs = t);
    }
    get ns() {
      return this.ct !== null ? this.ct.ns : null;
    }
    set ns(t) {
      this.ct !== null ? this.ct.ns = t : t !== null && (this.ct = new GradPanelSettings(), this.ct.ns = t);
    }
    get ys() {
      return this.ct !== null ? this.ct.ys : null;
    }
    set ys(t) {
      this.ct !== null ? this.ct.ys = t : t !== null && (this.ct = new GradPanelSettings(), this.ct.ys = t);
    }
    get Ee() {
      return this.ct !== null ? this.ct.Ee : null;
    }
    set Ee(t) {
      this.ct !== null ? this.ct.Ee = t : t !== null && (this.ct = new GradPanelSettings(), this.ct.Ee = t);
    }
    Q0(t) {
      super.Q0(t);
      const i = this.O.h, e = i.length;
      for (let s = 0; s < e; s++) i[s].Q0(t);
    }
    Dh(t, i) {
      if (this.tt === Panel2.Grid) {
        t.commitTransform(), this.tt.vi(this, t, i);
        return;
      }
      if (this.tt === Panel2.Graduated) {
        t.commitTransform(), this.tt.vi(this, t, i);
        return;
      }
      if (this.tt === Panel2.Table) if (t.commitTransform(), t instanceof SVGContext) {
        const r = t.currentElement;
        t.currentElement = t.newGroup2("gojs-ts"), this.tC(t, i), t.endGroup(), t.currentElement = r;
      } else this.tC(t, i);
      const e = this.isClipping && this.tt === Panel2.Spot;
      e && t.save();
      const s = this.findMainElement(), n = this.O.h, o = n.length;
      for (let r = 0; r < o; r++) {
        const l = n[r];
        e && l === s && (t.clipInsteadOfFill = true), l.vi(t, i), e && l === s && (t.clipInsteadOfFill = false);
      }
      e && (t.restore(), t.clearContextCache(true));
    }
    tC(t, i) {
      t.lineCap = "butt";
      const e = this.rowCount > 0 ? this.es : null, s = this.columnCount > 0 ? this.ss : null;
      e !== null && this.sS(t, i, true, e, true), s !== null && this.sS(t, i, false, s, true), e !== null && this.wD(t, true, e), s !== null && this.wD(t, false, s), e !== null && this.sS(t, i, true, e, false), s !== null && this.sS(t, i, false, s, false);
    }
    wD(t, i, e) {
      const s = e.length, n = this.actualBounds, o = this.naturalBounds;
      let r = true;
      for (let l = 0; l < s; l++) {
        const h = e[l];
        if (h === void 0 || h.actual === 0) continue;
        if (r) {
          r = false;
          continue;
        }
        if (i) {
          if (h.position > o.height) continue;
        } else if (h.position > o.width) continue;
        let f = h.separatorStrokeWidth;
        isNaN(f) && (f = i ? this.defaultRowSeparatorStrokeWidth : this.defaultColumnSeparatorStrokeWidth);
        let a = h.separatorStroke;
        if (a === null && (a = i ? this.defaultRowSeparatorStroke : this.defaultColumnSeparatorStroke), f === 0 || a === null) continue;
        this.Cn(t, a, false, false, o, n);
        let c = false, u = h.separatorDashArray;
        u === null && (u = i ? this.defaultRowSeparatorDashArray : this.defaultColumnSeparatorDashArray), u !== null && (c = true, t.enableDash(u, 0)), t.beginPath();
        const d = h.position + f;
        i ? d > o.height && (f -= d - o.height) : d > o.width && (f -= d - o.width);
        let m = h.position + f / 2;
        t.lineWidth = f;
        const g = this.si;
        if (i) {
          m += g.top;
          const p = g.left, y = o.width - g.right;
          t.moveTo(p, m), t.lineTo(y, m);
        } else {
          m += g.left;
          const p = g.top, y = o.height - g.bottom;
          t.moveTo(m, p), t.lineTo(m, y);
        }
        t.stroke(), t.endPath(), c && t.disableDash();
      }
    }
    sS(t, i, e, s, n) {
      const o = s.length, r = this.actualBounds, l = this.naturalBounds, h = this.xD(true), f = this.xD(false);
      for (let a = 0; a < o; a++) {
        const c = s[a];
        if (c === void 0 || c.background === null || c.coversSeparators === n || c.actual === 0) continue;
        const u = e ? r.height : r.width;
        if (c.position > u) continue;
        let d = c.computeEffectiveSpacing(), m = c.separatorStrokeWidth;
        isNaN(m) && (m = e ? this.defaultRowSeparatorStrokeWidth : this.defaultColumnSeparatorStrokeWidth);
        let g = c.separatorStroke;
        g === null && (g = e ? this.defaultRowSeparatorStroke : this.defaultColumnSeparatorStroke), (g === null || c.index === (e ? h : f)) && (m = 0), d -= m;
        const p = c.position + m;
        let y = d + c.actual;
        if (p + y > u && (y = u - p), y <= 0) continue;
        const x = this.si;
        this.Cn(t, c.background, true, false, l, r), e ? t.fillRect(x.left, p + x.top, r.width - (x.left + x.right), y) : t.fillRect(p + x.left, x.top, y, r.height - (x.top + x.bottom));
      }
    }
    xD(t) {
      const i = t ? this.rowCount : this.columnCount;
      for (let e = 0; e < i; e++) {
        const s = t ? this.es[e] : this.ss[e];
        if (s !== void 0) return s.index;
      }
      return 0;
    }
    Pc() {
      const t = this.O.h, i = t.length;
      for (let e = 0; e < i; e++) t[e].Pc();
      this.ts(true);
    }
    kc(t, i, e) {
      const s = this.svg;
      if (s === null) return false;
      if (this.type === Panel2.Table) {
        const r = s.getElementsByClassName("gojs-ts"), l = r.length !== 0 ? r[0] : null;
        l !== null && (l.innerHTML = ""), t.currentElement = l, this.tC(t, i), t.currentElement = null;
      } else {
        if (this.tt === Panel2.Grid) return s.innerHTML = "", s.remove(), false;
        if (this.tt === Panel2.Graduated) return s.innerHTML = "", s.remove(), false;
        if (this.tt === Panel2.Spot && this.isClipping) return s.innerHTML = "", s.remove(), this.Nh = null, this.Pc(), false;
      }
      if (!super.kc(t, i, e)) return false;
      const n = this.O.h, o = n.length;
      for (let r = 0; r < o; r++) n[r].vi(t, i);
      return true;
    }
    Ad(t) {
      return true;
    }
    tp(t, i, e, s) {
      if (!this.isClipping) {
        if (this.nn() && t.partClipRect !== null) {
          const n = t.partClipRect, o = this.O.h;
          let r = 0, l = 0;
          for (let h = 0; h < o.length; h++) {
            if (!o[h].isVisibleObject()) continue;
            const f = o[h].actualBounds;
            r = h === 0 ? f.x : Math.min(f.x, r), l = h === 0 ? f.y : Math.min(f.y, l);
          }
          s.setAttributeNS(null, "clip-path", `path('M ${n.x - e.x - r},${n.y - e.y - l} l ${n.width} 0 l 0 ${n.height} l -${n.width} 0 z')`);
          return;
        }
        super.tp(t, i, e, s);
      }
    }
    bc(t, i, e, s, n) {
      const o = this.Dn(), r = this.E, l = 1 / (r.m11 * r.m22 - r.m12 * r.m21);
      let h = r.m22 * l, f = -r.m12 * l, a = -r.m21 * l, c = r.m11 * l, u = l * (r.m21 * r.dy - r.m22 * r.dx), d = l * (r.m12 * r.dx - r.m11 * r.dy);
      if (this.background !== null) {
        const m = t * h + i * a + u, g = t * f + i * c + d, p = e * h + s * a + u, y = e * f + s * c + d;
        n.e(0, 0);
        const x = this.naturalBounds, S = G.Dl(0, 0, x.width, x.height, m, g, p, y, n);
        return n.E(r), S;
      } else {
        o || (h = 1, f = 0, a = 0, c = 1, u = 0, d = 0);
        const m = t * h + i * a + u, g = t * f + i * c + d, p = e * h + s * a + u, y = e * f + s * c + d;
        n.e(p, y);
        let x = (p - m) ** 2 + (y - g) ** 2, S = false;
        const b = this.O.h, k = b.length, P = Point2.a();
        let A = null, C = 1 / 0, M = null;
        const N = this.isClipping && this.tt === Panel2.Spot;
        N && (M = Point2.a(), A = this.findMainElement(), S = A.bc(m, g, p, y, M), S && (C = (m - M.x) ** 2 + (g - M.y) ** 2));
        for (let L = 0; L < k; L++) {
          const T = b[L];
          if (!T.visible || T === A || !T.bc(m, g, p, y, P)) continue;
          S = true;
          const D = (m - P.x) ** 2 + (g - P.y) ** 2;
          D < x && (x = D, n.set(P));
        }
        return N && (C > x && n.set(M), Point2.o(M)), Point2.o(P), o && n.E(r), S;
      }
    }
    tc() {
      const t = this.O.h, i = t.length;
      for (let e = 0; e < i; e++) t[e].tc();
      super.tc();
    }
    g(t) {
      if (this.Wo()) return;
      super.g(t);
      let i = null;
      (this.tt === Panel2.Auto || this.tt === Panel2.Link) && (i = this.findMainElement());
      const e = this.O.h, s = e.length;
      for (let n = 0; n < s; n++) {
        const o = e[n];
        if ((o === i || o.isPanelMain) && o.g(true), o.desiredSize.isReal() || !o.visible) continue;
        const r = o.sn(false);
        !(o instanceof Placeholder2) && !(o instanceof Panel2) && !(o instanceof TextBlock2) && r === 0 || o.g(true);
      }
    }
    Nc() {
      if (this.Wo()) return;
      this.Se(true), this.uo(true);
      const t = this.O.h, i = t.length;
      for (let e = 0; e < i; e++) t[e].Nc();
    }
    Sc() {
      if (this.vb() === false) {
        this.Td(true), this.Ka(true);
        const t = this.O.h, i = t.length;
        for (let e = 0; e < i; e++) t[e].ON();
      }
    }
    ON() {
      this.Ka(true);
      const t = this.O.h, i = t.length;
      for (let e = 0; e < i; e++) t[e].ON();
    }
    Nd(t, i, e, s) {
      const n = this.er;
      n.e(0, 0, 0, 0);
      const o = this.desiredSize, r = this.minSize;
      e === void 0 && (e = r.width, s = r.height), e = Math.max(e, r.width), s = Math.max(s, r.height);
      const l = this.maxSize;
      isNaN(o.width) || (t = Math.min(o.width, l.width)), isNaN(o.height) || (i = Math.min(o.height, l.height)), t = Math.max(e, t), i = Math.max(s, i);
      const h = this.si;
      t = Math.max(t - h.left - h.right, 0), i = Math.max(i - h.top - h.bottom, 0);
      const f = this.O.h;
      this.tt.measure(this, t, i, f, n, e, s);
      let a = n.width + h.left + h.right, c = n.height + h.top + h.bottom;
      isFinite(o.width) && (a = o.width), isFinite(o.height) && (c = o.height), a = Math.min(l.width, a), c = Math.min(l.height, c), a = Math.max(r.width, a), c = Math.max(r.height, c), a = Math.max(e, a), c = Math.max(s, c), n.Zn(a, c), this.naturalBounds.Zn(a, c), this.co(0, 0, a, c);
    }
    findMainElement() {
      if (this.ul === null) {
        const t = this.O.h, i = t.length;
        if (i === 0) return null;
        for (let e = 0; e < i; e++) {
          const s = t[e];
          if (s.isPanelMain === true) return this.ul = s, s;
        }
        this.ul = t[0];
      }
      return this.ul;
    }
    ir() {
      return this.part !== null ? this.part.locationObject : null;
    }
    get panelLayoutState() {
      return this._N;
    }
    set panelLayoutState(t) {
      this._N = t;
    }
    Th(t, i, e, s) {
      const n = this.O.h;
      if (this.actualBounds.e(t, i, e, s), !this.desiredSize.isReal()) {
        let o = this.sn(true);
        const r = this.measuredBounds, l = r.width, h = r.height, f = this.hl, a = f.left + f.right, c = f.top + f.bottom;
        switch (l === e && h === s && (o = 0), o) {
          case 0:
            (l > e || h > s) && (this.g(), this.gt(l > e ? e : l, h > s ? s : h, 0, 0));
            break;
          case 2:
            this.g(true), this.gt(e + a, s + c, 0, 0);
            break;
          case 5:
            this.g(true), this.gt(e + a, h + c, 0, 0);
            break;
          case 4:
            this.g(true), this.gt(l + a, s + c, 0, 0);
            break;
        }
      }
      this.tt.arrange(this, n, this.er);
    }
    Ah(t) {
      const i = this.naturalBounds, e = this.ir();
      if (Rect2.contains(0, 0, i.width, i.height, t.x, t.y)) {
        const s = this.O.h, n = s.length, o = Point2.U(0, 0);
        for (let r = n; r--; ) {
          const l = s[r];
          if (!(!l.visible && l !== e) && (o.set(t).je(l.E), l.containsPoint(o))) return Point2.o(o), true;
        }
        return Point2.o(o), this.It !== null;
      }
      return false;
    }
    W0(t) {
      if (this.ao === t) return this;
      const i = this.O.h, e = i.length;
      for (let s = 0; s < e; s++) {
        const o = i[s].W0(t);
        if (o !== null) return o;
      }
      return null;
    }
    walkVisualTreeFrom(t, i) {
      if (i(this, t), t instanceof Panel2) {
        const e = t.O.h, s = e.length;
        for (let n = 0; n < s; n++) this.walkVisualTreeFrom(e[n], i);
      }
    }
    Tn(t) {
      this.bD(this, t);
    }
    bD(t, i) {
      i(t);
      const e = t.O.h, s = e.length;
      for (let n = 0; n < s; n++) {
        const o = e[n];
        o instanceof Panel2 && this.bD(o, i);
      }
    }
    $3(t) {
      this.SD(this, t);
    }
    SD(t, i) {
      if (i(t), t instanceof Panel2) {
        const e = t.O.h, s = e.length;
        for (let n = 0; n < s; n++) this.SD(e[n], i);
      }
    }
    findInVisualTree(t) {
      return this.kD(this, t);
    }
    kD(t, i) {
      if (i(t)) return t;
      if (t instanceof Panel2) {
        const e = t.O.h, s = e.length;
        for (let n = 0; n < s; n++) {
          const o = this.kD(e[n], i);
          if (o !== null) return o;
        }
      }
      return null;
    }
    findObject(t) {
      if (this.name === t) return this;
      const i = this.O.h;
      let e = i.length;
      this.Z3() && (e = this.Kp());
      for (let s = 0; s < e; s++) {
        const n = i[s];
        if (n instanceof Panel2) {
          const o = n.findObject(t);
          if (o !== null) return o;
        }
        if (n.name === t) return n;
      }
      return null;
    }
    PD() {
      const t = this.O.h, i = t.length;
      let e = 0;
      for (let s = 0; s < i; s++) {
        const n = t[s];
        n instanceof Panel2 ? e = Math.max(e, n.PD()) : n instanceof Shape2 && (e = Math.max(e, n.Q3()));
      }
      return e;
    }
    Dn() {
      return !(this.type === Panel2.TableRow || this.type === Panel2.TableColumn);
    }
    fl() {
      return this.type === Panel2.TableRow || this.type === Panel2.TableColumn;
    }
    GT(t, i, e) {
      if (this.pickable === false || (i === void 0 && (i = null), e === void 0 && (e = null), this.us())) return null;
      const s = this.naturalBounds, n = 1 / this.getDocumentScale(), o = this.Dn(), r = o ? t : Point2.U(t.x, t.y).je(this.E), l = this.diagram;
      let h = 10, f = 5;
      if (l !== null && (h = l.getInputOption("extraTouchArea"), f = h / 2), Rect2.contains(-(f * n), -(f * n), s.width + h * n, s.height + h * n, r.x, r.y)) {
        if (!this.Rc) {
          const c = this.O.h, u = c.length, d = Point2.a(), m = this.isClipping && this.tt === Panel2.Spot, g = m ? this.findMainElement() : null;
          if (m && g && (g.Dn() ? d.set(t).je(g.E) : d.set(t), !g.containsPoint(d))) return Point2.o(d), o || Point2.o(r), null;
          const p = this.ir();
          for (let y = u; y--; ) {
            const x = c[y];
            if (!x.visible && x !== p || (x.Dn() ? d.set(t).je(x.E) : d.set(t), m && x === g)) continue;
            let S = null;
            if (x instanceof Panel2 ? S = x.GT(d, i, e) : x.pickable === true && x.containsPoint(d) && (S = x), S !== null && (i !== null && (S = i(S)), S !== null && (e === null || e(S)))) return Point2.o(d), o || Point2.o(r), S;
          }
          Point2.o(d);
        }
        if (this.background === null) return o || Point2.o(r), null;
        const a = Rect2.contains(0, 0, s.width, s.height, r.x, r.y) ? this : null;
        return o || Point2.o(r), a;
      }
      return o || Point2.o(r), null;
    }
    qT(t, i, e, s) {
      if (this.pickable === false) return false;
      i === void 0 && (i = null), e === void 0 && (e = null);
      const n = this.naturalBounds, o = this.Dn(), r = o ? t : Point2.U(t.x, t.y).je(this.E), l = this.fl(), h = Rect2.contains(0, 0, n.width, n.height, r.x, r.y);
      if (l || h) {
        if (!this.Rc) {
          const f = this.O.h, a = f.length, c = Point2.a(), u = this.ir();
          for (let d = a; d--; ) {
            const m = f[d];
            if (!m.visible && m !== u) continue;
            m.Dn() ? c.set(t).je(m.E) : c.set(t);
            let g = m;
            const p = m instanceof Panel2 ? m : null;
            if (p !== null ? p.qT(c, i, e, s) : g.containsPoint(c)) {
              if (g.pickable === false) continue;
              i !== null && (g = i(g)), g !== null && (e === null || e(g)) && s.add(g);
            }
          }
          Point2.o(c);
        }
        return o || Point2.o(r), h && this.background !== null;
      }
      return o || Point2.o(r), false;
    }
    i0(t, i, e, s, n, o) {
      if (this.pickable === false) return false;
      i === void 0 && (i = null), e === void 0 && (e = null);
      let r = o;
      if (r === void 0 && (r = Transform.a(), r.Ki()), r.Af(this.E), this.containedInRect(t, r)) return this.iC(i, e, n), o === void 0 && Transform.o(r), true;
      if (this.intersectsRect(t, r)) {
        if (!this.Rc) {
          const l = this.ir(), h = this.O.h, f = h.length;
          for (let a = f; a--; ) {
            const c = h[a];
            if (!c.visible && c !== l) continue;
            const u = c.actualBounds, d = this.naturalBounds;
            if (u.x > d.width || u.y > d.height || u.x + u.width < 0 || u.y + u.height < 0) continue;
            let m = c;
            const g = c instanceof Panel2 ? c : null, p = Transform.a();
            p.set(r), (g !== null ? g.i0(t, i, e, s, n, p) : m.tD(t, s, p)) && (i !== null && (m = i(m)), m !== null && (e === null || e(m)) && n.add(m)), Transform.o(p);
          }
        }
        return o === void 0 && Transform.o(r), s;
      }
      return o === void 0 && Transform.o(r), false;
    }
    iC(t, i, e) {
      const s = this.O.h, n = s.length;
      for (let o = n; o--; ) {
        const r = s[o];
        if (!r.visible) continue;
        const l = r.actualBounds, h = this.naturalBounds;
        if (l.x > h.width || l.y > h.height || l.x + l.width < 0 || l.y + l.height < 0) continue;
        r instanceof Panel2 && r.iC(t, i, e);
        let f = r;
        t !== null && (f = t(f)), f !== null && (i === null || i(f)) && e.add(f);
      }
    }
    HT(t, i, e, s, n, o) {
      if (this.pickable === false) return false;
      e === void 0 && (e = null), s === void 0 && (s = null);
      const r = this.naturalBounds, l = this.Dn(), h = l ? t : Point2.U(t.x, t.y).je(this.E), f = l ? i : Point2.U(i.x, i.y).je(this.E), a = h.distanceSquaredPoint(f), c = h.x > 0 && h.x < r.width && h.y > 0 && h.y < r.height || Point2.distanceLineSegmentSquared(h.x, h.y, 0, 0, 0, r.height) <= a || Point2.distanceLineSegmentSquared(h.x, h.y, 0, r.height, r.width, r.height) <= a || Point2.distanceLineSegmentSquared(h.x, h.y, r.width, r.height, r.width, 0) <= a || Point2.distanceLineSegmentSquared(h.x, h.y, r.width, 0, 0, 0) <= a, u = h.distanceSquared(0, 0) <= a && h.distanceSquared(0, r.height) <= a && h.distanceSquared(r.width, 0) <= a && h.distanceSquared(r.width, r.height) <= a;
      if (l || (Point2.o(h), Point2.o(f)), c) {
        if (!this.Rc) {
          const d = Point2.a(), m = Point2.a(), g = this.ir(), p = this.O.h, y = p.length;
          for (let x = y; x--; ) {
            const S = p[x];
            if (!S.visible && S !== g) continue;
            const b = S.actualBounds, k = this.naturalBounds;
            if (l && (b.x > k.width || b.y > k.height || b.x + b.width < 0 || b.y + b.height < 0)) continue;
            if (S.Dn()) {
              const C = S.E;
              d.set(t).je(C), m.set(i).je(C);
            } else d.set(t), m.set(i);
            let P = S;
            const A = S instanceof Panel2 ? S : null;
            (A !== null ? A.HT(d, m, e, s, n, o) : P.iD(d, m, n)) && (e !== null && (P = e(P)), P !== null && (s === null || s(P)) && o.add(P));
          }
          Point2.o(d), Point2.o(m);
        }
        return n ? c : u;
      }
      return false;
    }
    jN(t) {
      let i = null;
      if (t instanceof Shape2) {
        i = t.spot1, i === Spot2.Default && (i = null);
        const e = t.geometry;
        e !== null && i === null && (i = e.spot1);
      }
      return i === null && (i = Spot2.TopLeft), i;
    }
    JN(t) {
      let i = null;
      if (t instanceof Shape2) {
        i = t.spot2, i === Spot2.Default && (i = null);
        const e = t.geometry;
        e !== null && i === null && (i = e.spot2);
      }
      return i === null && (i = Spot2.BottomRight), i;
    }
    add(...t) {
      for (let i = 0; i < t.length; i++) this.insertAt(this.O.count, t[i]);
      return this;
    }
    elt(t) {
      return this.O.elt(t);
    }
    insertAt(t, i) {
      Debug && U.s(i, GraphObject2, Panel2, "insertAt"), i instanceof Part2 && U.n("Cannot add a Part to a Panel: " + i + "; use a Panel instead"), (this === i || this.isContainedBy(i)) && (this === i && U.n("Cannot make a Panel contain itself: " + this.toString()), U.n("Cannot make a Panel indirectly contain itself: " + this.toString() + " already contains " + i.toString()));
      const e = i.panel;
      if (e !== null && e !== this && U.n("Cannot add a GraphObject that already belongs to another Panel to this Panel: " + i.toString() + ", already contained by " + e.toString() + ", cannot be shared by this Panel: " + this.toString()), this.tt === Panel2.Grid && !(i instanceof Shape2) && U.n("Can only add Shapes to a Grid Panel, not: " + i), this.tt === Panel2.Graduated && !(i instanceof Shape2 || i instanceof TextBlock2) && U.n("Can only add Shapes or TextBlocks to a Graduated Panel, not: " + i), i.Ua(this), i.al = null, this.itemArray !== null) {
        const r = i.data;
        U.it(r) && (this.on === null && (this.on = new GMap2()), this.on.set(r, i));
      }
      const s = this.O;
      let n = -1;
      if (e === this) {
        let r = -1;
        const l = this.O.h, h = l.length;
        for (let f = 0; f < h; f++) if (l[f] === i) {
          r = f;
          break;
        }
        if (r !== -1) {
          if (r === t || r + 1 >= s.count && t >= s.count) return;
          s.removeAt(r), n = r;
        } else U.n("element " + i.toString() + " has panel " + e.toString() + " but is not contained by it.");
      }
      (t < 0 || t > s.count) && (t = s.count), s.insertAt(t, i), (t === 0 || i.isPanelMain) && (this.ul = null), this.Wo() || this.g(), i.g(false), i.portId !== null ? this.In = true : i instanceof Panel2 && i.In === true && (this.In = true), this.ys = null, this.isEnabledObject() || this.nS(i, false);
      const o = this.part;
      if (o !== null) {
        o.lp(), o.Oc(), this.In && o instanceof Node2 && (o.In = true), o.In && o instanceof Node2 && (o.ue = null);
        const r = this.diagram;
        if (r !== null && r.undoManager.isUndoingRedoing) return;
        n !== -1 && o.raiseChangedEvent(4, "elements", this, i, null, n, null), o.raiseChangedEvent(3, "elements", this, null, i, null, t);
      }
    }
    get In() {
      return (this.l & 8388608) !== 0;
    }
    set In(t) {
      (this.l & 8388608) !== 0 !== t && (this.l = this.l ^ 8388608);
    }
    DN() {
      return (this.l & 16777216) !== 0;
    }
    eC(t) {
      t ? this.l |= 16777216 : this.l &= -16777217;
    }
    J3(t) {
      t.Ua(this), t.al = null;
      const i = this.O, e = i.count;
      i.insertAt(e, t);
      const s = this.part;
      if (s !== null) {
        s.lp(), t.portId !== null && s instanceof Node2 && (s.In = true);
        const n = this.diagram;
        if (n !== null && n.undoManager.isUndoingRedoing) return;
        s.raiseChangedEvent(3, "elements", this, null, t, null, e);
      }
    }
    y3(t) {
      const i = this.O.h, e = i.length;
      let s = -1;
      for (let n = 0; n < e; n++) if (i[n] === t) {
        s = n;
        break;
      }
      return s;
    }
    remove(t) {
      Debug && U.s(t, GraphObject2, Panel2, "remove:element");
      const i = this.O.h, e = i.length;
      let s = -1;
      for (let n = 0; n < e; n++) if (i[n] === t) {
        s = n;
        break;
      }
      s !== -1 && this.ae(s, true);
    }
    removeAt(t) {
      Debug && U.r(t, Panel2, "removeAt:idx"), t >= 0 && this.ae(t, true);
    }
    ae(t, i) {
      const e = this.O, s = e.elt(t);
      if (s.al = null, s.Ua(null), this.on !== null) {
        const o = s.data;
        U.it(o) && this.on.delete(o);
      }
      e.removeAt(t), this.Se(false), this.g(), this.ul === s && (this.ul = null), this.ys = null;
      const n = this.part;
      if (n !== null) {
        n.lp(), n.Oc(), n.invalidateAdornments(), n instanceof Node2 && (s instanceof Panel2 ? s.walkVisualTreeFrom(s, (r, l) => n.zN(l, i)) : n.zN(s, i));
        const o = this.diagram;
        if (o !== null && o.undoManager.isUndoingRedoing) return;
        n.raiseChangedEvent(4, "elements", this, s, null, t, null);
      }
    }
    get es() {
      return this.V === null && (this.V = new TablePanelSettings()), this.V.es;
    }
    get rowCount() {
      return this.V === null ? 0 : this.es.length;
    }
    getRowDefinition(t) {
      Debug && U.r(t, Panel2, "getRowDefinition:idx"), t < 0 && U.G(t, ">= 0", Panel2, "getRowDefinition:idx"), t = Math.round(t);
      const i = this.es;
      if (i[t] === void 0) {
        const e = new RowColumnDefinition2();
        e.Ua(this), e.isRow = true, e.index = t, i[t] = e, this.raiseChangedEvent(3, "rowdefs", this, null, e, null, t);
      }
      return i[t];
    }
    removeRowDefinition(t) {
      if (Debug && U.r(t, Panel2, "removeRowDefinition:idx"), t < 0 && U.G(t, ">= 0", Panel2, "removeRowDefinition:idx"), this.rowCount === 0) return;
      t = Math.round(t);
      const i = this.es, e = i[t];
      if (e) {
        i[t] = void 0;
        let s = i.length - 1;
        for (; s >= 0 && i[s--] === void 0; ) i.length--;
        this.raiseChangedEvent(4, "rowdefs", this, e, null, t, null), this.g();
      }
    }
    PL(t, i) {
      const e = this.es;
      if (!(t < 0)) {
        if (e[t] = i instanceof RowColumnDefinition2 ? i : void 0, !i) {
          let s = e.length - 1;
          for (; s >= 0 && e[s--] === void 0; ) e.length--;
        }
        this.g();
      }
    }
    get ss() {
      return this.V === null && (this.V = new TablePanelSettings()), this.V.ss;
    }
    get columnCount() {
      return this.V === null ? 0 : this.ss.length;
    }
    getColumnDefinition(t) {
      Debug && U.r(t, Panel2, "getColumnDefinition:idx"), t < 0 && U.G(t, ">= 0", Panel2, "getColumnDefinition:idx"), t = Math.round(t);
      const i = this.ss;
      if (i[t] === void 0) {
        const e = new RowColumnDefinition2();
        e.Ua(this), e.isRow = false, e.index = t, i[t] = e, this.raiseChangedEvent(3, "coldefs", this, null, e, null, t);
      }
      return i[t];
    }
    removeColumnDefinition(t) {
      if (Debug && U.r(t, Panel2, "removeColumnDefinition:idx"), t < 0 && U.G(t, ">= 0", Panel2, "removeColumnDefinition:idx"), this.columnCount === 0) return;
      t = Math.round(t);
      const i = this.ss, e = i[t];
      if (e) {
        i[t] = void 0;
        let s = i.length - 1;
        for (; s >= 0 && i[s--] === void 0; ) i.length--;
        this.raiseChangedEvent(4, "coldefs", this, e, null, t, null), this.g();
      }
    }
    ML(t, i) {
      const e = this.ss;
      if (!(t < 0)) {
        if (e[t] = i instanceof RowColumnDefinition2 ? i : void 0, !i) {
          let s = e.length - 1;
          for (; s >= 0 && e[s--] === void 0; ) e.length--;
        }
        this.g();
      }
    }
    addRowColumnDefinition(t) {
      let i = null;
      return t.isRow ? i = this.getRowDefinition(t.index) : t.isRow || (i = this.getColumnDefinition(t.index)), i && i.jb(t), this;
    }
    addRowDefinition(t, i) {
      const e = this.getRowDefinition(t);
      return e && e.jb(new RowColumnDefinition2(i)), this;
    }
    addColumnDefinition(t, i) {
      const e = this.getColumnDefinition(t);
      return e && e.jb(new RowColumnDefinition2(i)), this;
    }
    get rowSizing() {
      return this.V !== null ? this.V.Up : 3;
    }
    set rowSizing(t) {
      const i = this.rowSizing;
      i !== t && (Debug && t !== 3 && t !== 2 && U.n("Panel.rowSizing must be ProportionalExtra or None, not: " + t), this.V === null && (this.V = new TablePanelSettings()), this.V.Up = t, this.g(), this.t("rowSizing", i, t));
    }
    get columnSizing() {
      return this.V !== null ? this.V.Gp : 3;
    }
    set columnSizing(t) {
      const i = this.columnSizing;
      i !== t && (Debug && t !== 3 && t !== 2 && U.n("Panel.columnSizing must be ProportionalExtra or None, not: " + t), this.V === null && (this.V = new TablePanelSettings()), this.V.Gp = t, this.g(), this.t("columnSizing", i, t));
    }
    get topIndex() {
      return this.V !== null ? this.V.qp : 0;
    }
    set topIndex(t) {
      const i = this.topIndex;
      i !== t && ((!isFinite(t) || t < 0) && U.n("Panel.topIndex must be greater than zero and a real number, not: " + t), this.V === null && (this.V = new TablePanelSettings()), this.V.qp = t, this.g(), this.t("topIndex", i, t));
    }
    get leftIndex() {
      return this.V !== null ? this.V.Hp : 0;
    }
    set leftIndex(t) {
      const i = this.leftIndex;
      i !== t && ((!isFinite(t) || t < 0) && U.n("Panel.leftIndex must be greater than zero and a real number, not: " + t), this.V === null && (this.V = new TablePanelSettings()), this.V.Hp = t, this.g(), this.t("leftIndex", i, t));
    }
    findRowForLocalY(t) {
      if (t < 0 || this.type !== Panel2.Table || this.rowCount === 0) return -1;
      let i = 0;
      const e = this.es, s = e.length;
      let n = this.topIndex;
      for (; n < s; n++) {
        const o = e[n];
        if (o !== void 0 && (i += o.total, t < i)) return n;
      }
      return n;
    }
    findColumnForLocalX(t) {
      if (t < 0 || this.type !== Panel2.Table || this.columnCount === 0) return -1;
      let i = 0;
      const e = this.ss, s = e.length;
      let n = this.leftIndex;
      for (; n < s; n++) {
        const o = e[n];
        if (o !== void 0 && (i += o.total, t < i)) return n;
      }
      return n;
    }
    graduatedPointForValue(t, i) {
      if (i === void 0 && (i = new Point2(NaN, NaN)), this.type !== Panel2.Graduated) return i.e(NaN, NaN), i;
      t = Math.min(Math.max(t, this.graduatedMin), this.graduatedMax);
      const e = this.findMainElement();
      return e.geometry.getPointAlongPath((t - this.graduatedMin) / this.graduatedRange, i), e.E.St(i);
    }
    graduatedValueForPoint(t) {
      if (this.type !== Panel2.Graduated) return NaN;
      const i = this.findMainElement();
      return i.E.De(t), i.geometry.getFractionForPoint(t) * this.graduatedRange + this.graduatedMin;
    }
    get data() {
      return this.oi;
    }
    set data(t) {
      const i = this.oi;
      if (i !== t) {
        const e = this instanceof Part2 && !(this instanceof Adornment2);
        e && U.i(t, "object", Panel2, "data"), this.Yt(), this.oi = t;
        const s = this.diagram;
        if (s !== null) if (e) {
          s.partManager._3(this, i, t);
          let n = this.adornments;
          for (; n.next(); ) {
            const o = n.value, r = o.adornedObject;
            if (r !== null) {
              const l = r.findBindingPanel();
              l !== null && (o.data = l.data);
            }
          }
        } else {
          const n = this.panel;
          n !== null && n.on !== null && (i !== null && n.on.delete(i), t !== null && n.on.set(t, this));
        }
        if (this.t("data", i, t), s !== null && s.undoManager.isUndoingRedoing) return;
        t !== null && this.updateTargetBindings();
      }
    }
    get itemIndex() {
      return this.Vd;
    }
    set itemIndex(t) {
      const i = this.Vd;
      i !== t && (Debug && U.i(t, "number", Panel2, "itemIndex"), this.Vd = t, this.t("itemIndex", i, t));
    }
    get Es() {
      return this.k !== null ? this.k.Es : null;
    }
    set Es(t) {
      this.Ei !== t && (this.k === null && (this.k = new GraphObjectTemplateSettings()), this.k.Es = t);
    }
    XN() {
      return this.Es !== null;
    }
    fD() {
      const t = this.Es;
      return t !== null && t.u;
    }
    freezeBindings() {
      return this.Yt();
    }
    Yt() {
      let t = this.Es;
      if (t === null) this.data !== null && U.n("Template cannot have .data be non-null: " + this), this.Es = t = new List2();
      else if (t.u) return this;
      const i = new List2();
      this.eC(false), this.walkVisualTreeFrom(this, (n, o) => {
        o.Ch();
        const r = o.Ei;
        if (r !== null) {
          o.EN(false);
          const l = r.iterator;
          for (; l.next(); ) {
            const h = l.value;
            h.mode === 2 && o.EN(true);
            const f = h.sourceName;
            if (h.isToObject) {
              f === "/" && n.eC(true);
              const a = h._L(n, o);
              a !== null && (i.add(a), a.fo === null && (a.fo = new List2()), a.fo.add(h));
            }
            t.add(h);
          }
        }
        if (o instanceof Panel2 && o.type === Panel2.Table) {
          if (o.rowCount > 0) {
            const l = o.es, h = l.length;
            for (let f = 0; f < h; f++) {
              const a = l[f];
              if (a !== void 0 && a.Vs !== null) {
                const c = a.Vs.iterator;
                for (; c.next(); ) {
                  const u = c.value;
                  u.Re = a, u.Yd = 2, u.Ec = a.index, t.add(u);
                }
              }
            }
          }
          if (o.columnCount > 0) {
            const l = o.ss, h = l.length;
            for (let f = 0; f < h; f++) {
              const a = l[f];
              if (a !== void 0 && a.Vs !== null) {
                const c = a.Vs.iterator;
                for (; c.next(); ) {
                  const u = c.value;
                  u.Re = a, u.Yd = 1, u.Ec = a.index, t.add(u);
                }
              }
            }
          }
        }
      });
      const e = i.iterator;
      for (; e.next(); ) {
        const n = e.value;
        if (n.fo !== null) {
          n.EN(true);
          const o = n.fo.iterator;
          for (; o.next(); ) {
            const r = o.value;
            n.Ei === null && (n.Ei = new List2()), n.Ei.add(r);
          }
        }
        n.fo = null;
      }
      let s = t.iterator;
      for (; s.next(); ) {
        const n = s.value;
        let o = n.Re;
        if (o !== null) {
          n.Re = null;
          const r = n.targetProperty, l = r.indexOf(".");
          if (l > 0 && o instanceof Panel2) {
            const h = r.substring(0, l), f = r.substring(l + 1), a = o.findObject(h);
            a !== null ? (o = a, n.targetProperty = f) : (U.ot('Warning: unable to find GraphObject named "' + h + '" for Binding: ' + n.toString()), o = null);
          }
          if (o instanceof RowColumnDefinition2) {
            const h = GSet2.Ps(o.panel);
            n.targetId = h === void 0 ? -1 : h, o.panel.ao = n.targetId;
          } else if (o instanceof GraphObject2) {
            const h = GSet2.Ps(o);
            n.targetId = h === void 0 ? -1 : h, o.ao = n.targetId;
          } else U.n("Unknown type of binding target: " + o);
          n.check(o);
        }
      }
      return t.S(), this instanceof Part2 && (this.Oe() && this.ensureBounds(), Debug && !Panel2.MD && this.walkVisualTreeFrom(this, (n, o) => {
        if (o instanceof Panel2 && (o.type === Panel2.Auto || o.type === Panel2.Spot || o.type === Panel2.Graduated) && o.elements.count <= 1 && !(o instanceof Part2)) {
          let r = false;
          if (o.elements.count === 1 && (r = o.itemArray !== null, !r)) {
            for (s = t.iterator; s.next(); ) if (s.value.targetProperty === "itemArray") {
              r = true;
              break;
            }
          }
          r || (U.ot("Auto, Spot, or Graduated Panel should not have zero or one elements: " + o.toString() + " in " + n.toString()), Panel2.MD = true);
        }
      })), this;
    }
    static MD = false;
    copyTemplate(t) {
      t === void 0 && (t = false);
      const i = this.copy();
      return i.$3((e) => {
        e instanceof Panel2 && (e.Es = null, e.oi = null);
        const s = e.Ei;
        s !== null && (e.Ei = null, s.each((o) => e.bind(o.copy())));
        const n = e.Os;
        n !== null && (e.Os = null, n.each((o) => e.trigger(o.value.copy())));
      }), t && i.Yt(), i;
    }
    updateTargetBindings(t) {
      const i = this.Es;
      if (i === null) return;
      t === void 0 && (t = "");
      const e = this.diagram?.model, s = i.iterator;
      for (; s.next(); ) {
        const n = s.value, o = this.sC(n, t);
        if (o === null) continue;
        const { data: r, elt: l } = o;
        n.isToTheme && this.diagram === null || l !== void 0 && n.updateTarget(l, r, void 0, e);
      }
    }
    tE(t) {
      if (t === "") {
        this.updateTargetBindings(t);
        return;
      }
      const i = this.Es;
      if (i === null) return;
      const e = this.diagram?.model, s = i.iterator;
      for (; s.next(); ) {
        const n = s.value;
        if (n.isToData && n.sourceProperty !== "") continue;
        const o = this.sC(n, "");
        if (o === null) continue;
        const { data: r, elt: l } = o;
        l !== void 0 && n.updateTarget(l, r, void 0, e);
      }
    }
    jo() {
      if (this.diagram !== null) if (this.XN()) {
        const t = this.diagram.model, i = this.Es.iterator;
        for (; i.next(); ) {
          const e = i.value;
          if (!e.isToTheme) continue;
          const s = this.sC(e);
          if (s === null) continue;
          const { data: n, elt: o } = s;
          o !== void 0 && e.updateTarget(o, n, void 0, t);
        }
      } else {
        const t = this.O.h, i = t.length;
        for (let e = 0; e < i; e++) t[e].jo();
      }
    }
    sC(t, i = "") {
      const e = t.sourceProperty;
      if (i !== "" && e !== "" && e !== i) return null;
      const s = t.targetProperty;
      if (t.converter === null && s === "") return null;
      let o = this.data;
      const r = t.sourceName;
      if (t.isToObject) {
        if (o = this.QL(r), o === null) return null;
      } else if (t.isToModel) {
        const a = this.diagram;
        if (a === null) return null;
        o = a.model.modelData;
      }
      let l = this;
      const h = t.targetId;
      if (h !== -1) {
        if (l = this.W0(h), l === null) return null;
      } else t.Re !== null && (l = t.Re);
      r === "/" ? o = l.part : r === "." ? o = l : r === ".." && (o = l.panel);
      const f = t.Yd;
      if (f !== 0) {
        if (!(l instanceof Panel2)) return null;
        f === 1 ? l = l.getColumnDefinition(t.Ec) : f === 2 && (l = l.getRowDefinition(t.Ec));
      }
      return { data: o, elt: l };
    }
    get itemArray() {
      return this.Oh;
    }
    set itemArray(t) {
      Debug && t !== null && !Array.isArray(t) && U.n("Panel.itemArray must be an Array-like object or null, not: " + t);
      const i = this.Oh;
      if (i !== t || t !== null && this.iE(t)) {
        const e = this.diagram;
        if (i !== t && (e !== null && i !== null && e.partManager.F2(this, e), this.Oh = t, e !== null && t !== null && e.partManager.D2(this, e)), this.t("itemArray", i, t), e !== null && e.undoManager.isUndoingRedoing) return;
        this.ND(i, t);
      }
    }
    findItemPanelForData(t) {
      return t == null || this.on === null ? null : (U.Oo(t, Panel2, "findItemPanelForData"), this.on.get(t));
    }
    iE(t) {
      const i = this.O.h, e = i.length, s = t.length;
      let n = 0, o = null;
      for (; n < e && (o = i[n], !(o instanceof Panel2) || o.data === null); ) n++, o = i[n];
      if (e - n !== s) return true;
      if (o === null) return s > 0;
      let r = 0;
      for (; n < e && r < s; ) {
        if (o = i[n], !(o instanceof Panel2) || o.data !== t[r]) return true;
        n++, r++;
      }
      return false;
    }
    Kp() {
      if (this.type === Panel2.Spot || this.type === Panel2.Auto) return Math.min(this.O.length, 1);
      if (this.type === Panel2.Link) {
        const t = this.O, i = t.length;
        let e = 0;
        for (; e < i; e++) {
          const s = t.elt(e);
          if (!(s instanceof Shape2) || !s.isPanelMain) return e;
        }
        return e;
      }
      if (this.type === Panel2.Table && this.O.length > 0) {
        const i = this.O.elt(0);
        if (i.isPanelMain && i instanceof Panel2 && i.fl()) return 1;
      }
      return 0;
    }
    rebuildItemElements() {
      const t = this.Kp();
      for (; this.O.length > t; ) this.ae(this.O.length - 1, false);
      this.ND(null, this.itemArray);
    }
    ND(t, i) {
      const e = this.Kp(), s = i;
      if (s === null || s.length === 0) {
        for (; this.O.length > e; ) this.ae(this.O.length - 1, false);
        return;
      }
      if (this.O.length <= e) {
        const n = s.length;
        for (let o = 0; o < n; o++) this.oS(s[o], o, true);
      } else {
        let n = e;
        for (let r = 0; r < s.length; r++, n++) {
          const l = s[r], h = n < this.O.length ? this.O.elt(n) : null;
          if (h instanceof Panel2) {
            if (h.data !== l) {
              const f = this.nC(h.data, r), a = this.nC(l, r);
              let c = a !== f;
              if (!c) {
                const u = this.oC(h.data, r, f);
                c = this.oC(l, r, a) !== u;
              }
              c ? (this.ae(n, false), this.oS(l, r, false)) : h.data = l;
            }
          } else this.oS(l, r, false);
        }
        for (; n < this.O.length; ) this.ae(n, false);
        this.ul = null, this.rC(e, 0), this.Wo() || this.g(), this.ys = null, this.isEnabledObject() || this.nS(this, false);
        const o = this.part;
        o !== null && (o.lp(), o.Oc(), this.In && o instanceof Node2 && (o.In = true), o.In && o instanceof Node2 && (o.ue = null));
      }
    }
    oS(t, i, e) {
      if (t == null || i < 0) return;
      const s = this.nC(t, i), n = this.oC(t, i, s);
      if (n !== null) {
        n.Yt();
        const o = n.copy();
        if (o.DN()) {
          const l = this.findBindingPanel();
          l !== null && l.eC(true);
        }
        U.it(t) && (this.on === null && (this.on = new GMap2()), this.on.set(t, o));
        const r = i + this.Kp();
        this.insertAt(r, o), e && (o.oi = t, this.rC(r, i), o.oi = null), o.data = t;
      }
    }
    eE(t) {
      if (t < 0) return;
      const i = t + this.Kp();
      this.ae(i, true), this.rC(i, t);
    }
    rC(t, i) {
      const e = this.O;
      let s = t, n = i;
      for (; s < e.length; ) {
        const o = e.elt(s);
        o instanceof Panel2 && o.sE(s, n), s++, n++;
      }
    }
    sE(t, i) {
      this.type === Panel2.TableRow ? this.row = t : this.type === Panel2.TableColumn && (this.column = t), this.itemIndex = i;
    }
    Z3() {
      return this.Oh !== null || this.itemTemplateMap !== null;
    }
    get itemTemplate() {
      const t = this.itemTemplateMap;
      if (t !== null) {
        const i = t.get("");
        if (i) return i;
      }
      return Panel2.CD();
    }
    set itemTemplate(t) {
      const i = this.itemTemplate;
      if (i !== t) {
        U.s(t, Panel2, Panel2, "itemTemplate"), (t instanceof Part2 || t.isPanelMain) && U.n("Panel.itemTemplate must not be a Part or be Panel.isPanelMain: " + t), this.itemTemplateMap === null && (this.itemTemplateMap = new GMap2()), this.itemTemplateMap.set("", t), this.t("itemTemplate", i, t);
        const e = this.diagram;
        if (e !== null && e.undoManager.isUndoingRedoing) return;
        this.rebuildItemElements();
      }
    }
    get itemTemplateMap() {
      return this.k !== null ? this.k.Pp : null;
    }
    set itemTemplateMap(t) {
      const i = this.itemTemplateMap;
      if (i !== t) {
        U.s(t, GMap2, Panel2, "itemTemplateMap");
        const e = t.iterator;
        for (; e.next(); ) {
          const n = e.value;
          Debug && (n instanceof Part2 || n.isPanelMain) && U.n("Template in Panel.itemTemplateMap must not be a Part or be Panel.isPanelMain: " + n);
        }
        this.jt().Pp = t, this.t("itemTemplateMap", i, t);
        const s = this.diagram;
        if (s !== null && s.undoManager.isUndoingRedoing) return;
        this.rebuildItemElements();
      }
    }
    get itemCategoryProperty() {
      return this.k !== null ? this.k.Mp : "category";
    }
    set itemCategoryProperty(t) {
      const i = this.itemCategoryProperty;
      i !== t && (typeof t != "string" && !U.at(t) && U.Ti(t, "string or function", Panel2, "itemCategoryProperty"), this.jt().Mp = t, this.t("itemCategoryProperty", i, t));
    }
    nC(t, i) {
      if (t === null) return "";
      const e = this.itemCategoryProperty;
      let s = "";
      if (U.at(e)) s = e(t);
      else if (typeof e == "string" && U.it(t)) {
        if (e === "") return "";
        const n = this.diagram, o = n !== null ? n.model : null;
        o ? s = o.Lt(t, e) : s = Model2.Lt(t, e);
      } else return "";
      if (s === void 0) return "";
      if (typeof s == "string") return s;
      U.n("Panel.getCategoryForItemData found a non-string category for " + t + ": " + s);
    }
    static AD = false;
    static lC;
    static CD() {
      return Panel2.lC || (Panel2.lC = new Panel2().add(new TextBlock2().bind("text", "", U.toString).theme("stroke", "text"))), Panel2.lC;
    }
    oC(t, i, e) {
      let s = null;
      const n = this.itemTemplateMap;
      return n !== null && (s = n.get(e), s === null && (s = n.get(""))), s === null && (Panel2.AD || (Panel2.AD = true, U.ot('No item template Panel found for category "' + e + '" on ' + this), U.ot("  Using default item template.")), s = Panel2.CD()), s;
    }
    get Rc() {
      return (this.l & 1048576) !== 0;
    }
    set Rc(t) {
      const i = (this.l & 1048576) !== 0;
      i !== t && (U.i(t, "boolean", Panel2, "isAtomic"), this.l = this.l ^ 1048576, this.t("isAtomic", i, t));
    }
    get isClipping() {
      return (this.l & 2097152) !== 0;
    }
    set isClipping(t) {
      const i = (this.l & 2097152) !== 0;
      i !== t && (this.Pc(), Debug && (U.i(t, "boolean", Panel2, "isClipping"), t && this.type !== Panel2.Spot && !(this instanceof Group2) && U.ot("Warning: Panel.isClipping set on non-Spot Panel: " + this.toString())), this.l = this.l ^ 2097152, this instanceof Group2 && (this.ui = null), this.g(), this.t("isClipping", i, t));
    }
    get isOpposite() {
      return (this.l & 33554432) !== 0;
    }
    set isOpposite(t) {
      const i = (this.l & 33554432) !== 0;
      i !== t && (Debug && U.i(t, "boolean", Panel2, "isOpposite"), this.l = this.l ^ 33554432, this.g(), this.t("isOpposite", i, t));
    }
    get isEnabled() {
      return (this.l & 4194304) !== 0;
    }
    set isEnabled(t) {
      const i = (this.l & 4194304) !== 0;
      if (i !== t) {
        Debug && U.i(t, "boolean", Panel2, "isEnabled");
        const e = this.panel === null || this.panel.isEnabledObject();
        this.l = this.l ^ 4194304, this.t("isEnabled", i, t);
        const s = this.diagram;
        if (s !== null && s.undoManager.isUndoingRedoing) return;
        e && this.nS(this, t);
      }
    }
    nS(t, i) {
      const e = t.enabledChanged;
      if (e !== null && e(t, i), t instanceof Panel2) {
        const s = t.O.h, n = s.length;
        for (let o = 0; o < n; o++) {
          const r = s[o];
          i && r instanceof Panel2 && !r.isEnabled || this.nS(r, i);
        }
      }
    }
    get alignmentFocusName() {
      return this.yo;
    }
    set alignmentFocusName(t) {
      const i = this.yo;
      i !== t && (Debug && U.i(t, "string", Panel2, "alignmentFocusName"), this.yo = t, this.g(), this.t("alignmentFocusName", i, t));
    }
    static definePanelLayout(t, i) {
      PanelLayout2.On(t, i);
    }
    static isLayoutDefined(t) {
      return PanelLayout2.ms.has(t);
    }
    static Position = PanelLayout2.ms.get("Position");
    static Horizontal = PanelLayout2.ms.get("Horizontal");
    static Vertical = PanelLayout2.ms.get("Vertical");
    static Spot = PanelLayout2.ms.get("Spot");
    static Auto = PanelLayout2.ms.get("Auto");
    static Table = PanelLayout2.ms.get("Table");
    static Viewbox = PanelLayout2.ms.get("Viewbox");
    static TableRow = PanelLayout2.ms.get("TableRow");
    static TableColumn = PanelLayout2.ms.get("TableColumn");
    static Link = PanelLayout2.ms.get("Link");
    static Grid = PanelLayout2.ms.get("Grid");
    static Graduated = PanelLayout2.ms.get("Graduated");
  }
  Panel2.definePanelLayout = Panel2.definePanelLayout;
  class GradPanelSettings {
    Vp;
    zp;
    Xp;
    Yp;
    Bs;
    ns;
    ys;
    Ee;
    constructor() {
      this.Vp = 0, this.zp = 100, this.Xp = 10, this.Yp = 0, this.Bs = null, this.ns = null, this.ys = null, this.Ee = null;
    }
    copy() {
      const t = new GradPanelSettings();
      return t.Vp = this.Vp, t.zp = this.zp, t.Xp = this.Xp, t.Yp = this.Yp, t.Bs = this.Bs, t.ns = this.ns, t.ys = this.ys, t.Ee = this.Ee, t;
    }
  }
  class GridPanelSettings {
    zd;
    Xd;
    dc;
    Lp;
    constructor() {
      this.zd = Size2.zA, this.Xd = Point2.wn, this.dc = Size2.ix, this.Lp = [];
    }
    copy() {
      const t = new GridPanelSettings();
      return t.zd = this.zd.copy(), t.Xd = this.Xd.copy(), t.dc = this.dc.copy(), t.Lp = this.Lp, t;
    }
  }
  class TablePanelSettings {
    es;
    ss;
    Up;
    Gp;
    qp;
    Hp;
    Dp;
    Ip;
    Fp;
    Rp;
    Ep;
    Op;
    Bp;
    Rh;
    constructor() {
      this.es = [], this.ss = [], this.Up = 3, this.Gp = 3, this.qp = 0, this.Hp = 0, this.Dp = Margin2.lm, this.Ip = 1, this.Fp = null, this.Rp = null, this.Ep = 1, this.Op = null, this.Bp = null, this.Rh = null;
    }
    copy(t) {
      const i = new TablePanelSettings(), e = this.es, s = e.length, n = i.es;
      for (let h = 0; h < s; h++) {
        const f = e[h];
        if (f === void 0) continue;
        const a = f.copy();
        a.Ua(t), n[h] = a;
      }
      const o = this.ss, r = o.length, l = i.ss;
      for (let h = 0; h < r; h++) {
        const f = o[h];
        if (f === void 0) continue;
        const a = f.copy();
        a.Ua(t), l[h] = a;
      }
      return i.Up = this.Up, i.Gp = this.Gp, i.qp = this.qp, i.Hp = this.Hp, i.Dp = this.Dp.T(), i.Ip = this.Ip, i.Fp = this.Fp, i.Rp = this.Rp, i.Ep = this.Ep, i.Op = this.Op, i.Bp = this.Bp, i.Rh = this.Rh, i;
    }
  }
  var Sizing2 = ((w) => (w[w.Default = 1] = "Default", w[w.None = 2] = "None", w[w.ProportionalExtra = 3] = "ProportionalExtra", w))(Sizing2 || {});
  class RowColumnDefinition2 {
    en;
    vp;
    Et;
    va;
    Wa;
    pi;
    yt;
    Kd;
    go;
    dl;
    Ud;
    Gd;
    ja;
    It;
    qd;
    Vs;
    $;
    Vi;
    Pe;
    constructor(t) {
      GSet2._i(this), this.en = null, this.vp = true, this.Et = 0, this.Pe = NaN, this.va = 0, this.Wa = 1 / 0, this.pi = Spot2.Default, this.$ = 0, this.Vi = 0, this.yt = 0, this.Vs = null, this.Kd = 1, this.go = 1, this.dl = null, this.Ud = null, this.Gd = NaN, this.ja = null, this.It = null, this.qd = false, t && (Object.assign(this, t), t.column !== void 0 ? (this.isRow = false, this.index = t.column) : t.row !== void 0 && (this.isRow = true, this.index = t.row));
    }
    copy() {
      const t = new RowColumnDefinition2();
      return t.vp = this.vp, t.Et = this.Et, t.Pe = this.Pe, t.va = this.va, t.Wa = this.Wa, t.pi = this.pi, t.$ = this.$, t.Vi = this.Vi, t.yt = this.yt, t.go = this.go, t.Kd = this.Kd, this.dl === null ? t.dl = null : t.dl = this.dl.T(), t.Ud = this.Ud, t.Gd = this.Gd, t.ja = null, this.ja !== null && (t.separatorDashArray = this.ja.slice()), t.It = this.It, t.qd = this.qd, t.Vs = this.Vs, t;
    }
    jb(t) {
      t.isRow ? t.height !== void 0 && (this.height = t.height) : t.width !== void 0 && (this.width = t.width), t.minimum !== void 0 && (this.minimum = t.minimum), t.maximum !== void 0 && (this.maximum = t.maximum), t.alignment !== void 0 && (this.alignment = t.alignment), t.stretch !== void 0 && (this.stretch = t.stretch), t.sizing !== void 0 && (this.sizing = t.sizing), t.separatorPadding !== void 0 && (this.separatorPadding = t.separatorPadding), t.separatorStroke !== void 0 && (this.separatorStroke = t.separatorStroke), t.separatorStrokeWidth !== void 0 && (this.separatorStrokeWidth = t.separatorStrokeWidth), t.separatorDashArray !== void 0 && (this.ja = t.separatorDashArray), t.background !== void 0 && (this.background = t.background), t.coversSeparators !== void 0 && (this.coversSeparators = t.coversSeparators), t.Vs !== void 0 && (this.Vs = t.Vs);
    }
    gi(t) {
      t in Sizing2 ? this.sizing = t : U.xr(this, t);
    }
    toString() {
      return "RowColumnDefinition " + (this.isRow ? "(Row " : "(Column ") + this.index + ") #" + GSet2.Ps(this);
    }
    static Default = 1;
    static None = 2;
    static ProportionalExtra = 3;
    Ua(t) {
      this.en = t;
    }
    computeEffectiveSpacingTop(t) {
      let i = 0;
      const e = this.en;
      if (this.index !== t) {
        let n = this.separatorStroke;
        n === null && e !== null && (n = this.isRow ? e.defaultRowSeparatorStroke : e.defaultColumnSeparatorStroke), n !== null && (i = this.separatorStrokeWidth, isNaN(i) && (e !== null ? i = this.isRow ? e.defaultRowSeparatorStrokeWidth : e.defaultColumnSeparatorStrokeWidth : i = 0));
      }
      let s = this.dl;
      if (s === null) if (e !== null) s = e.defaultSeparatorPadding;
      else return i;
      return i + (this.isRow ? s.top : s.left);
    }
    computeEffectiveSpacing() {
      let t = 0;
      const i = this.en;
      let e = 0;
      const s = this.isRow;
      if (i !== null && i.type === Panel2.Table) {
        const o = s ? i.es.length : i.ss.length;
        for (let r = 0; r < o; r++) {
          const l = s ? i.es[r] : i.ss[r];
          if (l !== void 0 && l.$ !== 0) {
            e = l.index;
            break;
          }
        }
      }
      if (this.index !== e) {
        let o = this.separatorStroke;
        o === null && i !== null && (o = s ? i.defaultRowSeparatorStroke : i.defaultColumnSeparatorStroke), o !== null && (t = this.separatorStrokeWidth, isNaN(t) && (i !== null ? t = s ? i.defaultRowSeparatorStrokeWidth : i.defaultColumnSeparatorStrokeWidth : t = 0));
      }
      let n = this.dl;
      if (n === null) if (i !== null) n = i.defaultSeparatorPadding;
      else return t;
      return t + (this.isRow ? n.top + n.bottom : n.left + n.right);
    }
    t(t, i, e, s, n) {
      const o = this.en;
      if (o !== null && (o.raiseChangedEvent(2, t, this, i, e, s, n), this.Vs !== null)) {
        const r = o.diagram;
        if (r !== null && !r.be) {
          const l = o.findBindingPanel();
          if (l !== null) {
            const h = l.data;
            if (h !== null) {
              const f = this.Vs.iterator;
              for (; f.next(); ) f.value.updateSource(this, h, t, l);
            }
          }
        }
      }
    }
    get panel() {
      return this.en;
    }
    get isRow() {
      return this.vp;
    }
    set isRow(t) {
      this.vp = t;
    }
    get index() {
      return this.Et;
    }
    set index(t) {
      this.Et = t;
    }
    get height() {
      return this.Pe;
    }
    set height(t) {
      const i = this.Pe;
      i !== t && (Debug && U.i(t, "number", RowColumnDefinition2, "height"), t < 0 && U.G(t, ">= 0", RowColumnDefinition2, "height"), this.Pe = t, this.actual = this.$, this.panel !== null && this.panel.g(), this.t("height", i, t));
    }
    get width() {
      return this.Pe;
    }
    set width(t) {
      const i = this.Pe;
      i !== t && (Debug && U.i(t, "number", RowColumnDefinition2, "width"), t < 0 && U.G(t, ">= 0", RowColumnDefinition2, "width"), this.Pe = t, this.actual = this.$, this.panel !== null && this.panel.g(), this.t("width", i, t));
    }
    get minimum() {
      return this.va;
    }
    set minimum(t) {
      const i = this.va;
      i !== t && (Debug && U.i(t, "number", RowColumnDefinition2, "minimum"), (t < 0 || !isFinite(t)) && U.G(t, ">= 0", RowColumnDefinition2, "minimum"), this.va = t, this.actual = this.$, this.panel !== null && this.panel.g(), this.t("minimum", i, t));
    }
    get maximum() {
      return this.Wa;
    }
    set maximum(t) {
      const i = this.Wa;
      i !== t && (Debug && U.i(t, "number", RowColumnDefinition2, "maximum"), t < 0 && U.G(t, ">= 0", RowColumnDefinition2, "maximum"), this.Wa = t, this.actual = this.$, this.panel !== null && this.panel.g(), this.t("maximum", i, t));
    }
    get alignment() {
      return this.pi;
    }
    set alignment(t) {
      const i = this.pi;
      i.equals(t) || (Debug && U.s(t, Spot2, RowColumnDefinition2, "alignment"), this.pi = t.T(), this.panel !== null && this.panel.g(), this.t("alignment", i, t));
    }
    get stretch() {
      return this.go;
    }
    set stretch(t) {
      const i = this.go;
      i !== t && (this.go = t, this.panel !== null && this.panel.g(), this.t("stretch", i, t));
    }
    get separatorPadding() {
      return this.dl;
    }
    set separatorPadding(t) {
      typeof t == "number" ? t = new Margin2(t) : t !== null && Debug && U.s(t, Margin2, RowColumnDefinition2, "separatorPadding");
      const i = this.dl;
      (t === null || i === null || !i.equals(t)) && (t !== null && (t = t.T()), this.dl = t, this.panel !== null && this.panel.g(), this.t("separatorPadding", i, t));
    }
    get separatorStroke() {
      return this.Ud;
    }
    set separatorStroke(t) {
      const i = this.Ud;
      i !== t && (t !== null && Brush2.Ld(t, "RowColumnDefinition.separatorStroke"), t instanceof Brush2 && t.S(), this.Ud = t, this.panel !== null && this.panel.g(), this.t("separatorStroke", i, t));
    }
    get separatorStrokeWidth() {
      return this.Gd;
    }
    set separatorStrokeWidth(t) {
      const i = this.Gd;
      i !== t && (this.Gd = t, this.panel !== null && this.panel.g(), this.t("separatorStrokeWidth", i, t));
    }
    get separatorDashArray() {
      return this.ja;
    }
    set separatorDashArray(t) {
      const i = this.ja;
      if (i !== t) {
        if (t !== null && !Array.isArray(t) && U.Ti(t, "Array", RowColumnDefinition2, "separatorDashArray:value"), t !== null) {
          const e = t.length;
          let s = 0;
          for (let n = 0; n < e; n++) {
            const o = t[n];
            (typeof o != "number" || !(o >= 0) || !isFinite(o)) && U.n("separatorDashArray value " + o + " at index " + n + " must be a positive number or zero."), s += o;
          }
          if (s === 0) {
            if (i === null) return;
            t = null;
          }
        }
        this.ja = t, this.panel !== null && this.panel.L(), this.t("separatorDashArray", i, t);
      }
    }
    get background() {
      return this.It;
    }
    set background(t) {
      const i = this.It;
      i !== t && (t !== null && Brush2.Ld(t, "RowColumnDefinition.background"), t instanceof Brush2 && t.S(), this.It = t, this.panel !== null && this.panel.L(), this.t("background", i, t));
    }
    get coversSeparators() {
      return this.qd;
    }
    set coversSeparators(t) {
      const i = this.qd;
      i !== t && (U.i(t, "boolean", RowColumnDefinition2, "coversSeparators"), this.qd = t, this.panel !== null && this.panel.L(), this.t("coversSeparators", i, t));
    }
    get sizing() {
      return this.Kd;
    }
    set sizing(t) {
      const i = this.Kd;
      i !== t && (Debug && U.W(t, Sizing2, "Sizing"), this.Kd = t, this.panel !== null && this.panel.g(), this.t("sizing", i, t));
    }
    tS() {
      if (this.sizing === 1) {
        const t = this.en;
        return t === null ? 2 : this.isRow ? t.rowSizing : t.columnSizing;
      }
      return this.sizing;
    }
    get actual() {
      return this.$;
    }
    set actual(t) {
      isNaN(this.Pe) ? this.$ = Math.max(Math.min(this.Wa, t), this.va) : this.$ = Math.max(Math.min(this.Wa, this.Pe), this.va);
    }
    get measured() {
      return this.Vi;
    }
    set measured(t) {
      this.Vi = t;
    }
    get total() {
      return this.$ + this.computeEffectiveSpacing();
    }
    get position() {
      return this.yt;
    }
    set position(t) {
      this.yt = t;
    }
    bind(t, i, e, s) {
      return this.Ac(t, i, e, s), this;
    }
    bindTwoWay(t, i, e, s) {
      const n = this.Ac(t, i, e, s);
      return s === void 0 && n.makeTwoWay(), this;
    }
    theme(t, i, e, s, n) {
      return this.Fh(t, i, e, s, n), this;
    }
    themeData(t, i, e, s, n) {
      return this.Fh(t, i, e, s, n).ofData(), this;
    }
    themeObject(t, i, e, s, n, o) {
      return this.Fh(t, i, e, s, n).ofObject(o), this;
    }
    themeModel(t, i, e, s, n) {
      return this.Fh(t, i, e, s, n).ofModel(), this;
    }
    Ac(t, i, e, s) {
      let n;
      return typeof t == "string" ? n = new Binding2(t, i, e, s) : n = t, this.kp(n), n;
    }
    Fh(t, i, e, s, n) {
      let o;
      return typeof t == "string" ? o = new ThemeBinding2(t, i, e, s, n) : o = t, this.kp(o), o;
    }
    kp(t) {
      t.Re = this;
      const i = this.panel;
      if (i !== null) {
        const e = i.findBindingPanel();
        e !== null && e.fD() && U.n("Cannot add a Binding to a RowColumnDefinition that is already frozen: " + t + " on " + i);
      }
      this.Vs === null && (this.Vs = new List2()), this.Vs.add(t);
    }
  }
  class Shape2 extends GraphObject2 {
    xt;
    rn;
    Hd;
    Ja;
    ee;
    sr;
    _o;
    Jt;
    vd;
    Wd;
    j;
    constructor(t, i) {
      super(), this.xt = null, this.rn = null, this.Hd = "None", this.Ja = "black", this.ee = "black", this.sr = 1, this._o = null, this.Jt = null, this.vd = NaN, this.Wd = NaN, this.j = null, typeof t == "string" ? this.figure = t : t && Object.assign(this, t), i && Object.assign(this, i);
    }
    cloneProtected(t) {
      super.cloneProtected(t), t.xt = this.xt, t.rn = this.rn, t.Hd = this.Hd, t.Ja = this.Ja, t.ee = this.ee, t.sr = this.sr, this._o !== null && (t._o = this._o.slice()), this.Jt !== null && (this.Jt.wi ? t.Jt = this.Jt : t.Jt = this.Jt.copy()), t.vd = this.vd, t.Wd = this.Wd, this.j !== null && (t.j = this.j.copy());
    }
    $a() {
      return this.Jt === null ? this.Jt = new ShapeTemplateSettings() : this.Jt.wi && (this.Jt = this.Jt.copy()), this.Jt;
    }
    Ch() {
      super.Ch(), this.Jt !== null && (this.Jt.wi = true);
    }
    gi(t) {
      t in GeometryStretch2 ? this.geometryStretch = t : super.gi(t);
    }
    toString() {
      return "Shape(" + (this.figure !== "None" ? this.figure : this.toArrow !== "None" ? this.toArrow : this.fromArrow) + ")#" + GSet2.Ps(this);
    }
    nE(t, i) {
      const e = this.pathPattern;
      if (e === null) return;
      e.gt(1 / 0, 1 / 0);
      const s = e.measuredBounds;
      e.Ut(0, 0, s.width, s.height);
      const n = this.geometry;
      if (n === null) return;
      t.save(), t.beginPath();
      const o = U.ft();
      if (n.type === 1) o.push(n.startX), o.push(n.startY), o.push(n.endX), o.push(n.endY), this.jd(t, i, o, e);
      else if (n.type === 4) {
        const r = n.figures.iterator;
        for (; r.next(); ) {
          const l = r.value;
          o.length = 0, o.push(l.startX), o.push(l.startY);
          let h = l.startX, f = l.startY, a = h, c = f;
          const u = l.segments.h, d = u.length;
          for (let m = 0; m < d; m++) {
            const g = u[m];
            switch (g.type) {
              case 1:
                this.jd(t, i, o, e), o.length = 0, o.push(g.endX), o.push(g.endY), h = g.endX, f = g.endY, a = h, c = f;
                break;
              case 2:
                o.push(g.endX), o.push(g.endY), h = g.endX, f = g.endY;
                break;
              case 3:
                G._n(h, f, g.point1X, g.point1Y, g.point2X, g.point2Y, g.endX, g.endY, 0.5, o), h = g.endX, f = g.endY;
                break;
              case 4:
                G.am(h, f, g.point1X, g.point1Y, g.endX, g.endY, 0.5, o), h = g.endX, f = g.endY;
                break;
              case 5: {
                const p = g.Vo(l), y = p.length;
                if (y === 0) {
                  o.push(g.centerX), o.push(g.centerY), h = g.centerX, f = g.centerY;
                  break;
                }
                for (let x = 0; x < y; x++) {
                  const S = p[x];
                  G._n(h, f, S[2], S[3], S[4], S[5], S[6], S[7], 0.5, o), h = S[6], f = S[7];
                }
                break;
              }
              case 6: {
                const p = g.ea(l, h, f), y = p.length;
                if (y === 0) {
                  o.push(g.endX), o.push(g.endY), h = g.endX, f = g.endY;
                  break;
                }
                for (let x = 0; x < y; x++) {
                  const S = p[x];
                  G._n(h, f, S[2], S[3], S[4], S[5], S[6], S[7], 0.5, o), h = S[6], f = S[7];
                }
                break;
              }
              default:
                U.n("Segment not of valid type: " + g.type);
            }
            g.isClosed && (o.push(a), o.push(c), this.jd(t, i, o, e));
          }
          this.jd(t, i, o, e);
        }
      } else if (n.type === 2) o.push(n.startX), o.push(n.startY), o.push(n.endX), o.push(n.startY), o.push(n.endX), o.push(n.endY), o.push(n.startX), o.push(n.endY), o.push(n.startX), o.push(n.startY), this.jd(t, i, o, e);
      else if (n.type === 3) {
        const r = new PathFigure2();
        r.startX = n.endX, r.startY = (n.startY + n.endY) / 2;
        const l = new PathSegment2(5);
        l.startAngle = 0, l.sweepAngle = 360, l.centerX = (n.startX + n.endX) / 2, l.centerY = (n.startY + n.endY) / 2, l.radiusX = Math.abs(n.startX - n.endX) / 2, l.radiusY = Math.abs(n.startY - n.endY) / 2, r.add(l);
        const h = l.Vo(r), f = h.length;
        if (f === 0) o.push(l.centerX), o.push(l.centerY);
        else {
          let a = r.startX, c = r.startY;
          for (let u = 0; u < f; u++) {
            const d = h[u];
            G._n(a, c, d[2], d[3], d[4], d[5], d[6], d[7], 0.5, o), a = d[6], c = d[7];
          }
        }
        this.jd(t, i, o, e);
      }
      U.et(o), t.restore(), t.clearContextCache(false);
    }
    oE(t) {
      let i = t.measuredBounds.width;
      return t instanceof Shape2 && (i -= t.strokeWidth), i < 1 && (i = 1), i;
    }
    jd(t, i, e, s) {
      const n = e.length;
      if (n < 4) return;
      const o = s.measuredBounds, r = Math.max(1, o.width), l = o.height;
      let h = e[0], f = e[1], a = 0, c = 0, u = 0, d = 0, m = 0, g = 0, p = 0, y = 0;
      const x = U.ft();
      for (let N = 2; N < n; N += 2) a = e[N], c = e[N + 1], u = a - h, d = c - f, u === 0 && (u = 1e-3), m = d / u, g = Math.atan2(d, u), p = Math.sqrt(u * u + d * d), x.push([u, g, m, p]), y += p, h = a, f = c;
      h = e[0], f = e[1];
      const S = this.oE(s);
      let b = S;
      const k = r / 2;
      let P = k !== 0, A = 0, C = x[A];
      u = C[0], g = C[1], m = C[2], p = C[3];
      let M = 0;
      for (; y >= 0.1; ) {
        if (M === 0 && (P ? (b = S, b -= k, y -= k, P = false) : b = S, b === 0 && (b = 1)), b > y) {
          b = y, U.et(x);
          return;
        }
        b > p ? (M = b - p, b = p) : M = 0;
        let N = Math.sqrt(b * b / (1 + m * m));
        if (u < 0 && (N = -N), h += N, f += m * N, t.translate(h, f), t.rotate(g), t.translate(-(r / 2), -(l / 2)), M === 0 && s.Dh(t, i), t.translate(r / 2, l / 2), t.rotate(-g), t.translate(-h, -f), y -= b, p -= b, M !== 0) {
          if (A++, A === x.length) {
            U.et(x);
            return;
          }
          C = x[A], u = C[0], g = C[1], m = C[2], p = C[3], b = M;
        }
      }
      U.et(x);
    }
    Dh(t, i) {
      const e = t instanceof SVGContext;
      let s = this.ee;
      const n = this.Ja;
      if (s === null && n === null) return;
      const o = this.xt;
      if (o === null) return;
      t.commitTransform();
      const r = this.actualBounds, l = this.naturalBounds;
      n !== null && this.Cn(t, n, true, false, l, r);
      const h = this.part;
      let f = this.sr;
      s !== null && f === 0 && h !== null && (this.isPanelMain || h.findMainElement() === this) && (f = h.rE()), f === 0 && (s = null), s !== null && f !== 0 && (this.Cn(t, s, false, false, l, r), t.lineWidth = f, t.lineJoin = this.strokeJoin, t.lineCap = this.strokeCap, t.miterLimit = this.strokeMiterLimit);
      let a = false;
      h && i.getRenderingHint("drawShadows") && (a = h.isShadowed), t.cl === false && (a = false);
      let c = true;
      s !== null && (n === null || n === "transparent") && (c = false);
      let u = false;
      const d = this.strokeDashArray;
      if (d !== null && (u = true, t.enableDash(d, this.strokeDashOffset)), o.type === 1) t.beginPath(), t.moveTo(o.startX, o.startY), t.lineTo(o.endX, o.endY), s !== null && t.strokeContext(), t.endPath();
      else if (o.type === 2) {
        const m = o.startX, g = o.startY, p = o.endX, y = o.endY, x = Math.min(m, p), S = Math.min(g, y), b = Math.abs(p - m), k = Math.abs(y - g);
        t.beginPath(), t.rect(x, S, b, k), n !== null && t.fillContext(n, false, null), s !== null && (c && a && t.shadowsOff(), t.strokeContext(), c && a && t.shadowsOn()), t.endPath();
      } else if (o.type === 3) {
        const m = o.startX, g = o.startY, p = o.endX, y = o.endY, x = Math.abs(p - m) / 2, S = Math.abs(y - g) / 2, b = Math.min(m, p) + x, k = Math.min(g, y) + S;
        t.beginPath(), t.moveTo(b, k - S), t.bezierCurveTo(b + G.Qn * x, k - S, b + x, k - G.Qn * S, b + x, k), t.bezierCurveTo(b + x, k + G.Qn * S, b + G.Qn * x, k + S, b, k + S), t.bezierCurveTo(b - G.Qn * x, k + S, b - x, k + G.Qn * S, b - x, k), t.bezierCurveTo(b - x, k - G.Qn * S, b - G.Qn * x, k - S, b, k - S), t.closePath(), n !== null && t.fillContext(n, false, null), s !== null && (c && a && t.shadowsOff(), t.strokeContext(), c && a && t.shadowsOn()), t.endPath();
      } else if (o.type === 4) {
        const m = o.figures, g = m.length;
        for (let p = 0; p < g; p++) {
          const y = m.h[p];
          e ? (t.beginPath(), this.TD(t, y)) : y.$e === null && (y.$e = new Path2D(), this.TD(y.$e, y));
          const x = y.isFilled;
          a ? y.isShadowed ? (x === true && n !== "transparent" && n !== null && t.fillContext(n, y.isEvenOdd, y.$e), s !== null && (x && c && t.shadowsOff(), t.stroke(y.$e), x && c && t.shadowsOn())) : (t.shadowsOff(), x && n !== "transparent" && n !== null && t.fillContext(n, y.isEvenOdd, y.$e), s !== null && t.stroke(y.$e), t.shadowsOn()) : (x && n !== null && t.fillContext(n, y.isEvenOdd, y.$e), s !== null && t.stroke(y.$e)), t.endPath(p);
        }
      }
      u && t.disableDash(), this.nE(t, i);
    }
    TD(t, i) {
      t.moveTo(i.startX, i.startY);
      const e = i.segments.h, s = e.length;
      let n = null;
      for (let o = 0; o < s; o++) {
        const r = e[o];
        switch (r.type) {
          case 1:
            t.moveTo(r.endX, r.endY);
            break;
          case 2:
            t.lineTo(r.endX, r.endY);
            break;
          case 3:
            t.bezierCurveTo(r.point1X, r.point1Y, r.point2X, r.point2Y, r.endX, r.endY);
            break;
          case 4:
            t.quadraticCurveTo(r.point1X, r.point1Y, r.endX, r.endY);
            break;
          case 5:
            if (r.radiusX === r.radiusY) {
              const l = n !== null ? n.endX : i.startX, h = n !== null ? n.endY : i.startY, f = Math.PI / 180;
              t.arc(r.point1X, r.point1Y, r.radiusX, r.startAngle * f, (r.startAngle + r.sweepAngle) * f, r.sweepAngle < 0, l, h);
            } else {
              const l = r.Vo(i), h = l.length;
              if (h === 0) {
                t.lineTo(r.centerX, r.centerY);
                break;
              }
              for (let f = 0; f < h; f++) {
                const a = l[f];
                f === 0 && t.lineTo(a[0], a[1]), t.bezierCurveTo(a[2], a[3], a[4], a[5], a[6], a[7]);
              }
            }
            break;
          case 6: {
            let l = 0, h = 0, f;
            if (n !== null && n.type === 5) {
              f = n.Vo(i);
              const c = f.length;
              if (c === 0) {
                t.lineTo(r.endX, r.endY);
                break;
              }
              const u = f[c - 1] || null;
              u !== null && (l = u[6], h = u[7]);
            } else l = n !== null ? n.endX : i.startX, h = n !== null ? n.endY : i.startY;
            f = r.ea(i, l, h);
            const a = f.length;
            if (a === 0) {
              t.lineTo(r.endX, r.endY);
              break;
            }
            for (let c = 0; c < a; c++) {
              const u = f[c];
              t.bezierCurveTo(u[2], u[3], u[4], u[5], u[6], u[7]);
            }
            break;
          }
        }
        r.isClosed && t.closePath(), n = r;
      }
    }
    kc(t, i, e) {
      if (!super.kc(t, i, e) || this.ee === null && this.Ja === null || this.xt === null || this.pathPattern !== null) return false;
      const s = this.svg.getElementsByTagName("path");
      return this.geometry.figures.length !== s.length ? false : (t.currentPath = this.svg, this.Dh(t, i), t.currentPath = null, true);
    }
    Ad(t) {
      return this.geometry !== null && this.geometry.figures.length > 1 || this.pathPattern !== null ? true : super.Ad(t);
    }
    RN(t, i) {
      if (t.nodeName !== "g") t.setAttributeNS(null, "filter", i);
      else {
        const e = t.getElementsByTagName("path");
        for (let s = 0; s < e.length; s++) e[s].setAttributeNS(null, "filter", i);
      }
    }
    getDocumentPoint(t, i) {
      if (i === void 0 && (i = new Point2()), t instanceof Spot2) {
        const e = t;
        e.isNoSpot() && U.n("getDocumentPoint Spot must be a real, specific Spot, not: " + e.toString());
        const s = this.naturalBounds, n = this.strokeWidth;
        return i.e(e.x * (s.width + n) - n / 2 + s.x + e.offsetX, e.y * (s.height + n) - n / 2 + s.y + e.offsetY), this._s.St(i), i;
      } else return i.set(t), this._s.St(i), i;
    }
    getDocumentBounds(t) {
      t === void 0 && (t = new Rect2());
      const i = this.naturalBounds, e = this._s, s = Rect2.U(i.x, i.y, i.width, i.height), n = this.strokeWidth;
      s.inflate(n / 2, n / 2);
      const o = Point2.U(s.x, s.y).E(e);
      return t.e(o.x, o.y, 0, 0), o.e(s.right, s.y).E(e), t.ai(o.x, o.y, 0, 0), o.e(s.right, s.bottom).E(e), t.ai(o.x, o.y, 0, 0), o.e(s.x, s.bottom).E(e), t.ai(o.x, o.y, 0, 0), Rect2.o(s), Point2.o(o), t;
    }
    Ah(t, i) {
      const e = this.geometry;
      if (e === null || this.fill === null && this.stroke === null) return false;
      const s = e.bounds;
      let n = this.strokeWidth / 2;
      e.type === 1 && !i && (n += 2);
      const o = Rect2.a();
      if (o.c(s), o.inflate(n + 2, n + 2), !o.containsPoint(t)) return Rect2.o(o), false;
      const r = n + 1e-4;
      if (e.type === 1) {
        if (this.stroke === null) return false;
        const l = (e.startX - e.endX) * (t.x - e.endX) + (e.startY - e.endY) * (t.y - e.endY), h = (e.endX - e.startX) * (t.x - e.startX) + (e.endY - e.startY) * (t.y - e.startY);
        return l < 0 || h < 0 ? false : (Rect2.o(o), G.Ui(e.startX, e.startY, e.endX, e.endY, n, t.x, t.y));
      } else if (e.type === 2) {
        const l = e.startX, h = e.startY, f = e.endX, a = e.endY;
        if (o.x = Math.min(l, f), o.y = Math.min(h, a), o.width = Math.abs(f - l), o.height = Math.abs(a - h), this.fill === null) {
          if (o.inflate(-r, -r), o.containsPoint(t)) return Rect2.o(o), false;
          o.inflate(r, r);
        }
        this.stroke !== null && o.inflate(n, n);
        const c = o.containsPoint(t);
        return Rect2.o(o), c;
      } else if (e.type === 3) {
        const l = e.startX, h = e.startY, f = e.endX, a = e.endY;
        let c = Math.min(l, f), u = Math.min(h, a);
        const d = Math.abs(f - l), m = Math.abs(a - h);
        let g = d / 2, p = m / 2;
        if (c = t.x - (c + g), u = t.y - (u + p), this.fill === null) {
          if (g -= r, p -= r, g <= 0 || p <= 0) return Rect2.o(o), false;
          if (c * c / (g * g) + u * u / (p * p) <= 1) return Rect2.o(o), false;
          g += r, p += r;
        }
        return this.stroke !== null && (g += r, p += r), Rect2.o(o), g <= 0 || p <= 0 ? false : c * c / (g * g) + u * u / (p * p) <= 1;
      } else {
        if (e.type === 4) return Rect2.o(o), this.fill === null ? e.iT(t.x, t.y, n) : e.qk(t, n, this.strokeWidth > 1, i);
        U.n("Unknown Geometry type: " + e.type);
      }
    }
    Nd(t, i, e, s) {
      const n = this.desiredSize, o = this.sr;
      t = Math.max(t, 0), i = Math.max(i, 0);
      let r;
      if (this.rn !== null) r = this.geometry.bounds;
      else {
        const g = this.figure;
        let p = Shape2.hC[g];
        if (p === void 0) {
          let y = G.bn[g];
          typeof y == "string" && (y = G.bn[y]), U.at(y) ? (p = y(null, 100, 100), Shape2.hC[g] = p) : U.n("Unsupported Figure: " + g);
        }
        r = p.bounds;
      }
      let l = r.width, h = r.height, f = r.width, a = r.height;
      switch (this.sn(true)) {
        case 0:
          e = 0, s = 0;
          break;
        case 2:
          f = Math.max(t - o, 0), a = Math.max(i - o, 0);
          break;
        case 5:
          f = Math.max(t - o, 0), s = 0;
          break;
        case 4:
          e = 0, a = Math.max(i - o, 0);
          break;
      }
      isFinite(n.width) && (f = n.width), isFinite(n.height) && (a = n.height);
      const u = this.maxSize, d = this.minSize;
      e = Math.max(e - o, d.width), s = Math.max(s - o, d.height), f = Math.min(u.width, f), a = Math.min(u.height, a), f = isFinite(f) ? Math.max(e, f) : Math.max(l, e), a = isFinite(a) ? Math.max(s, a) : Math.max(h, s);
      const m = this.nM();
      switch (m) {
        case 0:
          break;
        case 2:
          l = f, h = a;
          break;
        case 6: {
          let g = Math.min(f / l, a / h);
          isFinite(g) || (g = 1), l = l * g, h = h * g;
          break;
        }
        default:
          U.n(m + " is not a valid geometryStretch.");
      }
      if (this.rn !== null) {
        l === 0 && (l = 1e-3), h === 0 && (h = 1e-3);
        const g = this.rn.fR(l, h);
        Debug && g.S(), this.xt = g;
      } else (this.xt === null || !G.q(this.xt.Lf, t - o) || !G.q(this.xt.Df, i - o)) && (this.xt = Shape2.lE(this, l, h));
      r = this.xt.bounds, t === 1 / 0 || i === 1 / 0 ? this.co(r.x - o / 2, r.y - o / 2, t === 0 && l === 0 ? 0 : r.width + o, i === 0 && h === 0 ? 0 : r.height + o) : this.co(-(o / 2), -(o / 2), f + o, a + o), n.isReal() ? (f = n.width, a = n.height, f = Math.min(u.width, f), a = Math.min(u.height, a), f = Math.max(d.width, f), a = Math.max(d.height, a), this.ji.e(0, 0, f, a)) : this.ji.c(r);
    }
    nM() {
      const t = this.geometryStretch;
      return this.rn !== null ? t === 1 ? 2 : t : t === 1 ? Shape2.hC[this.figure].defaultStretch : t;
    }
    Th(t, i, e, s) {
      this.commonArrange(t, i, e, s);
    }
    getNearestIntersectionPoint(t, i, e) {
      return this.bc(t.x, t.y, i.x, i.y, e);
    }
    bc(t, i, e, s, n) {
      const o = this.E, r = 1 / (o.m11 * o.m22 - o.m12 * o.m21), l = o.m22 * r, h = -o.m12 * r, f = -o.m21 * r, a = o.m11 * r, c = r * (o.m21 * o.dy - o.m22 * o.dx), u = r * (o.m12 * o.dx - o.m11 * o.dy), d = t * l + i * f + c, m = t * h + i * a + u, g = e * l + s * f + c, p = e * h + s * a + u, y = this.sr / 2;
      let x = this.xt;
      x === null && (this.gt(1 / 0, 1 / 0), x = this.xt);
      const S = x.bounds;
      let b = false;
      if (x.type === 1) if (this.strokeWidth <= 1.5) b = G.Bo(x.startX, x.startY, x.endX, x.endY, d, m, g, p, n);
      else {
        let k = 0, P = 0;
        if (x.startX === x.endX) k = y, P = 0;
        else {
          const L = (x.endY - x.startY) / (x.endX - x.startX);
          P = y / Math.sqrt(1 + L * L), k = P * L;
        }
        const A = U.ft();
        let C = new Point2();
        G.Bo(x.startX + k, x.startY + P, x.endX + k, x.endY + P, d, m, g, p, C) && A.push(C), C = new Point2(), G.Bo(x.startX - k, x.startY - P, x.endX - k, x.endY - P, d, m, g, p, C) && A.push(C), C = new Point2(), G.Bo(x.startX + k, x.startY + P, x.startX - k, x.startY - P, d, m, g, p, C) && A.push(C), C = new Point2(), G.Bo(x.endX + k, x.endY + P, x.endX - k, x.endY - P, d, m, g, p, C) && A.push(C);
        const M = A.length;
        if (M === 0) return U.et(A), false;
        b = true;
        let N = 1 / 0;
        for (let L = 0; L < M; L++) {
          const T = A[L], D = (T.x - d) ** 2 + (T.y - m) ** 2;
          D < N && (N = D, n.x = T.x, n.y = T.y);
        }
        U.et(A);
      }
      else if (x.type === 2) b = G.Dl(S.x - y, S.y - y, S.x + S.width + y, S.y + S.height + y, d, m, g, p, n);
      else if (x.type === 3) {
        const k = Rect2.U(S.x, S.y, S.width, S.height).inflate(y, y);
        b = this.hE(k, d, m, g, p, n), Rect2.o(k);
      } else if (x.type === 4) {
        let k = 0, P = 0, A = 0, C = 0;
        const M = Point2.a();
        let N = g - d, L = p - m, T = N * N + L * L, D = d, F = m;
        if (T > 0 && S.contains(D, F) && (M.x = D, M.y = F, this.containsPoint(M))) for (N !== 0 && Math.abs(N) < 0.5 ? (L *= 0.5 / N, N = 0.5) : L !== 0 && Math.abs(L) < 0.5 && (N *= 0.5 / L, L = 0.5), D -= N, F -= L; S.contains(D, F); ) D -= N, F -= L;
        const R = 0.6;
        n.x = g, n.y = p;
        for (let K = 0; K < x.figures.count; K++) {
          const B = x.figures.h[K], Y = B.isFilled ? D : d, z = B.isFilled ? F : m, H = B.segments;
          k = B.startX, P = B.startY;
          let W = k, j = P;
          for (let Z = 0; Z < H.count; Z++) {
            const V = H.h[Z], $ = V.type;
            A = V.endX, C = V.endY;
            let J = false;
            switch ($) {
              case 1:
                W = A, j = C;
                break;
              case 2:
                J = this.rS(k, P, A, C, Y, z, g, p, M);
                break;
              case 3: {
                J = G.fm(k, P, V.point1X, V.point1Y, V.point2X, V.point2Y, A, C, Y, z, g, p, R, M);
                break;
              }
              case 4: {
                J = G.fm(k, P, k + 2 / 3 * (V.point1X - k), P + 2 / 3 * (V.point1Y - P), A + 2 / 3 * (V.point1X - A), C + 2 / 3 * (V.point1Y - C), A, C, Y, z, g, p, R, M);
                break;
              }
              case 5:
              case 6: {
                const tt = V.type === 5 ? V.Vo(B) : V.ea(B, k, P), q = tt.length;
                if (q === 0) {
                  J = this.rS(k, P, V.type === 5 ? V.centerX : V.endX, V.type === 5 ? V.centerY : V.endY, Y, z, g, p, M);
                  break;
                }
                let E = null;
                for (let v = 0; v < q; v++) {
                  if (E = tt[v], v === 0 && this.rS(k, P, E[0], E[1], Y, z, g, p, M)) {
                    const Q = this.lS(Y, z, M, T, n);
                    Q < T && (T = Q, b = true);
                  }
                  if (G.fm(E[0], E[1], E[2], E[3], E[4], E[5], E[6], E[7], Y, z, g, p, R, M)) {
                    const Q = this.lS(Y, z, M, T, n);
                    Q < T && (T = Q, b = true);
                  }
                }
                A = E[6], C = E[7];
                break;
              }
              default:
                U.n("Unknown Segment type: " + $);
            }
            if (k = A, P = C, J) {
              const tt = this.lS(Y, z, M, T, n);
              tt < T && (T = tt, b = true);
            }
            if (V.isClosed && (A = W, C = j, this.rS(k, P, A, C, Y, z, g, p, M))) {
              const tt = this.lS(Y, z, M, T, n);
              tt < T && (T = tt, b = true);
            }
          }
        }
        let I = e - t, O = s - i;
        const X = Math.sqrt(I * I + O * O);
        X !== 0 && (I /= X, O /= X), n.x -= I * y, n.y -= O * y, Point2.o(M);
      } else U.n("Unknown Geometry type: " + x.type);
      return b ? (this.E.St(n), true) : false;
    }
    lS(t, i, e, s, n) {
      const o = e.x - t, r = e.y - i, l = o * o + r * r;
      return l < s ? (n.x = e.x, n.y = e.y, l) : s;
    }
    rS(t, i, e, s, n, o, r, l, h) {
      if (G.q(t, e) && G.q(i, s) || G.q(n, r) && G.q(o, l)) return false;
      let f = false;
      const a = (n - r) * (i - s) - (o - l) * (t - e);
      if (a === 0) return false;
      if (h.x = ((n * l - o * r) * (t - e) - (n - r) * (t * s - i * e)) / a, h.y = ((n * l - o * r) * (i - s) - (o - l) * (t * s - i * e)) / a, (t > e ? t - e : e - t) < (i > s ? i - s : s - i)) {
        const c = i < s ? i : s, u = i < s ? s : i;
        (h.y > c || G.q(h.y, c)) && (h.y < u || G.q(h.y, u)) && (f = true);
      } else {
        const c = t < e ? t : e, u = t < e ? e : t;
        (h.x > c || G.q(h.x, c)) && (h.x < u || G.q(h.x, u)) && (f = true);
      }
      return f;
    }
    aE(t, i, e) {
      return this.pickable === false ? false : (e.Af(this.E), i ? this.fE(t, e) : this.containedInRect(t, e));
    }
    containedInRect(t, i) {
      if (i === void 0) return t.containsRect(this.actualBounds);
      let e = this.xt;
      e === null && (this.gt(1 / 0, 1 / 0), e = this.xt);
      const s = e.bounds, n = this.strokeWidth / 2;
      let o = false;
      const r = Point2.a();
      return r.e(s.x - n, s.y - n), t.containsPoint(i.St(r)) && (r.e(s.x - n, s.bottom + n), t.containsPoint(i.St(r)) && (r.e(s.right + n, s.bottom + n), t.containsPoint(i.St(r)) && (r.e(s.right + n, s.y - n), t.containsPoint(i.St(r)) && (o = true)))), Point2.o(r), o;
    }
    intersectsRect(t, i) {
      if (this.containedInRect(t, i) || i === void 0 && (i = this.E, t.containsRect(this.actualBounds))) return true;
      const e = Transform.a();
      e.set(i), e.cx();
      const s = t.left, n = t.right, o = t.top, r = t.bottom, l = Point2.a();
      if (l.e(s, o), e.St(l), this.Ah(l, true)) return Point2.o(l), true;
      if (l.e(n, o), e.St(l), this.Ah(l, true)) return Point2.o(l), true;
      if (l.e(s, r), e.St(l), this.Ah(l, true)) return Point2.o(l), true;
      if (l.e(n, r), e.St(l), this.Ah(l, true)) return Point2.o(l), true;
      const h = Point2.a(), f = Point2.a();
      e.set(i), e.qA(this.E), e.cx(), h.x = n, h.y = o, h.E(e), l.x = s, l.y = o, l.E(e);
      let a = false;
      return this.Za(l, h, f) ? a = true : (l.x = n, l.y = r, l.E(e), this.Za(l, h, f) ? a = true : (h.x = s, h.y = r, h.E(e), this.Za(l, h, f) ? a = true : (l.x = s, l.y = o, l.E(e), this.Za(l, h, f) && (a = true)))), Point2.o(l), Transform.o(e), Point2.o(h), Point2.o(f), a;
    }
    Za(t, i, e) {
      if (!this.getNearestIntersectionPoint(t, i, e)) return false;
      const s = t.x, n = t.y, o = i.x, r = i.y, l = e.x, h = e.y;
      if (s === o) {
        let f = 0, a = 0;
        return n < r ? (f = n, a = r) : (f = r, a = n), h >= f && h <= a;
      } else {
        let f = 0, a = 0;
        return s < o ? (f = s, a = o) : (f = o, a = s), l >= f && l <= a;
      }
    }
    fE(t, i) {
      if (this.containedInRect(t, i) || i === void 0 && (i = this.E, t.containsRect(this.actualBounds))) return true;
      const e = t.left, s = t.right, n = t.top, o = t.bottom, r = Point2.a(), l = Point2.a(), h = Point2.a(), f = Transform.a();
      f.set(i), f.qA(this.E), f.cx(), l.x = s, l.y = n, l.E(f), r.x = e, r.y = n, r.E(f);
      let a = false;
      return this.Za(r, l, h) ? a = true : (r.x = s, r.y = o, r.E(f), this.Za(r, l, h) ? a = true : (l.x = e, l.y = o, l.E(f), this.Za(r, l, h) ? a = true : (r.x = e, r.y = n, r.E(f), this.Za(r, l, h) && (a = true)))), Transform.o(f), Point2.o(r), Point2.o(l), Point2.o(h), a;
    }
    iD(t, i, e) {
      if (e && this.fill !== null && this.Ah(t, true)) return true;
      let s = t.distanceSquaredPoint(i);
      const n = s;
      this.strokeWidth > 1.5 && (s = this.strokeWidth / 2 + Math.sqrt(s), s *= s);
      let o = this.xt;
      if (o === null && (this.gt(1 / 0, 1 / 0), o = this.xt, o === null)) return false;
      if (!e) {
        const c = o.bounds, u = c.x, d = c.y, m = c.x + c.width, g = c.y + c.height;
        if (Point2.distanceSquared(t.x, t.y, u, d) <= s && Point2.distanceSquared(t.x, t.y, m, d) <= s && Point2.distanceSquared(t.x, t.y, u, g) <= s && Point2.distanceSquared(t.x, t.y, m, g) <= s) return true;
      }
      function r(c, u) {
        const d = c.length;
        for (let m = 0; m < d; m += 2) if (u.distanceSquared(c[m], c[m + 1]) > s) return true;
        return false;
      }
      const l = o.startX, h = o.startY, f = o.endX, a = o.endY;
      if (o.type === 1) {
        const c = Point2.distanceLineSegmentSquared(t.x, t.y, l, h, f, a), u = (f - l) * (t.x - l) + (a - h) * (t.y - h), d = (l - f) * (t.x - f) + (h - a) * (t.y - a), m = u >= 0 && d >= 0 ? s : n;
        return c <= m;
      } else if (o.type === 2) {
        let c = false;
        return e && (c = Point2.distanceLineSegmentSquared(t.x, t.y, l, h, l, a) <= s || Point2.distanceLineSegmentSquared(t.x, t.y, l, h, f, h) <= s || Point2.distanceLineSegmentSquared(t.x, t.y, f, h, f, a) <= s || Point2.distanceLineSegmentSquared(t.x, t.y, l, a, f, a) <= s), c;
      } else if (o.type === 3) {
        const c = (l + f) / 2, u = (h + a) / 2, d = t.x - c, m = t.y - u, g = Math.abs(f - l) / 2, p = Math.abs(a - h) / 2;
        if (g === 0 || p === 0) return Point2.distanceLineSegmentSquared(t.x, t.y, l, h, f, a) <= s;
        if (e) {
          const y = G.iR(g, p, d, m);
          return y * y <= s;
        } else return !(Point2.distanceSquared(d, m, -g, 0) >= s || Point2.distanceSquared(d, m, 0, -p) >= s || Point2.distanceSquared(d, m, 0, p) >= s || Point2.distanceSquared(d, m, g, 0) >= s);
      } else if (o.type === 4) {
        const c = o.bounds, u = c.x, d = c.y, m = c.x + c.width, g = c.y + c.height;
        if (t.x > m && t.x < u && t.y > g && t.y < d && Point2.distanceLineSegmentSquared(t.x, t.y, u, d, u, g) > s && Point2.distanceLineSegmentSquared(t.x, t.y, u, d, m, d) > s && Point2.distanceLineSegmentSquared(t.x, t.y, m, g, u, g) > s && Point2.distanceLineSegmentSquared(t.x, t.y, m, g, m, d) > s) return false;
        const p = Math.sqrt(s);
        if (e) {
          if (this.fill === null ? o.iT(t.x, t.y, p) : o.qk(t, p, true, false)) return true;
        } else {
          const y = o.figures;
          for (let x = 0; x < y.count; x++) {
            const S = y.h[x];
            let b = S.startX, k = S.startY;
            if (t.distanceSquared(b, k) > s) return false;
            const P = S.segments.h, A = P.length;
            for (let C = 0; C < A; C++) {
              const M = P[C];
              switch (M.type) {
                case 1:
                case 2:
                  if (b = M.endX, k = M.endY, t.distanceSquared(b, k) > s) return false;
                  break;
                case 3: {
                  const N = U.ft();
                  G._n(b, k, M.point1X, M.point1Y, M.point2X, M.point2Y, M.endX, M.endY, 0.8, N);
                  const L = r(N, t);
                  if (U.et(N), L || (b = M.endX, k = M.endY, t.distanceSquared(b, k) > s)) return false;
                  break;
                }
                case 4: {
                  const N = U.ft();
                  G.am(b, k, M.point1X, M.point1Y, M.endX, M.endY, 0.8, N);
                  const L = r(N, t);
                  if (U.et(N), L || (b = M.endX, k = M.endY, t.distanceSquared(b, k) > s)) return false;
                  break;
                }
                case 5:
                case 6: {
                  const N = M.type === 5 ? M.Vo(S) : M.ea(S, b, k), L = N.length;
                  if (L === 0) {
                    if (b = M.type === 5 ? M.centerX : M.endX, k = M.type === 5 ? M.centerY : M.endY, t.distanceSquared(b, k) > s) return false;
                    break;
                  }
                  let T = null;
                  const D = U.ft();
                  for (let F = 0; F < L; F++) if (T = N[F], D.length = 0, G._n(T[0], T[1], T[2], T[3], T[4], T[5], T[6], T[7], 0.8, D), r(D, t)) return U.et(D), false;
                  U.et(D), T !== null && (b = T[6], k = T[7]);
                  break;
                }
                default:
                  U.n("Unknown Segment type: " + M.type);
              }
            }
          }
          return true;
        }
      }
      return false;
    }
    hE(t, i, e, s, n, o) {
      if (t.width === 0) return G.Bo(t.x, t.y, t.x, t.y + t.height, i, e, s, n, o);
      if (t.height === 0) return G.Bo(t.x, t.y, t.x + t.width, t.y, i, e, s, n, o);
      {
        const r = t.width / 2, l = t.height / 2, h = t.x + r, f = t.y + l;
        let a = 9999;
        if (i !== s && (a = (e - n) / (i - s)), Math.abs(a) < 9999) {
          const c = e - f - a * (i - h);
          if (r * r * (a * a) + l * l - c * c < 0) return o.x = NaN, o.y = NaN, false;
          const u = Math.sqrt(r * r * (a * a) + l * l - c * c), d = (-(r * r * a * c) + r * l * u) / (l * l + r * r * (a * a)) + h, m = (-(r * r * a * c) - r * l * u) / (l * l + r * r * (a * a)) + h, g = a * (d - h) + c + f, p = a * (m - h) + c + f, y = Math.abs((i - d) ** 2) + Math.abs((e - g) ** 2), x = Math.abs((i - m) ** 2) + Math.abs((e - p) ** 2);
          y < x ? (o.x = d, o.y = g) : (o.x = m, o.y = p);
        } else {
          const c = l * l, u = r * r, d = i - h, m = c - c / u * (d * d);
          if (m < 0) return o.x = NaN, o.y = NaN, false;
          const g = Math.sqrt(m), p = f + g, y = f - g, x = Math.abs(p - e), S = Math.abs(y - e);
          x < S ? (o.x = i, o.y = p) : (o.x = i, o.y = y);
        }
        return true;
      }
    }
    Q3() {
      return this.sr / 2 * this.strokeMiterLimit * this.getDocumentScale();
    }
    get geometry() {
      return this.xt !== null ? this.xt : this.rn;
    }
    set geometry(t) {
      const i = this.xt, e = this.rn;
      if (i === t) return;
      t !== null ? (Debug && U.s(t, Geometry2, Shape2, "geometry"), this.xt = t.S(), this.rn = this.xt) : (this.xt = null, this.rn = null);
      const s = this.part;
      if (s !== null && s.Oc(), this.g(), this.t("geometry", i || e, t), this.xc()) {
        const n = this.part;
        n !== null && this.Ya(n, "geometryString");
      }
    }
    get geometryString() {
      return this.geometry === null ? "" : this.geometry.toString();
    }
    set geometryString(t) {
      const i = Geometry2.parse(t), e = i.normalize();
      this.geometry = i;
      const s = Point2.U(-e.x, -e.y);
      this.position = s, Point2.o(s);
    }
    get isGeometryPositioned() {
      return (this.l & 1048576) !== 0;
    }
    set isGeometryPositioned(t) {
      const i = (this.l & 1048576) !== 0;
      i !== t && (Debug && U.i(t, "boolean", Shape2, "isGeometryPositioned"), this.l = this.l ^ 1048576, this.g(), this.t("isGeometryPositioned", i, t));
    }
    ie() {
      this.xt = null;
    }
    get fill() {
      return this.Ja;
    }
    set fill(t) {
      const i = this.Ja;
      i !== t && (t !== null && Brush2.Ld(t, "Shape.fill"), t instanceof Brush2 && t.S(), this.Ja = t, this.L(), this.t("fill", i, t));
    }
    get stroke() {
      return this.ee;
    }
    set stroke(t) {
      const i = this.ee;
      i !== t && (t !== null && Brush2.Ld(t, "Shape.stroke"), t instanceof Brush2 && t.S(), this.ee = t, this.L(), this.t("stroke", i, t));
    }
    get strokeWidth() {
      return this.sr;
    }
    set strokeWidth(t) {
      const i = this.sr;
      if (i !== t) if (Debug && U.r(t, Shape2, "strokeWidth"), t >= 0) {
        this.sr = t, this.g();
        const e = this.part;
        e !== null && e.Oc(), this.t("strokeWidth", i, t);
      } else U.G(t, "value >= 0", Shape2, "strokeWidth:value");
    }
    $0() {
      return this.sr;
    }
    get strokeCap() {
      return this.Jt !== null ? this.Jt.Wp : "butt";
    }
    set strokeCap(t) {
      const i = this.strokeCap;
      i !== t && (typeof t == "string" && (t === "butt" || t === "round" || t === "square") ? (this.$a().Wp = t, this.L(), this.t("strokeCap", i, t)) : U.G(t, '"butt", "round", or "square"', Shape2, "strokeCap"));
    }
    get strokeJoin() {
      return this.Jt !== null ? this.Jt.jp : "miter";
    }
    set strokeJoin(t) {
      const i = this.strokeJoin;
      i !== t && (typeof t == "string" && (t === "miter" || t === "bevel" || t === "round") ? (this.$a().jp = t, this.L(), this.t("strokeJoin", i, t)) : U.G(t, '"miter", "bevel", or "round"', Shape2, "strokeJoin"));
    }
    get strokeMiterLimit() {
      return this.Jt !== null ? this.Jt.Jp : 10;
    }
    set strokeMiterLimit(t) {
      const i = this.strokeMiterLimit;
      if (i !== t) if (Debug && U.r(t, Shape2, "strokeMiterLimit"), t >= 1) {
        this.$a().Jp = t, this.L();
        const e = this.part;
        e !== null && e.Oc(), this.t("strokeMiterLimit", i, t);
      } else Debug && U.G(t, "value >= 1", Shape2, "strokeWidth:value");
    }
    get strokeDashArray() {
      return this._o;
    }
    set strokeDashArray(t) {
      const i = this._o;
      if (i !== t) {
        if (t !== null && !Array.isArray(t) && U.Ti(t, "Array", Shape2, "strokeDashArray:value"), t !== null) {
          const e = t.length;
          let s = 0;
          for (let n = 0; n < e; n++) {
            const o = t[n];
            (Debug && typeof o != "number" || !(o >= 0) || !isFinite(o)) && U.n("strokeDashArray:value " + o + " at index " + n + " must be a positive number or zero."), s += o;
          }
          if (s === 0) {
            if (i === null) return;
            t = null;
          }
        }
        this._o = t, this.L(), this.t("strokeDashArray", i, t);
      }
    }
    get strokeDashOffset() {
      return this.Jt !== null ? this.Jt.Ih : 0;
    }
    set strokeDashOffset(t) {
      const i = this.strokeDashOffset;
      i !== t && (Debug && U.r(t, Shape2, "strokeDashOffset"), t >= 0 && (this.$a().Ih = t, this.L(), this.t("strokeDashOffset", i, t)));
    }
    get figure() {
      return this.Hd;
    }
    set figure(t) {
      const i = this.Hd;
      if (i !== t) {
        Debug && U.i(t, "string", Shape2, "figure");
        let e = G.bn[t];
        if (U.at(e) ? e = t : (e = G.bn[t.toLowerCase()], (!e || typeof e == "function") && U.n("Unknown Shape.figure: " + t)), i !== e) {
          const s = this.part;
          s !== null && s.Oc(), this.Hd = e, this.rn = null, this.ie(), this.g(), this.t("figure", i, e);
        }
      }
    }
    get toArrow() {
      return this.Xt !== null ? this.Xt.$p : "None";
    }
    set toArrow(t) {
      const i = this.toArrow;
      if (t === true ? t = "Standard" : t === false && (t = ""), i !== t) {
        Debug && U.i(t, "string", Shape2, "toArrow");
        const e = Shape2.LD(t);
        e === null ? U.n("Unknown Shape.toArrow: " + t) : i !== e && (this.Xt === null && (this.Xt = new LinkElementSettings()), this.Xt.$p = e, this.rn = null, this.ie(), this.g(), this.DD(e), this.t("toArrow", i, e));
      }
    }
    get fromArrow() {
      return this.Xt !== null ? this.Xt.Zp : "None";
    }
    set fromArrow(t) {
      const i = this.fromArrow;
      if (t === true ? t = "Standard" : t === false && (t = ""), i !== t) {
        Debug && U.i(t, "string", Shape2, "fromArrow");
        const e = Shape2.LD(t);
        e === null ? U.n("Unknown Shape.fromArrow: " + t) : i !== e && (this.Xt === null && (this.Xt = new LinkElementSettings()), this.Xt.Zp = e, this.rn = null, this.ie(), this.g(), this.DD(e), this.t("fromArrow", i, e));
      }
    }
    DD(t) {
      const i = this.diagram;
      i !== null && i.undoManager.isUndoingRedoing || (this.S3(), this.toArrow !== "None" ? (this.segmentIndex = -1, this.alignmentFocus = Spot2.Right) : this.fromArrow !== "None" && (this.segmentIndex = 0, this.alignmentFocus = Spot2.Left));
    }
    get spot1() {
      return this.Jt !== null ? this.Jt.to : Spot2.Default;
    }
    set spot1(t) {
      const i = this.spot1;
      i.equals(t) || (Debug && U.s(t, Spot2, Shape2, "spot1"), t = t.T(), this.$a().to = t, this.g(), this.t("spot1", i, t));
    }
    get spot2() {
      return this.Jt !== null ? this.Jt.io : Spot2.Default;
    }
    set spot2(t) {
      const i = this.spot2;
      i.equals(t) || (Debug && U.s(t, Spot2, Shape2, "spot2"), t = t.T(), this.$a().io = t, this.g(), this.t("spot2", i, t));
    }
    get parameter1() {
      return this.vd;
    }
    set parameter1(t) {
      const i = this.vd;
      i !== t && (this.vd = t, this.ie(), this.g(), this.t("parameter1", i, t));
    }
    get parameter2() {
      return this.Wd;
    }
    set parameter2(t) {
      const i = this.Wd;
      i !== t && (this.Wd = t, this.ie(), this.g(), this.t("parameter2", i, t));
    }
    get naturalBounds() {
      return this.ji;
    }
    K3() {
      const t = this.desiredSize;
      if (!t.isReal() && this.xt !== null) {
        const i = this.xt.bounds;
        this.ji.c(i);
      } else this.ji.e(0, 0, t.width, t.height);
    }
    get pathPattern() {
      return this.Jt !== null ? this.Jt.Qp : null;
    }
    set pathPattern(t) {
      const i = this.pathPattern;
      i !== t && (Debug && t !== null && U.s(t, GraphObject2, Shape2, "pathPattern"), this.$a().Qp = t, this.L(), this.t("pathPattern", i, t));
    }
    get geometryStretch() {
      return this.Jt !== null ? this.Jt._p : 1;
    }
    set geometryStretch(t) {
      const i = this.geometryStretch;
      i !== t && (U.W(t, GeometryStretch2, "GeometryStretch"), this.$a()._p = t, this.g(), this.t("geometryStretch", i, t));
    }
    get interval() {
      return this.j !== null ? this.j.Bc : 1;
    }
    set interval(t) {
      const i = this.interval;
      if (Debug && U.r(t, Shape2, "interval"), t = Math.round(t), i !== t && t !== 0 && isFinite(t)) {
        this.j === null && (this.j = new GradElementSettings()), this.j.Bc = t;
        const e = this.diagram;
        e !== null && this.panel === e.grid && e.ph(), this.g();
        const s = this.panel;
        s !== null && (s.ys = null), this.t("interval", i, t);
      }
    }
    get graduatedStart() {
      return this.j !== null ? this.j.Vc : 0;
    }
    set graduatedStart(t) {
      const i = this.graduatedStart;
      Debug && U.r(t, Shape2, "graduatedStart"), i !== t && (t < 0 ? t = 0 : t > 1 && (t = 1), this.j === null && (this.j = new GradElementSettings()), this.j.Vc = t, this.g(), this.t("graduatedStart", i, t));
    }
    get graduatedEnd() {
      return this.j !== null ? this.j.zc : 1;
    }
    set graduatedEnd(t) {
      const i = this.graduatedEnd;
      Debug && U.r(t, Shape2, "graduatedEnd"), i !== t && (t < 0 ? t = 0 : t > 1 && (t = 1), this.j === null && (this.j = new GradElementSettings()), this.j.zc = t, this.g(), this.t("graduatedEnd", i, t));
    }
    get graduatedSkip() {
      return this.j !== null ? this.j.Xc : null;
    }
    set graduatedSkip(t) {
      const i = this.graduatedSkip;
      i !== t && (t !== null && U.C(t, Shape2, "graduatedSkip"), this.j === null && (this.j = new GradElementSettings()), this.j.Xc = t, this.g(), this.t("graduatedSkip", i, t));
    }
    polygonContainsRect(t) {
      const i = this;
      if (!i.part || !i.part.actualBounds.containsRect(t)) return false;
      const e = i.geometry;
      if (!e) return false;
      const s = t.x, n = t.y, o = t.width, r = t.height, l = Point2.a();
      if (l.x = s, l.y = n, i.getLocalPoint(l, l), !e.containsPoint(l) || o > 0 && r > 0 && (l.x = s + o, l.y = n + r, i.getLocalPoint(l, l), !e.containsPoint(l)) || o > 0 && (l.x = s + o, l.y = n, i.getLocalPoint(l, l), !e.containsPoint(l)) || r > 0 && (l.x = s, l.y = n + r, i.getLocalPoint(l, l), !e.containsPoint(l)) || e.type === 1) return false;
      if (e.type === 4) {
        const h = e.figures.iterator;
        for (; h.next(); ) {
          const f = h.value;
          if (!f.isFilled) continue;
          l.x = f.startX, l.y = f.startY, i.getDocumentPoint(l, l);
          let a = l.x, c = l.y, u = a, d = c, m = a, g = c;
          const p = f.segments.iterator;
          for (; p.next(); ) {
            const y = p.value;
            if (l.x = y.endX, l.y = y.endY, i.getDocumentPoint(l, l), m = l.x, g = l.y, y.type === 1) a = m, c = g;
            else if (y.type !== 5 && (Rect2.intersectsLineSegment(s, n, o, r, u, d, m, g) || y.isClosed && Rect2.intersectsLineSegment(s, n, o, r, m, g, a, c))) return false;
            u = m, d = g;
          }
        }
      }
      return Point2.o(l), true;
    }
    static lE(t, i, e) {
      let n = null;
      if (t.toArrow !== "None") n = Shape2.En[t.toArrow];
      else if (t.fromArrow !== "None") n = Shape2.En[t.fromArrow];
      else {
        let o = G.bn[t.figure];
        typeof o == "string" && (o = G.bn[o]), o === void 0 && U.n("Unknown Shape.figure: " + t.figure), n = o(t, i, e), n.Lf = i, n.Df = e;
      }
      if (n === null) {
        const o = G.bn.Rectangle;
        U.at(o) && (n = o(t, i, e));
      }
      return Debug && (n.bounds.width > i + 1e-5 || n.bounds.height > e + 1e-5) && U.n('Geometry made with figure "' + t.figure + '" has bounds ' + n.bounds.toString() + " that are too large for the given size (" + i + "," + e + "). See documentation for Shape.defineFigureGenerator."), n;
    }
    static getFigureGenerators() {
      const t = new GMap2();
      for (const i in G.bn) {
        if (i === i.toLowerCase()) continue;
        const e = G.bn[i];
        t.set(i, e);
      }
      return t.S(), t;
    }
    static defineFigureGenerator(t, i) {
      U.i(t, "string", Shape2, "defineFigureGenerator:name"), typeof i == "string" ? Debug && (i === "" || !G.bn[i]) && U.n("Shape.defineFigureGenerator synonym must not be empty or None or not a defined figure name: " + i) : U.C(i, Shape2, "defineFigureGenerator:func");
      const e = t.toLowerCase();
      Debug && (t === "" || t === e) && U.n("Shape.defineFigureGenerator name must not be empty or all-lower-case: " + t);
      const s = G.bn;
      s[t] = i, s[e] = t;
    }
    static isFigureDefined(t) {
      return t in G.bn;
    }
    static getArrowheadGeometries() {
      const t = new GMap2();
      for (const i in G.um) if (Shape2.En[i] === void 0) {
        const e = Geometry2.parse(G.um[i], false);
        Shape2.En[i] = e;
        const s = i.toLowerCase();
        s !== i && (Shape2.En[s] = i);
      }
      for (const i in Shape2.En) {
        if (i === i.toLowerCase()) continue;
        const e = Shape2.En[i];
        e instanceof Geometry2 && t.set(i, e);
      }
      return t.S(), t;
    }
    static defineArrowheadGeometry(t, i) {
      U.i(t, "string", Shape2, "defineArrowheadGeometry:name");
      let e = null;
      typeof i == "string" ? (U.i(i, "string", Shape2, "defineArrowheadGeometry:pathstr"), e = Geometry2.parse(i, false)) : (U.s(i, Geometry2, Shape2, "defineArrowheadGeometry:pathstr"), e = i);
      const s = t.toLowerCase();
      (Debug && t === "" || s === "none" || t === s) && U.n("Shape.defineArrowheadGeometry name must not be empty or None or all-lower-case: " + t);
      const n = Shape2.En;
      n[t] = e, n[s] = t;
    }
    static isArrowheadDefined(t) {
      return Shape2.En.has(t);
    }
    static En = new PropertyCollection();
    static hC = new PropertyCollection();
    static LD(t) {
      let i = Shape2.En[t];
      if (i === void 0) {
        const e = t.toLowerCase();
        if (e === "none") return "None";
        if (i = Shape2.En[e], i === void 0) {
          let s = null;
          for (const n in G.um) if (n.toLowerCase() === e) {
            s = n;
            break;
          }
          if (s !== null) {
            const n = Geometry2.parse(G.um[s], false);
            return Shape2.En[s] = n, e !== s && (Shape2.En[e] = s), s;
          }
        }
      }
      return typeof i == "string" ? i : i instanceof Geometry2 ? t : null;
    }
  }
  class ShapeTemplateSettings {
    wi;
    Wp;
    jp;
    Jp;
    Ih;
    Qp;
    _p;
    to;
    io;
    constructor() {
      this.wi = false, this.Wp = "butt", this.jp = "miter", this.Jp = 10, this.Ih = 0, this.Qp = null, this._p = 1, this.to = Spot2.Default, this.io = Spot2.Default;
    }
    copy() {
      const t = new ShapeTemplateSettings();
      return t.Wp = this.Wp, t.jp = this.jp, t.Jp = this.Jp, t.Ih = this.Ih, t.Qp = this.Qp, t._p = this._p, t.to = this.to.T(), t.io = this.io.T(), t;
    }
  }
  var Wrap2 = ((w) => (w[w.None = 0] = "None", w[w.Fit = 1] = "Fit", w[w.DesiredSize = 2] = "DesiredSize", w[w.BreakAll = 3] = "BreakAll", w))(Wrap2 || {}), TextOverflow2 = ((w) => (w[w.Clip = 0] = "Clip", w[w.Ellipsis = 1] = "Ellipsis", w))(TextOverflow2 || {}), TextFormat2 = ((w) => (w[w.Trim = 0] = "Trim", w[w.None = 1] = "None", w))(TextFormat2 || {});
  class TextBlock2 extends GraphObject2 {
    mi;
    ee;
    Bn;
    Me;
    xi;
    Z0;
    Jd;
    j;
    nt;
    Hl;
    wo;
    Vn;
    Xe;
    bi;
    zn;
    constructor(t, i) {
      return super(), TextBlock2.Tp === false && (TextBlock2.Tp = true, TextBlock2.ps = Diagram2.isUsingDOM() ? new CanvasSurface(null).ni : null), this.l |= 2097152, this.mi = "", this.ee = "black", this.Bn = "13px sans-serif", this.Me = 0, this.xi = 0, this.Z0 = 0, this.Jd = null, this.j = null, this.nt = null, this.Hl = 0, this.wo = null, this.Vn = 0, this.Xe = null, this.bi = null, this.zn = null, typeof t == "string" ? this.text = t : t && Object.assign(this, t), i && Object.assign(this, i), this;
    }
    cloneProtected(t) {
      super.cloneProtected(t), t.mi = this.mi, t.ee = this.ee, t.Bn = this.Bn, t.Me = this.Me, t.xi = this.xi, t.Z0 = this.Z0, t.Jd = this.Jd, this.j !== null && (t.j = this.j.copy()), this.nt !== null && (this.nt.wi ? t.nt = this.nt : t.nt = this.nt.copy()), t.Hl = this.Hl, t.wo = this.wo, t.Vn = this.Vn, t.Xe = this.Xe, t.bi = this.bi, t.zn = this.zn;
    }
    zs() {
      return this.nt === null ? this.nt = new TextBlockTemplateSettings() : this.nt.wi && (this.nt = this.nt.copy()), this.nt;
    }
    Ch() {
      super.Ch(), this.nt !== null && (this.nt.wi = true);
    }
    j3(t) {
      this.l = t.l | 2048 | 4096, this.ei = t.opacity, this.It = t.background, this.gs = t.desiredSize.T(), this.minSize = t.minSize.T(), this.maxSize = t.maxSize.T(), t.Ci !== null ? this.Ci = t.Ci.copy() : this.Ci = null, this.lt = t.scale, this.vt = t.angle, this.stretch = t.stretch, this.hl = t.margin.T(), this.pi = t.alignment.T(), this.Pd = t.alignmentFocus.T(), this.segmentFraction = t.segmentFraction, this.segmentOffset = t.segmentOffset.T(), this.segmentOrientation = t.segmentOrientation, t.ui !== null && (this.ui = t.ui.copy()), this.shadowVisible = t.shadowVisible, this.mi = t.mi, this.ee = t.ee, this.Bn = t.Bn, this.j !== null && (this.j = t.j.copy()), t.nt !== null && (t.nt.wi ? this.nt = t.nt : this.nt = t.nt.copy()), this.Hl = t.Hl;
    }
    v3(t) {
      if (this.mi = t.text || "", this.vt = t.labelAngle || 0, this.Me = t.lineCount || 0, this.cE(t.lines), t.naturalBounds && (this.ji = t.naturalBounds), t.actualBounds) {
        const i = t.actualBounds;
        this.Ut(i.x, i.y, i.width, i.height);
      }
    }
    gi(t) {
      t in Wrap2 ? this.wrap = t : super.gi(t);
    }
    toString() {
      return this.mi.length > 22 ? 'TextBlock("' + this.mi.substring(0, 20) + '"...)' : 'TextBlock("' + this.mi + '")';
    }
    static getEllipsis() {
      return TextBlock2.ty;
    }
    static setEllipsis(t) {
      TextBlock2.ty = t, TextBlock2.hS = new PropertyCollection(), TextBlock2.aC = 0;
    }
    static getBaseline() {
      return TextBlock2.aS;
    }
    static setBaseline(t) {
      TextBlock2.aS = t;
    }
    static aS = null;
    static getUnderline() {
      return TextBlock2.fS;
    }
    static setUnderline(t) {
      TextBlock2.fS = t;
    }
    static fS = null;
    static None = 0;
    static WrapFit = 1;
    static WrapDesiredSize = 2;
    static WrapBreakAll = 3;
    static OverflowClip = 0;
    static OverflowEllipsis = 1;
    static FormatTrim = 0;
    static FormatNone = 1;
    g() {
      super.g(), this.ts(true);
    }
    get font() {
      return this.Bn;
    }
    set font(t) {
      const i = this.Bn;
      i !== t && (Debug && (U.i(t, "string", TextBlock2, "font"), TextBlock2.isValidFont(t) || U.n('Not a valid font: "' + t + '"')), this.Bn = t, this.wo = null, this.g(), this.t("font", i, t));
    }
    static isValidFont(t) {
      return root.CSS ? root.CSS.supports("font", t) : true;
    }
    get text() {
      return this.mi;
    }
    set text(t) {
      const i = this.mi;
      t != null ? t = t.toString() : t = "", i !== t && (this.mi = t, this.g(), this.t("text", i, t));
    }
    get textAlign() {
      return this.nt !== null ? this.nt.iy : "start";
    }
    set textAlign(t) {
      const i = this.textAlign;
      i !== t && (Debug && U.i(t, "string", TextBlock2, "textAlign"), t === "start" || t === "end" || t === "left" || t === "right" || t === "center" ? (this.zs().iy = t, this.L(), this.t("textAlign", i, t)) : Debug && U.G(t, '"start", "end", "left", "right", or "center"', TextBlock2, "textAlign"));
    }
    get flip() {
      return this.nt !== null ? this.nt.xo : 0;
    }
    set flip(t) {
      const i = this.flip;
      i !== t && (U.W(t, Flip2, "Flip"), this.zs().xo = t, this.L(), this.t("flip", i, t));
    }
    get verticalAlignment() {
      return this.nt !== null ? this.nt.gl : Spot2.Top;
    }
    set verticalAlignment(t) {
      const i = this.verticalAlignment;
      i.equals(t) || (Debug && (U.s(t, Spot2, TextBlock2, "verticalAlignment"), t.isNoSpot() && U.n("TextBlock.verticalAlignment for " + this + " must be a real Spot, not:" + t)), t = t.T(), this.zs().gl = t, this.Cc(), this.t("verticalAlignment", i, t));
    }
    get naturalBounds() {
      if (!this.ji.isReal()) {
        const t = Size2.a();
        this.fC(this.mi, 999999, t);
        let i = t.width;
        Size2.o(t);
        let e = this.FD(i);
        const s = this.desiredSize;
        isNaN(s.width) || (i = s.width), isNaN(s.height) || (e = s.height), this.ji.Zn(i, e);
      }
      return this.ji;
    }
    get isMultiline() {
      return (this.l & 2097152) !== 0;
    }
    set isMultiline(t) {
      const i = (this.l & 2097152) !== 0;
      i !== t && (Debug && U.i(t, "boolean", TextBlock2, "isMultiline"), this.l = this.l ^ 2097152, this.g(), this.t("isMultiline", i, t));
    }
    get isUnderline() {
      return (this.l & 4194304) !== 0;
    }
    set isUnderline(t) {
      const i = (this.l & 4194304) !== 0;
      i !== t && (Debug && U.i(t, "boolean", TextBlock2, "isUnderline"), this.l = this.l ^ 4194304, this.ts(true), this.L(), this.t("isUnderline", i, t));
    }
    get isStrikethrough() {
      return (this.l & 8388608) !== 0;
    }
    set isStrikethrough(t) {
      const i = (this.l & 8388608) !== 0;
      i !== t && (Debug && U.i(t, "boolean", TextBlock2, "isStrikethrough"), this.l = this.l ^ 8388608, this.ts(true), this.L(), this.t("isStrikethrough", i, t));
    }
    get wrap() {
      return this.nt !== null ? this.nt.ey : 2;
    }
    set wrap(t) {
      const i = this.wrap;
      i !== t && (Debug && U.W(t, Wrap2, "Wrap"), this.zs().ey = t, this.g(), this.t("wrap", i, t));
    }
    get overflow() {
      return this.nt !== null ? this.nt.ny : 0;
    }
    set overflow(t) {
      const i = this.overflow;
      i !== t && (Debug && U.W(t, TextOverflow2, "Overflow"), this.zs().ny = t, this.g(), this.t("overflow", i, t));
    }
    get isOverflowed() {
      return (this.l & 16777216) !== 0;
    }
    cC(t) {
      t ? this.l |= 16777216 : this.l &= -16777217;
    }
    get stroke() {
      return this.ee;
    }
    set stroke(t) {
      const i = this.ee;
      i !== t && (t !== null && Brush2.Ld(t, "TextBlock.stroke"), t instanceof Brush2 && t.S(), this.ee = t, typeof t != "string" && this.Pc(), this.L(), this.t("stroke", i, t));
    }
    get lineCount() {
      return this.Me;
    }
    get lineHeight() {
      return this.ly();
    }
    get editable() {
      return (this.l & 1048576) !== 0;
    }
    set editable(t) {
      const i = (this.l & 1048576) !== 0;
      i !== t && (Debug && U.i(t, "boolean", TextBlock2, "editable"), this.l = this.l ^ 1048576, this.t("editable", i, t));
    }
    get QN() {
      return (this.l & 33554432) !== 0;
    }
    set QN(t) {
      this.l = this.l ^ 33554432;
    }
    get textEditor() {
      return this.nt !== null ? this.nt.hy : null;
    }
    set textEditor(t) {
      const i = this.textEditor;
      i !== t && (Debug && !(t instanceof HTMLInfo2) && U.n("TextBlock.textEditor must be an HTMLInfo."), this.zs().hy = t, this.t("textEditor", i, t));
    }
    get errorFunction() {
      return this.nt !== null ? this.nt.ws : null;
    }
    set errorFunction(t) {
      const i = this.errorFunction;
      i !== t && (t !== null && U.C(t, TextBlock2, "errorFunction"), this.zs().ws = t, this.t("errorFunction", i, t));
    }
    get interval() {
      return this.j !== null ? this.j.Bc : 1;
    }
    set interval(t) {
      const i = this.interval;
      if (Debug && U.r(t, TextBlock2, "interval"), t = Math.round(t), i !== t && t !== 0 && isFinite(t)) {
        this.j === null && (this.j = new GradElementSettings()), this.j.Bc = t, this.g();
        const e = this.panel;
        e !== null && (e.ys = null), this.t("interval", i, t);
      }
    }
    get graduatedStart() {
      return this.j !== null ? this.j.Vc : 0;
    }
    set graduatedStart(t) {
      const i = this.graduatedStart;
      Debug && U.r(t, TextBlock2, "graduatedStart"), i !== t && (t < 0 ? t = 0 : t > 1 && (t = 1), this.j === null && (this.j = new GradElementSettings()), this.j.Vc = t, this.g(), this.t("graduatedStart", i, t));
    }
    get graduatedEnd() {
      return this.j !== null ? this.j.zc : 1;
    }
    set graduatedEnd(t) {
      const i = this.graduatedEnd;
      Debug && U.r(t, TextBlock2, "graduatedEnd"), i !== t && (t < 0 ? t = 0 : t > 1 && (t = 1), this.j === null && (this.j = new GradElementSettings()), this.j.zc = t, this.g(), this.t("graduatedEnd", i, t));
    }
    get graduatedFunction() {
      return this.j !== null ? this.j.fy : null;
    }
    set graduatedFunction(t) {
      const i = this.graduatedFunction;
      i !== t && (t !== null && U.C(t, TextBlock2, "graduatedFunction"), this.j === null && (this.j = new GradElementSettings()), this.j.fy = t, this.g(), this.t("graduatedFunction", i, t));
    }
    get graduatedSkip() {
      return this.j !== null ? this.j.Xc : null;
    }
    set graduatedSkip(t) {
      const i = this.graduatedSkip;
      i !== t && (t !== null && U.C(t, TextBlock2, "graduatedSkip"), this.j === null && (this.j = new GradElementSettings()), this.j.Xc = t, this.g(), this.t("graduatedSkip", i, t));
    }
    Dh(t, i) {
      if (this.ee === null || this.mi.length === 0 || this.Bn === null) return;
      const e = this.naturalBounds, s = this.actualBounds, n = e.width, o = e.height, r = this.ly();
      let l = t.textAlign = this.textAlign;
      const h = i.dd;
      l === "start" ? l = h ? "right" : "left" : l === "end" && (l = h ? "left" : "right");
      const f = this.isUnderline, a = this.isStrikethrough;
      this.Cn(t, this.ee, true, false, e, s), (f || a) && this.Cn(t, this.ee, false, false, e, s);
      const c = 0;
      let u = 0;
      const d = n;
      let m = false;
      i._t === t && !(i._t instanceof SVGContext) && !this.QN && i.getRenderingHint("textGreeking") === true && r * this.Ra * i.scale < 3 && (m = true);
      const g = this.spacingAbove, p = this.spacingBelow;
      switch (this.flip) {
        case 0:
          break;
        case 2:
          t.translate(n, 0), t.scale(-1, 1);
          break;
        case 1:
          t.translate(0, o), t.scale(1, -1);
          break;
        case 3:
          t.translate(n, o), t.scale(-1, -1);
          break;
      }
      t.commitTransform();
      const y = this.Me, S = (g + r + p) * y;
      if (o > S) {
        const b = this.verticalAlignment;
        u = b.y * o - b.y * S + b.offsetY;
      }
      if (TextBlock2.cS && (t.letterSpacing = this.letterSpacing, t.wordSpacing = this.wordSpacing), y === 1 && this.zn !== null) {
        let b = this.xi;
        b > d && (b = d), u += g, this.ID(this.zn, t, c, u, d, r, b, m, l, f, a);
      } else if (this.Xe !== null && this.bi !== null) for (let b = 0; b < y; b++) {
        let k = this.Xe[b];
        k > d && (k = d), u += g, this.ID(this.bi[b], t, c, u, d, r, k, m, l, f, a), u += r + p;
      }
      switch (this.flip) {
        case 0:
          break;
        case 2:
          t.scale(-1, 1), t.translate(-n, 0);
          break;
        case 1:
          t.scale(1, -1), t.translate(0, -o);
          break;
        case 3:
          t.scale(-1, -1), t.translate(-n, -o);
          break;
      }
    }
    ID(t, i, e, s, n, o, r, l, h, f, a) {
      let c = 0;
      if (l) {
        h === "left" ? c = 0 : h === "right" ? c = n - r : h === "center" && (c = (n - r) / 2);
        const m = i.globalAlpha;
        i.globalAlpha = m / 2, i.fillRect(e + c, s + o / 4, r, o / 2), i.globalAlpha = m;
        return;
      }
      h === "left" ? c = 0 : h === "right" ? c = n : h === "center" && (c = n / 2);
      const u = TextBlock2.aS !== null ? TextBlock2.aS(this, o) : o * 0.75;
      i.fillText(t, e + c, s + u);
      let d = o / 20 | 0;
      if (d === 0 && (d = 1), h === "right" ? c -= r : h === "center" && (c -= r / 2), f) {
        const m = TextBlock2.fS !== null ? TextBlock2.fS(this, o) : o * 0.8;
        this.RD(e + c, s + m, e + c + r, s + m, d, i), i instanceof SVGContext && i.lastCreatedElement.classList.add("gojs-td");
      }
      if (a) {
        let m = s + o - o / 2.2 | 0;
        d % 2 !== 0 && (m += 0.5), this.RD(e + c, m, e + c + r, m, d, i), i instanceof SVGContext && i.lastCreatedElement.classList.add("gojs-td");
      }
    }
    RD(t, i, e, s, n, o) {
      o.beginPath(), o.lineWidth = n, o.moveTo(t, i), o.lineTo(e, s), o.stroke(), o.endPath();
    }
    kc(t, i, e) {
      if (!super.kc(t, i, e)) return false;
      if (this.Cn(t, this.ee, true, false, this.naturalBounds, this.actualBounds), e) {
        if (this.svg.getElementsByTagName("text").length === 0) return true;
        const n = this.svg.getElementsByClassName("gojs-td");
        for (let o = 0; o < n.length; o++) t.setFillOrStrokeInPlace(n[o], false);
      } else this.uE(this.svg, this.bi ? this.bi[0] : this.text, t);
      return true;
    }
    uE(t, i, e) {
      t.innerHTML = i, e.setFillOrStrokeInPlace(t, true);
    }
    Ad(t) {
      return this.lineCount > 1 || this.isUnderline || this.isStrikethrough ? true : super.Ad(t);
    }
    RN(t, i) {
      if (t.nodeName !== "g") t.setAttributeNS(null, "filter", i);
      else {
        const e = t.getElementsByTagName("text");
        for (let s = 0; s < e.length; s++) e[s].setAttributeNS(null, "filter", i);
      }
    }
    dE() {
      this.Vn = 0, this.xi = 0, this.wo = null, this.Xe = null, this.bi = null, this.zn = null;
    }
    Nd(t, i, e, s) {
      const n = this.Me;
      this.Hl = t, this.cC(false);
      const o = this.Bn;
      TextBlock2.ps !== null && (TextBlock2.OD !== o && (TextBlock2.ps.font = o, TextBlock2.OD = o), TextBlock2.cS && (TextBlock2.ps.letterSpacing = this.letterSpacing, TextBlock2.ps.wordSpacing = this.wordSpacing)), this.dE();
      let r = 0, l = 0;
      isNaN(this.desiredSize.width) ? (r = this.gE(), r = Math.min(r, t / this.scale)) : r = this.desiredSize.width, this.panel !== null && (r = Math.min(r, this.panel.maxSize.width)), l = this.FD(r), isNaN(this.desiredSize.height) ? l = Math.min(l, i / this.scale) : l = this.desiredSize.height, this.mE(t, l), (this.wrap === 1 || isNaN(this.desiredSize.width)) && (r = isNaN(t) ? this.xi : Math.min(t, this.xi)), r = Math.max(e, r), l = Math.max(s, l), this.ji.Zn(r, l), this.co(0, 0, r, l), this.svg !== null && n !== this.Me && this.ts(true);
    }
    Th(t, i, e, s) {
      this.commonArrange(t, i, e, s);
    }
    Xn(t, i) {
      this.zn === null ? (this.zn = t, this.xi = i) : ((this.bi === null || this.Xe === null) && (this.bi = [], this.Xe = [], this.bi.push(this.zn), this.Xe.push(this.xi)), this.bi.push(t), this.Xe.push(i), this.bi.length > this.maxLines && (this.l |= 16777216));
    }
    fC(t, i, e) {
      const s = this.formatting === 0;
      s && (t = t.trim());
      let n = 0, o = 0, r = 0;
      const l = this.Bn, h = this.spacingAbove + this.spacingBelow, f = Math.max(0, this.ly() + h), a = this.overflow === 1 ? this.ED(l) : 0;
      if (this.Me >= this.maxLines) {
        e !== void 0 && e.e(0, f);
        return;
      }
      let c = t;
      if (this.wrap === 0) {
        if (this.Vn = 1, o = this.getStringWidth(t), a === 0 || o <= i) {
          this.xi = Math.max(this.xi, o), this.Xn(t, this.xi), e !== void 0 && e.e(o, f);
          return;
        }
        let d = this.$d(c);
        c = c.substring(d.length);
        let m = this.$d(c);
        for (o = this.getStringWidth(d + m), r = 0; m.length > 0 && o <= i; ) {
          d += m, c = c.substring(m.length), m = this.$d(c), r = o;
          let g = d + m;
          s && (g = g.trim()), o = this.getStringWidth(g);
        }
        for (s && (m = m.trim()), d += m, i = Math.max(1, i - a); this.getStringWidth(d) > i && d.length > 1; ) d = d.substring(0, d.length - 1);
        this.cC(true), d += TextBlock2.ty, r = this.getStringWidth(d), this.xi = r, this.Xn(d, r), e !== void 0 && e.e(r, f);
        return;
      }
      let u = 0;
      for (c.length === 0 && (u = 1, this.Xn(c, 0)); c.length > 0; ) {
        let d = this.$d(c);
        for (c = c.substring(d.length); this.getStringWidth(d) > i; ) {
          let p = 1;
          for (o = this.getStringWidth(d.substring(0, p)), r = 0; o <= i; ) p++, r = o, o = this.getStringWidth(d.substring(0, p));
          let y = 0;
          p === 1 ? (y = o, n = Math.max(n, o)) : (y = r, n = Math.max(n, r)), p--, p < 1 && (p = 1);
          const x = d.substring(0, p);
          if (this.Xn(x, y), u++, d = d.substring(p), this.Me + u > this.maxLines) break;
        }
        let m = this.$d(c);
        for (o = this.getStringWidth(d + m), r = 0; m.length > 0 && o <= i; ) {
          d += m, c = c.substring(m.length), m = this.$d(c), r = o;
          let p = d + m;
          s && (p = p.trim()), o = this.getStringWidth(p);
        }
        if (s && (d = d.trim()), d === "") continue;
        d[d.length - 1] === "" && (d = d.substring(0, d.length - 1) + "");
        let g = 0;
        if (m.length === 0 ? (g = o, n = Math.max(n, o)) : (r = this.getStringWidth(d), g = r, n = Math.max(n, r)), this.Xn(d, g), u++, this.Me + u > this.maxLines) break;
      }
      this.Vn = Math.min(this.maxLines - this.Me, u), this.xi = Math.max(this.xi, n), e !== void 0 && e.e(this.xi, f * this.Vn);
    }
    mE(t, i) {
      if (this.xi === 0 || this.Xe === null || this.bi === null || this.overflow !== 1) return;
      const e = this.Bn, s = this.overflow === 1 ? this.ED(e) : 0, n = this.spacingAbove + this.spacingBelow, o = Math.max(0, this.ly() + n), r = Math.min(this.maxLines - 1, Math.max(Math.floor(i / o + 0.01) - 1, 0));
      if (r + 1 >= this.bi.length) return;
      this.cC(true);
      let l = this.bi[r];
      const h = Math.max(1, t - s);
      for (; this.getStringWidth(l) > h && l.length > 1; ) l = l.substring(0, l.length - 1);
      l += TextBlock2.ty;
      const f = this.getStringWidth(l);
      this.bi[r] = l, this.bi = this.bi.slice(0, r + 1), this.Xe[r] = f, this.Xe = this.Xe.slice(0, r + 1), this.Vn = this.bi.length, this.xi = Math.max(this.xi, f), this.Me = this.Vn, this.Me === 1 && (this.zn = this.bi[0]);
    }
    $d(t) {
      if (this.wrap === 3) return t.substring(0, 1);
      let i = t.length, e = 0;
      const s = TextBlock2.pE;
      for (; e < i && !s.test(t.charAt(e)); ) e++;
      for (this.formatting === 1 && (i = Math.min(i, e + 1)); e < i && s.test(t.charAt(e)); ) e++;
      return e >= t.length ? t : t.substring(0, e);
    }
    getStringWidth(t) {
      return TextBlock2.ps === null ? t.length * 8 : TextBlock2.ps.measureText(t).width;
    }
    ly() {
      if (this.wo !== null) return this.wo;
      const t = this.Bn;
      let i = 0;
      if (TextBlock2.ps === null) return i = 16, this.wo = i, i;
      if (TextBlock2.uC[t] !== void 0 && TextBlock2.BD < 5e3) i = TextBlock2.uC[t];
      else {
        TextBlock2.ps.letterSpacing = "0px";
        const e = TextBlock2.ps.measureText("M");
        TextBlock2.ps.letterSpacing = this.letterSpacing, i = e.width * 1.3, TextBlock2.uC[t] = i, TextBlock2.BD++;
      }
      return this.wo = i, i;
    }
    ED(t) {
      if (TextBlock2.ps === null) return 6;
      let i = 0;
      return TextBlock2.hS[t] !== void 0 && TextBlock2.aC < 5e3 ? i = TextBlock2.hS[t] : (i = TextBlock2.ps.measureText(TextBlock2.ty).width, TextBlock2.hS[t] = i, TextBlock2.aC++), i;
    }
    uS(t, i) {
      return t.indexOf(`
`, i);
    }
    FD(t) {
      let i = this.mi.replace(/\r\n/g, `
`).replace(/\r/g, `
`);
      const e = this.spacingAbove + this.spacingBelow, s = Math.max(0, this.ly() + e);
      if (i.length === 0) return this.xi = 0, this.Me = 1, s;
      if (!this.isMultiline) {
        const h = this.uS(i, 0);
        h >= 0 && (i = i.substring(0, h));
      }
      let n = 0;
      this.Me = 0;
      let o = 0, r = -1, l = false;
      for (; !l; ) {
        if (r = this.uS(i, o), r === -1 && (r = i.length, l = true), o <= r) {
          const h = i.substring(o, r);
          if (this.wrap !== 0) {
            this.Vn = 0;
            const f = Size2.a();
            this.fC(h, t, f), n += f.height, Size2.o(f), this.Me += this.Vn;
          } else this.fC(h, t), n += s, this.Me++;
          this.Me === this.maxLines && (l = true);
        }
        o = r + 1;
      }
      return this.Z0 = n, n;
    }
    gE() {
      let t = this.mi.replace(/\r\n/g, `
`).replace(/\r/g, `
`);
      if (t.length === 0) return 8;
      if (this.isMultiline) {
        let i = 0, e = 0, s = false;
        for (; !s; ) {
          let n = this.uS(t, e);
          n === -1 && (n = t.length, s = true);
          let o = t.substring(e, n);
          this.formatting === 0 && (o = o.trim()), i = Math.max(i, this.getStringWidth(o)), e = n + 1;
        }
        return i;
      } else {
        const i = this.uS(t, 0);
        return i >= 0 && (t = t.substring(0, i)), this.getStringWidth(t);
      }
    }
    get textValidation() {
      return this.nt !== null ? this.nt.ql : null;
    }
    set textValidation(t) {
      const i = this.textValidation;
      i !== t && (t !== null && U.C(t, TextBlock2, "textValidation"), this.zs().ql = t, this.t("textValidation", i, t));
    }
    get textEdited() {
      return this.nt !== null ? this.nt.cy : null;
    }
    set textEdited(t) {
      const i = this.textEdited;
      i !== t && (t !== null && U.C(t, TextBlock2, "textEdited"), this.zs().cy = t, this.t("textEdited", i, t));
    }
    get spacingAbove() {
      return this.nt !== null ? this.nt.uy : 0;
    }
    set spacingAbove(t) {
      const i = this.spacingAbove;
      i !== t && (Debug && U.i(t, "number", TextBlock2, "spacingAbove"), this.zs().uy = t, this.g(), this.t("spacingAbove", i, t));
    }
    get spacingBelow() {
      return this.nt !== null ? this.nt.gy : 0;
    }
    set spacingBelow(t) {
      const i = this.spacingBelow;
      i !== t && (Debug && U.i(t, "number", TextBlock2, "spacingBelow"), this.zs().gy = t, this.g(), this.t("spacingBelow", i, t));
    }
    get letterSpacing() {
      return this.nt !== null ? this.nt.my : "0px";
    }
    set letterSpacing(t) {
      const i = this.letterSpacing;
      i !== t && (TextBlock2.cS = true, Debug && U.i(t, "string", TextBlock2, "letterSpacing"), this.zs().my = t, this.g(), this.t("letterSpacing", i, t));
    }
    get wordSpacing() {
      return this.nt !== null ? this.nt.yy : "0px";
    }
    set wordSpacing(t) {
      const i = this.wordSpacing;
      i !== t && (TextBlock2.cS = true, Debug && U.i(t, "string", TextBlock2, "wordSpacing"), this.zs().yy = t, this.g(), this.t("wordSpacing", i, t));
    }
    get formatting() {
      return this.nt !== null ? this.nt.wy : 0;
    }
    set formatting(t) {
      const i = this.formatting;
      i !== t && (U.W(t, TextFormat2, "formatting"), this.zs().wy = t, this.g(), this.t("formatting", i, t));
    }
    get maxLines() {
      return this.nt !== null ? this.nt.xy : 1 / 0;
    }
    set maxLines(t) {
      const i = this.maxLines;
      i !== t && (Debug && U.i(t, "number", TextBlock2, "maxLines"), t = Math.floor(t), t <= 0 && U.G(t, "> 0", TextBlock2, "maxLines"), this.zs().xy = t, this.g(), this.t("maxLines", i, t));
    }
    getMetrics() {
      return [this.xi, this.Hl, this.wo, this.Vn, this.Xe, this.bi, this.zn || ""];
    }
    cE(t) {
      t !== void 0 && (this.xi = t[0], this.Hl = t[1], this.wo = t[2], this.Vn = t[3], this.Xe = t[4], this.bi = t[5], this.zn = t[6]);
    }
    get metrics() {
      return { arrSize: this.Xe !== null ? this.Xe : [this.xi], arrText: this.bi !== null ? this.bi : [this.zn], maxLineWidth: this.xi, fontHeight: this.wo };
    }
    get choices() {
      return this.Jd;
    }
    set choices(t) {
      const i = this.Jd;
      i !== t && (Debug && t !== null && !Array.isArray(t) && U.Ti(t, "Array", TextBlock2, "choices:value"), this.Jd = t, this.t("choices", i, t));
    }
    static pE = new RegExp("[ ]");
    static uC = new PropertyCollection();
    static BD = 0;
    static hS = new PropertyCollection();
    static aC = 0;
    static ty = "...";
    static OD = "";
    static ps = null;
    static Tp = false;
    static cS = false;
  }
  class TextBlockTemplateSettings {
    wi;
    ws;
    xo;
    wy;
    xy;
    ny;
    uy;
    gy;
    iy;
    cy;
    hy;
    ql;
    gl;
    ey;
    my;
    yy;
    constructor() {
      this.wi = false, this.ws = null, this.xo = 0, this.wy = 0, this.xy = 1 / 0, this.ny = 0, this.uy = 0, this.gy = 0, this.iy = "start", this.cy = null, this.hy = null, this.ql = null, this.gl = Spot2.Top, this.ey = 2, this.my = "0px", this.yy = "0px";
    }
    copy() {
      const t = new TextBlockTemplateSettings();
      return t.ws = this.ws, t.xo = this.xo, t.wy = this.wy, t.xy = this.xy, t.ny = this.ny, t.uy = this.uy, t.gy = this.gy, t.iy = this.iy, t.cy = this.cy, t.hy = this.hy, t.ql = this.ql, t.gl = this.gl, t.ey = this.ey, t.my = this.my, t.yy = this.yy, t;
    }
  }
  class GradElementSettings {
    Bc;
    Vc;
    zc;
    fy;
    Xc;
    constructor() {
      this.Bc = 1, this.Vc = 0, this.zc = 1, this.fy = null, this.Xc = null;
    }
    copy() {
      const t = new GradElementSettings();
      return t.Bc = this.Bc, t.Vc = this.Vc, t.zc = this.zc, t.fy = this.fy, t.Xc = this.Xc, t;
    }
  }
  var ImageStretch2 = ((w) => (w[w.None = 0] = "None", w[w.Fill = 2] = "Fill", w[w.Uniform = 6] = "Uniform", w[w.UniformToFill = 7] = "UniformToFill", w))(ImageStretch2 || {});
  class Picture2 extends GraphObject2 {
    pl;
    ln;
    yl;
    Yc;
    ws;
    wl;
    Kc;
    xo;
    Uc;
    Gc;
    qb;
    constructor(t, i) {
      super(), this.l |= 2097152, this.pl = null, this.ln = "", this.yl = Rect2.JI, this.Yc = 2, this.ws = null, this.wl = null, this.Kc = Spot2.Center, this.xo = 0, this.Uc = null, this.Gc = null, this.qb = null, typeof t == "string" ? this.source = t : t && Object.assign(this, t), i && Object.assign(this, i);
    }
    cloneProtected(t) {
      super.cloneProtected(t), t.ln = this.ln, t.element = this.pl, t.yl = this.yl.T(), t.Yc = this.Yc, t.xo = this.xo, t.ws = this.ws, t.wl = this.wl, t.Kc = this.Kc.T(), t.Gc = this.Gc;
    }
    gi(t) {
      t in ImageStretch2 ? this.imageStretch = t : super.gi(t);
    }
    toString() {
      return "Picture(" + this.source + ")#" + GSet2.Ps(this);
    }
    get qc() {
      return (this.l & 1048576) !== 0;
    }
    set qc(t) {
      this.qc !== t && (this.l = this.l ^ 1048576);
    }
    get Qa() {
      return (this.l & 2097152) !== 0;
    }
    set Qa(t) {
      this.Qa !== t && (this.l = this.l ^ 2097152);
    }
    get Ln() {
      return (this.l & 4194304) !== 0;
    }
    set Ln(t) {
      this.Ln !== t && (this.l = this.l ^ 4194304);
    }
    static clearCache(t) {
      t === void 0 && (t = ""), U.i(t, "string", Picture2, "clearCache:url"), t !== "" ? Picture2.Sy[t] && (delete Picture2.Sy[t], Picture2.dS--) : (Picture2.Sy = new PropertyCollection(), Picture2.dS = 0);
    }
    static AL(t, i) {
      i.VD || (i.gS = (e) => {
        Picture2.yE(i, e), t.desiredSize.isReal() || (t.Se(false), t.g());
      }, i.mS = (e) => Picture2.wE(i, e), i.addEventListener("load", i.gS), i.addEventListener("error", i.mS), i.VD = true);
    }
    static VO(t) {
      t.gS && t.removeEventListener("load", t.gS), t.mS && t.removeEventListener("error", t.mS), delete t.gS, delete t.mS, t.VD = false;
    }
    get element() {
      return this.pl;
    }
    set element(t) {
      const i = this.pl;
      if (this.ts(true), i !== t) {
        this.qc = t instanceof HTMLCanvasElement;
        const e = t instanceof HTMLImageElement;
        t !== null && !(e || t instanceof HTMLVideoElement || this.qc) && U.n("Picture.element must be an instance of Image, Canvas, or Video, not: " + t);
        const s = this.diagram;
        s !== null && s.z2(this), this.pl = t, t !== null && e && t.ds === void 0 && (t.ds = new GSet2()), s !== null && e && s.V2(this), this.t("element", i, t), this.L();
      }
    }
    EO() {
      const t = this.pl;
      if (t === null) return;
      const i = this.desiredSize.isReal();
      (this.qc || t.complete === true) && (t.O0 && (t.ky instanceof Event && this.ws !== null ? this.ws(this, t.ky) : t.Ln === true && !t.ky && this.wl !== null && t.dC && this.wl(this, t.dC)), t.Ln = true), t.Ln && i && this.diagram !== null && this.diagram.ud.add(this);
    }
    xE() {
      if (this.pl === null) {
        this.Uc = false;
        return;
      }
      const t = new CanvasSurface(null).ni;
      try {
        t.drawImage(this.pl, 0, 0);
      } catch (i) {
        Debug && this.Qa && U.ot(i.toString()), this.Qa = false;
      }
      try {
        t.getImageData(0, 0, 1, 1).data[3] && (this.Uc = false), this.Uc = false;
      } catch {
        this.Uc = true;
      }
    }
    get source() {
      return this.ln;
    }
    set source(t) {
      const i = this.ln;
      if (i !== t) {
        this.ts(true), U.i(t, "string", Picture2, "source"), this.ln = t;
        let e = Picture2.Sy;
        if (!Diagram2.isUsingDOM()) {
          this.t("source", i, t);
          return;
        }
        let s = null;
        if (e[t] !== void 0) s = e[t];
        else if (t !== "") {
          Picture2.dS > 30 && (Picture2.clearCache(), e = Picture2.Sy), s = U.Le("img"), s.O0 = true, Picture2.AL(this, s);
          const n = this.Gc;
          n !== null && (s.crossOrigin = n(this)), s.src = t, e[t] = s, Picture2.dS++;
        }
        this.element = s, s !== null && s.__goCache === void 0 && (s.__goCache = new PictureCacheArray()), this.g(), this.L(), this.t("source", i, t);
      }
    }
    static yE(t, i) {
      t.Ln = true, t.ky = false;
      let e;
      const s = t.ds.copy();
      if (s == null) return;
      const n = s.iterator;
      for (; n.next(); ) {
        const o = n.value;
        o.L();
        const r = t.getAttribute("src") || "", l = o.ch.get(r);
        if (l === null) continue;
        const h = l.length;
        for (let f = 0; f < h; f++) e = l[f], e.desiredSize.isReal() || o.ud.add(e), e.ts(true), o.requestUpdate(), t.O0 && (t.dC === void 0 && (t.dC = i), e.wl !== null && e.wl(e, i));
      }
      t.ds.clear();
    }
    static wE(t, i) {
      t.ky = i;
      let e;
      const s = t.ds.copy();
      if (s == null) return;
      const n = s.iterator;
      for (; n.next(); ) {
        const o = n.value, r = t.getAttribute("src") || "", l = o.ch.get(r);
        if (l === null) continue;
        const h = l.length, f = U.ft();
        for (let a = 0; a < h; a++) f.push(l[a]);
        if (t.O0) for (let a = 0; a < h; a++) e = f[a], e.ws !== null && e.ws(e, i);
        U.et(f);
      }
      t.ds.clear();
    }
    reloadSource() {
      if (this.source === "") return;
      Picture2.clearCache(this.source);
      const t = this.source;
      this.source = "", this.source = t;
    }
    redraw() {
      this.L(), this.ts(true);
    }
    get sourceCrossOrigin() {
      return this.Gc;
    }
    set sourceCrossOrigin(t) {
      if (this.Gc !== t && (t !== null && U.C(t, Picture2, "sourceCrossOrigin"), this.Gc = t, this.element !== null)) {
        const e = this.element.getAttribute("src");
        this.element instanceof HTMLImageElement && (t === null && typeof e == "string" ? this.element.crossOrigin = null : t !== null && (this.element.crossOrigin = t(this)), e && (this.element.src = e));
      }
    }
    get sourceRect() {
      return this.yl;
    }
    set sourceRect(t) {
      const i = this.yl;
      i.equals(t) || (U.s(t, Rect2, Picture2, "sourceRect"), t = t.T(), this.yl = t, this.L(), this.t("sourceRect", i, t));
    }
    get imageStretch() {
      return this.Yc;
    }
    set imageStretch(t) {
      const i = this.Yc;
      i !== t && (U.W(t, ImageStretch2, "ImageStretch"), this.Yc = t, this.L(), this.t("imageStretch", i, t));
    }
    get flip() {
      return this.xo;
    }
    set flip(t) {
      const i = this.xo;
      i !== t && (U.W(t, Flip2, "Flip"), this.xo = t, this.L(), this.t("flip", i, t));
    }
    get imageAlignment() {
      return this.Kc;
    }
    set imageAlignment(t) {
      U.s(t, Spot2, Picture2, "imageAlignment");
      const i = this.Kc;
      i.equals(t) || (t = t.T(), this.Kc = t, this.L(), this.t("imageAlignment", i, t));
    }
    get errorFunction() {
      return this.ws;
    }
    set errorFunction(t) {
      const i = this.ws;
      i !== t && (t !== null && U.C(t, Picture2, "errorFunction"), this.ws = t, this.t("errorFunction", i, t));
    }
    get successFunction() {
      return this.wl;
    }
    set successFunction(t) {
      const i = this.wl;
      i !== t && (t !== null && U.C(t, Picture2, "successFunction"), this.wl = t, this.t("successFunction", i, t));
    }
    Dh(t, i) {
      const e = this.pl;
      if (e === null) return;
      const s = e.getAttribute("src");
      if (e instanceof HTMLImageElement && (s === null || s === "") || e.ky instanceof Event && t instanceof CanvasSurfaceContext) return;
      const n = t instanceof SVGContext, o = this.naturalBounds;
      let r = 0, l = 0;
      const h = this.qc;
      let f = h ? +e.width : e.naturalWidth, a = h ? +e.height : e.naturalHeight;
      if (f === void 0 && e.videoWidth && (f = e.videoWidth), a === void 0 && e.videoHeight && (a = e.videoHeight), f === 0 || a === 0) return;
      const c = f, u = a;
      this.sourceRect.isReal() && (r = this.yl.x, l = this.yl.y, f = this.yl.width, a = this.yl.height);
      let d = f, m = a;
      const g = this.Yc, p = this.Kc;
      switch (g) {
        case 0:
          if (this.sourceRect.isReal()) break;
          d >= o.width && (r = r + p.offsetX + (d * p.x - o.width * p.x)), m >= o.height && (l = l + p.offsetY + (m * p.y - o.height * p.y)), f = Math.min(o.width, d), a = Math.min(o.height, m);
          break;
        case 2:
          d = o.width, m = o.height;
          break;
        case 6:
        case 7:
          let T = 0;
          g === 6 ? (T = Math.min(o.height / m, o.width / d), d *= T, m *= T) : g === 7 && (T = Math.max(o.height / m, o.width / d), d *= T, m *= T, d >= o.width && (r = (r + p.offsetX + (d * p.x - o.width * p.x) / d) * f), m >= o.height && (l = (l + p.offsetY + (m * p.y - o.height * p.y) / m) * a), f *= 1 / (d / o.width), a *= 1 / (m / o.height), d = o.width, m = o.height);
          break;
      }
      const y = f * a, x = this.getDocumentScale() * i.scale, S = d * x, b = m * x, k = S * b, P = y / k, A = e.__goCache;
      let C = null;
      const M = Picture2.bE;
      if (!n) {
        if (e.Ln && A !== void 0 && c < 8e3 && u < 8e3 && k > 4 && P > M * M) {
          A.Gt === null && (A.zD(4, c, u, e), A.zD(16, c, u, e));
          const T = A.Gt, D = T.length;
          for (let F = 0; F < D && T[F].Zd * T[F].Zd < P; F++) C = T[F];
        }
        if (!i.cd && (this.Uc === null && this.xE(), this.Uc)) return;
      }
      const N = d < o.width ? p.offsetX + (o.width * p.x - d * p.x) : 0, L = m < o.height ? p.offsetY + (o.height * p.y - m * p.y) : 0;
      switch (this.flip) {
        case 0:
          break;
        case 2:
          t.translate(Math.min(o.width, d), 0), t.scale(-1, 1);
          break;
        case 1:
          t.translate(0, Math.min(o.height, m)), t.scale(1, -1);
          break;
        case 3:
          t.translate(Math.min(o.width, d), Math.min(o.height, m)), t.scale(-1, -1);
          break;
      }
      if (t.commitTransform(), i.getRenderingHint("pictureRatioOptimization") && !i.xa && A !== void 0 && C !== null && C.Zd !== 1) {
        t.save();
        const T = C.Zd;
        try {
          t.drawImage(C.ln, r / T, l / T, Math.min(C.ln.width, f / T), Math.min(C.ln.height, a / T), N, L, Math.min(o.width, d), Math.min(o.height, m)), t instanceof SVGContext && (this.qb = [r / T, l / T, Math.min(C.ln.width, f / T), Math.min(C.ln.height, a / T), N, L, Math.min(o.width, d), Math.min(o.height, m)]);
        } catch (D) {
          Debug && this.Qa && U.ot(D.toString()), this.Qa = false;
        }
        t.restore();
      } else try {
        t.drawImage(e, r, l, f, a, N, L, Math.min(o.width, d), Math.min(o.height, m)), t instanceof SVGContext && (this.qb = [r, l, f, a, N, L, Math.min(o.width, d), Math.min(o.height, m)]);
      } catch (T) {
        Debug && this.Qa && U.ot(T.toString()), this.Qa = false;
      }
      switch (this.flip) {
        case 0:
          break;
        case 2:
          t.scale(-1, 1), t.translate(-Math.min(o.width, d), 0);
          break;
        case 1:
          t.scale(1, -1), t.translate(0, -Math.min(o.height, m));
          break;
        case 3:
          t.scale(-1, -1), t.translate(-Math.min(o.width, d), -Math.min(o.height, m));
          break;
      }
    }
    get naturalBounds() {
      return this.ji;
    }
    Nd(t, i, e, s) {
      const n = this.desiredSize, o = this.sn(true), r = this.pl, l = this.qc;
      let h = 0, f = 0;
      (l || !this.Ln && r && r.complete) && (this.Ln = true), r === null ? (isFinite(n.width) || (t = e), isFinite(n.height) || (i = s)) : (h = l ? +r.width : r.naturalWidth, f = l ? +r.height : r.naturalHeight), !isFinite(n.width) && o !== 2 && o !== 5 ? r !== null && this.Ln !== false && (this.sourceRect.isReal() ? t = this.sourceRect.width : t = h) : (isFinite(t) || (this.sourceRect.isReal() ? t = this.sourceRect.width : r !== null && (t = h)), e = 0), !isFinite(n.height) && o !== 2 && o !== 4 ? r !== null && this.Ln !== false && (this.sourceRect.isReal() ? i = this.sourceRect.height : i = f) : (isFinite(i) || (this.sourceRect.isReal() ? i = this.sourceRect.height : r !== null && (i = f)), s = 0), isFinite(n.width) && (t = n.width), isFinite(n.height) && (i = n.height);
      const a = this.maxSize, c = this.minSize;
      e = Math.max(e || 0, c.width), s = Math.max(s || 0, c.height), t = Math.min(a.width, t), i = Math.min(a.height, i), t = Math.max(e, t), i = Math.max(s, i), r !== null && !r.complete && (isFinite(t) || (t = 0), isFinite(i) || (i = 0)), this.ji.Zn(t, i), this.co(0, 0, t, i);
    }
    Th(t, i, e, s) {
      this.commonArrange(t, i, e, s);
    }
    static Sy = new PropertyCollection();
    static dS = 0;
    static bE = 4;
  }
  class PictureCacheArray {
    Gt;
    constructor() {
      this.Gt = null;
    }
    zD(t, i, e, s) {
      this.Gt === null && (this.Gt = []);
      const n = new CanvasSurface(null), o = n.ni, r = 1 / t;
      if (n.width = i / t, n.height = e / t, n.width === 0 || n.height === 0) return;
      const l = new PictureCacheInstance(n.Nt, t);
      let h = s, f = 1;
      if (this.Gt.length > 0) {
        const a = this.Gt[this.Gt.length - 1];
        h = a.ln, f = a.Zd;
      }
      o.setTransform(r * f, 0, 0, r * f, 0, 0), o.commitTransform(), o.drawImage(h, 0, 0), this.Gt.push(l);
    }
  }
  class PictureCacheInstance {
    ln;
    Zd;
    constructor(t, i) {
      this.ln = t, this.Zd = i;
    }
  }
  class GeoStream {
    Li;
    ym;
    constructor() {
      this.ym = new Geometry2(), this.Li = null;
    }
    Ki(t) {
      t !== null ? (this.ym = t, t.figures.clear()) : this.ym = new Geometry2(), this.Li = null;
    }
    Ru(t, i, e, s, n, o) {
      if (s !== void 0 && s === true) {
        const r = new PathSegment2(1);
        r.endX = t, r.endY = i, this.Li.segments.add(r);
      } else this.Li = new PathFigure2(), this.Li.startX = t, this.Li.startY = i, this.Li.isFilled = e, this.Li.isEvenOdd = o || false, this.ym.figures.add(this.Li);
      n !== void 0 && (this.Li.isShadowed = n);
    }
    rR() {
      const t = this.Li.segments.length;
      t > 0 && this.Li.segments.elt(t - 1).close();
    }
    lR() {
      this.Li.segments.length > 0 && (this.Li.isFilled = true);
    }
    hR(t) {
      this.Li.isShadowed = t;
    }
    YB(t) {
      this.Li.isEvenOdd = t;
    }
    sR(t, i, e) {
      e === void 0 && (e = false);
      const s = new PathSegment2(1);
      s.endX = t, s.endY = i, e && s.close(), this.Li.segments.add(s);
    }
    js(t, i, e) {
      e === void 0 && (e = false);
      const s = new PathSegment2(2);
      s.endX = t, s.endY = i, e && s.close(), this.Li.segments.add(s);
    }
    Mr(t, i, e, s, n, o, r) {
      r === void 0 && (r = false);
      const l = new PathSegment2(3);
      l.point1X = t, l.point1Y = i, l.point2X = e, l.point2Y = s, l.endX = n, l.endY = o, r && l.close(), this.Li.segments.add(l);
    }
    Ou(t, i, e, s, n) {
      n === void 0 && (n = false);
      const o = new PathSegment2(4);
      o.point1X = t, o.point1Y = i, o.endX = e, o.endY = s, n && o.close(), this.Li.segments.add(o);
    }
    nR(t, i, e, s, n, o, r) {
      o === void 0 && (o = 0), r === void 0 && (r = false);
      const l = new PathSegment2(5);
      l.startAngle = t, l.sweepAngle = i, l.centerX = e, l.centerY = s, l.radiusX = n, o !== 0 ? l.radiusY = o : l.radiusY = n, r && l.close(), this.Li.segments.add(l);
    }
    oR(t, i, e, s, n, o, r, l) {
      l === void 0 && (l = false);
      const h = new PathSegment2(6, o, r, t, i, e, s, n);
      l && h.close(), this.Li.segments.add(h);
    }
    static gC = null;
    static ZA(t) {
      const i = GeoStream.gC;
      if (i !== null) return GeoStream.gC = null, i.Ki(t), i;
      {
        const e = new GeoStream();
        return e.Ki(t), e;
      }
    }
    static QA(t) {
      GeoStream.gC = t;
    }
  }
  {
    const w = function(n, o) {
      const r = n.toLowerCase(), l = G.bn;
      l[n] = o, l[r] = n;
    };
    w("Rectangle", (n, o, r) => {
      const l = "r" + o + "," + r;
      let h = G.kr[l];
      return h !== void 0 || (h = new Geometry2(2), h.endX = o, h.endY = r, G.Pr < G.dm && (G.kr[l] = h, G.Pr++)), h;
    }), w("Square", (n, o, r) => {
      const l = "s" + o + "," + r;
      let h = G.kr[l];
      return h !== void 0 || (h = new Geometry2(2), h.endX = o, h.endY = r, h.defaultStretch = 6, G.Pr < G.dm && (G.kr[l] = h, G.Pr++)), h;
    });
    const t = (n, o, r, l, h) => {
      (isNaN(l) || l < 0) && (l = 5), isNaN(h) && (h = 15);
      const f = "rr" + o + "," + r + "," + l + "," + h;
      let a = G.kr[f];
      if (a !== void 0) return a;
      let c = l;
      (h & 1) === 1 ? (c = Math.min(c, (h & 2) === 2 ? o / 3 : o), c = Math.min(c, (h & 8) === 8 ? r / 3 : r)) : c = 0;
      const u = new PathFigure2(c, 0, true);
      a = new Geometry2().add(u);
      const d = Spot2.TopLeft.copy(), m = Spot2.BottomRight.copy();
      if ((h & 2) === 2) {
        let g = l;
        g = Math.min(g, (h & 1) === 1 ? o / 3 : o), g = Math.min(g, (h & 4) === 4 ? r / 3 : r);
        const p = g * G.Qn;
        u.add(new PathSegment2(2, o - g, 0)).add(new PathSegment2(3, o, g, o - p, 0, o, p)), d.offsetY = p, m.offsetX = -p;
      } else u.add(new PathSegment2(2, o, 0));
      if ((h & 4) === 4) {
        let g = l;
        g = Math.min(g, (h & 8) === 8 ? o / 3 : o), g = Math.min(g, (h & 2) === 2 ? r / 3 : r);
        const p = g * G.Qn;
        u.add(new PathSegment2(2, o, r - g)).add(new PathSegment2(3, o - g, r, o, r - p, o - p, r)), m.offsetX = -p, m.offsetY = -p;
      } else u.add(new PathSegment2(2, o, r));
      if ((h & 8) === 8) {
        let g = l;
        g = Math.min(g, (h & 4) === 4 ? o / 3 : o), g = Math.min(g, (h & 1) === 1 ? r / 3 : r);
        const p = g * G.Qn;
        u.add(new PathSegment2(2, g, r)).add(new PathSegment2(3, 0, r - g, p, r, 0, r - p)), d.offsetX = p, m.offsetY = -p;
      } else u.add(new PathSegment2(2, 0, r));
      if ((h & 1) === 1) {
        const g = c * G.Qn;
        u.add(new PathSegment2(2, 0, c)).add(new PathSegment2(3, c, 0, 0, g, g, 0).close()), d.offsetX = g, d.offsetY = g;
      } else u.add(new PathSegment2(2, 0, 0).close());
      return a.spot1 = d, a.spot2 = m, G.Pr < G.dm && (G.kr[f] = a, G.Pr++), a;
    };
    w("RoundedRectangle", (n, o, r) => {
      const l = n ? n.parameter1 : NaN, h = n ? n.parameter2 : NaN;
      return t(n, o, r, l, h);
    }), w("Border", "RoundedRectangle"), w("RoundedTopRectangle", (n, o, r) => {
      const l = n ? n.parameter1 : NaN;
      return t(n, o, r, l, 3);
    }), w("RoundedBottomRectangle", (n, o, r) => {
      const l = n ? n.parameter1 : NaN;
      return t(n, o, r, l, 12);
    }), w("RoundedLeftRectangle", (n, o, r) => {
      const l = n ? n.parameter1 : NaN;
      return t(n, o, r, l, 9);
    }), w("RoundedRightRectangle", (n, o, r) => {
      const l = n ? n.parameter1 : NaN;
      return t(n, o, r, l, 6);
    }), w("Ellipse", (n, o, r) => {
      const l = "e" + o + "," + r;
      let h = G.kr[l];
      return h !== void 0 || (h = new Geometry2(3), h.endX = o, h.endY = r, h.spot1 = Spot2.Vk, h.spot2 = Spot2.zk, G.Pr < G.dm && (G.kr[l] = h, G.Pr++)), h;
    }), w("Circle", (n, o, r) => {
      const l = "c" + o + "," + r;
      let h = G.kr[l];
      return h !== void 0 || (h = new Geometry2(3), h.endX = o, h.endY = r, h.spot1 = Spot2.Vk, h.spot2 = Spot2.zk, h.defaultStretch = 6, G.Pr < G.dm && (G.kr[l] = h, G.Pr++)), h;
    }), w("TriangleRight", (n, o, r) => new Geometry2().add(new PathFigure2(0, 0).add(new PathSegment2(2, o, 0.5 * r)).add(new PathSegment2(2, 0, r).close())).setSpots(0, 0.25, 0.5, 0.75)), w("TriangleDown", (n, o, r) => new Geometry2().add(new PathFigure2(0, 0).add(new PathSegment2(2, o, 0)).add(new PathSegment2(2, 0.5 * o, r).close())).setSpots(0.25, 0, 0.75, 0.5)), w("TriangleLeft", (n, o, r) => new Geometry2().add(new PathFigure2(o, r).add(new PathSegment2(2, 0, 0.5 * r)).add(new PathSegment2(2, o, 0).close())).setSpots(0.5, 0.25, 1, 0.75)), w("TriangleUp", (n, o, r) => new Geometry2().add(new PathFigure2(o, r).add(new PathSegment2(2, 0, r)).add(new PathSegment2(2, 0.5 * o, 0).close())).setSpots(0.25, 0.5, 0.75, 1)), w("Triangle", "TriangleUp"), w("Diamond", (n, o, r) => new Geometry2().add(new PathFigure2(0.5 * o, 0).add(new PathSegment2(2, 0, 0.5 * r)).add(new PathSegment2(2, 0.5 * o, r)).add(new PathSegment2(2, o, 0.5 * r).close())).setSpots(0.25, 0.25, 0.75, 0.75)), w("LineH", (n, o, r) => {
      const l = new Geometry2(1);
      return l.startX = 0, l.startY = r / 2, l.endX = o, l.endY = r / 2, l;
    }), w("LineV", (n, o, r) => {
      const l = new Geometry2(1);
      return l.startX = o / 2, l.startY = 0, l.endX = o / 2, l.endY = r, l;
    }), w("None", "Rectangle"), w("BarH", "Rectangle"), w("BarV", "Rectangle"), w("MinusLine", "LineH"), w("PlusLine", (n, o, r) => new Geometry2().add(new PathFigure2(0, r / 2, false).add(new PathSegment2(2, o, r / 2)).add(new PathSegment2(1, o / 2, 0)).add(new PathSegment2(2, o / 2, r)))), w("XLine", (n, o, r) => new Geometry2().add(new PathFigure2(0, r, false).add(new PathSegment2(2, o, 0)).add(new PathSegment2(1, 0, 0)).add(new PathSegment2(2, o, r)))), w("LineRight", (n, o, r) => new Geometry2().add(new PathFigure2(0.25 * o, 0, false).add(new PathSegment2(2, 0.75 * o, 0.5 * r)).add(new PathSegment2(2, 0.25 * o, r)))), w("LineDown", (n, o, r) => new Geometry2().add(new PathFigure2(0, 0.25 * r, false).add(new PathSegment2(2, 0.5 * o, 0.75 * r)).add(new PathSegment2(2, o, 0.25 * r)))), w("LineLeft", (n, o, r) => new Geometry2().add(new PathFigure2(0.75 * o, 0, false).add(new PathSegment2(2, 0.25 * o, 0.5 * r)).add(new PathSegment2(2, 0.75 * o, r)))), w("LineUp", (n, o, r) => new Geometry2().add(new PathFigure2(0, 0.75 * r, false).add(new PathSegment2(2, 0.5 * o, 0.25 * r)).add(new PathSegment2(2, o, 0.75 * r)))), w("Capsule", (n, o, r) => {
      const l = new Geometry2();
      if (o < r) {
        const h = o / 2, f = new PathFigure2(0, h, true);
        l.add(f), f.add(new PathSegment2(5, 180, 180, h, h, h, h)), f.add(new PathSegment2(2, o, r - h)), f.add(new PathSegment2(5, 0, 180, h, r - h, h, h)), f.add(new PathSegment2(2, 0, h));
        const a = isFinite(n.parameter1) ? n.parameter1 : o * 0.156;
        return l.setSpots(0, 0, 1, 1, 0, a, 0, -a), l;
      } else if (o > r) {
        const h = r / 2, f = new PathFigure2(h, 0, true);
        l.add(f), f.add(new PathSegment2(2, o - h, 0)), f.add(new PathSegment2(5, 270, 180, o - h, h, h, h)), f.add(new PathSegment2(2, h, r)), f.add(new PathSegment2(5, 90, 180, h, h, h, h));
        const a = isFinite(n.parameter1) ? n.parameter1 : r * 0.156;
        return l.setSpots(0, 0, 1, 1, a, 0, -a, 0), l;
      } else return l.type = 3, l.endX = o, l.endY = r, l.spot1 = Spot2.Vk, l.spot2 = Spot2.zk, l;
    });
    const i = (n, o) => new PathFigure2(n, o, false, false), e = (n, o, r) => n.add(new PathSegment2(2, o, r)), s = (n, o, r) => n.add(new PathSegment2(1, o, r));
    w("Borders", (n, o, r) => {
      let l = n ? n.parameter1 : NaN;
      isNaN(l) ? l = 10 : l = l & 15;
      const h = new Geometry2();
      let f;
      return l === 10 ? (f = i(o, 0), e(f, o, r), s(f, 0, r), e(f, 0, 0)) : l === 5 ? (f = i(0, 0), e(f, o, 0), s(f, o, r), e(f, 0, r)) : l === 1 ? (f = i(0, 0), e(f, o, 0), s(f, o, r)) : l === 2 ? (f = i(o, 0), e(f, o, r)) : l === 4 ? (f = i(o, r), e(f, 0, r)) : l === 8 ? (f = i(0, r), e(f, 0, 0), s(f, o, r)) : l === 3 ? (f = i(0, 0), e(f, o, 0), e(f, o, r)) : l === 6 ? (f = i(o, 0), e(f, o, r), e(f, 0, r)) : l === 12 ? (f = i(o, r), e(f, 0, r), e(f, 0, 0)) : l === 9 ? (f = i(0, r), e(f, 0, 0), e(f, o, 0)) : l === 7 ? (f = i(0, 0), e(f, o, 0), e(f, o, r), e(f, 0, r)) : l === 14 ? (f = i(o, 0), e(f, o, r), e(f, 0, r), e(f, 0, 0)) : l === 13 ? (f = i(o, r), e(f, 0, r), e(f, 0, 0), e(f, o, 0)) : l === 11 ? (f = i(0, r), e(f, 0, 0), e(f, o, 0), e(f, o, r)) : l === 15 ? (f = i(0, 0), e(f, o, 0), e(f, o, r), e(f, 0, r), f.add(new PathSegment2(2, 0, 0).close())) : (f = i(0, 0), s(f, o, r)), h.add(f), h;
    });
  }
  G.um = { "": "", Standard: "F1 m 0,0 l 8,4 -8,4 2,-4 z", Backward: "F1 m 8,0 l -2,4 2,4 -8,-4 z", Triangle: "F1 m 0,0 l 8,4.62 -8,4.62 z", BackwardTriangle: "F1 m 8,4 l 0,4 -8,-4 8,-4 0,4 z", Boomerang: "F1 m 0,0 l 8,4 -8,4 4,-4 -4,-4 z", BackwardBoomerang: "F1 m 8,0 l -8,4 8,4 -4,-4 4,-4 z", SidewaysV: "m 0,0 l 8,4 -8,4 0,-1 6,-3 -6,-3 0,-1 z", BackwardV: "m 8,0 l -8,4 8,4 0,-1 -6,-3 6,-3 0,-1 z", OpenTriangle: "m 0,0 l 8,4 -8,4", BackwardOpenTriangle: "m 8,0 l -8,4 8,4", OpenTriangleLine: "m 0,0 l 8,4 -8,4 m 8.5,0 l 0,-8", BackwardOpenTriangleLine: "m 8,0 l  -8,4 8,4 m -8.5,0 l 0,-8", OpenTriangleTop: "m 0,0 l 8,4 m 0,4", BackwardOpenTriangleTop: "m 8,0 l -8,4 m 0,4", OpenTriangleBottom: "m 0,8 l 8,-4", BackwardOpenTriangleBottom: "m 0,4 l 8,4", HalfTriangleTop: "F1 m 0,0 l 0,4 8,0 z m 0,8", BackwardHalfTriangleTop: "F1 m 8,0 l 0,4 -8,0 z m 0,8", HalfTriangleBottom: "F1 m 0,4 l 0,4 8,-4 z", BackwardHalfTriangleBottom: "F1 m 8,4 l 0,4 -8,-4 z", ForwardSemiCircle: "m 4,0 b 270 180 0 4 4", BackwardSemiCircle: "m 4,8 b 90 180 0 -4 4", Feather: "m 0,0 l 3,4 -3,4", BackwardFeather: "m 3,0 l -3,4 3,4", DoubleFeathers: "m 0,0 l 3,4 -3,4 m 3,-8 l 3,4 -3,4", BackwardDoubleFeathers: "m 3,0 l -3,4 3,4 m 3,-8 l -3,4 3,4", TripleFeathers: "m 0,0 l 3,4 -3,4 m 3,-8 l 3,4 -3,4 m 3,-8 l 3,4 -3,4", BackwardTripleFeathers: "m 3,0 l -3,4 3,4 m 3,-8 l -3,4 3,4 m 3,-8 l -3,4 3,4", ForwardSlash: "m 0,8 l 5,-8", BackSlash: "m 0,0 l 5,8", DoubleForwardSlash: "m 0,8 l 4,-8 m -2,8 l 4,-8", DoubleBackSlash: "m 0,0 l 4,8 m -2,-8 l 4,8", TripleForwardSlash: "m 0,8 l 4,-8 m -2,8 l 4,-8 m -2,8 l 4,-8", TripleBackSlash: "m 0,0 l 4,8 m -2,-8 l 4,8 m -2,-8 l 4,8", Fork: "m 0,4 l 8,0 m -8,0 l 8,-4 m -8,4 l 8,4", BackwardFork: "m 8,4 l -8,0 m 8,0 l -8,-4 m 8,4 l -8,4", LineFork: "m 0,0 l 0,8 m 0,-4 l 8,0 m -8,0 l 8,-4 m -8,4 l 8,4", BackwardLineFork: "m 8,4 l -8,0 m 8,0 l -8,-4 m 8,4 l -8,4 m 8,-8 l 0,8", CircleFork: "F1 m 6,4 b 0 360 -3 0 3 z m 0,0 l 6,0 m -6,0 l 6,-4 m -6,4 l 6,4", BackwardCircleFork: "F1 m 0,4 l 6,0 m -6,-4 l 6,4 m -6,4 l 6,-4 m 6,0 b 0 360 -3 0 3", CircleLineFork: "F1 m 6,4 b 0 360 -3 0 3 z m 1,-4 l 0,8 m 0,-4 l 6,0 m -6,0 l 6,-4 m -6,4 l 6,4", BackwardCircleLineFork: "F1 m 0,4 l 6,0 m -6,-4 l 6,4 m -6,4 l 6,-4 m 0,-4 l 0,8 m 7,-4 b 0 360 -3 0 3", Circle: "F1 m 8,4 b 0 360 -4 0 4 z", Block: "F1 m 0,0 l 0,8 8,0 0,-8 z", StretchedDiamond: "F1 m 0,3 l 5,-3 5,3 -5,3 -5,-3 z", Diamond: "F1 m 0,4 l 4,-4 4,4 -4,4 -4,-4 z", Chevron: "F1 m 0,0 l 5,0 3,4 -3,4 -5,0 3,-4 -3,-4 z", StretchedChevron: "F1 m 0,0 l 8,0 3,4 -3,4 -8,0 3,-4 -3,-4 z", NormalArrow: "F1 m 0,2 l 4,0 0,-2 4,4 -4,4 0,-2 -4,0 z", X: "m 0,0 l 8,8 m 0,-8 l -8,8", TailedNormalArrow: "F1 m 0,0 l 2,0 1,2 3,0 0,-2 2,4 -2,4 0,-2 -3,0 -1,2 -2,0 1,-4 -1,-4 z", DoubleTriangle: "F1 m 0,0 l 4,4 -4,4 0,-8 z  m 4,0 l 4,4 -4,4 0,-8 z", BigEndArrow: "F1 m 0,0 l 5,2 0,-2 3,4 -3,4 0,-2 -5,2 0,-8 z", ConcaveTailArrow: "F1 m 0,2 h 4 v -2 l 4,4 -4,4 v -2 h -4 l 2,-2 -2,-2 z", RoundedTriangle: "F1 m 0,1 a 1,1 0 0 1 1,-1 l 7,3 a 0.5,1 0 0 1 0,2 l -7,3 a 1,1 0 0 1 -1,-1 l 0,-6 z", SimpleArrow: "F1 m 1,2 l -1,-2 2,0 1,2 -1,2 -2,0 1,-2 5,0 0,-2 2,2 -2,2 0,-2 z", AccelerationArrow: "F1 m 0,0 l 0,8 0.2,0 0,-8 -0.2,0 z m 2,0 l 0,8 1,0 0,-8 -1,0 z m 3,0 l 2,0 2,4 -2,4 -2,0 0,-8 z", BoxArrow: "F1 m 0,0 l 4,0 0,2 2,0 0,-2 2,4 -2,4 0,-2 -2,0 0,2 -4,0 0,-8 z", TriangleLine: "F1 m 8,4 l -8,-4 0,8 8,-4 z m 0.5,4 l 0,-8", CircleEndedArrow: "F1 m 10,4 l -2,-3 0,2 -2,0 0,2 2,0 0,2 2,-3 z m -4,0 b 0 360 -3 0 3 z", DynamicWidthArrow: "F1 m 0,3 l 2,0 2,-1 2,-2 2,4 -2,4 -2,-2 -2,-1 -2,0 0,-2 z", EquilibriumArrow: "m 0,3 l 8,0 -3,-3 m 3,5 l -8,0 3,3", FastForward: "F1 m 0,0 l 3.5,4 0,-4 3.5,4 0,-4 1,0 0,8 -1,0 0,-4 -3.5,4 0,-4 -3.5,4 0,-8 z", Kite: "F1 m 0,4 l 2,-4 6,4 -6,4 -2,-4 z", HalfArrowTop: "F1 m 0,0 l 4,4 4,0 -8,-4 z m 0,8", HalfArrowBottom: "F1 m 0,8 l 4,-4 4,0 -8,4 z", OpposingDirectionDoubleArrow: "F1 m 0,4 l 2,-4 0,2 4,0 0,-2 2,4 -2,4 0,-2 -4,0 0,2 -2,-4 z", PartialDoubleTriangle: "F1 m 0,0 4,3 0,-3 4,4 -4,4 0,-3 -4,3 0,-8 z", LineCircle: "F1 m 0,0 l 0,8 m 7 -4 b 0 360 -3 0 3 z", DoubleLineCircle: "F1 m 0,0 l 0,8 m 2,-8 l 0,8 m 7 -4 b 0 360 -3 0 3 z", TripleLineCircle: "F1 m 0,0 l 0,8 m 2,-8 l 0,8 m 2,-8 l 0,8 m 7 -4 b 0 360 -3 0 3 z", CircleLine: "F1 m 6 4 b 0 360 -3 0 3 z m 1,-4 l 0,8", DiamondCircle: "F1 m 8,4 l -4,4 -4,-4 4,-4 4,4 m 8,0 b 0 360 -4 0 4 z", PlusCircle: "F1 m 8,4 b 0 360 -4 0 4 l -8 0 z m -4 -4 l 0 8", OpenRightTriangleTop: "m 8,0 l 0,4 -8,0 m 0,4", OpenRightTriangleBottom: "m 8,8 l 0,-4 -8,0", Line: "m 0,0 l 0,8", DoubleLine: "m 0,0 l 0,8 m 2,0 l 0,-8", TripleLine: "m 0,0 l 0,8 m 2,0 l 0,-8 m 2,0 l 0,8", PentagonArrow: "F1 m 8,4 l -4,-4 -4,0 0,8 4,0 4,-4 z" };
  var LayoutConditions2 = ((w) => (w[w.None = 0] = "None", w[w.Added = 1] = "Added", w[w.Removed = 2] = "Removed", w[w.Shown = 4] = "Shown", w[w.Hidden = 8] = "Hidden", w[w.NodeSized = 16] = "NodeSized", w[w.GroupLayout = 32] = "GroupLayout", w[w.NodeReplaced = 64] = "NodeReplaced", w[w.Standard = 127] = "Standard", w[w.All = 16777215] = "All", w))(LayoutConditions2 || {});
  class Part2 extends Panel2 {
    P;
    nr;
    J;
    xl;
    bl;
    or;
    mi;
    Sl;
    Eh;
    hn;
    rr;
    Qd;
    UM;
    XD;
    Py;
    My;
    constructor(t, i) {
      let e;
      t === void 0 || t instanceof PanelLayout2 || typeof t == "string" ? e = t : t && (i = t), super(e), this.P = 2408959, this.nr = "", this.J = null, this.xl = "", this.bl = null, this.or = null, this.mi = "", this.Sl = null, this.Eh = null, this.hn = new Point2(NaN, NaN).S(), this.rr = null, this.Qd = NaN, this.UM = -1, this.XD = new Rect2(), this.Py = null, this.My = NaN, i && Object.assign(this, i);
    }
    cloneProtected(t) {
      super.cloneProtected(t), t.P = this.P & -4097 | 16384 | 32768, t.nr = this.nr, this.J !== null && (this.J.wi ? t.J = this.J : t.J = this.J.copy()), t.xl = this.xl, t.or = null, t.mi = this.mi, t.hn.c(this.hn), t.Qd = this.Qd;
    }
    Zo(t) {
      super.Zo(t), t.Lh(), t.bl = null, t.rr = null, t.Py = null;
    }
    toString() {
      let t = U.$n(this.constructor) + "#" + GSet2.Ps(this);
      return this.data !== null && (t += "(" + U.toString(this.data) + ")"), t;
    }
    static LayoutNone = 0;
    static LayoutAdded = 1;
    static LayoutRemoved = 2;
    static LayoutShown = 4;
    static LayoutHidden = 8;
    static LayoutNodeSized = 16;
    static LayoutGroupLayout = 32;
    static LayoutNodeReplaced = 64;
    static LayoutStandard = 127;
    static LayoutAll = 16777215;
    se() {
      return this.J === null ? this.J = new PartTemplateSettings() : this.J.wi && (this.J = this.J.copy()), this.J;
    }
    Ch() {
      super.Ch(), this.J !== null && (this.J.wi = true);
    }
    wc(t, i, e, s, n, o, r) {
      const l = this.diagram;
      l !== null && (t === 3 && i === "elements" ? n instanceof Panel2 ? n.Tn((h) => {
        l.partManager.D2(h, l);
      }) : n instanceof Picture2 && l.V2(n) : t === 4 && i === "elements" && (n instanceof Panel2 ? n.Tn((h) => l.partManager.F2(h, l)) : n instanceof Picture2 && l.z2(n)), l.raiseChangedEvent(t, i, e, s, n, o, r));
    }
    updateTargetBindings(t) {
      if (super.updateTargetBindings(t), this.data === null) return;
      const i = this.O.h, e = i.length;
      for (let n = 0; n < e; n++) {
        const o = i[n];
        o instanceof Panel2 && o.Tn((r) => {
          r.data !== null && r.tE(t);
        });
      }
      const s = this.adornments;
      for (; s.next(); ) s.value.updateTargetBindings(t);
    }
    jo() {
      if (super.jo(), this.XN()) {
        const i = this.O.h, e = i.length;
        for (let s = 0; s < e; s++) {
          const n = i[s];
          n instanceof Panel2 && n.Tn((o) => o.jo());
        }
      }
      const t = this.adornments;
      for (; t.next(); ) t.value.jo();
    }
    updateRelationshipsFromData() {
      this.data !== null && this.diagram?.partManager.updateRelationshipsFromData(this);
    }
    get key() {
      const t = this.diagram;
      if (t !== null) return t.model.getKeyForNodeData(this.data);
    }
    get adornments() {
      return this.or === null ? EmptyIterator.instance : this.or.iteratorValues;
    }
    findAdornment(t) {
      Debug && U.i(t, "string", Part2, "findAdornment:category");
      const i = this.or;
      return i === null ? null : i.get(t);
    }
    addAdornment(t, i) {
      if (i === null) return;
      Debug && (U.i(t, "string", Part2, "addAdornment:category"), U.s(i, Adornment2, Part2, "addAdornment:ad"));
      let e = null, s = this.or;
      if (s !== null && (e = s.get(t)), e !== i) {
        if (e !== null) {
          const o = e.diagram;
          o !== null && o.remove(e);
        }
        s === null && (s = new GMap2(), this.or = s), i.nr !== t && (i.category = t), s.set(t, i);
        const n = this.diagram;
        if (n !== null) {
          n.add(i);
          const o = i.adornedObject;
          if (o !== null) {
            const r = o.findBindingPanel();
            r !== null && (i.data = r.data);
          }
        }
      }
    }
    removeAdornment(t) {
      Debug && U.i(t, "string", Part2, "removeAdornment:category");
      const i = this.or;
      if (i === null) return;
      const e = i.get(t);
      if (e !== null) {
        const s = e.diagram;
        s !== null && (s.remove(e), e.data = null);
      }
      i.delete(t), i.count === 0 && (this.or = null);
    }
    clearAdornments() {
      const t = this.or;
      if (t === null) return;
      const i = U.ft(), e = t.iterator;
      for (; e.next(); ) {
        const n = e.key;
        i.push(n);
      }
      const s = i.length;
      for (let n = 0; n < s; n++) this.removeAdornment(i[n]);
      U.et(i);
    }
    updateAdornments() {
      const t = this.diagram;
      if (t === null) return;
      this.SE(t), this.kE(t);
      let i = this.adornments;
      for (; i.next(); ) {
        const e = i.value;
        e.g(), e.hasPlaceholder() && e.placeholder.g();
      }
      for (i = this.adornments; i.next(); ) i.value.updateTargetBindings();
    }
    invalidateAdornments() {
      const t = this.diagram;
      t !== null && (t.mh(), this.YD() !== true && this.KD(true));
    }
    GM() {
      this.YD() !== false && (this.updateAdornments(), this.KD(false));
    }
    SE(t) {
      const i = "Selection";
      if (this.isSelected && this.selectionAdorned) {
        const e = this.selectionObject;
        if (e !== null && this.actualBounds.isReal() && this.isVisible() && e.isVisibleObject() && e.actualBounds.isReal()) {
          let s = this.findAdornment(i);
          if (s === null) {
            let n = this.selectionAdornmentTemplate;
            n === null && (this.Rr() ? n = t.linkSelectionAdornmentTemplate : this instanceof Group2 ? n = t.groupSelectionAdornmentTemplate : n = t.nodeSelectionAdornmentTemplate), s = n.copy(), s !== null && (this.Rr() && this.selectionObject === this.path && (s.type = Panel2.Link), s.adornedObject = e);
          }
          if (s !== null) {
            s.type === Panel2.Link && s.g(), this.addAdornment(i, s);
            return;
          }
        }
      }
      this.removeAdornment(i);
    }
    kE(t) {
      const i = this;
      t.toolManager.mouseDownTools.each((e) => {
        e.isEnabled && e.updateAdornments(i);
      }), t.toolManager.updateAdornments(i);
    }
    YM(t) {
      this.Sl = t, t === null && this.w3();
    }
    get layer() {
      return this.Sl;
    }
    get diagram() {
      const t = this.Sl;
      return t == null ? null : t.diagram;
    }
    get layerName() {
      return this.xl;
    }
    set layerName(t) {
      const i = this.xl;
      if (i === t) return;
      Debug && U.i(t, "string", Part2, "layerName");
      let e = this.diagram;
      if (e !== null && (e.findLayer(t) === null || e.partManager.addsToTemporaryLayer)) return;
      this.xl = t, e !== null && e.invalidateDocumentBounds(), this.t("layerName", i, t);
      const s = this.layer;
      if (s === null || s.name === t || (e = s.diagram, e === null)) return;
      const n = e.findLayer(t);
      if (n === null || n === s) return;
      let o = s.ae(-1, this, true);
      o >= 0 && e.raiseChangedEvent(4, "parts", s, this, null, o, true), o = n.da(99999999, this, true), s.visible !== n.visible && this.Hi(n.visible), o >= 0 && e.raiseChangedEvent(3, "parts", n, null, this, true, o);
      const r = this.layerChanged;
      if (r === null) return;
      const l = e.H;
      e.H = true, r(this, s, n), e.H = l;
    }
    get layerChanged() {
      return this.J !== null ? this.J.Ny : null;
    }
    set layerChanged(t) {
      const i = this.layerChanged;
      i !== t && (t !== null && U.C(t, Part2, "layerChanged"), this.se().Ny = t, this.t("layerChanged", i, t));
    }
    get zOrder() {
      return this.Qd;
    }
    set zOrder(t) {
      const i = this.Qd;
      if (i === t) return;
      Debug && U.i(t, "number", Part2, "zOrder"), this.Qd = t;
      const e = this.layer;
      e !== null && e.m1(-1, this), this.t("zOrder", i, t);
      const s = this.diagram;
      s !== null && s.L();
    }
    PE() {
      const t = this.layer;
      t !== null && t.m1(-1, this);
    }
    pS() {
      if (this.yh() !== false) return;
      this.mC(true), this.Sc();
      const t = this.diagram;
      t !== null && (t.D0(this), t.requestUpdate());
    }
    UD() {
      if (this.P |= 2097152, this.yh() === false) return;
      const t = this.position, i = this.location;
      (!i.isReal() || !t.isReal()) && this.GD(t, i);
      const e = this.Oi, s = Rect2.a().c(e);
      e.di(), e.x = t.x, e.y = t.y, e.S(), this.Cd(s, e), Rect2.o(s), this.mC(false), this.Sc();
    }
    co(t, i, e, s) {
      const n = this.ce;
      n.e(t, i, e, s), this.Ci === null && (this.Ci = new Transform());
      const o = this.Ci;
      o.Ki(), this.j0(o, t, i, e, s), this.Ci = o, o.Xk() || o.hm(n);
    }
    j0(t, i, e, s, n) {
      if (this.lt !== 1 && t.lt(this.lt), this.vt === 0) return;
      let o = Spot2.Center;
      this.locationSpot.isSpot() && (o = this.locationSpot);
      const r = Point2.a();
      if (this.locationObject !== this) {
        const l = this.locationObject, h = l.naturalBounds;
        r.setSpot(h.x, h.y, h.width, h.height, o), l.Ci !== null && l.Ci.St(r), r.offset(-l.measuredBounds.x, -l.measuredBounds.y);
        let f = l.panel;
        for (; f !== null && f !== this; ) f.Ci !== null && f.Ci.St(r), r.offset(-f.measuredBounds.x, -f.measuredBounds.y), f = f.panel;
      } else r.setSpot(i, e, s, n, o);
      t.Ns(this.vt, r.x, r.y), Point2.o(r);
    }
    get locationObject() {
      if (this.rr === null) if (this instanceof Adornment2 && this.type !== Panel2.Link && this.hasPlaceholder()) this.rr = this.placeholder;
      else {
        const t = this.locationObjectName;
        if (t !== "") {
          const i = this.findObject(t);
          i !== null ? this.rr = i : this.rr = this;
        } else this.rr = this;
      }
      return this.rr?.visible ? this.rr : this;
    }
    get minLocation() {
      return this.J !== null ? this.J.Cy : Point2.OA;
    }
    set minLocation(t) {
      const i = this.minLocation;
      i.equals(t) || (Debug && U.s(t, Point2, Part2, "minLocation"), t = t.T(), this.se().Cy = t, this.t("minLocation", i, t));
    }
    get maxLocation() {
      return this.J !== null ? this.J.Ay : Point2.EA;
    }
    set maxLocation(t) {
      const i = this.maxLocation;
      i.equals(t) || (Debug && U.s(t, Point2, Part2, "maxLocation"), t = t.T(), this.se().Ay = t, this.t("maxLocation", i, t));
    }
    get locationObjectName() {
      return this.J !== null ? this.J.Ty : "";
    }
    set locationObjectName(t) {
      const i = this.locationObjectName;
      i !== t && (Debug && U.i(t, "string", Part2, "locationObjectName"), this.se().Ty = t, this.rr = null, this.g(), this.t("locationObjectName", i, t));
    }
    get locationSpot() {
      return this.J !== null ? this.J.Ly : Spot2.TopLeft;
    }
    set locationSpot(t) {
      const i = this.locationSpot;
      i.equals(t) || (Debug && (U.s(t, Spot2, Part2, "locationSpot"), t.isSpot() || U.n("Part.locationSpot must be a specific Spot value, not: " + t)), t = t.T(), this.se().Ly = t, this.g(), this.t("locationSpot", i, t));
    }
    move(t, i) {
      i === true ? this.location = t : this.position = t;
    }
    moveTo(t, i, e) {
      const s = Point2.U(t, i);
      this.move(s, e), Point2.o(s);
    }
    isVisible() {
      if (!this.visible) return false;
      const t = this.layer;
      if (t !== null) {
        if (!t.visible) return false;
        const e = t.diagram;
        if (e !== null && e.animationManager.i1(this)) return true;
      }
      const i = this.containingGroup;
      return !(i !== null && (!i.isSubGraphExpanded || !i.isVisible()));
    }
    Hi(t) {
      const i = this.diagram;
      t ? (this.invalidateLayout(4), this.invalidateAdornments(), i !== null && i.D0(this)) : (this.invalidateLayout(8), this.clearAdornments()), this.Lh(), i !== null && (i.invalidateDocumentBounds(), i.L());
    }
    findObject(t) {
      if (this.name === t) return this;
      let i = this.Py;
      if (i === null && (this.Py = i = new GMap2()), i.get(t) !== null) return i.get(t);
      const e = super.findObject(t);
      return e !== null ? (i.set(t, e), e) : (i.set(t, null), null);
    }
    lp() {
      this.Py = null;
    }
    getRelativePoint(t, i, e) {
      e === void 0 && (e = new Point2());
      const s = i.isNoSpot() ? Spot2.Center : i, n = t.naturalBounds;
      if (e.e(n.width * s.x + s.offsetX, n.height * s.y + s.offsetY), t === null || t === this) return e;
      t.E.St(e);
      let o = t.panel;
      for (; o !== null && o !== this; ) o.E.St(e), o = o.panel;
      return this.Ci !== null && this.Ci.St(e), e.offset(-this.ce.x, -this.ce.y), e;
    }
    getDocumentBounds(t) {
      return t === void 0 && (t = new Rect2()), t.c(this.actualBounds);
    }
    ensureBounds() {
      this.gt(1 / 0, 1 / 0), this.Ut();
    }
    pD(t) {
      const i = this.locationSpot, e = this.locationObject;
      let s = e.naturalBounds;
      s.isReal() || (s = Rect2.rm);
      const n = e instanceof Shape2 ? e.strokeWidth : 0;
      if (t.setSpot(0, 0, s.width + n, s.height + n, i), e !== this) {
        t.offset(-n / 2, -n / 2), e.E.St(t);
        let o = e.panel;
        for (; o !== null && o !== this; ) o.E.St(t), o = o.panel;
      }
      return this.Ci !== null && this.Ci.St(t), t.offset(-this.ce.x, -this.ce.y), t;
    }
    ua(t, i) {
      const e = i === void 0 ? this.XD : i, s = this.ME(), n = s * 2;
      if (!this.isShadowed) return e.e(t.x - 1 - s, t.y - 1 - s, t.width + 2 + n, t.height + 2 + n), e;
      let o = t.x, r = t.y, l = t.width, h = t.height;
      const f = this.shadowBlur, a = this.shadowOffset;
      return l += f, h += f, o -= f / 2, r -= f / 2, a.x > 0 ? l += a.x : (o += a.x, l -= a.x), a.y > 0 ? h += a.y : (r += a.y, h -= a.y), e.e(o - 1, r - 1, l + 2, h + 2), e;
    }
    rE() {
      return this.type === Panel2.Link && this instanceof Adornment2 && this.category === "Selection" && this.adornedObject instanceof Shape2 && this.adornedPart.findMainElement() === this.adornedObject ? this.adornedObject.strokeWidth : 0;
    }
    ME() {
      return isNaN(this.My) && (this.My = this.PD()), this.My;
    }
    Oc() {
      this.My = NaN;
    }
    Ut() {
      if (this.us() === false) {
        this.UD();
        return;
      }
      this.uo(false);
      const t = this.Oi, i = Rect2.a();
      i.c(t);
      const e = this.Kl();
      this.Th(0, 0, this.ce.width, this.ce.height);
      const s = this.position;
      this.GD(s, this.location), t.di(), t.x = s.x, t.y = s.y, t.S(), this.Cd(i, t), i.equals(t) ? this.Is(e) : this.Oe() && (!G.p(i.width, t.width) || !G.p(i.height, t.height)) && this.UM >= 0 && this.invalidateLayout(16), Rect2.o(i), this.mC(false);
    }
    Cd(t, i) {
      const e = this.diagram;
      if (e === null) return;
      let s = false;
      if (e.wa === false && t.isReal()) {
        const n = Rect2.a();
        n.c(e.documentBounds), n.subtractMargin(e.padding), t.x > n.x && t.y > n.y && t.right < n.right && t.bottom < n.bottom && i.x > n.x && i.y > n.y && i.right < n.right && i.bottom < n.bottom && (s = true), Rect2.o(n);
      }
      (this.NE() === true || !t.equals(i)) && this.yL(s, e), e.L(), !(!t.isReal() && !i.isReal() || t.equalsApproxClose(i)) && (this instanceof Node2 && !e.undoManager.isUndoingRedoing && this.invalidateConnectedLinks(), this.Lh());
    }
    get location() {
      return this.hn;
    }
    set location(t) {
      Debug && U.s(t, Point2, Part2, "location");
      const i = t.x, e = t.y, s = this.hn;
      (s.x !== i && (!isNaN(s.x) || !isNaN(i)) || s.y !== e && (!isNaN(s.y) || !isNaN(e))) && (t = t.copy(), this.CE(t, s) && this.t("location", s, t.copy()));
    }
    CE(t, i) {
      if (this.Rr()) return false;
      if (this.hn = t, this.P |= 2097152, this.us() === false) {
        this.pS();
        const e = this.yt;
        if (e.isReal()) {
          const s = this.diagram;
          if (s === null || s.animationManager.isTicking || !s.undoManager.isUndoingRedoing) {
            const n = e.copy();
            e.e(e.x + (t.x - i.x), e.y + (t.y - i.y)), this.qD(s, e, n.x, n.y), this.t("position", n, e.copy());
          }
        }
      }
      return true;
    }
    BN(t, i, e) {
      if (this.Rr() || !t.isReal()) return false;
      const s = this.diagram;
      if (s !== null && this.qD(s, t, i, e), this.yt = t, this.P &= -2097153, this.hn.isReal() && (s === null || s.animationManager.isTicking || !s.undoManager.isUndoingRedoing)) {
        const n = this.hn;
        this.hn = new Point2(n.x + (t.x - i), n.y + (t.y - e)).S(), this.t("location", n, this.hn.copy());
      }
      return this.yh() === false && this.us() === false && (this.pS(), this.UD()), true;
    }
    qD(t, i, e, s) {
      if (t === null || this instanceof Adornment2) return;
      const n = t.animationManager;
      n.Mi && n.ET(this, new Point2(e, s), i, false);
    }
    Gf(t, i, e) {
      const s = this.hn, n = this.yt;
      if (e) {
        if (s.x === t && s.y === i) return;
        this.yh() || this.us() ? n.e(NaN, NaN) : n.e(n.x + t - s.x, n.y + i - s.y), s.e(t, i);
      } else {
        if (n.x === t && n.y === i) return;
        s.e(s.x + t - n.x, s.y + i - n.y), n.e(t, i);
      }
      this.pS();
    }
    VN() {
      this.P &= -2097153, this.pS();
    }
    GD(t, i) {
      const e = this.pD(Point2.a()), s = this.diagram, n = i.isReal(), o = t.isReal();
      n && o ? (this.P & 2097152) !== 0 ? this.HD(t, i, s, e) : this.vD(t, i, s, e) : n ? this.HD(t, i, s, e) : o && this.vD(t, i, s, e), this.P |= 2097152, Point2.o(e), this.Sc();
    }
    HD(t, i, e, s) {
      const n = t.x, o = t.y;
      if (t.e(i.x - s.x, i.y - s.y), e !== null) {
        const r = e.animationManager, l = r.defaultAnimation.isAnimating;
        !l && r.Mi && !(this instanceof Adornment2) && r.ET(this, new Point2(n, o), t, false), !l && !(t.x === n && t.y === o) && this.t("position", new Point2(n, o), t.copy());
      }
    }
    vD(t, i, e, s) {
      const n = i.copy();
      i.e(t.x + s.x, t.y + s.y), !i.equals(n) && e !== null && this.t("location", n, i.copy());
    }
    yL(t, i) {
      this.FN(false), this instanceof Node2 && i.q2(this), !this.layer.isTemporary && !t && i.invalidateDocumentBounds();
      const e = this.Oi, s = i.viewportBounds;
      s.isReal() ? this.Kl() ? (e.KA(s, 10) || this.Is(false), this.updateAdornments()) : this.isVisible() && e.intersectsRect(s) ? (this.Is(true), this.updateAdornments()) : this.invalidateAdornments() : i.rc = true;
    }
    nl() {
      return true;
    }
    Oe() {
      return true;
    }
    Rr() {
      return false;
    }
    nn() {
      return true;
    }
    hasPlaceholder() {
      return false;
    }
    get category() {
      return this.nr;
    }
    set category(t) {
      const i = this.nr;
      if (i === t) return;
      this.svg !== null && (this.svg.remove(), this.ts(true)), Debug && U.i(t, "string", Part2, "category");
      const e = this.diagram, s = this.data;
      let n = null;
      if (e !== null && s !== null && !(this instanceof Adornment2)) {
        const o = e.model.undoManager;
        o.isEnabled && !o.isUndoingRedoing && (n = this.clone(), n.O.addAll(this.O));
      }
      if (this.nr = t, this.t("category", i, t), e !== null && s !== null && !(this instanceof Adornment2)) {
        const o = e.model;
        if (o.undoManager.isUndoingRedoing) return;
        if (this.Rr()) {
          e.partManager.setLinkCategoryForData(s, t);
          const r = e.partManager.findLinkTemplateForCategory(t);
          if (r !== null) {
            r.Yt();
            const l = r.copy();
            l !== null && this.pC(l, i, t);
          }
        } else {
          o !== null && o.setCategoryForNodeData(s, t);
          const r = e.partManager.findTemplateForNodeData(s, t);
          if (r !== null) {
            r.Yt();
            const l = r.copy();
            if (l !== null && !(l instanceof Link2)) {
              const h = this.location.copy();
              this.pC(l, i, t), this.location.isReal() || (this.location = h);
            }
          }
        }
        if (n !== null) {
          const r = this.clone();
          r.O.addAll(this.O), this.t("self", n, r);
        }
      } else if (this instanceof Adornment2) {
        const o = this.adornedPart;
        if (o !== null) {
          const r = o.or;
          r !== null && r.delete(i), o.addAdornment(this.category, this);
        }
      }
    }
    get self() {
      return this;
    }
    set self(t) {
      this.pC(t, this.category, t.category);
    }
    static WD = false;
    pC(t, i, e) {
      t.constructor !== this.constructor && (Part2.WD || (Part2.WD = true, U.ot('Should not change the class of the Part when changing category from "' + i + '" to "' + e + '"'), U.ot("  Old class: " + U.$n(this.constructor) + ", new class: " + U.$n(t.constructor) + ", part: " + this.toString()))), this.clearAdornments();
      const s = this.data, n = this.layerName, o = this.isSelected, r = this.isHighlighted;
      let l = true, h = true, f = false;
      this instanceof Node2 && (l = this.isTreeLeaf, h = this.isTreeExpanded, f = this.wasTreeExpanded), t.Zo(this), t.cloneProtected(this), this.nr = e, this.svg !== null && (this.svg.remove(), this.tc(), this.ts(true)), this.g(), this.L();
      const a = this.diagram;
      let c = true;
      a !== null && (c = a.skipsUndoManager, a.skipsUndoManager = true), this.oi = s, this.P = o ? this.P | 4096 : this.P & -4097, this.P = r ? this.P | 524288 : this.P & -524289, this instanceof Node2 && (this.z = l ? this.z | 4 : this.z & -5, this.z = h ? this.z | 1 : this.z & -2, this.z = f ? this.z | 2 : this.z & -3), s !== null && this.updateTargetBindings();
      const u = this.layerName;
      u !== n && (this.xl = n, this.layerName = u), a !== null && (a.skipsUndoManager = c), this.Oe() && this.invalidateLayout(64);
    }
    canCopy() {
      if (!this.copyable) return false;
      const t = this.layer;
      if (t === null) return true;
      if (!t.allowCopy) return false;
      const i = t.diagram;
      return i === null ? true : !!i.allowCopy;
    }
    canDelete() {
      if (!this.deletable) return false;
      const t = this.layer;
      if (t === null) return true;
      if (!t.allowDelete) return false;
      const i = t.diagram;
      return i === null ? true : !!i.allowDelete;
    }
    canEdit() {
      if (!this.textEditable) return false;
      const t = this.layer;
      if (t === null) return true;
      if (!t.allowTextEdit) return false;
      const i = t.diagram;
      return i === null ? true : !!i.allowTextEdit;
    }
    canGroup() {
      if (!this.groupable) return false;
      const t = this.layer;
      if (t === null) return true;
      if (!t.allowGroup) return false;
      const i = t.diagram;
      return i === null ? true : !!i.allowGroup;
    }
    canMove() {
      if (!this.movable) return false;
      const t = this.layer;
      if (t === null) return true;
      if (!t.allowMove) return false;
      const i = t.diagram;
      return i === null ? true : !!i.allowMove;
    }
    canReshape() {
      if (!this.reshapable) return false;
      const t = this.layer;
      if (t === null) return true;
      if (!t.allowReshape) return false;
      const i = t.diagram;
      return i === null ? true : !!i.allowReshape;
    }
    canResize() {
      if (!this.resizable) return false;
      const t = this.layer;
      if (t === null) return true;
      if (!t.allowResize) return false;
      const i = t.diagram;
      return i === null ? true : !!i.allowResize;
    }
    canRotate() {
      if (!this.rotatable) return false;
      const t = this.layer;
      if (t === null) return true;
      if (!t.allowRotate) return false;
      const i = t.diagram;
      return i === null ? true : !!i.allowRotate;
    }
    canSelect() {
      if (!this.selectable) return false;
      const t = this.layer;
      if (t === null) return true;
      if (!t.allowSelect) return false;
      const i = t.diagram;
      return i === null ? true : !!i.allowSelect;
    }
    get copyable() {
      return (this.P & 1) !== 0;
    }
    set copyable(t) {
      const i = (this.P & 1) !== 0;
      i !== t && (Debug && U.i(t, "boolean", Part2, "copyable"), this.P = this.P ^ 1, this.t("copyable", i, t));
    }
    get deletable() {
      return (this.P & 2) !== 0;
    }
    set deletable(t) {
      const i = (this.P & 2) !== 0;
      i !== t && (Debug && U.i(t, "boolean", Part2, "deletable"), this.P = this.P ^ 2, this.t("deletable", i, t));
    }
    get textEditable() {
      return (this.P & 4) !== 0;
    }
    set textEditable(t) {
      const i = (this.P & 4) !== 0;
      i !== t && (Debug && U.i(t, "boolean", Part2, "textEditable"), this.P = this.P ^ 4, this.t("textEditable", i, t), this.invalidateAdornments());
    }
    get groupable() {
      return (this.P & 8) !== 0;
    }
    set groupable(t) {
      const i = (this.P & 8) !== 0;
      i !== t && (Debug && U.i(t, "boolean", Part2, "groupable"), this.P = this.P ^ 8, this.t("groupable", i, t));
    }
    get movable() {
      return (this.P & 16) !== 0;
    }
    set movable(t) {
      const i = (this.P & 16) !== 0;
      i !== t && (Debug && U.i(t, "boolean", Part2, "movable"), this.P = this.P ^ 16, this.t("movable", i, t));
    }
    get selectionAdorned() {
      return (this.P & 32) !== 0;
    }
    set selectionAdorned(t) {
      const i = (this.P & 32) !== 0;
      i !== t && (Debug && U.i(t, "boolean", Part2, "selectionAdorned"), this.P = this.P ^ 32, this.t("selectionAdorned", i, t), this.invalidateAdornments());
    }
    get isInDocumentBounds() {
      return (this.P & 64) !== 0;
    }
    set isInDocumentBounds(t) {
      const i = (this.P & 64) !== 0;
      if (i !== t) {
        Debug && U.i(t, "boolean", Part2, "isInDocumentBounds"), this.P = this.P ^ 64;
        const e = this.diagram;
        e !== null && e.invalidateDocumentBounds(), this.t("isInDocumentBounds", i, t);
      }
    }
    get isLayoutPositioned() {
      return (this.P & 128) !== 0;
    }
    set isLayoutPositioned(t) {
      const i = (this.P & 128) !== 0;
      i !== t && (Debug && U.i(t, "boolean", Part2, "isLayoutPositioned"), this.P = this.P ^ 128, this.t("isLayoutPositioned", i, t), this.invalidateLayout(t ? 4 : 8));
    }
    get selectable() {
      return (this.P & 256) !== 0;
    }
    set selectable(t) {
      const i = (this.P & 256) !== 0;
      i !== t && (Debug && U.i(t, "boolean", Part2, "selectable"), this.P = this.P ^ 256, this.t("selectable", i, t), this.invalidateAdornments());
    }
    get reshapable() {
      return (this.P & 512) !== 0;
    }
    set reshapable(t) {
      const i = (this.P & 512) !== 0;
      i !== t && (Debug && U.i(t, "boolean", Part2, "reshapable"), this.P = this.P ^ 512, this.t("reshapable", i, t), this.invalidateAdornments());
    }
    get resizable() {
      return (this.P & 1024) !== 0;
    }
    set resizable(t) {
      const i = (this.P & 1024) !== 0;
      i !== t && (Debug && U.i(t, "boolean", Part2, "resizable"), this.P = this.P ^ 1024, this.t("resizable", i, t), this.invalidateAdornments());
    }
    get rotatable() {
      return (this.P & 2048) !== 0;
    }
    set rotatable(t) {
      const i = (this.P & 2048) !== 0;
      i !== t && (Debug && U.i(t, "boolean", Part2, "rotatable"), this.P = this.P ^ 2048, this.t("rotatable", i, t), this.invalidateAdornments());
    }
    get isSelected() {
      return (this.P & 4096) !== 0;
    }
    set isSelected(t) {
      const i = (this.P & 4096) !== 0;
      if (i !== t) {
        Debug && U.i(t, "boolean", Part2, "isSelected");
        const e = this.diagram;
        if (t) {
          if (!this.canSelect()) return;
          if (e !== null) {
            const o = e.maxSelectionCount;
            if (e.selection.count >= o) return;
          }
        }
        this.P = this.P ^ 4096;
        let s = false;
        if (e !== null) {
          s = e.skipsUndoManager, e.skipsUndoManager = true;
          const o = e.selection;
          o.di(), t ? o.add(this) : o.delete(this), o.S();
        }
        this.t("isSelected", i, t), this.invalidateAdornments();
        const n = this.selectionChanged;
        n !== null && n(this), e !== null && (e.requestUpdate(), e.skipsUndoManager = s);
      }
    }
    get isHighlighted() {
      return (this.P & 524288) !== 0;
    }
    set isHighlighted(t) {
      const i = (this.P & 524288) !== 0;
      if (i !== t) {
        Debug && U.i(t, "boolean", Part2, "isHighlighted"), this.P = this.P ^ 524288;
        const e = this.diagram;
        if (e !== null) {
          const n = e.highlighteds;
          n.di(), t ? n.add(this) : n.delete(this), n.S();
        }
        this.t("isHighlighted", i, t), this.L();
        const s = this.highlightedChanged;
        s !== null && s(this);
      }
    }
    get isShadowed() {
      return (this.P & 8192) !== 0;
    }
    set isShadowed(t) {
      const i = (this.P & 8192) !== 0;
      i !== t && (Debug && U.i(t, "boolean", Part2, "isShadowed"), this.P = this.P ^ 8192, this.ts(true), this.t("isShadowed", i, t), this.L());
    }
    YD() {
      return (this.P & 16384) !== 0;
    }
    KD(t) {
      t ? this.P |= 16384 : this.P &= -16385;
    }
    yh() {
      return (this.P & 32768) !== 0;
    }
    mC(t) {
      t ? this.P |= 32768 : this.P &= -32769;
    }
    NE() {
      return (this.P & 65536) !== 0;
    }
    FN(t) {
      t ? this.P |= 65536 : this.P &= -65537;
    }
    Kl() {
      return (this.P & 131072) !== 0;
    }
    Is(t) {
      t ? this.P |= 131072 : this.P &= -131073;
    }
    jD() {
      return (this.P & 1048576) !== 0;
    }
    yS(t) {
      t ? this.P |= 1048576 : this.P &= -1048577;
    }
    get isAnimated() {
      return (this.P & 262144) !== 0;
    }
    set isAnimated(t) {
      const i = (this.P & 262144) !== 0;
      i !== t && (Debug && U.i(t, "boolean", Part2, "isAnimated"), this.P = this.P ^ 262144, this.t("isAnimated", i, t));
    }
    get highlightedChanged() {
      return this.J !== null ? this.J.Dy : null;
    }
    set highlightedChanged(t) {
      const i = this.highlightedChanged;
      i !== t && (t !== null && U.C(t, Part2, "highlightedChanged"), this.se().Dy = t, this.t("highlightedChanged", i, t));
    }
    get selectionObjectName() {
      return this.J !== null ? this.J.Fy : "";
    }
    set selectionObjectName(t) {
      const i = this.selectionObjectName;
      i !== t && (Debug && U.i(t, "string", Part2, "selectionObjectName"), this.se().Fy = t, this.bl = null, this.t("selectionObjectName", i, t));
    }
    get selectionAdornmentTemplate() {
      return this.J !== null ? this.J.Iy : null;
    }
    set selectionAdornmentTemplate(t) {
      const i = this.selectionAdornmentTemplate;
      i !== t && (t !== null && (U.s(t, Adornment2, Part2, "selectionAdornmentTemplate"), t.Yt()), this.se().Iy = t, this.t("selectionAdornmentTemplate", i, t));
    }
    get selectionObject() {
      if (this.bl === null) {
        const t = this.selectionObjectName;
        if (t !== null && t !== "") {
          const i = this.findObject(t);
          i !== null ? this.bl = i : this.bl = this;
        } else if (this instanceof Link2) {
          const i = this.path;
          i !== null ? this.bl = i : this.bl = this;
        } else this.bl = this;
      }
      return this.bl;
    }
    get selectionChanged() {
      return this.J !== null ? this.J.Ry : null;
    }
    set selectionChanged(t) {
      const i = this.selectionChanged;
      i !== t && (t !== null && U.C(t, Part2, "selectionChanged"), this.se().Ry = t, this.t("selectionChanged", i, t));
    }
    get resizeAdornmentTemplate() {
      return this.J !== null ? this.J.Oy : null;
    }
    set resizeAdornmentTemplate(t) {
      const i = this.resizeAdornmentTemplate;
      i !== t && (Debug && U.s(t, Adornment2, Part2, "resizeAdornmentTemplate"), this.se().Oy = t !== null ? t.Yt() : null, this.t("resizeAdornmentTemplate", i, t));
    }
    get resizeObjectName() {
      return this.J !== null ? this.J.Ey : "";
    }
    set resizeObjectName(t) {
      const i = this.resizeObjectName;
      i !== t && (Debug && U.i(t, "string", Part2, "resizeObjectName"), this.se().Ey = t, this.t("resizeObjectName", i, t));
    }
    get resizeObject() {
      const t = this.resizeObjectName;
      if (t !== "") {
        const i = this.findObject(t);
        if (i !== null) return i;
      }
      return this;
    }
    get resizeCellSize() {
      return this.J !== null ? this.J.By : Size2.ix;
    }
    set resizeCellSize(t) {
      const i = this.resizeCellSize;
      i.equals(t) || (Debug && U.s(t, Size2, Part2, "resizeCellSize"), t = t.T(), this.se().By = t, this.t("resizeCellSize", i, t));
    }
    get rotateAdornmentTemplate() {
      return this.J !== null ? this.J.Vy : null;
    }
    set rotateAdornmentTemplate(t) {
      const i = this.rotateAdornmentTemplate;
      i !== t && (Debug && U.s(t, Adornment2, Part2, "rotateAdornmentTemplate"), this.se().Vy = t !== null ? t.Yt() : null, this.t("rotateAdornmentTemplate", i, t));
    }
    get rotateObjectName() {
      return this.J !== null ? this.J.zy : "";
    }
    set rotateObjectName(t) {
      const i = this.rotateObjectName;
      i !== t && (Debug && U.i(t, "string", Part2, "rotateObjectName"), this.se().zy = t, this.t("rotateObjectName", i, t));
    }
    get rotateObject() {
      const t = this.rotateObjectName;
      if (t !== "") {
        const i = this.findObject(t);
        if (i !== null) return i;
      }
      return this;
    }
    get rotationSpot() {
      return this.J !== null ? this.J.Xy : Spot2.Default;
    }
    set rotationSpot(t) {
      const i = this.rotationSpot;
      i.equals(t) || (Debug && (U.s(t, Spot2, Part2, "rotationSpot"), t !== Spot2.Default && !t.isSpot() && U.n("Part.rotationSpot must be a specific Spot value or Spot.Default, not: " + t)), t = t.T(), this.se().Xy = t, this.t("rotationSpot", i, t));
    }
    get text() {
      return this.mi;
    }
    set text(t) {
      const i = this.mi;
      i !== t && (Debug && U.i(t, "string", Part2, "text"), this.mi = t, this.t("text", i, t));
    }
    get containingGroup() {
      return this.Eh;
    }
    set containingGroup(t) {
      if (this.Oe()) {
        const i = this.Eh;
        if (i !== t) {
          Debug && t !== null && U.s(t, Group2, Part2, "containingGroup"), t !== null && (this === t || t.isMemberOf(this)) && (this === t && U.n("Cannot make a Group a member of itself: " + this.toString()), U.n("Cannot make a Group indirectly contain itself: " + this.toString() + " already contains " + t.toString())), this.invalidateLayout(2);
          const e = this.diagram;
          if (i !== null ? i.yC(this) : this instanceof Group2 && e !== null && e.el.delete(this), this.Eh = t, t !== null ? t.wC(this) : this instanceof Group2 && e !== null && e.el.add(this), this.invalidateLayout(1), e !== null && e.H) {
            const n = this.data, o = e.model;
            if (n !== null && o.Ia()) {
              const r = t !== null ? t.data : null;
              o.setGroupForData(n, o.getKeyForNodeData(r));
            }
          }
          const s = this.containingGroupChanged;
          if (s !== null) {
            let n = true;
            e !== null && (n = e.H, e.H = true), s(this, i, t), e !== null && (e.H = n);
          }
          if (this instanceof Group2) {
            const n = new GSet2();
            Part2.bh(n, this, true, 0, true);
            const o = n.iterator;
            for (; o.next(); ) {
              const r = o.value;
              if (r instanceof Node2) {
                const l = r.linksConnected;
                for (; l.next(); ) l.value._d();
              }
            }
          }
          if (this instanceof Node2) {
            const n = this.linksConnected;
            for (; n.next(); ) n.value._d();
            const o = this.labeledLink;
            o !== null && o._d();
          }
          this.t("containingGroup", i, t), t !== null && t.PE();
        }
      } else U.n("cannot set the Part.containingGroup of a Link or Adornment");
    }
    Lh() {
      const t = this.containingGroup;
      t !== null && (t.hasPlaceholder() && t.placeholder.g(), t.g(), t.invalidateConnectedLinks());
    }
    L() {
      const t = this.diagram;
      t !== null && !this.us() && !this.yh() && this.isVisible() && this.Oi.isReal() && t.L(this.ua(this.Oi));
    }
    g() {
      if (this.Wo()) return;
      super.g();
      const t = this.diagram;
      t !== null && (t.D0(this), this instanceof Node2 && this.labeledLink !== null && this.labeledLink.Cc(), t.requestUpdate(true));
    }
    Cc(t) {
      if (this.us()) return;
      const i = this.diagram;
      i !== null && (i.D0(this), this instanceof Node2 && this.invalidateConnectedLinks(), i.requestUpdate()), this.uo(true);
    }
    o0(t) {
      if (!t) {
        const i = this.Eh;
        i !== null && i.wC(this);
      }
    }
    r0(t) {
      if (!t) {
        const i = this.Eh;
        i !== null && i.yC(this);
      }
    }
    uc() {
      const t = this.data;
      if (t !== null) {
        const i = this.diagram;
        if (i !== null) {
          const e = i.model;
          e !== null && e.removeNodeData(t);
        }
      }
    }
    get containingGroupChanged() {
      return this.J !== null ? this.J.Yy : null;
    }
    set containingGroupChanged(t) {
      const i = this.containingGroupChanged;
      i !== t && (t !== null && U.C(t, Part2, "containingGroupChanged"), this.se().Yy = t, this.t("containingGroupChanged", i, t));
    }
    findSubGraphLevel() {
      return this.xC(this);
    }
    xC(t) {
      const i = t.containingGroup;
      if (i !== null) return 1 + this.xC(i);
      if (t instanceof Node2) {
        const e = t.labeledLink;
        if (e !== null) return this.xC(e);
      }
      return 0;
    }
    findTopLevelPart() {
      return this.bC(this);
    }
    bC(t) {
      const i = t.containingGroup;
      if (i !== null) return this.bC(i);
      if (t instanceof Node2) {
        const e = t.labeledLink;
        if (e !== null) return this.bC(e);
      }
      return t;
    }
    get isTopLevel() {
      return !(this.containingGroup !== null || this instanceof Node2 && this.labeledLink !== null);
    }
    isMemberOf(t) {
      return t instanceof Group2 ? this.SC(this, t) : false;
    }
    SC(t, i) {
      if (t === i || i === null) return false;
      const e = t.containingGroup;
      if (e !== null && (e === i || this.SC(e, i))) return true;
      if (t instanceof Node2) {
        const s = t.labeledLink;
        if (s !== null) return this.SC(s, i);
      }
      return false;
    }
    findCommonContainingGroup(t) {
      if (t === null) return null;
      if (Debug && U.s(t, Part2, Part2, "findCommonContainingGroup:other"), this === t) return this.containingGroup;
      let i = this;
      for (; i !== null; ) {
        if (i instanceof Group2 && i.yS(true), i instanceof Node2) {
          const s = i.labeledLink;
          s !== null && (i = s);
        }
        i = i.containingGroup;
      }
      let e = null;
      for (i = t; i !== null; ) {
        if (i.jD()) {
          e = i;
          break;
        }
        if (i instanceof Node2) {
          const s = i.labeledLink;
          s !== null && (i = s);
        }
        i = i.containingGroup;
      }
      for (i = this; i !== null; ) {
        if (i instanceof Group2 && i.yS(false), i instanceof Node2) {
          const s = i.labeledLink;
          s !== null && (i = s);
        }
        i = i.containingGroup;
      }
      return e;
    }
    get layoutConditions() {
      return this.J !== null ? this.J.Ky : 127;
    }
    set layoutConditions(t) {
      const i = this.layoutConditions;
      i !== t && (Debug && U.i(t, "number", Part2, "layoutConditions"), this.se().Ky = t, this.t("layoutConditions", i, t));
    }
    canLayout() {
      if (!this.isLayoutPositioned || !this.isVisible()) return false;
      const t = this.layer;
      return !(t !== null && t.isTemporary || this instanceof Node2 && this.isLinkLabel);
    }
    AE(t) {
      if (!this.isLayoutPositioned || (t & this.layoutConditions) === 0) return false;
      const i = this.layer;
      if (i !== null && i.isTemporary || this instanceof Node2 && this.isLinkLabel) return false;
      const e = this.diagram;
      return !(e !== null && e.undoManager.isUndoingRedoing);
    }
    invalidateLayout(t) {
      if (t === void 0 && (t = 16777215), !this.AE(t)) return;
      const i = this.Eh;
      if (i !== null) {
        const e = i.layout;
        e !== null ? e.b() : i.invalidateLayout(t);
      } else {
        const e = this.diagram;
        if (e !== null) {
          const s = e.layout;
          s !== null && s.b();
        }
      }
    }
    wL() {
      if (!this.isVisible()) return false;
      const t = this.layer;
      return !(t !== null && t.isTemporary);
    }
    static bh(t, i, e, s, n, o) {
      if (o === void 0 && (o = null), !t.has(i) && !(o !== null && !o(i)) && !(i instanceof Adornment2)) {
        if (t.add(i), i instanceof Node2) {
          if (e && i instanceof Group2) {
            const r = i.memberParts;
            for (; r.next(); ) {
              const l = r.value;
              Part2.bh(t, l, e, s, n, o);
            }
          }
          if (n !== false) {
            const r = i.linksConnected;
            for (; r.next(); ) {
              const l = r.value;
              if (t.has(l)) continue;
              const h = l.fromNode, f = l.toNode, a = h === null || t.has(h), c = f === null || t.has(f);
              (n ? a && c : a || c) && Part2.bh(t, l, e, s, n, o);
            }
          }
          if (s > 1) {
            const r = i.findTreeChildrenNodes();
            for (; r.next(); ) {
              const l = r.value;
              Part2.bh(t, l, e, s - 1, n, o);
            }
          }
        } else if (i instanceof Link2) {
          const r = i.labelNodes;
          for (; r.next(); ) {
            const l = r.value;
            Part2.bh(t, l, e, s, n, o);
          }
        }
      }
    }
    get dragComputation() {
      return this.J !== null ? this.J.Uy : null;
    }
    set dragComputation(t) {
      const i = this.dragComputation;
      i !== t && (t !== null && U.C(t, Part2, "dragComputation"), this.se().Uy = t, this.t("dragComputation", i, t));
    }
    get shadowOffset() {
      return this.J !== null ? this.J.Gy : Point2.BA;
    }
    set shadowOffset(t) {
      const i = this.shadowOffset;
      i.equals(t) || (Debug && U.s(t, Point2, Part2, "shadowOffset"), t = t.T(), this.se().Gy = t, this.L(), this.t("shadowOffset", i, t));
    }
    get shadowColor() {
      return this.J !== null ? this.J.qy : "gray";
    }
    set shadowColor(t) {
      const i = this.shadowColor;
      i !== t && (Debug && U.i(t, "string", Part2, "shadowColor"), this.se().qy = t, this.L(), this.t("shadowColor", i, t));
    }
    get shadowBlur() {
      return this.J !== null ? this.J.Rn : 4;
    }
    set shadowBlur(t) {
      const i = this.shadowBlur;
      i !== t && (Debug && U.i(t, "number", Part2, "shadowBlur"), this.se().Rn = t, this.L(), this.t("shadowBlur", i, t));
    }
  }
  class PartTemplateSettings {
    wi;
    Ny;
    Yy;
    Iy;
    Fy;
    Ry;
    Dy;
    Oy;
    Ey;
    By;
    Vy;
    zy;
    Xy;
    Ty;
    Ly;
    Cy;
    Ay;
    Uy;
    Ky;
    Gy;
    qy;
    Rn;
    constructor() {
      this.wi = false, this.Ny = null, this.Yy = null, this.Iy = null, this.Fy = "", this.Ry = null, this.Dy = null, this.Oy = null, this.Ey = "", this.By = Size2.ix, this.Vy = null, this.zy = "", this.Xy = Spot2.Default, this.Ty = "", this.Ly = Spot2.TopLeft, this.Cy = Point2.OA, this.Ay = Point2.EA, this.Uy = null, this.Ky = 127, this.Gy = Point2.BA, this.qy = "gray", this.Rn = 4;
    }
    copy() {
      const t = new PartTemplateSettings();
      return t.Ny = this.Ny, t.Yy = this.Yy, t.Iy = this.Iy, t.Fy = this.Fy, t.Ry = this.Ry, t.Dy = this.Dy, t.Oy = this.Oy, t.Ey = this.Ey, t.By = this.By.T(), t.Vy = this.Vy, t.zy = this.zy, t.Xy = this.Xy.T(), t.Ty = this.Ty, t.Ly = this.Ly.T(), t.Cy = this.Cy.T(), t.Ay = this.Ay.T(), t.Uy = this.Uy, t.Ky = this.Ky, t.Gy = this.Gy.T(), t.qy = this.qy, t.Rn = this.Rn, t;
    }
  }
  class Adornment2 extends Part2 {
    Ts;
    Rt;
    _P;
    tM;
    Ic;
    constructor(t, i) {
      let e;
      t === void 0 || t instanceof PanelLayout2 || typeof t == "string" ? e = t : t && (i = t), super(e), this.P &= -257, this.xl = "Adornment", this.Ts = null, this._P = 0, this.tM = false, this.Rt = null, this.Ic = null, i && Object.assign(this, i);
    }
    toString() {
      const t = this.adornedPart;
      return "Adornment(" + this.category + ")" + (t !== null ? t.toString() : "");
    }
    updateRelationshipsFromData() {
    }
    Od(t) {
      const i = this.adornedObject;
      if (!(i instanceof Shape2)) return;
      const e = i.part;
      if (!(e instanceof Link2)) return;
      const s = e.path;
      let n = s.geometry;
      e.Od(t), n = s.geometry;
      const o = this.O.h, r = o.length;
      for (let l = 0; l < r; l++) {
        const h = o[l];
        h.isPanelMain && h instanceof Shape2 && (h.xt = n);
      }
    }
    hasPlaceholder() {
      return this.Rt !== null && this.Rt.isVisibleObject();
    }
    get placeholder() {
      return this.Rt;
    }
    get adornedObject() {
      return this.Ts;
    }
    set adornedObject(t) {
      Debug && t !== null && U.s(t, GraphObject2, Part2, "adornedObject:value");
      const i = this.adornedPart;
      let e = null;
      t !== null && (e = t.part), i !== null && (t === null || i !== e) && i.removeAdornment(this.category), this.Ts = t, e !== null && e.addAdornment(this.category, this);
    }
    get adornedPart() {
      const t = this.Ts;
      return t !== null ? t.part : null;
    }
    nl() {
      const t = this.Ts;
      if (t === null) return true;
      const i = t.part;
      return i === null || !i.us();
    }
    Oe() {
      return false;
    }
    get containingGroup() {
      return null;
    }
    wc(t, i, e, s, n, o, r) {
      if (t === 3 && i === "elements") {
        if (n instanceof Placeholder2) this.Rt === null ? this.Rt = n : Debug && this.Rt !== n && U.n("Cannot insert a second Placeholder into the visual tree of an Adornment.");
        else if (n instanceof Panel2) {
          const l = n.findInVisualTree((h) => h instanceof Placeholder2);
          l instanceof Placeholder2 && (this.Rt === null ? this.Rt = l : Debug && this.Rt !== l && U.n("Cannot insert a second Placeholder into the visual tree of an Adornment."));
        }
      } else t === 4 && i === "elements" && this.Rt !== null && (s === this.Rt ? this.Rt = null : s instanceof Panel2 && this.Rt.isContainedBy(s) && (this.Rt = null));
      super.wc(t, i, e, s, n, o, r);
    }
    updateAdornments() {
    }
    uc() {
    }
  }
  var PortSpreading2 = ((w) => (w[w.None = 0] = "None", w[w.Evenly = 1] = "Evenly", w[w.Packed = 2] = "Packed", w))(PortSpreading2 || {});
  class Node2 extends Part2 {
    z;
    Bt;
    Hc;
    kl;
    Bh;
    ue;
    ri;
    constructor(t, i) {
      let e;
      t === void 0 || t instanceof PanelLayout2 || typeof t == "string" ? e = t : t && (i = t), super(e), this.z = 13, this.Bt = null, this.ri = new List2(), this.Hc = null, this.kl = null, this.ue = null, this.Bh = false, i && Object.assign(this, i);
    }
    cloneProtected(t) {
      super.cloneProtected(t), t.z = this.z, this.Bt !== null && (this.Bt.wi ? t.Bt = this.Bt : t.Bt = this.Bt.copy());
    }
    Zo(t) {
      super.Zo(t), t.invalidateConnectedLinks(), t.kl = this.kl, t.ue = null;
    }
    static SpreadingNone = 0;
    static SpreadingEvenly = 1;
    static SpreadingPacked = 2;
    Pl() {
      return this.Bt === null ? this.Bt = new NodeTemplateSettings() : this.Bt.wi && (this.Bt = this.Bt.copy()), this.Bt;
    }
    Ch() {
      super.Ch(), this.Bt !== null && (this.Bt.wi = true);
    }
    JD(t) {
      t !== null && (this.kl === null && (this.kl = new GSet2()), this.kl.add(t));
    }
    $D(t) {
      t !== null && this.kl !== null && this.kl.delete(t);
    }
    ZD(t, i, e) {
      if (t === null || this.kl === null) return null;
      const s = this.kl.iterator;
      for (; s.next(); ) {
        const n = s.value;
        if (n.Hy === this && n.wS === t && n.kC === i && n.PC === e || n.Hy === t && n.wS === this && n.kC === e && n.PC === i) return n;
      }
      return null;
    }
    invalidateLinkBundle(t, i, e) {
      i == null && (i = ""), e == null && (e = "");
      const s = this.ZD(t, i, e);
      s !== null && s.tg();
    }
    wc(t, i, e, s, n, o, r) {
      t === 3 && i === "elements" ? this.ue = null : t === 4 && i === "elements" && (this.ue = null), super.wc(t, i, e, s, n, o, r);
    }
    invalidateConnectedLinks(t, i) {
      const e = this.linksConnected;
      for (; e.next(); ) {
        const s = e.value;
        t && t.has(s) || i && s.fromPort !== i && s.toPort !== i || (this.Ne(s.fromPort), this.Ne(s.toPort), s.ii());
      }
    }
    Ne(t) {
      if (t === null) return;
      const i = t.kd;
      i !== null && i.tg();
      const e = t.part, s = e.containingGroup;
      s !== null && !e.isVisible() && s.Ne(s.port);
    }
    nl() {
      return true;
    }
    get portSpreading() {
      return this.Bt !== null ? this.Bt.vy : 1;
    }
    set portSpreading(t) {
      const i = this.portSpreading;
      if (i !== t) {
        Debug && t !== 0 && t !== 1 && t !== 2 && U.n("Node.portSpreading can only be set to PortSpreading.None, PortSpreading.Evenly, or PortSpreading.Packed, not: " + t), this.Pl().vy = t, this.t("portSpreading", i, t);
        const e = this.diagram;
        if (e !== null && e.undoManager.isUndoingRedoing) return;
        this.invalidateConnectedLinks();
      }
    }
    get avoidable() {
      return (this.z & 8) !== 0;
    }
    set avoidable(t) {
      const i = (this.z & 8) !== 0;
      if (i !== t) {
        Debug && U.i(t, "boolean", Node2, "avoidable"), this.z = this.z ^ 8;
        const e = this.diagram;
        e !== null && e.q2(this), this.t("avoidable", i, t);
      }
    }
    get avoidableMargin() {
      return this.Bt !== null ? this.Bt.Wy : Margin2.GA;
    }
    set avoidableMargin(t) {
      typeof t == "number" ? t = new Margin2(t) : U.s(t, Margin2, Node2, "avoidableMargin");
      const i = this.avoidableMargin;
      if (!i.equals(t)) {
        t = t.T(), this.Pl().Wy = t;
        const e = this.diagram;
        e !== null && e.q2(this), this.t("avoidableMargin", i, t);
      }
    }
    canAvoid() {
      return this.avoidable && !this.isLinkLabel;
    }
    getAvoidableRect(t) {
      return t.set(this.actualBounds), t.addMargin(this.avoidableMargin), t;
    }
    findVisibleNode() {
      let t = this;
      for (; t !== null && !t.isVisible(); ) t = t.containingGroup;
      return t;
    }
    isVisible() {
      if (!super.isVisible()) return false;
      let t = true, i = 1;
      const e = this.diagram;
      if (e !== null) {
        if (e.animationManager.i1(this)) return true;
        t = e.isTreePathToChildren, i = e.treeCollapsePolicy;
      }
      if (i === 1) {
        const n = this.findTreeParentNode();
        if (n !== null && !n.isTreeExpanded) return false;
      } else if (i === 2) {
        const n = t ? this.findLinksInto() : this.findLinksOutOf();
        let o = false, r = false;
        for (; n.next(); ) {
          const l = n.value;
          if (l.isTreeLink) {
            o = true;
            const h = t ? l.fromNode : l.toNode;
            if (h && h.isTreeExpanded) {
              r = true;
              break;
            }
          }
        }
        if (o && !r) return false;
      } else if (i === 3) {
        const n = t ? this.findLinksInto() : this.findLinksOutOf();
        let o = false, r = false;
        for (; n.next(); ) {
          const l = n.value;
          if (l.isTreeLink) {
            o = true;
            const h = t ? l.fromNode : l.toNode;
            if (h && !h.isTreeExpanded) {
              r = true;
              break;
            }
          }
        }
        if (o && r) return false;
      }
      const s = this.labeledLink;
      return s !== null ? s.isVisible() : true;
    }
    Hi(t) {
      super.Hi(t);
      const i = this.linksConnected;
      for (; i.next(); ) {
        const e = i.value;
        if (t && this.containingGroup !== null) {
          const s = e.getOtherNode(this);
          s !== null && !s.isMemberOf(this.containingGroup) && e.ii();
        }
        e.Hi(t);
      }
    }
    get linksConnected() {
      return this.ri.iterator;
    }
    findExternalTreeLinksConnected() {
      const t = new GSet2(), i = new GSet2();
      return this.QD(this, t, i), i.iterator;
    }
    QD(t, i, e) {
      if (t === null || i.has(t)) return;
      i.add(t);
      let s = true;
      const n = this.diagram;
      n !== null && (s = n.isTreePathToChildren), t.linksConnected.each((o) => {
        o.isTreeLink ? (s ? o.fromNode === t : o.toNode === t) && this.QD(s ? o.toNode : o.fromNode, i, e) : e.add(o);
      });
    }
    findLinksConnected(t) {
      if (t === void 0 && (t = null), t === null) return this.ri.iterator;
      Debug && U.i(t, "string", Node2, "findLinksConnected:pid");
      const i = new ListIterator(this.ri), e = this;
      return i.predicate = (s) => s.fromNode === e && s.fromPortId === t || s.toNode === e && s.toPortId === t, i;
    }
    findLinksOutOf(t) {
      t === void 0 && (t = null), Debug && t !== null && U.i(t, "string", Node2, "findLinksOutOf:pid");
      const i = new ListIterator(this.ri), e = this;
      return i.predicate = (s) => s.fromNode !== e ? false : t === null ? true : s.fromPortId === t, i;
    }
    findLinksInto(t) {
      t === void 0 && (t = null), Debug && t !== null && U.i(t, "string", Node2, "findLinksInto:pid");
      const i = new ListIterator(this.ri), e = this;
      return i.predicate = (s) => s.toNode !== e ? false : t === null ? true : s.toPortId === t, i;
    }
    findNodesConnected(t) {
      t === void 0 && (t = null), Debug && t !== null && U.i(t, "string", Node2, "findNodesConnected:pid");
      let i = null, e = null;
      const s = this.ri.iterator;
      for (; s.next(); ) {
        const n = s.value;
        if (n.fromNode === this) {
          if (t === null || n.fromPortId === t) {
            const o = n.toNode;
            i !== null ? i.add(o) : e !== null && e !== o ? (i = new GSet2(), i.add(e), i.add(o)) : e = o;
          }
        } else if (n.toNode === this && (t === null || n.toPortId === t)) {
          const o = n.fromNode;
          i !== null ? i.add(o) : e !== null && e !== o ? (i = new GSet2(), i.add(e), i.add(o)) : e = o;
        }
      }
      return i !== null ? i.iterator : e !== null ? new SingletonIterator(e) : EmptyIterator.instance;
    }
    findNodesOutOf(t) {
      t === void 0 && (t = null), Debug && t !== null && U.i(t, "string", Node2, "findNodesOutOf:pid");
      let i = null, e = null;
      const s = this.ri.iterator;
      for (; s.next(); ) {
        const n = s.value;
        if (n.fromNode === this && (t === null || n.fromPortId === t)) {
          const o = n.toNode;
          i !== null ? i.add(o) : e !== null && e !== o ? (i = new GSet2(), i.add(e), i.add(o)) : e = o;
        }
      }
      return i !== null ? i.iterator : e !== null ? new SingletonIterator(e) : EmptyIterator.instance;
    }
    findNodesInto(t) {
      t === void 0 && (t = null), Debug && t !== null && U.i(t, "string", Node2, "findNodesInto:pid");
      let i = null, e = null;
      const s = this.ri.iterator;
      for (; s.next(); ) {
        const n = s.value;
        if (n.toNode === this && (t === null || n.toPortId === t)) {
          const o = n.fromNode;
          i !== null ? i.add(o) : e !== null && e !== o ? (i = new GSet2(), i.add(e), i.add(o)) : e = o;
        }
      }
      return i !== null ? i.iterator : e !== null ? new SingletonIterator(e) : EmptyIterator.instance;
    }
    findLinksBetween(t, i, e) {
      i === void 0 && (i = null), e === void 0 && (e = null), Debug && (U.s(t, Node2, Node2, "findLinksBetween:othernode"), i !== null && U.i(i, "string", Node2, "findLinksBetween:pid"), e !== null && U.i(e, "string", Node2, "findLinksBetween:otherpid"));
      const s = new ListIterator(this.ri), n = this;
      return s.predicate = (o) => o.fromNode === n && o.toNode === t && (i === null || o.fromPortId === i) && (e === null || o.toPortId === e) || o.fromNode === t && o.toNode === n && (e === null || o.fromPortId === e) && (i === null || o.toPortId === i), s;
    }
    findLinksTo(t, i, e) {
      i === void 0 && (i = null), e === void 0 && (e = null), Debug && (U.s(t, Node2, Node2, "findLinksTo:othernode"), i !== null && U.i(i, "string", Node2, "findLinksTo:pid"), e !== null && U.i(e, "string", Node2, "findLinksTo:otherpid"));
      const s = new ListIterator(this.ri), n = this;
      return s.predicate = (o) => !(o.fromNode !== n || o.toNode !== t || i !== null && o.fromPortId !== i || e !== null && o.toPortId !== e), s;
    }
    findSuccessorParts(t) {
      return t === void 0 && (t = new GSet2()), this._D(this, t), t.remove(this), t;
    }
    _D(t, i) {
      t !== null && (i.has(t) || (i.add(t), t.findLinksOutOf().each((e) => {
        if (i.has(e)) return;
        i.add(e);
        const s = e.toNode;
        s !== null && this._D(s, i);
      })));
    }
    findPredecessorParts(t) {
      return t === void 0 && (t = new GSet2()), this.tF(this, t), t.remove(this), t;
    }
    tF(t, i) {
      t !== null && (i.has(t) || (i.add(t), t.findLinksInto().each((e) => {
        if (i.has(e)) return;
        i.add(e);
        const s = e.fromNode;
        s !== null && this.tF(s, i);
      })));
    }
    get linkConnected() {
      return this.Bt !== null ? this.Bt.jy : null;
    }
    set linkConnected(t) {
      const i = this.linkConnected;
      i !== t && (t !== null && U.C(t, Node2, "linkConnected"), this.Pl().jy = t, this.t("linkConnected", i, t));
    }
    get linkDisconnected() {
      return this.Bt !== null ? this.Bt.Jy : null;
    }
    set linkDisconnected(t) {
      const i = this.linkDisconnected;
      i !== t && (t !== null && U.C(t, Node2, "linkDisconnected"), this.Pl().Jy = t, this.t("linkDisconnected", i, t));
    }
    get linkValidation() {
      return this.Bt !== null ? this.Bt.Yl : null;
    }
    set linkValidation(t) {
      const i = this.linkValidation;
      i !== t && (t !== null && U.C(t, Node2, "linkValidation"), this.Pl().Yl = t, this.t("linkValidation", i, t));
    }
    xS(t, i) {
      this.Ne(i);
      const e = this.ri.has(t);
      if (e || this.ri.add(t), !e || t.fromNode === t.toNode) {
        const s = this.linkConnected;
        if (s !== null) {
          let n = true;
          const o = this.diagram;
          o !== null && (n = o.H, o.H = true), s(this, t, i), o !== null && (o.H = n);
        }
      }
      if (!e) {
        if (!t.isTreeLink) return;
        const s = t.fromNode, n = t.toNode;
        if (s !== null && n !== null && s !== n) {
          let o = true;
          const r = this.diagram;
          r !== null && (o = r.isTreePathToChildren);
          const l = o ? n : s, h = o ? s : n;
          if (l.Bh || (l.Bh = h), h.isTreeLeaf) {
            if (r !== null && r.undoManager.isUndoingRedoing) return;
            o ? s === h && (h.isTreeLeaf = false) : n === h && (h.isTreeLeaf = false);
          }
        }
      }
    }
    bS(t, i) {
      this.Ne(i);
      const e = this.ri.delete(t);
      let s = null;
      if (e || t.toNode === t.fromNode) {
        const n = this.linkDisconnected;
        if (s = this.diagram, n !== null) {
          let o = true;
          s !== null && (o = s.H, s.H = true), n(this, t, i), s !== null && (s.H = o);
        }
      }
      if (e) {
        if (!t.isTreeLink) return;
        let n = true;
        s !== null && (n = s.isTreePathToChildren);
        const o = n ? t.toNode : t.fromNode, r = n ? t.fromNode : t.toNode;
        if (o !== null && (o.Bh = false), r !== null && !r.isTreeLeaf) if (r.ri.count === 0) {
          if (r.Bh = null, s !== null && s.undoManager.isUndoingRedoing) return;
          r.isTreeLeaf = true;
        } else r.E0();
      }
    }
    E0() {
      if (this.Bh = false, this.ri.count === 0) return;
      let t = true;
      const i = this.diagram;
      if (i !== null && i.undoManager.isUndoingRedoing) return;
      i !== null && (t = i.isTreePathToChildren);
      const e = this.ri.iterator;
      for (; e.next(); ) {
        const s = e.value;
        if (s.isTreeLink) {
          if (t) {
            if (s.fromNode === this) {
              this.isTreeLeaf = false;
              return;
            }
          } else if (s.toNode === this) {
            this.isTreeLeaf = false;
            return;
          }
        }
      }
      this.isTreeLeaf = true;
    }
    updateRelationshipsFromData() {
      const t = this.diagram;
      t !== null && t.partManager.updateRelationshipsFromData(this);
    }
    o0(t) {
      if (super.o0(t), !t) {
        this.E0();
        const i = this.Hc;
        i !== null && i.iF(this);
      }
    }
    r0(t) {
      if (super.r0(t), !t) {
        const i = this.Hc;
        i !== null && i.eF(this);
      }
    }
    uc() {
      if (this.ri.count > 0) {
        const t = this.diagram;
        if (t !== null) {
          const i = t.commandHandler !== null ? t.commandHandler.deletesConnectedLinks : true, s = this.ri.copy().iterator;
          for (; s.next(); ) {
            const n = s.value;
            i ? t.remove(n) : (n.fromNode === this && (n.fromNode = null), n.toNode === this && (n.toNode = null));
          }
        }
      }
      this.labeledLink = null, super.uc();
    }
    get isLinkLabel() {
      return this.Hc !== null;
    }
    get labeledLink() {
      return this.Hc;
    }
    set labeledLink(t) {
      const i = this.Hc;
      if (i !== t) {
        Debug && t !== null && U.s(t, Link2, Node2, "labeledLink");
        const e = this.diagram, s = this.data;
        if (i !== null) {
          if (i.eF(this), e !== null && s !== null && !e.undoManager.isUndoingRedoing) {
            const n = i.data, o = e.model;
            if (n !== null && o._a()) {
              const r = o.getKeyForNodeData(s);
              r !== void 0 && o.removeLabelKeyForLinkData(n, r);
            }
          }
          this.containingGroup = null;
        }
        if (this.Hc = t, t !== null) {
          if (t.iF(this), e !== null && s !== null && !e.undoManager.isUndoingRedoing) {
            const n = t.data, o = e.model;
            if (n !== null && o._a()) {
              const r = o.getKeyForNodeData(s);
              r !== void 0 && o.addLabelKeyForLinkData(n, r);
            }
          }
          this.containingGroup = t.containingGroup;
        }
        this.Cc(), this.t("labeledLink", i, t);
      }
    }
    findVisiblePort(t) {
      let i = t;
      for (; i !== null && (!i.actualBounds.isReal() || !i.isVisibleObject()); ) i = i.panel;
      return i === null ? this.port : i;
    }
    findPort(t) {
      if (Debug && U.i(t, "string", Node2, "findPort:pid"), this.ue === null) {
        if (t === "" && this.In === false) return this;
        this.sF();
      }
      let i = this.ue.get(t);
      return i !== null || t !== "" && (i = this.ue.get(""), i !== null) ? i : this;
    }
    get port() {
      return this.findPort("");
    }
    get ports() {
      return this.ue === null && this.sF(), this.ue.iteratorValues;
    }
    sF() {
      this.ue === null ? this.ue = new GMap2() : this.ue.clear(), this.walkVisualTreeFrom(this, (t, i) => t.aD(i)), this.ue.count === 0 && this.ue.set("", this);
    }
    aD(t) {
      const i = t.portId;
      i !== null && this.ue !== null && this.ue.set(i, t);
    }
    zN(t, i) {
      const e = t.portId;
      if (e !== null) {
        this.ue !== null && this.ue.delete(e);
        const s = this.diagram;
        if (s !== null && i) {
          let n = null;
          const o = this.findLinksConnected(e);
          for (; o.next(); ) {
            const r = o.value;
            n === null && (n = U.ft()), n.push(r);
          }
          if (n !== null) {
            for (let r = 0; r < n.length; r++) {
              const l = n[r];
              s.remove(l);
            }
            U.et(n);
          }
        }
      }
    }
    isInTreeOf(t) {
      if (t === null || t === this) return false;
      let i = true;
      const e = this.diagram;
      e !== null && (i = e.isTreePathToChildren);
      let s = this;
      const n = t;
      let o;
      if (i) for (; s !== n; ) {
        o = null;
        const r = s.ri.iterator;
        for (; r.next(); ) {
          const l = r.value;
          if (l.isTreeLink && (o = l.fromNode, o !== s && o !== this)) break;
        }
        if (o === this || o === null || o === s) return false;
        s = o;
      }
      else for (; s !== n; ) {
        o = null;
        const r = s.ri.iterator;
        for (; r.next(); ) {
          const l = r.value;
          if (l.isTreeLink && (o = l.toNode, o !== s && o !== this)) break;
        }
        if (o === this || o === null || o === s) return false;
        s = o;
      }
      return true;
    }
    findTreeRoot() {
      let t = true;
      const i = this.diagram;
      i !== null && (t = i.isTreePathToChildren);
      let e = this, s;
      if (t) for (; ; ) {
        s = null;
        const n = e.ri.iterator;
        for (; n.next(); ) {
          const o = n.value;
          if (o.isTreeLink && (s = o.fromNode, s !== e && s !== this)) break;
        }
        if (s === this) return this;
        if (s === null || s === e) return e;
        e = s;
      }
      else for (; ; ) {
        s = null;
        const n = e.ri.iterator;
        for (; n.next(); ) {
          const o = n.value;
          if (o.isTreeLink && (s = o.toNode, s !== e && s !== this)) break;
        }
        if (s === this) return this;
        if (s === null || s === e) return e;
        e = s;
      }
    }
    findCommonTreeParent(t) {
      if (t === null) return null;
      if (Debug && U.s(t, Node2, Node2, "findCommonTreeParent:other"), this === t) return this;
      let i = this;
      for (; i !== null; ) i.yS(true), i = i.findTreeParentNode();
      let e = null;
      for (i = t; i !== null; ) {
        if (i.jD()) {
          e = i;
          break;
        }
        i = i.findTreeParentNode();
      }
      for (i = this; i !== null; ) i.yS(false), i = i.findTreeParentNode();
      return e;
    }
    findTreeParentLink() {
      let t = true;
      const i = this.diagram;
      i !== null && (t = i.isTreePathToChildren);
      const e = this.ri.iterator;
      if (t) for (; e.next(); ) {
        const s = e.value;
        if (s.isTreeLink && s.fromNode !== this) return s;
      }
      else for (; e.next(); ) {
        const s = e.value;
        if (s.isTreeLink && s.toNode !== this) return s;
      }
      return null;
    }
    findTreeParentNode() {
      const t = this.Bh;
      if (t === null) return null;
      if (t instanceof Node2) return t;
      const i = this.diagram, e = i !== null ? i.isTreePathToChildren : true, s = this.ri.iterator;
      for (; s.next(); ) {
        const n = s.value;
        if (!n.isTreeLink) continue;
        const o = e ? n.fromNode : n.toNode;
        if (o !== this) return this.Bh = o, o;
      }
      return this.Bh = null, null;
    }
    findTreeParentChain(t) {
      function i(e, s) {
        s.add(e);
        const n = e.findTreeParentLink();
        if (n !== null) {
          s.add(n);
          const o = e.findTreeParentNode();
          if (o === null) return;
          i(o, s);
        }
      }
      return t === void 0 && (t = new GSet2()), i(this, t), t;
    }
    findTreeLevel() {
      return this.TE(this);
    }
    TE(t) {
      let i = 0, e = t.findTreeParentNode();
      for (; e !== null && e !== t; ) e = e.findTreeParentNode(), i++;
      return i;
    }
    findTreeChildrenLinks() {
      let t = true;
      const i = this.diagram;
      i !== null && (t = i.isTreePathToChildren);
      const e = new ListIterator(this.ri), s = this;
      return t ? e.predicate = (n) => !(!n.isTreeLink || n.fromNode !== s) : e.predicate = (n) => !(!n.isTreeLink || n.toNode !== s), e;
    }
    findTreeChildrenNodes() {
      let t = true;
      const i = this.diagram;
      i !== null && (t = i.isTreePathToChildren);
      let e = null, s = null;
      const n = this.ri.iterator;
      if (t) for (; n.next(); ) {
        const o = n.value;
        if (o.isTreeLink && o.fromNode === this) {
          const r = o.toNode;
          e !== null ? e.add(r) : s !== null && s !== r ? (e = new List2(), e.add(s), e.add(r)) : s = r;
        }
      }
      else for (; n.next(); ) {
        const o = n.value;
        if (o.isTreeLink && o.toNode === this) {
          const r = o.fromNode;
          e !== null ? e.add(r) : s !== null && s !== r ? (e = new List2(), e.add(s), e.add(r)) : s = r;
        }
      }
      return e !== null ? e.iterator : s !== null ? new SingletonIterator(s) : EmptyIterator.instance;
    }
    findTreeParts(t, i) {
      return t === void 0 && (t = 1 / 0), U.i(t, "number", Node2, "findTreeParts:level"), i === void 0 && (i = new GSet2()), Part2.bh(i, this, false, t, true), i;
    }
    collapseTree(t) {
      t === void 0 && (t = 1), U.r(t, Node2, "collapseTree:level"), t < 1 && (t = 1);
      const i = this.diagram;
      if (i === null || i.isCollapsingExpanding) return;
      i.isCollapsingExpanding = true;
      const e = new GSet2();
      e.add(this), this.nF(e, i.isTreePathToChildren, t, i, this, i.treeCollapsePolicy === 1), i.isCollapsingExpanding = false;
    }
    nF(t, i, e, s, n, o) {
      if (e > 1) {
        const r = i ? this.findLinksOutOf() : this.findLinksInto();
        for (; r.next(); ) {
          const l = r.value;
          if (!l.isTreeLink) continue;
          const h = l.getOtherNode(this);
          h !== null && h !== this && !t.has(h) && (t.add(h), h.nF(t, i, e - 1, s, n, o));
        }
      } else this.oF(t, i, s, n, o);
    }
    oF(t, i, e, s, n) {
      const o = s === this ? true : this.isTreeExpanded, r = i ? this.findLinksOutOf() : this.findLinksInto();
      for (; r.next(); ) {
        const l = r.value;
        if (!l.isTreeLink) continue;
        const h = l.getOtherNode(this);
        if (h !== null && h !== this) {
          const f = t.has(h);
          if (f || t.add(h), o) {
            const a = i ? h.findNodesInto() : h.findNodesOutOf(), c = this;
            a.all((u) => u === c || !u.isTreeExpanded) && e.$f(h, s), h.Lh(), h.Hi(false);
          }
          h.isTreeExpanded && (h.wasTreeExpanded = h.isTreeExpanded, f || h.oF(t, i, e, s, n));
        }
      }
      this.isTreeExpanded = false;
    }
    expandTree(t) {
      t === void 0 && (t = 2), U.r(t, Node2, "expandTree:level"), t < 2 && (t = 2);
      const i = this.diagram;
      if (i === null || i.isCollapsingExpanding) return;
      i.isCollapsingExpanding = true;
      const e = new GSet2();
      e.add(this), this.rF(e, i.isTreePathToChildren, t, i, this, i.treeCollapsePolicy === 1), i.isCollapsingExpanding = false;
    }
    rF(t, i, e, s, n, o) {
      const r = n === this ? false : this.isTreeExpanded, l = i ? this.findLinksOutOf() : this.findLinksInto();
      for (; l.next(); ) {
        const h = l.value;
        if (!h.isTreeLink) continue;
        r || h.Be || h.ii();
        const f = h.getOtherNode(this);
        if (f !== null && f !== this && !t.has(f)) {
          if (t.add(f), !r) {
            f.Hi(true), f.Lh();
            const a = i ? f.findNodesInto() : f.findNodesOutOf(), c = this;
            a.all((u) => u === c || !u.isTreeExpanded) && s.Jf(f, n);
          }
          (e > 2 || f.wasTreeExpanded) && (f.wasTreeExpanded = false, f.rF(t, i, e - 1, s, n, o));
        }
      }
      this.isTreeExpanded = true;
    }
    get isTreeExpanded() {
      return (this.z & 1) !== 0;
    }
    set isTreeExpanded(t) {
      const i = (this.z & 1) !== 0;
      if (i !== t) {
        Debug && U.i(t, "boolean", Node2, "isTreeExpanded"), this.z = this.z ^ 1;
        const e = this.diagram;
        this.t("isTreeExpanded", i, t);
        const s = this.treeExpandedChanged;
        if (s !== null) {
          let n = true;
          e !== null && (n = e.H, e.H = true), s(this), e !== null && (e.H = n);
        }
        if (e !== null && e.undoManager.isUndoingRedoing) {
          this.Hi(t);
          return;
        }
        t ? this.expandTree() : this.collapseTree();
      }
    }
    get wasTreeExpanded() {
      return (this.z & 2) !== 0;
    }
    set wasTreeExpanded(t) {
      const i = (this.z & 2) !== 0;
      i !== t && (Debug && U.i(t, "boolean", Node2, "wasTreeExpanded"), this.z = this.z ^ 2, this.t("wasTreeExpanded", i, t));
    }
    get treeExpandedChanged() {
      return this.Bt !== null ? this.Bt.$y : null;
    }
    set treeExpandedChanged(t) {
      const i = this.treeExpandedChanged;
      i !== t && (t !== null && U.C(t, Node2, "treeExpandedChanged"), this.Pl().$y = t, this.t("treeExpandedChanged", i, t));
    }
    get isTreeLeaf() {
      return (this.z & 4) !== 0;
    }
    set isTreeLeaf(t) {
      const i = (this.z & 4) !== 0;
      i !== t && (Debug && U.i(t, "boolean", Node2, "isTreeLeaf"), this.z = this.z ^ 4, this.t("isTreeLeaf", i, t));
    }
    get isTreeRoot() {
      return this.findTreeParentLink() === null;
    }
  }
  class NodeTemplateSettings {
    wi;
    jy;
    Jy;
    Yl;
    $y;
    Wy;
    vy;
    Zy;
    Qy;
    xh;
    _y;
    constructor() {
      this.wi = false, this.jy = null, this.Jy = null, this.Yl = null, this.$y = null, this.Wy = Margin2.GA, this.vy = 1, this.Zy = null, this.Qy = null, this.xh = null, this._y = null;
    }
    copy() {
      const t = new NodeTemplateSettings();
      return t.jy = this.jy, t.Jy = this.Jy, t.Yl = this.Yl, t.$y = this.$y, t.Wy = this.Wy.T(), t.vy = this.vy, t.Zy = this.Zy, t.Qy = this.Qy, t.xh = this.xh, t._y = this._y, t;
    }
  }
  var LinkAdjusting2 = ((w) => (w[w.None = 0] = "None", w[w.End = 17] = "End", w[w.Scale = 18] = "Scale", w[w.Stretch = 19] = "Stretch", w))(LinkAdjusting2 || {}), Routing2 = ((w) => (w[w.Normal = 1] = "Normal", w[w.Orthogonal = 2] = "Orthogonal", w[w.AvoidsNodes = 6] = "AvoidsNodes", w[w.AvoidsNodesStraight = 7] = "AvoidsNodesStraight", w))(Routing2 || {}), Curve2 = ((w) => (w[w.None = 0] = "None", w[w.Bezier = 9] = "Bezier", w[w.JumpGap = 10] = "JumpGap", w[w.JumpOver = 11] = "JumpOver", w))(Curve2 || {});
  class Link2 extends Part2 {
    Dt;
    bo;
    So;
    ig;
    ko;
    Po;
    eg;
    vc;
    sg;
    ng;
    og;
    tf;
    rg;
    an;
    Ai;
    Ye;
    Br;
    Wc;
    lr;
    MC;
    NC;
    SS;
    CC;
    AC;
    ef;
    kS;
    xt;
    hr;
    static sf = null;
    static nf = null;
    Ic;
    TC;
    LC;
    constructor(t) {
      super(Panel2.Link), this.Dt = 8, this.bo = null, this.So = "", this.ig = null, this.ko = null, this.Po = "", this.eg = null, this.vc = 0, this.sg = 0, this.ng = 0, this.og = NaN, this.tf = 1, this.rg = 0.5, this.an = null, this.Ai = new List2().S(), this.Ye = null, this.Br = null, this.Wc = new Rect2(), this.xt = new Geometry2(), this.lr = null, this.hr = null, this.MC = Point2.xn, this.NC = Point2.xn, this.TC = 0, this.LC = 0, this.SS = new Point2(), this.CC = null, this.AC = null, this.ef = null, this.kS = NaN, this.wt = null, this.Ic = [], t && Object.assign(this, t);
    }
    cloneProtected(t) {
      super.cloneProtected(t), t.Dt = this.Dt & -113, t.So = this.So, t.ig = this.ig, t.Po = this.Po, t.eg = this.eg, t.vc = this.vc, t.sg = this.sg, t.ng = this.ng, t.og = this.og, t.tf = this.tf, t.rg = this.rg, this.wt !== null && (t.wt = this.wt.copy());
    }
    Zo(t) {
      super.Zo(t), this.So = t.So, this.Po = t.Po, t.Ye = null, t.ii(), t.hr = this.hr;
      const i = t.fromPort;
      i !== null && t.fromNode.Ne(i);
      const e = t.toPort;
      e !== null && t.toNode.Ne(e);
    }
    gi(t) {
      t in Routing2 || t in Curve2 || t in LinkAdjusting2 ? Link2.DC(t) ? this.routing = t : t === 9 || t === 10 || t === 11 ? this.curve = t : t === 17 || t === 18 || t === 19 ? this.adjusting = t : t === 1 || t === 0 || U.n("Unknown Link enum value for a Link property: " + t) : super.gi(t);
    }
    static Normal = 1;
    static Orthogonal = 2;
    static AvoidsNodes = 6;
    static AvoidsNodesStraight = 7;
    static None = 0;
    static Bezier = 9;
    static JumpGap = 10;
    static JumpOver = 11;
    static End = 17;
    static Scale = 18;
    static Stretch = 19;
    static OrientAlong = 21;
    static OrientPlus90 = 22;
    static OrientMinus90 = 23;
    static OrientOpposite = 24;
    static OrientUpright = 25;
    static OrientPlus90Upright = 26;
    static OrientMinus90Upright = 27;
    static OrientUpright45 = 28;
    static lF = 8;
    static hF = 16;
    static Vh = 8;
    static eS = 3;
    static aF = 3;
    static fF = 1.333;
    static FC = 1;
    static IC = 0;
    static cF = 10;
    static jc = 9999;
    static uF = 30;
    static dF = 30;
    static RC = 10;
    static gF = 10;
    static mF = 14;
    static pF = 30;
    static yF = 14;
    static sL = 8;
    static nL = 8;
    static wF = 11;
    static setRoutingParameter(t, i) {
      switch (t) {
        case 1:
          Link2.lF = i;
          break;
        case 2:
          Link2.hF = i;
          break;
        case 3:
          Link2.Vh = i;
          break;
        case 4:
          Link2.eS = i;
          break;
        case 5:
          Link2.aF = i;
          break;
        case 6:
          Link2.fF = i;
          break;
        case 7:
          Link2.FC = i;
          break;
        case 8:
          Link2.IC = i;
          break;
        case 9:
          Link2.cF = i;
          break;
        case 10:
          Link2.jc = i;
          break;
        case 11:
          Link2.uF = i;
          break;
        case 12:
          Link2.dF = i;
          break;
        case 13:
          Link2.RC = i;
          break;
        case 14:
          Link2.gF = i;
          break;
        case 15:
          Link2.mF = i;
          break;
        case 16:
          Link2.pF = i;
          break;
        case 17:
          Link2.yF = i;
          break;
        case 18:
          Link2.sL = i;
          break;
        case 19:
          Link2.nL = i;
          break;
        case 20:
          Link2.wF = i;
          break;
      }
      t > 29 && t < 71 && (Link2.YL = t + parseInt(i.toString().slice(0, -1)));
    }
    static YL;
    _e() {
      return this.wt === null && (this.wt = new LinkSettings()), this.wt;
    }
    Y3(t, i, e) {
      const s = t.segmentIndex, n = t.segmentFraction;
      let o = t.alignmentFocus;
      const r = t.segmentOrientation, l = t.segmentOffset;
      let h = 0, f = 0, a = 0, c = 0;
      if (isNaN(s)) {
        const C = this.xt, M = U.ft();
        C.getPointAndAngleAlongPath(n, M);
        const N = Point2.U(M[0], M[1]);
        if (c = M[2], N.add(this.getPoint(0)), C.type === 1) N.offset(-C.startX, -C.startY);
        else {
          const L = C.figures.first();
          N.offset(-L.startX, -L.startY);
        }
        r !== 0 && (a = this.computeAngle(t, r, c), t.angle = a), h = N.x, f = N.y, Point2.o(N), U.et(M);
      } else if (s < -i || s >= i) {
        const C = Point2.a();
        this.ZN(C), c = this.midAngle, r !== 0 && (a = this.computeAngle(t, r, c), t.angle = a), h = C.x, f = C.y, Point2.o(C);
      } else {
        let C, M, N = 0;
        if (s >= 0 ? (C = e.h[s], M = s < i - 1 ? e.h[s + 1] : C) : (N = i + s, C = e.h[N], M = N > 0 ? e.h[N - 1] : C), C.equalsApprox(M)) {
          let L, T;
          s >= 0 ? (L = s > 0 ? e.h[s - 1] : C, T = s < i - 2 ? e.h[s + 2] : M) : (L = N < i - 1 ? e.h[N + 1] : C, T = N > 1 ? e.h[N - 2] : M);
          const D = L.distanceSquaredPoint(C), F = M.distanceSquaredPoint(T);
          D > F + 10 ? c = s >= 0 ? L.directionPoint(C) : C.directionPoint(L) : F > D + 10 ? c = s >= 0 ? M.directionPoint(T) : T.directionPoint(M) : c = s >= 0 ? L.directionPoint(T) : T.directionPoint(L);
        } else c = s >= 0 ? C.directionPoint(M) : M.directionPoint(C);
        r !== 0 && (a = this.computeAngle(t, r, c), t.angle = a), h = C.x + (M.x - C.x) * n, f = C.y + (M.y - C.y) * n;
      }
      if (o.isNone()) {
        t.moveTo(h, f, true);
        return;
      } else o.isNoSpot() && (o = Spot2.Center);
      const u = Transform.a();
      u.Ki(), u.lt(t.scale, t.scale), u.Ns(t.angle, 0, 0);
      const d = t.naturalBounds, m = Rect2.U(0, 0, d.width, d.height), g = Point2.a();
      g.setRectSpot(m, o), u.St(g);
      let p = -g.x, y = -g.y;
      const x = d.width, S = d.height, b = Point2.Ms(l), k = isNaN(l.x), P = isNaN(l.y);
      if (k || P) {
        const C = x / 2 + Link2.eS, M = S / 2 + Link2.aF, N = c >= 45 && c <= 135, L = c >= 225 && c <= 315;
        r === 0 && (N || L) ? (b.x = P ? C : l.y, b.y = k ? M : l.x, N ? s >= 0 || isNaN(s) && n < 0.5 || k && (b.y = -M) : L && ((s >= 0 || isNaN(s) && n < 0.5) && k && (b.y = -M), P && (b.x = -C))) : (k && (s >= 0 || isNaN(s) && n < 0.5 ? b.x = C : b.x = -C), P && (b.y = -M), b.rotate(c));
      } else b.rotate(c);
      h += b.x, f += b.y, u.hm(m), p += m.x, y += m.y;
      const A = Point2.U(h + p, f + y);
      t.move(A), Point2.o(A), Point2.o(b), Point2.o(g), Rect2.o(m), Transform.o(u);
    }
    nl() {
      let t = this.fromNode;
      if (t !== null) {
        const e = t.findVisibleNode();
        if (e !== null && (t = e), t.us() || t.yh()) return false;
      }
      let i = this.toNode;
      if (i !== null) {
        const e = i.findVisibleNode();
        if (e !== null && (i = e), i.us() || i.yh()) return false;
      }
      return true;
    }
    BN(t, i, e) {
      return false;
    }
    VN() {
    }
    Oe() {
      return false;
    }
    computeAngle(t, i, e) {
      return Link2.computeAngle(i, e);
    }
    static computeAngle(t, i) {
      let e = 0;
      switch (t) {
        default:
        case 0:
          e = 0;
          break;
        case 21:
          e = i;
          break;
        case 22:
          e = i + 90;
          break;
        case 23:
          e = i - 90;
          break;
        case 24:
          e = i + 180;
          break;
        case 25:
          e = G.Yi(i), e > 90 && e < 270 && (e -= 180);
          break;
        case 26:
          e = G.Yi(i + 90), e > 90 && e < 270 && (e -= 180);
          break;
        case 27:
          e = G.Yi(i - 90), e > 90 && e < 270 && (e -= 180);
          break;
        case 28:
          if (e = G.Yi(i), e > 45 && e < 135 || e > 225 && e < 315) return 0;
          e > 90 && e < 270 && (e -= 180);
          break;
      }
      return G.Yi(e);
    }
    get fromNode() {
      return this.bo;
    }
    set fromNode(t) {
      const i = this.bo;
      if (i !== t) {
        Debug && t !== null && U.s(t, Node2, Link2, "fromNode");
        const e = this.fromPort;
        i !== null && (this.ko !== i && i.bS(this, e), this.tw(), this.invalidateLayout(2)), this.bo = t, t !== null && this.Hi(t.isVisible()), this.lr = null, this.ii();
        const s = this.diagram;
        s !== null && s.H && s.partManager.setFromNodeForLink(this, t, i);
        const n = this.fromPort, o = this.fromPortChanged;
        if (o !== null) {
          let r = true;
          s !== null && (r = s.H, s.H = true), o(this, e, n), s !== null && (s.H = r);
        }
        t !== null && (this.ko !== t && t.xS(this, n), this.iw(), this.invalidateLayout(1)), this.t("fromNode", i, t), this._d();
      }
    }
    get fromPortId() {
      return this.So;
    }
    set fromPortId(t) {
      const i = this.So;
      if (i !== t) {
        Debug && U.i(t, "string", Link2, "fromPortId");
        const e = this.fromPort;
        e !== null && this.fromNode?.Ne(e), this.tw(), this.So = t;
        const s = this.fromPort;
        s !== null && this.fromNode?.Ne(s);
        const n = this.diagram;
        if (n !== null) {
          const o = this.data, r = n.model;
          o !== null && r._a() && r.setFromPortIdForLinkData(o, t);
        }
        if (e !== s) {
          this.lr = null, this.ii();
          const o = this.fromPortChanged;
          if (o !== null) {
            let r = true;
            n !== null && (r = n.H, n.H = true), o(this, e, s), n !== null && (n.H = r);
          }
        }
        this.iw(), this.t("fromPortId", i, t);
      }
    }
    get fromPort() {
      const t = this.bo;
      if (t === null) return null;
      const i = this.So;
      return t.findPort(i);
    }
    get fromPortChanged() {
      return this.ig;
    }
    set fromPortChanged(t) {
      const i = this.ig;
      i !== t && (t !== null && U.C(t, Link2, "fromPortChanged"), this.ig = t, this.t("fromPortChanged", i, t));
    }
    get toNode() {
      return this.ko;
    }
    set toNode(t) {
      const i = this.ko;
      if (i !== t) {
        Debug && t !== null && U.s(t, Node2, Link2, "toNode");
        const e = this.toPort;
        i !== null && (this.bo !== i && i.bS(this, e), this.tw(), this.invalidateLayout(2)), this.ko = t, t !== null && this.Hi(t.isVisible()), this.lr = null, this.ii();
        const s = this.diagram;
        s !== null && s.H && s.partManager.setToNodeForLink(this, t, i);
        const n = this.toPort, o = this.toPortChanged;
        if (o !== null) {
          let r = true;
          s !== null && (r = s.H, s.H = true), o(this, e, n), s !== null && (s.H = r);
        }
        t !== null && (this.bo !== t && t.xS(this, n), this.iw(), this.invalidateLayout(1)), this.t("toNode", i, t), this._d();
      }
    }
    get toPortId() {
      return this.Po;
    }
    set toPortId(t) {
      const i = this.Po;
      if (i !== t) {
        Debug && U.i(t, "string", Link2, "toPortId");
        const e = this.toPort;
        e !== null && this.toNode?.Ne(e), this.tw(), this.Po = t;
        const s = this.toPort;
        s !== null && this.toNode?.Ne(s);
        const n = this.diagram;
        if (n !== null) {
          const o = this.data, r = n.model;
          o !== null && r._a() && r.setToPortIdForLinkData(o, t);
        }
        if (e !== s) {
          this.lr = null, this.ii();
          const o = this.toPortChanged;
          if (o !== null) {
            let r = true;
            n !== null && (r = n.H, n.H = true), o(this, e, s), n !== null && (n.H = r);
          }
        }
        this.iw(), this.t("toPortId", i, t);
      }
    }
    get toPort() {
      const t = this.ko;
      if (t === null) return null;
      const i = this.Po;
      return t.findPort(i);
    }
    get toPortChanged() {
      return this.eg;
    }
    set toPortChanged(t) {
      const i = this.eg;
      i !== t && (t !== null && U.C(t, Link2, "toPortChanged"), this.eg = t, this.t("toPortChanged", i, t));
    }
    get fromSpot() {
      return this.wt !== null ? this.wt.Oa : Spot2.Default;
    }
    set fromSpot(t) {
      const i = this.fromSpot;
      if (!i.equals(t)) {
        if (Debug && U.s(t, Spot2, Link2, "fromSpot"), t = t.T(), this._e().Oa = t, this.t("fromSpot", i, t), i.isSide() || t.isSide()) {
          const e = this.fromNode;
          e !== null && e.Ne(this.fromPort);
        }
        this.ii();
      }
    }
    get fromEndSegmentLength() {
      return this.wt !== null ? this.wt.Ba : NaN;
    }
    set fromEndSegmentLength(t) {
      const i = this.fromEndSegmentLength;
      if (i !== t) {
        if (Debug && U.i(t, "number", Link2, "fromEndSegmentLength"), t < 0 && U.G(t, ">= 0", Link2, "fromEndSegmentLength"), this._e().Ba = t, this.t("fromEndSegmentLength", i, t), this.computeSpot(true, this.fromPort).isSide()) {
          const e = this.fromNode;
          e !== null && e.Ne(this.fromPort);
        }
        this.ii();
      }
    }
    get fromShortLength() {
      return this.wt !== null ? this.wt.za : NaN;
    }
    set fromShortLength(t) {
      const i = this.fromShortLength;
      i !== t && (Debug && U.i(t, "number", Link2, "fromShortLength"), this._e().za = t, this.ie(), this.t("fromShortLength", i, t));
    }
    get toSpot() {
      return this.wt !== null ? this.wt.Ea : Spot2.Default;
    }
    set toSpot(t) {
      const i = this.toSpot;
      if (!i.equals(t)) {
        if (Debug && U.s(t, Spot2, Link2, "toSpot"), t = t.T(), this._e().Ea = t, this.t("toSpot", i, t), i.isSide() || t.isSide()) {
          const e = this.toNode;
          e !== null && e.Ne(this.toPort);
        }
        this.ii();
      }
    }
    get toEndSegmentLength() {
      return this.wt !== null ? this.wt.Va : NaN;
    }
    set toEndSegmentLength(t) {
      const i = this.toEndSegmentLength;
      if (i !== t) {
        if (Debug && U.i(t, "number", Link2, "toEndSegmentLength"), t < 0 && U.G(t, ">= 0", Link2, "toEndSegmentLength"), this._e().Va = t, this.t("toEndSegmentLength", i, t), this.computeSpot(false, this.toPort).isSide()) {
          const e = this.toNode;
          e !== null && e.Ne(this.toPort);
        }
        this.ii();
      }
    }
    get toShortLength() {
      return this.wt !== null ? this.wt.Xa : NaN;
    }
    set toShortLength(t) {
      const i = this.toShortLength;
      i !== t && (Debug && U.i(t, "number", Link2, "toShortLength"), this._e().Xa = t, this.ie(), this.t("toShortLength", i, t));
    }
    _d() {
      const t = this.fromNode, i = this.toNode;
      let e = null;
      if (t !== null ? i !== null ? e = t.findCommonContainingGroup(i) : e = t.containingGroup : i !== null ? e = i.containingGroup : e = null, this.LE(e), this.isLabeledLink) {
        const s = this.labelNodes;
        for (; s.next(); ) {
          const n = s.value;
          n.containingGroup = e;
        }
      }
    }
    LE(t) {
      const i = this.Eh;
      if (i !== t) {
        i !== null && i.yC(this), this.Eh = t, t !== null && t.wC(this);
        const e = this.containingGroupChanged;
        if (e !== null) {
          let s = true;
          const n = this.diagram;
          n !== null && (s = n.H, n.H = true), e(this, i, t), n !== null && (n.H = s);
        }
        this.Be && (this.CC === i || this.AC === i) && this.ii();
      }
    }
    Lh() {
      const t = this.containingGroup;
      t !== null && this.fromNode !== t && this.toNode !== t && t.computesBoundsIncludingLinks && super.Lh();
    }
    getOtherNode(t) {
      Debug && U.s(t, Node2, Link2, "getOtherNode:node");
      const i = this.fromNode;
      return t === i ? this.toNode : i;
    }
    getOtherPort(t) {
      Debug && U.s(t, GraphObject2, Link2, "getOtherPort:port");
      const i = this.fromPort;
      return t === i ? this.toPort : i;
    }
    get isLabeledLink() {
      return this.an === null ? false : this.an.count > 0;
    }
    get labelNodes() {
      return this.an === null ? EmptyIterator.instance : this.an.iterator;
    }
    iF(t) {
      this.an === null && (this.an = new GSet2()), this.an.add(t), this.g();
    }
    eF(t) {
      this.an !== null && (this.an.delete(t), this.g());
    }
    o0(t) {
      if (super.o0(t), this.of() && this.invalidateOtherJumpOvers(this.actualBounds), !t) {
        const i = this.bo;
        let e = null;
        i !== null && (e = this.fromPort, i.xS(this, e));
        const s = this.ko;
        let n = null;
        s !== null && (n = this.toPort, (s !== i || n !== e) && s.xS(this, n)), this.iw();
      }
    }
    r0(t) {
      if (super.r0(t), this.of() && this.invalidateOtherJumpOvers(this.actualBounds), !t) {
        const i = this.bo;
        let e = null;
        i !== null && (e = this.fromPort, i.bS(this, e));
        const s = this.ko;
        let n = null;
        s !== null && (n = this.toPort, (s !== i || n !== e) && s.bS(this, n)), this.tw();
      }
    }
    uc() {
      if (this.Be = true, this.an !== null) {
        const i = this.diagram;
        if (i !== null) {
          const s = this.an.copy().iterator;
          for (; s.next(); ) {
            const n = s.value;
            i.remove(n);
          }
        }
      }
      if (this.data !== null) {
        const i = this.diagram;
        i !== null && i.partManager.OC(this);
      }
    }
    updateRelationshipsFromData() {
      if (this.data === null) return;
      const i = this.diagram;
      i !== null && i.partManager.updateRelationshipsFromData(this);
    }
    move(t, i) {
      const e = i ? this.location : this.position;
      let s = e.x;
      isNaN(s) && (s = 0);
      let n = e.y;
      isNaN(n) && (n = 0);
      const o = t.x - s, r = t.y - n;
      if (i === true) super.move(t, false);
      else {
        const h = Point2.U(e.x + o, e.y + r);
        super.move(h, false), Point2.o(h);
      }
      this.Ar(o, r);
      const l = this.labelNodes;
      for (; l.next(); ) {
        const h = l.value, f = h.position;
        h.moveTo(f.x + o, f.y + r);
      }
    }
    get relinkableFrom() {
      return (this.Dt & 1) !== 0;
    }
    set relinkableFrom(t) {
      const i = (this.Dt & 1) !== 0;
      i !== t && (Debug && U.i(t, "boolean", Link2, "relinkableFrom"), this.Dt = this.Dt ^ 1, this.t("relinkableFrom", i, t), this.invalidateAdornments());
    }
    get relinkableTo() {
      return (this.Dt & 2) !== 0;
    }
    set relinkableTo(t) {
      const i = (this.Dt & 2) !== 0;
      i !== t && (Debug && U.i(t, "boolean", Link2, "relinkableTo"), this.Dt = this.Dt ^ 2, this.t("relinkableTo", i, t), this.invalidateAdornments());
    }
    canRelinkFrom() {
      if (!this.relinkableFrom) return false;
      const t = this.layer;
      if (t === null) return true;
      if (!t.allowRelink) return false;
      const i = t.diagram;
      return !(i !== null && !i.allowRelink);
    }
    canRelinkTo() {
      if (!this.relinkableTo) return false;
      const t = this.layer;
      if (t === null) return true;
      if (!t.allowRelink) return false;
      const i = t.diagram;
      return !(i !== null && !i.allowRelink);
    }
    get resegmentable() {
      return (this.Dt & 4) !== 0;
    }
    set resegmentable(t) {
      const i = (this.Dt & 4) !== 0;
      i !== t && (Debug && U.i(t, "boolean", Link2, "resegmentable"), this.Dt = this.Dt ^ 4, this.t("resegmentable", i, t), this.invalidateAdornments());
    }
    get isTreeLink() {
      return (this.Dt & 8) !== 0;
    }
    set isTreeLink(t) {
      const i = (this.Dt & 8) !== 0;
      i !== t && (Debug && U.i(t, "boolean", Link2, "isTreeLink"), this.Dt = this.Dt ^ 8, this.t("isTreeLink", i, t), this.fromNode !== null && this.fromNode.E0(), this.toNode !== null && this.toNode.E0());
    }
    get path() {
      const t = this.findMainElement();
      return t instanceof Shape2 ? t : null;
    }
    get routeBounds() {
      return this.updateRoute(), this.DE(this.Wc);
    }
    DE(t) {
      let i = 1 / 0, e = 1 / 0;
      const s = this.pointsCount;
      if (s === 0) return t.e(NaN, NaN, 0, 0), t;
      if (s === 1) {
        const n = this.getPoint(0);
        i = Math.min(n.x, i), e = Math.min(n.y, e), t.e(n.x, n.y, 0, 0);
      } else if (s === 2) {
        const n = this.getPoint(0), o = this.getPoint(1);
        i = Math.min(n.x, o.x), e = Math.min(n.y, o.y), t.e(n.x, n.y, 0, 0), t.unionPoint(o);
      } else if (this.computeCurve() === 9 && s >= 3 && !this.isOrthogonal) {
        let n = this.getPoint(0);
        if (i = n.x, e = n.y, t.e(i, e, 0, 0), s === 3) {
          const o = this.getPoint(1);
          i = Math.min(o.x, i), e = Math.min(o.y, e);
          const r = this.getPoint(2);
          i = Math.min(r.x, i), e = Math.min(r.y, e), G.Du(n.x, n.y, o.x, o.y, o.x, o.y, r.x, r.y, 0.5, t);
        } else for (let o = 3; o < s; o += 3) {
          const r = this.getPoint(o - 2);
          o + 3 >= s && (o = s - 1);
          const l = this.getPoint(o - 1), h = this.getPoint(o);
          G.Du(n.x, n.y, r.x, r.y, l.x, l.y, h.x, h.y, 0.5, t), i = Math.min(h.x, i), e = Math.min(h.y, e), n = h;
        }
      } else {
        const n = this.getPoint(0), o = this.getPoint(1);
        i = Math.min(n.x, o.x), e = Math.min(n.y, o.y), t.e(n.x, n.y, 0, 0), t.unionPoint(o);
        for (let r = 2; r < s; r++) {
          const l = this.getPoint(r);
          i = Math.min(l.x, i), e = Math.min(l.y, e), t.unionPoint(l);
        }
      }
      return this.SS.e(i - t.x, e - t.y), t;
    }
    get midPoint() {
      return this.ZN(new Point2());
    }
    ZN(t) {
      return this.updateRoute(), this.computeMidPoint(t);
    }
    computeMidPoint(t) {
      const i = this.pointsCount;
      if (i === 0) return t.c(Point2.xn), t;
      if (i === 1) return t.c(this.getPoint(0)), t;
      if (i === 2) {
        const f = this.getPoint(0), a = this.getPoint(1);
        return t.e((f.x + a.x) / 2, (f.y + a.y) / 2), t;
      }
      if (this.isOrthogonal && (this.computeCorner() >= 15 || this.computeCurve() === 9)) {
        this.xt.getPointAlongPath(0.5, t), t.add(this.getPoint(0));
        const f = this.xt.figures.first();
        return t.offset(-f.startX, -f.startY), t;
      }
      if (this.computeCurve() === 9) {
        if (i === 3) {
          const c = this.getPoint(0), u = this.getPoint(1), d = this.getPoint(2);
          return G.WA(c.x, c.y, u.x, u.y, u.x, u.y, d.x, d.y, t), t;
        }
        const f = (i - 1) / 3 | 0, a = (f / 2 | 0) * 3;
        if (f % 2 === 1) {
          const c = this.getPoint(a), u = this.getPoint(a + 1), d = this.getPoint(a + 2), m = this.getPoint(a + 3);
          return G.WA(c.x, c.y, u.x, u.y, d.x, d.y, m.x, m.y, t), t;
        } else return t.c(this.getPoint(a)), t;
      }
      const e = this.flattenedLengths, s = this.flattenedTotalLength;
      let n = 0, o = 0, r = 0;
      for (; n < s / 2 && o < i && (r = e[o], !(n + r > s / 2)); ) n += r, o++;
      const l = this.getPoint(o), h = this.getPoint(o + 1);
      if (Math.abs(l.x - h.x) < 1) l.y > h.y ? t.e(l.x, l.y - (s / 2 - n)) : t.e(l.x, l.y + (s / 2 - n));
      else if (Math.abs(l.y - h.y) < 1) l.x > h.x ? t.e(l.x - (s / 2 - n), l.y) : t.e(l.x + (s / 2 - n), l.y);
      else {
        const f = (s / 2 - n) / r, a = f * (h.x - l.x), c = f * (h.y - l.y);
        t.e(l.x + a, l.y + c);
      }
      return t;
    }
    get midAngle() {
      return this.updateRoute(), this.computeMidAngle();
    }
    computeMidAngle() {
      const t = this.pointsCount;
      if (t < 2) return NaN;
      if (t === 2) {
        const h = this.getPoint(0), f = this.getPoint(1);
        return h.directionPoint(f);
      }
      if (this.isOrthogonal && (this.computeCorner() >= 15 || this.computeCurve() === 9)) return this.xt.getAngleAlongPath(0.5);
      if (this.computeCurve() === 9 && t >= 4) {
        const h = (t - 1) / 3 | 0;
        let f = (h / 2 | 0) * 3;
        if (h % 2 === 1) {
          f = Math.floor(f);
          const a = this.getPoint(f), c = this.getPoint(f + 1), u = this.getPoint(f + 2), d = this.getPoint(f + 3);
          return G.QI(a.x, a.y, c.x, c.y, u.x, u.y, d.x, d.y);
        } else if (f > 0 && f + 1 < t) {
          const a = this.getPoint(f - 1), c = this.getPoint(f + 1);
          return a.directionPoint(c);
        }
      }
      const i = this.flattenedLengths, e = this.flattenedTotalLength;
      let s = 0, n = 0, o = 0;
      for (; s < e / 2 && n < t && (o = i[n], !(s + o > e / 2)); ) s += o, n++;
      const r = this.getPoint(n), l = this.getPoint(n + 1);
      if (Math.abs(r.x - l.x) < 0.5 && Math.abs(r.y - l.y) < Link2.FC) {
        if (n > 0 && n < t - 2) {
          const h = this.getPoint(n - 1), f = this.getPoint(n + 2);
          return h.x < f.x ? 0 : h.x > f.x ? 180 : h.y < f.y ? 90 : 270;
        }
      } else if (Math.abs(r.y - l.y) < 0.5 && Math.abs(r.x - l.x) < Link2.FC && n > 0 && n < t - 2) {
        const h = this.getPoint(n - 1), f = this.getPoint(n + 2);
        return h.y < f.y ? 90 : h.y > f.y ? 270 : h.x < f.x ? 0 : 180;
      }
      return r.directionPoint(l);
    }
    get flattenedLengths() {
      return this.ef !== null ? this.ef : (this.Be || this.PS(), this.FE());
    }
    get flattenedTotalLength() {
      let t = this.kS;
      if (isNaN(t)) {
        const i = this.flattenedLengths, e = i.length;
        t = 0;
        for (let s = 0; s < e; s++) t += i[s];
        this.kS = t;
      }
      return t;
    }
    FE() {
      this.ef === null ? this.ef = [] : this.ef.length = 0;
      const t = this.ef, i = this.pointsCount;
      for (let e = 0; e < i - 1; e++) {
        let s = 0;
        const n = this.getPoint(e), o = this.getPoint(e + 1);
        G.q(n.x, o.x) ? (s = o.y - n.y, s < 0 && (s = -s), t.push(s)) : G.q(n.y, o.y) ? (s = o.x - n.x, s < 0 && (s = -s), t.push(s)) : (s = Math.sqrt(n.distanceSquaredPoint(o)), t.push(s));
      }
      return t;
    }
    get points() {
      return this.Ai;
    }
    set points(t) {
      const i = this.Ai;
      if (i === t) return;
      let e = null;
      if (Array.isArray(t)) e = this.convertPointsArrayToList(t);
      else if (t instanceof List2) {
        e = t.copy();
        const n = e.iterator;
        for (; n.next(); ) n.value.S();
      } else U.n("Link.points value is not an instance of List or Array: " + t);
      if (e === null) return;
      e.S(), this.Ai = e, this.ie(), this.PS();
      const s = this.diagram;
      s !== null && (!s.sa && !s.undoManager.isUndoingRedoing && s.d1.add(this), s.animationManager.Mi && s.animationManager.RM(this, e)), this.t("points", i, e);
    }
    convertPointsArrayToList(t) {
      let i = null, e = t.length % 2 === 0;
      if (e) {
        for (let s = 0; s < t.length; s++) if (typeof t[s] != "number" || isNaN(t[s])) {
          e = false;
          break;
        }
      }
      if (e) {
        i = new List2();
        for (let s = 0; s < t.length / 2; s++) i.add(new Point2(t[s * 2], t[s * 2 + 1]).S());
      } else {
        let s = true;
        for (let n = 0; n < t.length; n++) {
          const o = t[n];
          if (!U.it(o) || typeof o.x != "number" || isNaN(o.x) || typeof o.y != "number" || isNaN(o.y)) {
            s = false;
            break;
          }
        }
        if (s) {
          i = new List2();
          for (let n = 0; n < t.length; n++) {
            const o = t[n];
            i.add(new Point2(o.x, o.y).S());
          }
        } else Debug && U.n("Link.points array must contain only an even number of numbers or objects with x and y properties, not: " + t);
      }
      return i;
    }
    get pointsCount() {
      return this.Ai.count;
    }
    getPoint(t) {
      return this.Ai.h[t];
    }
    setPoint(t, i) {
      Debug && (U.s(i, Point2, Link2, "setPoint"), i.isReal() || U.n("Link.setPoint called with a Point that does not have real numbers: " + i.toString())), Debug && this.Ye === null && U.n("Call Link.startRoute before modifying the points of the route."), this.Ai.setElt(t, i);
    }
    setPointAt(t, i, e) {
      Debug && (U.r(i, Link2, "setPointAt:x"), U.r(e, Link2, "setPointAt:y")), Debug && this.Ye === null && U.n("Call Link.startRoute before modifying the points of the route."), this.Ai.setElt(t, new Point2(i, e));
    }
    insertPoint(t, i) {
      Debug && (U.s(i, Point2, Link2, "insertPoint"), i.isReal() || U.n("Link.insertPoint called with a Point that does not have real numbers: " + i.toString())), Debug && this.Ye === null && U.n("Call Link.startRoute before modifying the points of the route."), this.Ai.insertAt(t, i);
    }
    insertPointAt(t, i, e) {
      Debug && (U.r(i, Link2, "insertPointAt:x"), U.r(e, Link2, "insertPointAt:y")), Debug && this.Ye === null && U.n("Call Link.startRoute before modifying the points of the route."), this.Ai.insertAt(t, new Point2(i, e));
    }
    addPoint(t) {
      Debug && (U.s(t, Point2, Link2, "addPoint"), t.isReal() || U.n("Link.addPoint called with a Point that does not have real numbers: " + t.toString())), Debug && this.Ye === null && U.n("Call Link.startRoute before modifying the points of the route."), this.Ai.add(t);
    }
    addPointAt(t, i) {
      Debug && (U.r(t, Link2, "insertPointAt:x"), U.r(i, Link2, "insertPointAt:y")), Debug && this.Ye === null && U.n("Call Link.startRoute before modifying the points of the route."), this.Ai.add(new Point2(t, i));
    }
    removePoint(t) {
      Debug && this.Ye === null && U.n("Call Link.startRoute before modifying the points of the route."), this.Ai.removeAt(t);
    }
    clearPoints() {
      Debug && this.Ye === null && U.n("Call Link.startRoute before modifying the points of the route."), this.Ai.clear();
    }
    Ar(t, i) {
      if (t === 0 && i === 0) return;
      if (this.pointsCount === 0) {
        this.defaultFromPoint.isReal() && this.defaultFromPoint.offset(t, i), this.defaultToPoint.isReal() && this.defaultToPoint.offset(t, i);
        return;
      }
      const e = this.Be, s = new List2(), n = this.Ai.iterator;
      for (; n.next(); ) {
        const l = n.value;
        s.add(new Point2(l.x + t, l.y + i).S());
      }
      s.S();
      const o = this.Ai;
      this.Ai = s;
      const r = this.diagram;
      isNaN(t) || isNaN(i) || r !== null && r.animationManager.Mi ? this.g() : (this.hn.e(this.hn.x + t, this.hn.y + i), this.yt.e(this.yt.x + t, this.yt.y + i), this.Cc()), e ? this.PS() : (this.defaultFromPoint.isReal() && (this.defaultFromPoint = this.getPoint(0)), this.defaultToPoint.isReal() && (this.defaultToPoint = this.getPoint(this.pointsCount - 1))), r !== null && r.animationManager.Mi && r.animationManager.RM(this, s), this.t("points", o, s);
    }
    startRoute() {
      this.Ye === null && (this.Ye = this.Ai, this.Ai = this.Ai.copy());
    }
    commitRoute() {
      if (this.Ye === null) return;
      const t = this.Ye, i = this.Ai;
      let e = 1 / 0, s = 1 / 0;
      const n = t.h, o = n.length;
      for (let c = 0; c < o; c++) {
        const u = n[c];
        e = Math.min(u.x, e), s = Math.min(u.y, s);
      }
      let r = 1 / 0, l = 1 / 0;
      const h = i.h, f = h.length;
      for (let c = 0; c < f; c++) {
        const u = h[c];
        r = Math.min(u.x, r), l = Math.min(u.y, l), u.S();
      }
      if (i.S(), f === o) for (let c = 0; c < f; c++) {
        const u = n[c], d = h[c];
        if (u.x - e !== d.x - r || u.y - s !== d.y - l) {
          this.ie();
          break;
        }
      }
      else this.ie();
      this.Ye = null;
      const a = this.diagram;
      a !== null && a.animationManager.Mi && a.animationManager.RM(this, i), this.PS(), this.t("points", t, i);
    }
    rollbackRoute() {
      this.Ye !== null && (this.Ai = this.Ye, this.Ye = null);
    }
    VR() {
      this.Br !== null && (this.points = this.Br, this.Br = null);
    }
    PS() {
      if (this.Ai.count === 0) {
        this.Be = false;
        return;
      }
      this.Be = true, this.ef = null, this.kS = NaN, this.defaultFromPoint = this.getPoint(0), this.defaultToPoint = this.getPoint(this.pointsCount - 1), this.MS(false);
    }
    invalidateRoute() {
      this.ii();
    }
    ii() {
      if (this.suspendsRouting) return;
      const t = this.path;
      if (t === null) return;
      const i = this.diagram;
      if (i) {
        if (i.d1.has(this) || i.undoManager.isUndoingRedoing) return;
        const e = i.animationManager;
        if (e.isTicking && !e.isAnimating) return;
        this.Br !== null && !e.isTicking && (this.Br = null);
      }
      this.Be = false, this.g(), t.g();
    }
    get Be() {
      return (this.Dt & 16) !== 0;
    }
    set Be(t) {
      (this.Dt & 16) !== 0 !== t && (this.Dt = this.Dt ^ 16);
    }
    get suspendsRouting() {
      return (this.Dt & 32) !== 0;
    }
    set suspendsRouting(t) {
      (this.Dt & 32) !== 0 !== t && (this.Dt = this.Dt ^ 32);
    }
    get ew() {
      return (this.Dt & 64) !== 0;
    }
    set ew(t) {
      (this.Dt & 64) !== 0 !== t && (this.Dt = this.Dt ^ 64);
    }
    get EC() {
      return (this.Dt & 512) !== 0;
    }
    set EC(t) {
      (this.Dt & 512) !== 0 !== t && (this.Dt = this.Dt ^ 512);
    }
    get defaultFromPoint() {
      return this.MC;
    }
    set defaultFromPoint(t) {
      this.MC = t && t.isReal() ? t.copy() : Point2.xn;
    }
    get defaultToPoint() {
      return this.NC;
    }
    set defaultToPoint(t) {
      this.NC = t && t.isReal() ? t.copy() : Point2.xn;
    }
    updateRoute() {
      if (this.Be || this.ew) return;
      let t = true;
      try {
        this.ew = true, this.startRoute(), t = this.computePoints();
      } catch {
        this.ew = false, this.rollbackRoute();
      } finally {
        this.ew = false, t ? this.commitRoute() : this.rollbackRoute();
      }
    }
    computePoints() {
      const t = this.diagram;
      if (t === null) return false;
      let i = this.fromNode, e = null;
      if (i === null ? (Link2.sf || (Link2.sf = new Node2(), Link2.sf.desiredSize = Size2.ia, Link2.sf.ensureBounds()), this.defaultFromPoint.isReal() && (Link2.sf.location = this.defaultFromPoint, Link2.sf.ensureBounds(), i = Link2.sf, e = Link2.sf)) : e = this.fromPort, e !== null && !i.isVisible()) {
        const m = i.findVisibleNode();
        m !== null && m !== i ? (i = m, e = m.port) : i = m;
      }
      if (this.CC = i, i === null || !i.location.isReal() || e === null || (e = i.findVisiblePort(e), e === null)) return false;
      let s = this.toNode, n = null;
      if (s === null ? (Link2.nf || (Link2.nf = new Node2(), Link2.nf.desiredSize = Size2.ia, Link2.nf.ensureBounds()), this.defaultToPoint.isReal() && (Link2.nf.location = this.defaultToPoint, Link2.nf.ensureBounds(), s = Link2.nf, n = Link2.nf)) : n = this.toPort, n !== null && !s.isVisible()) {
        const m = s.findVisibleNode();
        m !== null && m !== s ? (s = m, n = m.port) : s = m;
      }
      if (this.AC = s, s === null || !s.location.isReal() || n === null || (n = s.findVisiblePort(n), n === null)) return false;
      const o = this.pointsCount, r = this.computeSpot(true, e), l = this.computeSpot(false, n), h = this.rf(r), f = this.rf(l), a = e === n && e !== null, c = this.isOrthogonal;
      let u = this.curve === 9;
      a && !c ? (u = true, this.lr = true) : this.lr = false;
      const d = this.computeAdjusting() === 0 || a;
      if (!c && !a && h && f) {
        let m = false;
        if (!d && o >= 3) {
          let g = this.getLinkPoint(i, e, r, true, false, s, n), p = this.getLinkPoint(s, n, l, false, false, i, e);
          m = this.adjustPoints(0, g, o - 1, p), m && (g = this.getLinkPoint(i, e, r, true, false, s, n), p = this.getLinkPoint(s, n, l, false, false, i, e), this.adjustPoints(0, g, o - 1, p));
        }
        m || (this.clearPoints(), u ? this.IE(i, e, r, s, n, l) : this.RE(i, e, r, s, n, l));
      } else {
        const m = a ? this.computeCurviness() : 0;
        d && (c && this.isAvoiding || a) && this.clearPoints();
        const g = this.getLinkPoint(i, e, r, true, c, s, n), p = this.getLinkPoint(s, n, l, false, c, i, e);
        let y = 0, x = 0, S = 0;
        if (c || !h || a) {
          S = this.getLinkDirection(i, e, g, r, true, c, s, n);
          let M = this.NS(i, e, r, true, S);
          if (a && (h || r.equals(l) || !c && r.x + l.x === 1 && r.y + l.y === 1) && (S -= c ? 90 : Link2.uF, m < 0 && (S -= 180)), S = G.Yi(S), a && (M += Math.abs(m) * (c ? 1 : 2)), S === 0 ? y = M : S === 90 ? x = M : S === 180 ? y = -M : S === 270 ? x = -M : (y = M * Math.cos(S * Math.PI / 180), x = M * Math.sin(S * Math.PI / 180)), r.isNoSpot() && a) {
            const N = e.getDocumentPoint(Spot2.Center, Point2.a()), L = Point2.U(N.x + y * Link2.jc, N.y + x * Link2.jc);
            this.getLinkPointFromPoint(i, e, N, L, true, g), Point2.o(N), Point2.o(L);
          }
        }
        let b = 0, k = 0, P = 0;
        if (c || !f || a) {
          P = this.getLinkDirection(s, n, p, l, false, c, i, e);
          let M = this.NS(s, n, l, false, P);
          if (a && (f || r.equals(l) || !c && r.x + l.x === 1 && r.y + l.y === 1) && (P += c ? 0 : Link2.dF, m < 0 && (P += 180)), P = G.Yi(P), a && (M += Math.abs(m) * (c ? 1 : 2)), P === 0 ? b = M : P === 90 ? k = M : P === 180 ? b = -M : P === 270 ? k = -M : (b = M * Math.cos(P * Math.PI / 180), k = M * Math.sin(P * Math.PI / 180)), l.isNoSpot() && a) {
            const N = n.getDocumentPoint(Spot2.Center, Point2.a()), L = Point2.U(N.x + b * Link2.jc, N.y + k * Link2.jc);
            this.getLinkPointFromPoint(s, n, N, L, false, p), Point2.o(N), Point2.o(L);
          }
        }
        let A = g;
        (c || !h || a) && (A = new Point2(g.x + y, g.y + x));
        let C = p;
        (c || !f || a) && (C = new Point2(p.x + b, p.y + k)), !d && !c && h && o > 3 && this.adjustPoints(0, g, o - 2, C) ? this.setPoint(o - 1, p) : !d && !c && f && o > 3 && this.adjustPoints(1, A, o - 1, p) ? this.setPoint(0, g) : !d && (c ? o >= 6 : o > 4) && this.adjustPoints(1, A, o - 2, C) ? (this.setPoint(0, g), this.setPoint(o - 1, p)) : (this.clearPoints(), this.addPoint(g), (c || !h || a) && this.addPoint(A), c && this.addOrthoPoints(A, S, C, P, i, s), (c || !f || a) && this.addPoint(C), this.addPoint(p));
      }
      return t.addInvalidRoute(this), true;
    }
    BC(t, i) {
      return Math.abs(i.x - t.x) > Math.abs(i.y - t.y) ? (i.x >= t.x ? i.x = t.x + 9e9 : i.x = t.x - 9e9, i.y = t.y) : (i.y >= t.y ? i.y = t.y + 9e9 : i.y = t.y - 9e9, i.x = t.x), i;
    }
    getLinkPointFromPoint(t, i, e, s, n, o) {
      if (o === void 0 && (o = new Point2()), t === null || i === null) return o.c(e), o;
      if (!t.isVisible()) {
        const u = t.findVisibleNode();
        u !== null && u !== t && (t = u, i = t.port);
      }
      let r = 0, l = 0, h = 0, f = 0, a = null, c = i.panel;
      if (c !== null && !c.Dn() && (c = c.panel), c === null) r = s.x, l = s.y, h = e.x, f = e.y;
      else {
        a = c._s;
        const u = 1 / (a.m11 * a.m22 - a.m12 * a.m21), d = a.m22 * u, m = -a.m12 * u, g = -a.m21 * u, p = a.m11 * u, y = u * (a.m21 * a.dy - a.m22 * a.dx), x = u * (a.m12 * a.dx - a.m11 * a.dy);
        r = s.x * d + s.y * g + y, l = s.x * m + s.y * p + x, h = e.x * d + e.y * g + y, f = e.x * m + e.y * p + x;
      }
      return i.bc(r, l, h, f, o), a !== null && o.E(a), o;
    }
    OE(t, i) {
      const e = t.kd;
      return e !== null ? e.xF(i) : null;
    }
    CS(t) {
      if (t === null) return null;
      let i = t.kd;
      return i === null && (i = new Knot(t.part, t), t.kd = i), i.xF(this);
    }
    getLinkPoint(t, i, e, s, n, o, r, l) {
      if (l === void 0 && (l = new Point2()), e.isSpot() && !this.rf(e)) return i.getDocumentPoint(e, l), l;
      if (e.isSide()) {
        const a = this.CS(i);
        if (a !== null) {
          const c = a.lf;
          if (l.c(c), n && this.routing === 7) {
            const u = this.CS(r);
            if (u !== null && a.Jc < u.Jc) {
              const d = Point2.a(), m = Point2.a(), g = Rect2.a();
              i.getDocumentPoint(Spot2.TopLeft, d), i.getDocumentPoint(Spot2.BottomRight, m);
              const p = d.x, y = d.y, x = m.x, S = m.y;
              g.x = Math.min(p, x), g.y = Math.min(y, S), g.width = Math.abs(p - x), g.height = Math.abs(y - S);
              const b = this.computeSpot(!s, r), k = this.getLinkPoint(o, r, b, !s, n, t, i, m);
              (e.includesSide(Spot2.LeftSide) || e.includesSide(Spot2.RightSide)) && k.y >= g.y && k.y <= g.y + g.height ? l.y = k.y : (e.includesSide(Spot2.TopSide) || e.includesSide(Spot2.BottomSide)) && k.x >= g.x && k.x <= g.x + g.width && (l.x = k.x), Rect2.o(g), Point2.o(d), Point2.o(m);
            }
          }
          return l;
        }
      }
      const h = i.getDocumentPoint(this.lg(e, s), Point2.a()), f = Point2.a();
      if (this.pointsCount > (n ? 6 : 2)) f.c(s ? this.getPoint(1) : this.getPoint(this.pointsCount - 2)), n && this.BC(h, f);
      else if (t?.isMemberOf(o) || o?.isMemberOf(t)) {
        const a = i.getDocumentBounds(Rect2.a()), c = r.getDocumentBounds(Rect2.a());
        a.isReal() && c.isReal() ? c.containsRect(a) ? (f.c(h), this.VC(c, h.x, h.y, 0, this.computeSpot(r === this.toPort, r), f)) : a.containsRect(c) ? (r.getDocumentPoint(Spot2.Center, f), this.VC(a, f.x, f.y, 0, this.computeSpot(i === this.toPort, i), f)) : this.zC(r, h, s, n, f) : this.zC(r, h, s, n, f), Rect2.o(a), Rect2.o(c);
      } else this.zC(r, h, s, n, f);
      return this.getLinkPointFromPoint(t, i, h, f, s, l), Point2.o(f), Point2.o(h), l;
    }
    zC(t, i, e, s, n) {
      const o = this.computeSpot(!e, t);
      t.getDocumentPoint(this.lg(o, !e), n), s && this.BC(i, n);
    }
    getLinkDirection(t, i, e, s, n, o, r, l) {
      let h = this.EE(t, i, e, s, n, o, r, l);
      if (t && r) {
        const a = Rect2.a(), c = Rect2.a();
        if (s.isNone() && t.isMemberOf(r) && i && l) {
          if (i.getDocumentBounds(a), l.getDocumentBounds(c), a.isReal() && c.isReal() && c.containsRect(a)) {
            const u = this.computeSpot(l === this.toPort, l);
            u.equals(Spot2.Left) || u.equals(Spot2.LeftSide) ? h = 180 : u.equals(Spot2.Right) || u.equals(Spot2.RightSide) ? h = 0 : u.equals(Spot2.Top) || u.equals(Spot2.TopSide) ? h = 270 : u.equals(Spot2.Bottom) || u.equals(Spot2.BottomSide) ? h = 90 : h = G.Yi(h + 180);
          }
        } else r?.isMemberOf(t) && i && l && (i.getDocumentBounds(a), l.getDocumentBounds(c), a.isReal() && c.isReal() && a.containsRect(c) && (h = G.Yi(h + 180)));
        Rect2.o(a), Rect2.o(c);
      }
      if (this.rf(s) || i === null) return h;
      const f = i.getDocumentAngle();
      return f === 0 ? h : (45 <= f && f < 135 ? h += 90 : 135 <= f && f < 225 ? h += 180 : 225 <= f && f < 315 && (h += 270), G.Yi(h));
    }
    EE(t, i, e, s, n, o, r, l) {
      if (s.isSpot()) return G.nx(null, s.x, s.y);
      if (s.isSide()) {
        const c = this.CS(i);
        if (c !== null) switch (c.de) {
          case 1:
            return 270;
          case 8:
            return 90;
          case 2:
            return 180;
          default:
            return 0;
        }
        else return s.includesSide(Spot2.TopSide) ? 270 : s.includesSide(Spot2.BottomSide) ? 90 : s.includesSide(Spot2.LeftSide) ? 180 : 0;
      }
      if (i === null || l === null) return 0;
      const h = i.getDocumentPoint(Spot2.Center, Point2.a()), f = Point2.a();
      this.pointsCount > (o ? 6 : 2) ? o ? (f.c(n ? this.getPoint(1) : this.getPoint(this.pointsCount - 2)), this.BC(h, f)) : f.c(e) : l.getDocumentPoint(Spot2.Center, f);
      let a = 0;
      return Math.abs(f.x - h.x) > Math.abs(f.y - h.y) ? f.x >= h.x ? a = 0 : a = 180 : f.y >= h.y ? a = 90 : a = 270, Point2.o(f), Point2.o(h), a;
    }
    computeEndSegmentLength(t, i, e, s) {
      return this.NS(t, i, e, s, NaN);
    }
    NS(t, i, e, s, n) {
      if (i !== null && e.isSide()) {
        const r = this.CS(i);
        if (r !== null) return r.AS;
      }
      let o = NaN;
      if (s ? o = this.fromEndSegmentLength : o = this.toEndSegmentLength, i !== null && isNaN(o)) if (n === void 0 && (n = NaN), Link2.IC > 0 && this.computeCurve() === 9 && !isNaN(n) && e.isSpot()) {
        const r = this.getOtherPort(i);
        if (r) {
          const l = Point2.a(), h = Point2.a(), f = i.getDocumentPoint(e, l), a = r.getDocumentPoint(e.opposite(), h), c = n >= 315 || n <= 45 || n >= 135 && n <= 225;
          let u = Math.abs(c ? f.x - a.x : f.y - a.y) / Link2.IC;
          return u = Math.max(u, Link2.RC), Point2.o(l), Point2.o(h), u;
        }
      } else s ? o = i.fromEndSegmentLength : o = i.toEndSegmentLength;
      return isNaN(o) && (o = Link2.RC), o;
    }
    computeSpot(t, i) {
      return i === void 0 && (i = null), t ? this.BE(i || this.fromPort) : this.VE(i || this.toPort);
    }
    BE(t) {
      if (t === null) return Spot2.Center;
      let i = this.fromSpot;
      return i.isDefault() && (i = t.fromSpot), i === Spot2.Default ? Spot2.None : i;
    }
    VE(t) {
      if (t === null) return Spot2.Center;
      let i = this.toSpot;
      return i.isDefault() && (i = t.toSpot), i === Spot2.Default ? Spot2.None : i;
    }
    rf(t) {
      return t === Spot2.None || t.x === 0.5 && t.y === 0.5;
    }
    lg(t, i) {
      return t.x === 0.5 && t.y === 0.5 ? t : Spot2.Center;
    }
    computeOtherPoint(t, i) {
      if (this.computeAdjusting() !== 0 && this.pointsCount > 4) return this.computeMidPoint(new Point2());
      {
        const e = this.OE(i, this);
        if (e !== null) return e.lf;
        if (t instanceof Group2) {
          let s = this.fromNode, n = this.fromPort;
          n === i && (s = this.toNode, n = this.toPort);
          const o = Rect2.a(), r = Rect2.a();
          if (n && s?.isMemberOf(t)) {
            const l = this.computeSpot(n === i, i);
            if (i.getDocumentBounds(o), n.getDocumentBounds(r), o.isReal() && r.isReal() && o.containsRect(r)) {
              const h = n.getDocumentPoint(Spot2.Center);
              return this.VC(o, h.x, h.y, 0, l, h), Rect2.o(o), Rect2.o(r), h;
            }
          }
          Rect2.o(o), Rect2.o(r);
        }
        return i.getDocumentPoint(Spot2.Center);
      }
    }
    computeShortLength(t) {
      if (t) {
        let i = this.fromShortLength;
        if (isNaN(i)) {
          const e = this.fromPort;
          e !== null && (i = e.fromShortLength);
        }
        return isNaN(i) ? 0 : i;
      } else {
        let i = this.toShortLength;
        if (isNaN(i)) {
          const e = this.toPort;
          e !== null && (i = e.toShortLength);
        }
        return isNaN(i) ? 0 : i;
      }
    }
    i0(t, i, e, s, n, o) {
      if (this.pickable === false) return false;
      i === void 0 && (i = null), e === void 0 && (e = null);
      let r;
      if (o === void 0 ? (r = Transform.a(), r.Ki()) : r = o, r.Af(this.E), this.containedInRect(t, r)) return this.iC(i, e, n), o === void 0 && Transform.o(r), true;
      if (this.intersectsRect(t, r)) {
        let l = false;
        if (!this.Rc) {
          const h = this.O.h, f = h.length;
          for (let a = f; a--; ) {
            const c = h[a];
            if (!c.visible && c !== this.locationObject) continue;
            const u = c.actualBounds, d = this.naturalBounds;
            if (u.x > d.width || u.y > d.height || u.x + u.width < 0 || u.y + u.height < 0) continue;
            const m = c, g = Transform.a();
            if (g.set(r), m instanceof Panel2 ? l = m.i0(t, i, e, s, n, g) : this.path === m ? m instanceof Shape2 && (l = m.aE(t, s, g)) : l = m.tD(t, s, g), l) {
              let p = m;
              i !== null && (p = i(m)), p && (e === null || e(p)) && n.add(p);
            }
            Transform.o(g);
          }
        }
        return o === void 0 && Transform.o(r), l || this.background !== null;
      }
      return o === void 0 && Transform.o(r), false;
    }
    get isOrthogonal() {
      return (this.tf & 2) === 2;
    }
    static DC(t) {
      return (t & 2) === 2;
    }
    get isAvoiding() {
      return (this.tf & 4) === 4;
    }
    computeCurve() {
      if (this.lr === null) {
        const t = this.fromPort, i = t !== null && t === this.toPort, e = this.isOrthogonal;
        this.lr = i && !e;
      }
      return this.lr ? 9 : this.curve;
    }
    computeCorner() {
      if (this.curve === 9) return 0;
      let t = this.corner;
      return (isNaN(t) || t < 0) && (t = Link2.gF), t;
    }
    findMidLabel() {
      const t = this.path, i = this.O.h, e = i.length;
      for (let n = 0; n < e; n++) {
        const o = i[n];
        if (!(o === t || o.isPanelMain) && (o.segmentIndex === -1 / 0 || isNaN(o.segmentIndex))) return o;
      }
      const s = this.labelNodes;
      for (; s.next(); ) {
        const n = s.value;
        if (n.segmentIndex === -1 / 0 || isNaN(n.segmentIndex)) return n;
      }
      return null;
    }
    computeSpacing() {
      if (!this.isVisible()) return 0;
      let t = Link2.mF;
      t = Math.max(t, this.computeThickness());
      const i = this.fromPort, e = this.toPort;
      if (i !== null && e !== null) {
        const s = this.findMidLabel();
        if (s !== null) {
          const n = s.naturalBounds, o = s.margin, r = isNaN(n.width) ? Link2.pF : n.width * s.scale + o.left + o.right, l = isNaN(n.height) ? Link2.yF : n.height * s.scale + o.top + o.bottom, h = s.segmentOrientation;
          if (h === 21 || h === 25 || h === 24) t = Math.max(t, l);
          else if (h === 23 || h === 27 || h === 22 || h === 26) t = Math.max(t, r);
          else {
            const a = i.getDocumentPoint(Spot2.Center).directionPoint(e.getDocumentPoint(Spot2.Center)) / 180 * Math.PI;
            t = Math.max(t, Math.abs(Math.sin(a) * r) + Math.abs(Math.cos(a) * l) + 1);
          }
          this.curve === 9 && (t *= Link2.fF);
        }
      }
      return t;
    }
    arrangeBundledLinks(t, i) {
      if (i) for (let e = 0; e < t.length; e++) {
        const s = t[e];
        s.computeAdjusting() === 0 && s.ii();
      }
    }
    computeCurviness() {
      let t = this.curviness;
      if (isNaN(t)) {
        t = Link2.hF;
        const i = this.hr;
        if (i !== null) {
          const e = U.ft();
          let s = 0;
          const n = i.fn;
          for (let r = 0; r < n.length; r++) {
            const h = n[r].computeSpacing();
            e.push(h), s += h;
          }
          let o = -s / 2;
          for (let r = 0; r < n.length; r++) {
            if (n[r] === this) {
              t = o + e[r] / 2;
              break;
            }
            o += e[r];
          }
          i.Hy === this.fromNode && (t = -t), U.et(e);
        }
      }
      return t;
    }
    computeThickness() {
      if (!this.isVisible()) return 0;
      const t = this.path;
      return t !== null ? Math.max(t.strokeWidth, 1) : 1;
    }
    hasCurviness() {
      return !isNaN(this.curviness) || this.hr !== null;
    }
    RE(t, i, e, s, n, o) {
      let r = this.getLinkPoint(t, i, e, true, false, s, n), l = this.getLinkPoint(s, n, o, false, false, t, i);
      if (this.bF(t, i, e, r, s, n, o, l), this.addPoint(r), this.addPoint(l), this.hasCurviness()) {
        const h = l.x - r.x, f = l.y - r.y, a = this.computeCurviness(), c = a, u = r.x + h / 2, d = r.y + f / 2;
        let m = u, g = d;
        if (G.p(f, 0)) h > 0 ? g -= c : g += c;
        else {
          const p = -h / f;
          let y = Math.sqrt(c * c / (p * p + 1));
          a < 0 && (y = -y), m = (f < 0 ? -1 : 1) * y + u, g = p * (m - u) + d;
        }
        this.insertPointAt(1, m, g);
      }
    }
    bF(t, i, e, s, n, o, r, l) {
      const h = o.getDocumentBounds(Rect2.a()), f = i.getDocumentBounds(Rect2.a());
      if (h.intersectsRect(f) && !h.containsRect(f) && !f.containsRect(h)) {
        const a = Point2.a();
        i.getDocumentPoint(this.lg(e, true), a);
        const c = Point2.a();
        o.getDocumentPoint(this.lg(r, false), c);
        const u = f.width * f.height, d = h.width * h.height;
        u > d ? (s.c(a), this.getLinkPointFromPoint(n, o, c, a, false, c), l.c(c)) : u < d ? (this.getLinkPointFromPoint(t, i, a, c, true, a), s.c(a), l.c(c)) : (s.c(a), l.c(c)), Point2.o(a), Point2.o(c);
      } else if (h.containsPoint(s)) {
        const a = Point2.a();
        i.getDocumentPoint(this.lg(e, true), a), l.c(a), this.XC(h, a.x, a.y, Link2.jc, l), this.getLinkPointFromPoint(n, o, h.containsPoint(a) ? a : s, l, false, l), this.getLinkPointFromPoint(t, i, a, l, true, s), Point2.o(a);
      } else if (f.containsPoint(l)) {
        const a = Point2.a();
        o.getDocumentPoint(this.lg(r, false), a), s.c(a), this.XC(f, a.x, a.y, Link2.jc, s), this.getLinkPointFromPoint(t, i, f.containsPoint(a) ? a : l, s, true, s), this.getLinkPointFromPoint(n, o, a, s, false, l), Point2.o(a);
      }
      Rect2.o(f), Rect2.o(h);
    }
    VC(t, i, e, s, n, o) {
      let r = -1;
      return n.equals(Spot2.Left) || n.equals(Spot2.LeftSide) ? r = 180 : n.equals(Spot2.Right) || n.equals(Spot2.RightSide) ? r = 0 : n.equals(Spot2.Top) || n.equals(Spot2.TopSide) ? r = 270 : (n.equals(Spot2.Bottom) || n.equals(Spot2.BottomSide)) && (r = 90), r === -1 ? this.XC(t, i, e, 0, o) : this.SF(t, i, e, 0, r, o);
    }
    XC(t, i, e, s, n) {
      const o = G.nx(t, i, e);
      return this.SF(t, i, e, s, o, n);
    }
    SF(t, i, e, s, n, o) {
      return n === 0 ? o.x = t.right + s : n === 90 ? o.y = t.bottom + s : n === 180 ? o.x = t.x - s : n === 270 ? o.y = t.y - s : n === 45 ? (o.x = t.right + s, o.y = t.bottom + s) : n === 135 ? (o.x = t.x - s, o.y = t.bottom + s) : n === 225 ? (o.x = t.x - s, o.y = t.y - s) : n === 315 && (o.x = t.right + s, o.y = t.y - s), o;
    }
    IE(t, i, e, s, n, o) {
      let r = this.getLinkPoint(t, i, e, true, false, s, n), l = this.getLinkPoint(s, n, o, false, false, t, i);
      this.bF(t, i, e, r, s, n, o, l), this.addPoint(r), this.addPoint(l);
      const h = l.x - r.x, f = l.y - r.y, a = this.computeCurviness();
      let c = 0, u = 0, d = r.x + h / 3, m = r.y + f / 3, g = d, p = m;
      G.p(f, 0) ? h > 0 ? p -= a : p += a : (c = -h / f, u = Math.sqrt(a * a / (c * c + 1)), a < 0 && (u = -u), g = (f < 0 ? -1 : 1) * u + d, p = c * (g - d) + m), d = r.x + 2 * h / 3, m = r.y + 2 * f / 3;
      let y = d, x = m;
      G.p(f, 0) ? h > 0 ? x -= a : x += a : (y = (f < 0 ? -1 : 1) * u + d, x = c * (y - d) + m), this.insertPointAt(1, g, p), this.insertPointAt(2, y, x), this.setPoint(0, this.getLinkPoint(t, i, e, true, false, s, n)), this.setPoint(3, this.getLinkPoint(s, n, o, false, false, t, i));
    }
    adjustPoints(t, i, e, s) {
      let n = this.computeAdjusting();
      if (this.isOrthogonal) {
        if (n === 18) return false;
        n === 19 && (n = 17);
      }
      switch (n) {
        case 18:
          return this.zE(t, i, e, s);
        case 19:
          return this.XE(t, i, e, s);
        case 17:
          return this.YE(t, i, e, s);
        default:
          return false;
      }
    }
    zE(t, i, e, s) {
      const n = this.getPoint(t), o = this.getPoint(e);
      if (n.equalsApprox(i) && o.equalsApprox(s)) return true;
      const r = n.x, l = n.y, h = o.x, f = o.y;
      let a = h - r, c = f - l;
      const u = Math.sqrt(a * a + c * c);
      if (G.q(u, 0)) return true;
      let d = 0;
      G.q(a, 0) ? c < 0 ? d = -Math.PI / 2 : d = Math.PI / 2 : (d = Math.atan(c / Math.abs(a)), a < 0 && (d = Math.PI - d));
      const m = i.x, g = i.y, p = s.x, y = s.y, x = p - m, S = y - g, b = Math.sqrt(x * x + S * S);
      let k = 0;
      G.q(x, 0) ? S < 0 ? k = -Math.PI / 2 : k = Math.PI / 2 : (k = Math.atan(S / Math.abs(x)), x < 0 && (k = Math.PI - k));
      const P = b / u, A = k - d;
      this.setPoint(t, i);
      for (let C = t + 1; C < e; C++) {
        const M = this.getPoint(C);
        a = M.x - r, c = M.y - l;
        const N = Math.sqrt(a * a + c * c);
        if (G.q(N, 0)) continue;
        let L = 0;
        G.q(a, 0) ? c < 0 ? L = -Math.PI / 2 : L = Math.PI / 2 : (L = Math.atan(c / Math.abs(a)), a < 0 && (L = Math.PI - L));
        const T = L + A, D = N * P, F = m + D * Math.cos(T), R = g + D * Math.sin(T);
        this.setPointAt(C, F, R);
      }
      return this.setPoint(e, s), true;
    }
    XE(t, i, e, s) {
      const n = this.getPoint(t), o = this.getPoint(e);
      if (n.equalsApprox(i) && o.equalsApprox(s)) return true;
      const r = n.x, l = n.y, h = o.x, f = o.y, a = (h - r) ** 2 + (f - l) ** 2, c = i.x, u = i.y, d = s.x, m = s.y;
      let g = 0, p = 1;
      d - c !== 0 ? (g = (m - u) / (d - c), p = Math.sqrt(1 + 1 / (g * g))) : g = 9e9, this.setPoint(t, i);
      for (let y = t + 1; y < e; y++) {
        const x = this.getPoint(y), S = x.x, b = x.y;
        let k = 0.5;
        a !== 0 && (k = ((r - S) * (r - h) + (l - b) * (l - f)) / a);
        const P = r + k * (h - r), A = l + k * (f - l);
        let C = Math.sqrt((S - P) ** 2 + (b - A) ** 2);
        b < g * (S - P) + A && (C = -C), g > 0 && (C = -C);
        const M = c + k * (d - c), N = u + k * (m - u);
        if (g !== 0) {
          const L = M + C / p, T = N - (L - M) / g;
          this.setPointAt(y, L, T);
        } else this.setPointAt(y, M, N + C);
      }
      return this.setPoint(e, s), true;
    }
    YE(t, i, e, s) {
      if (this.isOrthogonal) {
        let n = this.getPoint(t), o = this.getPoint(t + 1), r = this.getPoint(t + 2), l = o.x, h = o.y;
        const f = l, a = h;
        G.p(n.y, o.y) ? G.p(o.x, r.x) ? h = i.y : G.p(o.y, r.y) && (l = i.x) : G.p(n.x, o.x) && (G.p(o.y, r.y) ? l = i.x : G.p(o.x, r.x) && (h = i.y)), this.setPointAt(t + 1, l, h), n = this.getPoint(e), o = this.getPoint(e - 1), r = this.getPoint(e - 2);
        let c = o.x, u = o.y;
        const d = c, m = u;
        if (G.p(n.y, o.y) ? G.p(o.x, r.x) ? u = s.y : G.p(o.y, r.y) && (c = s.x) : G.p(n.x, o.x) && (G.p(o.y, r.y) ? c = s.x : G.p(o.x, r.x) && (u = s.y)), this.setPointAt(e - 1, c, u), this.SL()) return this.setPointAt(t + 1, f, a), this.setPointAt(e - 1, d, m), false;
      }
      return this.setPoint(t, i), this.setPoint(e, s), true;
    }
    addOrthoPoints(t, i, e, s, n, o) {
      i = G.Yi(i), s = G.Yi(s);
      const a = s;
      i >= 315 || i < 45 ? i = 0 : 45 <= i && i < 135 ? i = 90 : 135 <= i && i < 225 ? i = 180 : i = 270, s >= 315 || s < 45 ? s = 0 : 45 <= s && s < 135 ? s = 90 : 135 <= s && s < 225 ? s = 180 : s = 270;
      const c = t, u = e, d = Rect2.Ms(n.actualBounds), m = Rect2.Ms(o.actualBounds);
      d.inflate(Link2.Vh, Link2.Vh), m.inflate(Link2.Vh, Link2.Vh), d.unionPoint(t), m.unionPoint(e);
      const g = Point2.a(), p = Point2.a();
      i === 0 ? u.x > c.x || s === 270 && u.y < c.y && m.right > c.x || s === 90 && u.y > c.y && m.right > c.x ? (g.e(u.x, c.y), p.e(u.x, (c.y + u.y) / 2), s === 180 ? (g.x = this.computeMidOrthoPosition(c.x, c.y, u.x, u.y, false), p.x = g.x, p.y = u.y) : s === 270 && u.y < c.y || s === 90 && u.y > c.y ? (c.x < m.left ? g.x = this.computeMidOrthoPosition(c.x, c.y, m.left, u.y, false) : c.x < m.right && (s === 270 && c.y < m.top || s === 90 && c.y > m.bottom) ? g.x = this.computeMidOrthoPosition(c.x, c.y, u.x, u.y, false) : g.x = m.right, p.x = g.x, p.y = u.y) : s === 0 && c.x < m.left && c.y > m.top && c.y < m.bottom && (g.x = c.x, c.y < u.y ? g.y = Math.min(u.y, m.top) : g.y = Math.max(u.y, m.bottom), p.y = g.y)) : (g.e(c.x, u.y), p.e((c.x + u.x) / 2, u.y), (s === 180 || s === 90 && u.y < d.top || s === 270 && u.y > d.bottom) && (s === 180 && (m.containsPoint(c) || d.containsPoint(u)) ? g.y = this.computeMidOrthoPosition(c.x, c.y, u.x, u.y, true) : u.y < c.y && (s === 180 || s === 90) ? g.y = this.computeMidOrthoPosition(c.x, d.top, u.x, Math.min(u.y, m.bottom), true) : u.y > c.y && (s === 180 || s === 270) && (g.y = this.computeMidOrthoPosition(c.x, d.bottom, u.x, Math.max(u.y, m.top), true)), p.x = u.x, p.y = g.y), g.y > d.top && g.y < d.bottom && (u.x >= d.left && u.x <= c.x || c.x <= m.right && c.x >= u.x ? (s === 90 || s === 270) && (g.e(Math.max((c.x + u.x) / 2, c.x), c.y), p.e(g.x, u.y)) : (s === 270 || (s === 0 || s === 180) && u.y < c.y ? g.y = Math.min(u.y, s === 0 ? d.top : Math.min(d.top, m.top)) : g.y = Math.max(u.y, s === 0 ? d.bottom : Math.max(d.bottom, m.bottom)), p.x = u.x, p.y = g.y))) : i === 180 ? u.x < c.x || s === 270 && u.y < c.y && m.left < c.x || s === 90 && u.y > c.y && m.left < c.x ? (g.e(u.x, c.y), p.e(u.x, (c.y + u.y) / 2), s === 0 ? (g.x = this.computeMidOrthoPosition(c.x, c.y, u.x, u.y, false), p.x = g.x, p.y = u.y) : s === 270 && u.y < c.y || s === 90 && u.y > c.y ? (c.x > m.right ? g.x = this.computeMidOrthoPosition(c.x, c.y, m.right, u.y, false) : c.x > m.left && (s === 270 && c.y < m.top || s === 90 && c.y > m.bottom) ? g.x = this.computeMidOrthoPosition(c.x, c.y, u.x, u.y, false) : g.x = m.left, p.x = g.x, p.y = u.y) : s === 180 && c.x > m.right && c.y > m.top && c.y < m.bottom && (g.x = c.x, c.y < u.y ? g.y = Math.min(u.y, m.top) : g.y = Math.max(u.y, m.bottom), p.y = g.y)) : (g.e(c.x, u.y), p.e((c.x + u.x) / 2, u.y), (s === 0 || s === 90 && u.y < d.top || s === 270 && u.y > d.bottom) && (s === 0 && (m.containsPoint(c) || d.containsPoint(u)) ? g.y = this.computeMidOrthoPosition(c.x, c.y, u.x, u.y, true) : u.y < c.y && (s === 0 || s === 90) ? g.y = this.computeMidOrthoPosition(c.x, d.top, u.x, Math.min(u.y, m.bottom), true) : u.y > c.y && (s === 0 || s === 270) && (g.y = this.computeMidOrthoPosition(c.x, d.bottom, u.x, Math.max(u.y, m.top), true)), p.x = u.x, p.y = g.y), g.y > d.top && g.y < d.bottom && (u.x <= d.right && u.x >= c.x || c.x >= m.left && c.x <= u.x ? (s === 90 || s === 270) && (g.e(Math.min((c.x + u.x) / 2, c.x), c.y), p.e(g.x, u.y)) : (s === 270 || (s === 0 || s === 180) && u.y < c.y ? g.y = Math.min(u.y, s === 180 ? d.top : Math.min(d.top, m.top)) : g.y = Math.max(u.y, s === 180 ? d.bottom : Math.max(d.bottom, m.bottom)), p.x = u.x, p.y = g.y))) : i === 90 ? u.y > c.y || s === 180 && u.x < c.x && m.bottom > c.y || s === 0 && u.x > c.x && m.bottom > c.y ? (g.e(c.x, u.y), p.e((c.x + u.x) / 2, u.y), s === 270 ? (g.y = this.computeMidOrthoPosition(c.x, c.y, u.x, u.y, true), p.x = u.x, p.y = g.y) : s === 180 && u.x < c.x || s === 0 && u.x > c.x ? (c.y < m.top ? g.y = this.computeMidOrthoPosition(c.x, c.y, u.x, m.top, true) : c.y < m.bottom && (s === 180 && c.x < m.left || s === 0 && c.x > m.right) ? g.y = this.computeMidOrthoPosition(c.x, c.y, u.x, u.y, true) : g.y = m.bottom, p.x = u.x, p.y = g.y) : s === 90 && c.y < m.top && c.x > m.left && c.x < m.right && (c.x < u.x ? g.x = Math.min(u.x, m.left) : g.x = Math.max(u.x, m.right), g.y = c.y, p.x = g.x)) : (g.e(u.x, c.y), p.e(u.x, (c.y + u.y) / 2), (s === 270 || s === 0 && u.x < d.left || s === 180 && u.x > d.right) && (s === 270 && (m.containsPoint(c) || d.containsPoint(u)) ? g.x = this.computeMidOrthoPosition(c.x, c.y, u.x, u.y, false) : u.x < c.x && (s === 270 || s === 0) ? g.x = this.computeMidOrthoPosition(d.left, c.y, Math.min(u.x, m.right), u.y, false) : u.x > c.x && (s === 270 || s === 180) && (g.x = this.computeMidOrthoPosition(d.right, c.y, Math.max(u.x, m.left), u.y, false)), p.x = g.x, p.y = u.y), g.x > d.left && g.x < d.right && (u.y >= d.top && u.y <= c.y || c.y <= m.bottom && c.y >= u.y ? (s === 0 || s === 180) && (g.e(c.x, Math.max((c.y + u.y) / 2, c.y)), p.e(u.x, g.y)) : (s === 180 || (s === 90 || s === 270) && u.x < c.x ? g.x = Math.min(u.x, s === 90 ? d.left : Math.min(d.left, m.left)) : g.x = Math.max(u.x, s === 90 ? d.right : Math.max(d.right, m.right)), p.x = g.x, p.y = u.y))) : u.y < c.y || s === 180 && u.x < c.x && m.top < c.y || s === 0 && u.x > c.x && m.top < c.y ? (g.e(c.x, u.y), p.e((c.x + u.x) / 2, u.y), s === 90 ? (g.y = this.computeMidOrthoPosition(c.x, c.y, u.x, u.y, true), p.x = u.x, p.y = g.y) : s === 180 && u.x < c.x || s === 0 && u.x >= c.x ? (c.y > m.bottom ? g.y = this.computeMidOrthoPosition(c.x, c.y, u.x, m.bottom, true) : c.y > m.top && (s === 180 && c.x < m.left || s === 0 && c.x > m.right) ? g.y = this.computeMidOrthoPosition(c.x, c.y, u.x, u.y, true) : g.y = m.top, p.x = u.x, p.y = g.y) : s === 270 && c.y > m.bottom && c.x > m.left && c.x < m.right && (c.x < u.x ? g.x = Math.min(u.x, m.left) : g.x = Math.max(u.x, m.right), g.y = c.y, p.x = g.x)) : (g.e(u.x, c.y), p.e(u.x, (c.y + u.y) / 2), (s === 90 || s === 0 && u.x < d.left || s === 180 && u.x > d.right) && (s === 90 && (m.containsPoint(c) || d.containsPoint(u)) ? g.x = this.computeMidOrthoPosition(c.x, c.y, u.x, u.y, false) : u.x < c.x && (s === 90 || s === 0) ? g.x = this.computeMidOrthoPosition(d.left, c.y, Math.min(u.x, m.right), u.y, false) : u.x > c.x && (s === 90 || s === 180) && (g.x = this.computeMidOrthoPosition(d.right, c.y, Math.max(u.x, m.left), u.y, false)), p.x = g.x, p.y = u.y), g.x > d.left && g.x < d.right && (u.y <= d.bottom && u.y >= c.y || c.y >= m.top && c.y <= u.y ? (s === 0 || s === 180) && (g.e(c.x, Math.min((c.y + u.y) / 2, c.y)), p.e(u.x, g.y)) : (s === 180 || (s === 90 || s === 270) && u.x < c.x ? g.x = Math.min(u.x, s === 270 ? d.left : Math.min(d.left, m.left)) : g.x = Math.max(u.x, s === 270 ? d.right : Math.max(d.right, m.right)), p.x = g.x, p.y = u.y))), this.EC = s !== a, this.TC = i, this.LC = s, this.addPoint(g.copy()), this.addPoint(p.copy()), Point2.o(g), Point2.o(p), Rect2.o(d), Rect2.o(m);
    }
    computeMidOrthoPosition(t, i, e, s, n) {
      let o = 0;
      return this.hasCurviness() && !this.computeSpot(true, this.fromPort).isSide() && !this.computeSpot(false, this.toPort).isSide() && (o = this.computeCurviness()), n ? (i + s) / 2 + o : (t + e) / 2 + o;
    }
    SL() {
      if (this.diagram === null || !this.isAvoiding || this.diagram.animationManager.isTicking) return false;
      const t = this.points.h, i = t.length;
      if (i < 4) return false;
      const e = this.diagram.getPositions(false, this.containingGroup, null);
      for (let s = 1; s < i - 2; s++) {
        const n = t[s], o = t[s + 1];
        if (!e.isUnoccupied(Math.min(n.x, o.x), Math.min(n.y, o.y), Math.abs(n.x - o.x), Math.abs(n.y - o.y))) return true;
      }
      return false;
    }
    findClosestSegment(t) {
      Debug && U.s(t, Point2, Link2, "findClosestSegment:p");
      const i = t.x, e = t.y;
      let s = this.getPoint(0), n = this.getPoint(1), o = Point2.distanceLineSegmentSquared(i, e, s.x, s.y, n.x, n.y), r = 0;
      for (let l = 1; l < this.pointsCount - 1; l++) {
        s = this.getPoint(l + 1);
        const h = Point2.distanceLineSegmentSquared(i, e, n.x, n.y, s.x, s.y);
        n = s, h < o && (r = l, o = h);
      }
      return r;
    }
    invalidateGeometry() {
      this.ie();
    }
    ie() {
      this.Ml && (this.Ml = false, this.g());
    }
    get Ml() {
      return (this.Dt & 128) !== 0;
    }
    set Ml(t) {
      (this.Dt & 128) !== 0 !== t && (this.Dt = this.Dt ^ 128);
    }
    get geometry() {
      if (!this.Ml) {
        if (this.updateRoute(), this.pointsCount < 2) return this.Ml = true, this.xt;
        this.xt = this.makeGeometry();
      }
      return this.xt;
    }
    Od(t) {
      if (!t) {
        if (this.Be === false) return;
        const n = this.findMainElement();
        if (this.Ml && (n === null || n.geometry !== null)) return;
      }
      this.pointsCount < 2 ? this.Ml = true : this.xt = this.makeGeometry();
      const i = this.path;
      if (i === null) return;
      i.xt = this.xt;
      const e = this.O.h, s = e.length;
      for (let n = 0; n < s; n++) {
        const o = e[n];
        o !== i && o.isPanelMain && o instanceof Shape2 && (o.xt = this.xt);
      }
    }
    KE(t) {
      return this.of() && t.uh.has(this) && (this.Wc.width !== 0 || this.Wc.height !== 0) && (t.animationManager.isAnimating || t.currentTool !== t.toolManager);
    }
    makeGeometry() {
      const t = this.xt, i = this.pointsCount;
      let e = false;
      const s = this.diagram;
      s !== null && this.KE(s) && (e = true);
      let n = 0, o = 0, r = Point2.Ms(this.getPoint(0));
      const l = Point2.Ms(r), h = this.Ai.h, f = this.computeCurve();
      if (f === 9 && i >= 3 && !G.q(this.smoothness, 0)) if (i === 3) {
        let a = this.getPoint(1);
        n = Math.min(r.x, a.x), o = Math.min(r.y, a.y), a = this.getPoint(2), n = Math.min(n, a.x), o = Math.min(o, a.y);
      } else if (this.isOrthogonal) {
        for (let a = 0; a < i; a++) {
          const c = h[a];
          l.x = Math.min(c.x, l.x), l.y = Math.min(c.y, l.y);
        }
        n = l.x, o = l.y;
      } else {
        for (let a = 3; a < i; a += 3) {
          a + 3 >= i && (a = i - 1);
          const c = this.getPoint(a);
          l.x = Math.min(c.x, l.x), l.y = Math.min(c.y, l.y);
        }
        n = l.x, o = l.y;
      }
      else {
        for (let a = 0; a < i; a++) {
          const c = h[a];
          l.x = Math.min(c.x, l.x), l.y = Math.min(c.y, l.y);
        }
        n = l.x, o = l.y;
      }
      if (n -= this.SS.x, o -= this.SS.y, r.x -= n, r.y -= o, this.computeShortLength(true) !== 0 && (r = this.hf(r, true, l)), i === 2 && !this.of()) {
        let a = Point2.Ms(this.getPoint(1));
        return a.x -= n, a.y -= o, this.computeShortLength(false) !== 0 && (a = this.hf(a, false, l)), t.type = 1, t.startX = r.x, t.startY = r.y, t.endX = a.x, t.endY = a.y, this.Ml = true, Point2.o(a), Point2.o(r), Point2.o(l), t;
      } else {
        t.type = 4;
        const a = GeoStream.ZA(t);
        if (a.Ru(r.x, r.y, false, false), f === 9 && i >= 3 && !G.q(this.smoothness, 0)) if (i === 3) {
          const c = this.getPoint(1), u = c.x - n, d = c.y - o, m = Point2.Ms(this.getPoint(2));
          m.x -= n, m.y -= o, this.computeShortLength(false) !== 0 && this.hf(m, false, l), a.Mr(u, d, u, d, m.x, m.y), Point2.o(m);
        } else if (this.isOrthogonal) {
          const c = Point2.U(n, o), u = Point2.Ms(this.getPoint(1)), d = Point2.U(n, o), m = Point2.U(n, o);
          let g = this.getPoint(0), p;
          const y = this.smoothness / 3;
          for (let k = 1; k < this.pointsCount - 1; k++) {
            p = this.getPoint(k);
            const P = g, A = p, C = this.getPoint(this.YC(p, k, false));
            G.q(P.x, A.x) && G.q(A.x, C.x) || G.q(P.y, A.y) && G.q(A.y, C.y) || (this.UE(P, A, C, y, d, m), (k === 1 || k === 2 && G.q(g.x, this.getPoint(0).x) && G.q(g.y, this.getPoint(0).y)) && (u.x = (g.x + p.x) * 0.5, u.y = (g.y + p.y) * 0.5), a.Mr(u.x - n, u.y - o, d.x - n, d.y - o, p.x - n, p.y - o), c.c(d), u.c(m), g = p);
          }
          let x = g.x, S = g.y;
          const b = Point2.Ms(this.getPoint(this.pointsCount - 1));
          this.computeShortLength(false) !== 0 && this.hf(b, false, Point2.wn), x = 0.5 * (x + b.x), S = 0.5 * (S + b.y), a.Mr(m.x - n, m.y - o, x - n, S - o, b.x - n, b.y - o), Point2.o(b), Point2.o(c), Point2.o(u), Point2.o(d), Point2.o(m);
        } else for (let c = 3; c < i; c += 3) {
          const u = this.getPoint(c - 2);
          c + 3 >= i && (c = i - 1);
          const d = this.getPoint(c - 1), m = Point2.Ms(this.getPoint(c));
          c === i - 1 && this.computeShortLength(false) !== 0 && this.hf(m, false, Point2.wn), a.Mr(u.x - n, u.y - o, d.x - n, d.y - o, m.x - n, m.y - o), Point2.o(m);
        }
        else if (this.isOrthogonal || i === 2) {
          const c = Point2.Ms(this.getPoint(0)), u = Point2.a(), d = Point2.Ms(c), m = this.computeCorner();
          let g = 1, p = 0;
          for (; g < i; ) {
            if (g = this.YC(c, g, g > 1), u.c(this.getPoint(g)), g >= i - 1) {
              if (!c.equals(u)) this.computeShortLength(false) !== 0 && this.hf(u, false, Point2.wn), this.Xn(a, -n, -o, c, u, e);
              else if (p === 0) for (g = 1; g < i; ) d.c(c), u.c(this.getPoint(g++)), this.Xn(a, -n, -o, c, u, e), c.c(u);
              break;
            }
            p = this.YC(u, g + 1, g < i - 3);
            const y = this.getPoint(p);
            this.GE(a, -n, -o, c, u, y, c, d, m, e), d.c(u), g = p;
          }
          Point2.o(c), Point2.o(u), Point2.o(d);
        } else {
          const c = this.computeCorner();
          if (i > 2 && c >= 0.5) {
            const u = Point2.Ms(h[i - 1]);
            this.computeShortLength(false) !== 0 && this.hf(u, false, Point2.wn), r.x += n, r.y += o;
            for (let d = 1; d < i; d++) {
              const m = d === 1 ? r : h[d - 1], g = d === i - 1 ? u : h[d], p = Math.sqrt(m.distanceSquaredPoint(g)), y = c / p;
              if (y < 0.5) {
                if (d > 1) {
                  const x = m.x + (g.x - m.x) * y, S = m.y + (g.y - m.y) * y;
                  a.Ou(m.x - n, m.y - o, x - n, S - o);
                }
                a.js(g.x + (m.x - g.x) * y - n, g.y + (m.y - g.y) * y - o);
              } else d > 1 && a.Ou(m.x - n, m.y - o, (m.x + g.x) / 2 - n, (m.y + g.y) / 2 - o);
              d === i - 1 && a.js(u.x - n, u.y - o);
            }
            Point2.o(u);
          } else if (i >= 2) {
            const u = Point2.Ms(h[i - 1]);
            this.computeShortLength(false) !== 0 && this.hf(u, false, Point2.wn);
            for (let d = 1; d < i - 1; d++) a.js(h[d].x - n, h[d].y - o);
            a.js(u.x - n, u.y - o), Point2.o(u);
          }
        }
        return GeoStream.QA(a), this.Ml = true, Point2.o(r), Point2.o(l), t;
      }
    }
    TS(t, i, e, s) {
      let n = e - t;
      if (isNaN(n) || n === 1 / 0 || n === -1 / 0) return NaN;
      n < 0 && (n = -n);
      let o = s - i;
      return isNaN(o) || o === 1 / 0 || o === -1 / 0 ? NaN : (o < 0 && (o = -o), G.q(n, 0) ? o : G.q(o, 0) ? n : Math.sqrt(n * n + o * o));
    }
    UE(t, i, e, s, n, o) {
      isNaN(s) && (s = this.smoothness / 3);
      const r = t.x, l = t.y, h = i.x, f = i.y, a = e.x, c = e.y, u = s * this.TS(r, l, h, f), d = s * this.TS(h, f, a, c);
      if (G.q(l, f) && G.q(h, a) && (h > r ? c > f ? (n.x = h - u, n.y = f - u, o.x = h + d, o.y = f + d) : (n.x = h - u, n.y = f + u, o.x = h + d, o.y = f - d) : c > f ? (n.x = h + u, n.y = f - u, o.x = h - d, o.y = f + d) : (n.x = h + u, n.y = f + u, o.x = h - d, o.y = f - d)), G.q(r, h) && G.q(f, c) && (f > l ? a > h ? (n.x = h - u, n.y = f - u, o.x = h + d, o.y = f + d) : (n.x = h + u, n.y = f - u, o.x = h - d, o.y = f + d) : a > h ? (n.x = h - u, n.y = f + u, o.x = h + d, o.y = f - d) : (n.x = h + u, n.y = f + u, o.x = h - d, o.y = f - d)), G.q(r, h) && G.q(h, a) || G.q(l, f) && G.q(f, c)) {
        const m = 0.5 * (r + a), g = 0.5 * (l + c);
        n.x = m, n.y = g, o.x = m, o.y = g;
      }
    }
    hf(t, i, e) {
      const s = this.pointsCount;
      if (s < 2) return t;
      if (i) {
        const n = this.getPoint(1), o = n.x - e.x, r = n.y - e.y, l = this.TS(t.x, t.y, o, r);
        if (l === 0) return t;
        const h = s === 2 ? l * 0.5 : l;
        let f = this.computeShortLength(true);
        f > h && (f = h);
        const a = f * (o - t.x) / l, c = f * (r - t.y) / l;
        t.x += a, t.y += c;
      } else {
        const n = this.getPoint(s - 2), o = n.x - e.x, r = n.y - e.y, l = this.TS(t.x, t.y, o, r);
        if (l === 0) return t;
        const h = s === 2 ? l * 0.5 : l;
        let f = this.computeShortLength(false);
        f > h && (f = h);
        const a = f * (t.x - o) / l, c = f * (t.y - r) / l;
        t.x -= a, t.y -= c;
      }
      return t;
    }
    YC(t, i, e) {
      const s = this.pointsCount;
      let n = t;
      for (; G.q(t.x, n.x) && G.q(t.y, n.y); ) {
        if (i >= s) return s - 1;
        n = this.getPoint(i++);
      }
      if (!G.q(t.x, n.x) && !G.q(t.y, n.y)) return i - 1;
      let o = n;
      for (; G.q(t.x, n.x) && G.q(n.x, o.x) && (!e || (t.y >= n.y ? n.y >= o.y : n.y <= o.y)) || G.q(t.y, n.y) && G.q(n.y, o.y) && (!e || (t.x >= n.x ? n.x >= o.x : n.x <= o.x)); ) {
        if (i >= s) return s - 1;
        o = this.getPoint(i++);
      }
      return i - 2;
    }
    GE(t, i, e, s, n, o, r, l, h, f) {
      if (G.p(s.y, n.y) && G.p(n.x, o.x)) {
        let a = Math.min(h, Math.abs(n.x - l.x) / 2);
        const c = Math.min(a, Math.abs(o.y - n.y) / 2);
        if (a = c, G.p(a, 0)) {
          this.Xn(t, i, e, s, n, f), r.c(n);
          return;
        }
        let u = n.x;
        const d = n.y, m = u;
        let g = d;
        n.x > s.x ? (u = n.x - a, o.y > n.y ? g = n.y + c : g = n.y - c) : (u = n.x + a, o.y > n.y ? g = n.y + c : g = n.y - c);
        const p = Point2.U(u, d);
        this.Xn(t, i, e, s, p, f), Point2.o(p), t.Ou(n.x + i, n.y + e, m + i, g + e), r.e(m, g);
      } else if (G.p(s.x, n.x) && G.p(n.y, o.y)) {
        let a = Math.min(h, Math.abs(n.y - l.y) / 2);
        const c = Math.min(a, Math.abs(o.x - n.x) / 2);
        if (a = c, G.p(c, 0)) {
          this.Xn(t, i, e, s, n, f), r.c(n);
          return;
        }
        const u = n.x;
        let d = n.y, m = u;
        const g = d;
        n.y > s.y ? (d = n.y - a, o.x > n.x ? m = n.x + c : m = n.x - c) : (d = n.y + a, o.x > n.x ? m = n.x + c : m = n.x - c);
        const p = Point2.U(u, d);
        this.Xn(t, i, e, s, p, f), Point2.o(p), t.Ou(n.x + i, n.y + e, m + i, g + e), r.e(m, g);
      } else this.Xn(t, i, e, s, n, f), r.c(n);
    }
    Xn(t, i, e, s, n, o) {
      if (o || !this.of()) t.js(n.x + i, n.y + e);
      else {
        const r = Link2.cF, l = r / 2, h = [];
        let f = 0;
        this.isVisible() && (f = this.qE(s, n, h));
        let a = s.x, c = s.y;
        if (f > 0) {
          if (G.p(s.y, n.y)) if (s.x < n.x) {
            let u = 0;
            for (; u < f; ) {
              const d = Math.max(s.x, Math.min(h[u++] - l, n.x - r));
              t.js(d + i, n.y + e), a = d + i, c = n.y + e;
              let m = Math.min(d + r, n.x);
              for (; u < f; ) {
                const x = h[u];
                if (x < m + r) u++, m = Math.min(x + l, n.x);
                else break;
              }
              const g = n.y - r + e, p = m + i, y = n.y + e;
              this.curve === 10 ? t.Ru(p, y, false, false) : t.Mr(a, g, p, g, p, y), a = p, c = y;
            }
          } else {
            let u = f - 1;
            for (; u >= 0; ) {
              const d = Math.min(s.x, Math.max(h[u--] + l, n.x + r));
              t.js(d + i, n.y + e), a = d + i, c = n.y + e;
              let m = Math.max(d - r, n.x);
              for (; u >= 0; ) {
                const x = h[u];
                if (x > m - r) u--, m = Math.max(x - l, n.x);
                else break;
              }
              const g = n.y - r + e, p = m + i, y = n.y + e;
              this.curve === 10 ? t.Ru(p, y, false, false) : t.Mr(a, g, p, g, p, y), a = p, c = y;
            }
          }
          else if (G.p(s.x, n.x)) if (s.y < n.y) {
            let u = 0;
            for (; u < f; ) {
              const d = Math.max(s.y, Math.min(h[u++] - l, n.y - r));
              t.js(n.x + i, d + e), a = n.x + i, c = d + e;
              let m = Math.min(d + r, n.y);
              for (; u < f; ) {
                const x = h[u];
                if (x < m + r) u++, m = Math.min(x + l, n.y);
                else break;
              }
              const g = n.x - r + i, p = n.x + i, y = m + e;
              this.curve === 10 ? t.Ru(p, y, false, false) : t.Mr(g, c, g, y, p, y), a = p, c = y;
            }
          } else {
            let u = f - 1;
            for (; u >= 0; ) {
              const d = Math.min(s.y, Math.max(h[u--] + l, n.y + r));
              t.js(n.x + i, d + e), a = n.x + i, c = d + e;
              let m = Math.max(d - r, n.y);
              for (; u >= 0; ) {
                const x = h[u];
                if (x > m - r) u--, m = Math.max(x - l, n.y);
                else break;
              }
              const g = n.x - r + i, p = n.x + i, y = m + e;
              this.curve === 10 ? t.Ru(p, y, false, false) : t.Mr(g, c, g, y, p, y), a = p, c = y;
            }
          }
        }
        t.js(n.x + i, n.y + e);
      }
    }
    qE(t, i, e) {
      const s = this.diagram;
      if (s === null || t.equals(i)) return 0;
      const n = s.layers;
      for (; n.next(); ) {
        const o = n.value;
        if (o !== null && o.visible) {
          const r = o.KM(), l = r.length;
          for (let h = 0; h < l; h++) {
            const f = r[h];
            if (!(f instanceof Link2)) continue;
            if (f === this) return e.length > 0 && e.sort((u, d) => u - d), e.length;
            if (!f.isVisible() || !f.of()) continue;
            const a = f.routeBounds;
            if (!a.isReal() || !this.routeBounds.intersectsRect(a) || this.usesSamePort(f)) continue;
            const c = f.path;
            c !== null && c.isVisibleObject() && this.HE(t, i, e, f);
          }
        }
      }
      return e.length > 0 && e.sort((o, r) => o - r), e.length;
    }
    HE(t, i, e, s) {
      const n = G.p(t.y, i.y), o = s.pointsCount;
      let r = s.getPoint(0);
      const l = Point2.a();
      for (let h = 1; h < o; h++) {
        const f = s.getPoint(h);
        if (h < o - 1) {
          const a = s.getPoint(h + 1);
          if (r.y === f.y && f.y === a.y) {
            if (f.x > r.x && a.x >= f.x || f.x < r.x && a.x <= f.x) continue;
          } else if (r.x === f.x && f.x === a.x && (f.y > r.y && a.y >= f.y || f.y < r.y && a.y <= f.y)) continue;
        }
        this.vE(t, i, r, f, l) && (n ? e.push(l.x) : e.push(l.y)), r = f;
      }
      Point2.o(l);
    }
    vE(t, i, e, s, n) {
      const o = t.x, r = t.y, l = i.x, h = i.y, f = e.x, a = e.y, c = s.x, u = s.y;
      if (G.p(o, l)) {
        if (!G.p(r, h) && G.p(a, u) && Math.min(r, h) < a && Math.max(r, h) > a && Math.min(f, c) < o && Math.max(f, c) > o && !G.p(f, c)) return n.x = o, n.y = a, true;
      } else if (G.p(r, h) && G.p(f, c) && Math.min(o, l) < f && Math.max(o, l) > f && Math.min(a, u) < r && Math.max(a, u) > r && !G.p(a, u)) return n.x = f, n.y = r, true;
      return n.x = 0, n.y = 0, false;
    }
    get firstPickIndex() {
      return this.pointsCount <= 2 ? 0 : this.isOrthogonal || !this.rf(this.computeSpot(true)) ? 1 : 0;
    }
    get lastPickIndex() {
      const t = this.pointsCount;
      return t === 0 ? 0 : t <= 2 ? t - 1 : this.isOrthogonal || !this.rf(this.computeSpot(false)) ? t - 2 : t - 1;
    }
    of() {
      const t = this.curve;
      return t === 11 || t === 10;
    }
    MS(t) {
      if (t || this.of()) {
        const i = this.diagram;
        i !== null && !i.animationManager.isTicking && !i.uh.has(this) && (this.Wc.width !== 0 || this.Wc.height !== 0) && i.uh.set(this, this.Wc.copy());
      }
    }
    invalidateOtherJumpOvers(t) {
      const i = this.layer;
      if (i === null || !i.visible || i.isTemporary) return;
      const e = i.diagram;
      if (e === null || e.animationManager.isTicking) return;
      let s = false;
      const n = e.layers;
      for (; n.next(); ) {
        const o = n.value;
        if (o.visible) {
          if (o === i) {
            s = true;
            let r = false;
            const l = o.KM(), h = l.length;
            for (let f = 0; f < h; f++) {
              const a = l[f];
              a instanceof Link2 && (a === this ? r = true : r && this.kF(a, t));
            }
          } else if (s) {
            const r = o.KM(), l = r.length;
            for (let h = 0; h < l; h++) {
              const f = r[h];
              f instanceof Link2 && this.kF(f, t);
            }
          }
        }
      }
    }
    kF(t, i) {
      if (t === null || !t.Ml || !t.Be || !t.of()) return;
      const e = t.routeBounds;
      e.isReal() && (!this.routeBounds.intersectsRect(e) && !i.intersectsRect(e) || this.usesSamePort(t) || t.ie());
    }
    usesSamePort(t) {
      const i = this.pointsCount, e = t.pointsCount;
      if (i > 0 && e > 0) {
        const s = this.getPoint(0), n = t.getPoint(0);
        if (s.equalsApprox(n)) return true;
        const o = this.getPoint(i - 1), r = t.getPoint(e - 1);
        if (o.equalsApprox(r) || s.equalsApprox(r) || o.equalsApprox(n)) return true;
      } else if (this.fromNode === t.fromNode || this.toNode === t.toNode || this.fromNode === t.toNode || this.toNode === t.fromNode) return true;
      return false;
    }
    isVisible() {
      if (!super.isVisible()) return false;
      const t = this.containingGroup;
      let i = true;
      const e = this.diagram;
      e !== null && (i = e.isTreePathToChildren);
      const s = this.fromNode;
      if (s !== null) {
        if (this.isTreeLink && i && !s.isTreeExpanded) return false;
        if (s === t) return true;
        let o = s;
        for (; o !== null; ) {
          if (o.labeledLink === this) return true;
          o = o.containingGroup;
        }
        const r = s.findVisibleNode();
        if (r === null || r === t) return false;
      }
      const n = this.toNode;
      if (n !== null) {
        if (this.isTreeLink && !i && !n.isTreeExpanded) return false;
        if (n === t) return true;
        let o = n;
        for (; o !== null; ) {
          if (o.labeledLink === this) return true;
          o = o.containingGroup;
        }
        const r = n.findVisibleNode();
        if (r === null || r === t) return false;
      }
      return true;
    }
    Hi(t) {
      if (super.Hi(t), t && this.MS(false), this.hr !== null && this.hr.tg(), this.an !== null) {
        const e = this.an.iterator;
        for (; e.next(); ) e.value.Hi(t);
      }
    }
    get adjusting() {
      return this.vc;
    }
    set adjusting(t) {
      const i = this.vc;
      i !== t && (Debug && t !== 0 && t !== 17 && t !== 18 && t !== 19 && U.n("Link.adjusting can only be set to None, End, Scale, or Stretch, not: " + t), this.vc = t, this.t("adjusting", i, t));
    }
    computeAdjusting() {
      return this.isAvoiding && this.diagram !== null && this.diagram.animationManager.defaultAnimation.isAnimating ? 17 : this.vc;
    }
    get corner() {
      return this.sg;
    }
    set corner(t) {
      const i = this.sg;
      i !== t && (Debug && U.i(t, "number", Link2, "corner"), this.sg = t, this.ie(), this.t("corner", i, t));
    }
    get curve() {
      return this.ng;
    }
    set curve(t) {
      const i = this.ng;
      i !== t && (Debug && t !== 0 && t !== 9 && t !== 10 && t !== 11 && U.n("Link.curve can only be set to None, Bezier, JumpGap, or JumpOver, not: " + t), this.ng = t, this.ii(), this.ie(), this.MS(i === 10 || i === 11 || t === 10 || t === 11), this.t("curve", i, t));
    }
    get curviness() {
      return this.og;
    }
    set curviness(t) {
      const i = this.og;
      i !== t && (Debug && U.i(t, "number", Link2, "curviness"), this.og = t, this.ii(), this.ie(), this.t("curviness", i, t));
    }
    get routing() {
      return this.tf;
    }
    set routing(t) {
      const i = this.tf;
      i !== t && (Debug && t !== 1 && t !== 2 && t !== 6 && t !== 7 && U.n("Link.routing can only be set to Normal, Orthogonal, AvoidsNodes, not: " + t), this.tf = t, this.isAvoiding && this.diagram !== null && (this.diagram.u0 = true), this.lr = null, this.ii(), this.MS(Link2.DC(i) || Link2.DC(t)), this.t("routing", i, t));
    }
    get smoothness() {
      return this.rg;
    }
    set smoothness(t) {
      const i = this.rg;
      i !== t && (Debug && U.i(t, "number", Link2, "smoothness"), this.rg = t, this.ie(), this.t("smoothness", i, t));
    }
    iw() {
      const t = this.bo;
      if (t === null) return;
      const i = this.ko;
      if (i === null || !isNaN(this.curviness)) return;
      const e = this.So, s = this.Po;
      let n = null, o = null;
      const r = t.ri.h, l = r.length;
      for (let h = 0; h < l; h++) {
        const f = r[h];
        !(f.bo === t && f.So === e && f.ko === i && f.Po === s) && !(f.bo === i && f.So === s && f.ko === t && f.Po === e) || (o === null ? o = f : (n === null && (n = [], n.push(o)), n.push(f)));
      }
      if (n !== null) {
        let h = t.ZD(i, e, s);
        h === null && (h = new LinkBundle(t, e, i, s), t.JD(h), i.JD(h)), h.fn = n;
        for (let f = 0; f < n.length; f++) {
          const a = n[f];
          a.hr = h;
        }
        h.tg();
      }
    }
    tw() {
      const t = this.hr;
      if (t !== null) {
        if (!isNaN(this.curviness)) return;
        this.hr = null;
        const i = t.fn.indexOf(this);
        i >= 0 && (t.fn.splice(i, 1), t.tg());
      }
    }
    Rr() {
      return true;
    }
    get key() {
      const t = this.diagram;
      if (!(t === null || !t.model._a())) return t.model.getKeyForLinkData(this.data);
    }
  }
  class LinkBundle {
    Jo;
    Zs;
    Hy;
    kC;
    wS;
    PC;
    fn;
    constructor(t, i, e, s) {
      GSet2._i(this), this.Jo = false, this.Zs = false, this.Hy = t, this.kC = i, this.wS = e, this.PC = s, this.fn = [];
    }
    tg() {
      if (!this.Jo) {
        const t = this.fn;
        if (t.length > 0) {
          const i = t[0].diagram;
          i !== null && (i.c2.add(this), this.Zs = i.undoManager.isUndoingRedoing);
        }
      }
      this.Jo = true;
    }
    A2() {
      if (this.Jo) {
        this.Jo = false;
        const t = this.fn;
        if (t.length > 0) {
          const i = t[0], e = i.diagram, s = e === null || e.sa && !this.Zs;
          this.Zs = false, i.arrangeBundledLinks(t, s), t.length === 1 && (i.hr = null, t.length = 0);
        }
        t.length === 0 && (this.Hy.$D(this), this.wS.$D(this));
      }
    }
  }
  class PositionArray {
    ge;
    me;
    af;
    ff;
    Si;
    ki;
    Gt;
    zh;
    Xh;
    Fa;
    Y2;
    Jo;
    nw;
    gc;
    K2;
    U2;
    constructor(t) {
      GSet2._i(this), this.Fa = null, this.Y2 = null, this.Jo = true, this.nw = false, this.ge = 1, this.me = 1, this.af = -1, this.ff = -1, this.Si = t.width, this.ki = t.height, this.Gt = [], this.zh = 0, this.Xh = 0, this.gc = Link2.wF, this.K2 = this.gc * 2, this.U2 = this.gc * 2;
    }
    static cn = 0;
    static cf = 1;
    static hg = 999999;
    static KC = PositionArray.hg + 1;
    static UC = PositionArray.hg + 2;
    bb(t) {
      if (t.width <= 0 || t.height <= 0) return;
      const i = t.x, e = t.y, s = t.x + t.width, n = t.y + t.height;
      this.ge = Math.floor((i - this.Si) / this.Si) * this.Si, this.me = Math.floor((e - this.ki) / this.ki) * this.ki, this.af = Math.ceil((s + 2 * this.Si) / this.Si) * this.Si, this.ff = Math.ceil((n + 2 * this.ki) / this.ki) * this.ki;
      const o = 1 + (Math.ceil((this.af - this.ge) / this.Si) | 0), r = 1 + (Math.ceil((this.ff - this.me) / this.ki) | 0);
      if (this.Gt.length === 0 || this.zh < o - 1 || this.Xh < r - 1) {
        const l = [];
        for (let h = 0; h <= o; h++) l[h] = new Uint32Array(r);
        this.Gt = l, this.zh = o - 1, this.Xh = r - 1;
      }
      this.WE(PositionArray.KC);
    }
    get bounds() {
      return new Rect2(this.ge, this.me, this.af - this.ge, this.ff - this.me);
    }
    get cellWidth() {
      return this.Si;
    }
    set cellWidth(t) {
      t > 0 && t !== this.Si && (this.Si = t, this.bb(this.bounds));
    }
    get cellHeight() {
      return this.ki;
    }
    set cellHeight(t) {
      t > 0 && t !== this.ki && (this.ki = t, this.bb(this.bounds));
    }
    ag(t, i) {
      return this.ge <= t && t <= this.af && this.me <= i && i <= this.ff;
    }
    Mo(t, i) {
      if (!this.ag(t, i)) return PositionArray.KC;
      t -= this.ge, t /= this.Si, i -= this.me, i /= this.ki;
      const e = t | 0, s = i | 0;
      return this.Gt[e][s];
    }
    zO(t, i, e, s) {
      if (!this.ag(t, i)) return;
      const n = (t - this.ge) / this.Si | 0, o = (i - this.me) / this.ki | 0, r = (t + e - this.ge) / this.Si | 0, l = (i + s - this.me) / this.ki | 0, h = Math.min(r, this.zh), f = Math.min(l, this.Xh);
      for (let a = n; a <= h; a++) {
        const c = this.Gt[a];
        if (c.fill) c.fill(PositionArray.cn, o, f + 1);
        else for (let u = o; u <= f; u++) c[u] = PositionArray.cn;
      }
    }
    WE(t) {
      for (let i = 0; i <= this.zh; i++) {
        const e = this.Gt[i];
        if (e.fill) e.fill(t);
        else for (let s = 0; s <= this.Xh; s++) e[s] = t;
      }
    }
    RL() {
      for (let t = 0; t <= this.zh; t++) {
        const i = this.Gt[t];
        for (let e = 0; e <= this.Xh; e++) i[e] >= PositionArray.cf && (i[e] = PositionArray.KC);
      }
    }
    jE(t, i) {
      return this.Mo(t, i) === PositionArray.cn;
    }
    isUnoccupied(t, i, e, s) {
      if (t > this.af || t + e < this.ge || i > this.ff || i + s < this.me) return true;
      let n = (t - this.ge) / this.Si | 0, o = (i - this.me) / this.ki | 0, r = Math.max(0, e) / this.Si + 1 | 0, l = Math.max(0, s) / this.ki + 1 | 0;
      if (n < 0 && (r += n, n = 0), o < 0 && (l += o, o = 0), r < 0 || l < 0) return true;
      const h = Math.min(n + r - 1, this.zh) | 0, f = Math.min(o + l - 1, this.Xh) | 0;
      for (let a = n; a <= h; a++) {
        const c = this.Gt[a];
        for (let u = o; u <= f; u++) if (c[u] === PositionArray.cn) return false;
      }
      return true;
    }
    maxAvoidsLinksSpaceH(t, i, e, s) {
      if (t > this.af || i < this.ge || e > this.ff || e < this.me) return 0;
      const n = (t - this.ge) / this.Si | 0, o = (i - this.ge) / this.Si | 0, r = (e - this.me) / this.ki | 0, l = s / this.ki + 1 | 0;
      let h;
      for (h = 0; h < l / 2; h++) {
        let f = false;
        for (let a = n; a <= o; a++) if (this.Gt[a][r + h] === PositionArray.cn || this.Gt[a][r - h] === PositionArray.cn) {
          f = true;
          break;
        }
        if (f) return Math.max(0, (2 * h - 1) * this.ki);
      }
      return s;
    }
    maxAvoidsLinksSpaceV(t, i, e, s) {
      if (t > this.ff || i < this.me || e > this.af || e < this.ge) return 0;
      const n = (t - this.me) / this.ki | 0, o = (i - this.me) / this.ki | 0, r = (e - this.ge) / this.Si | 0, l = s / this.Si + 1 | 0;
      let h;
      for (h = 0; h < l / 2; h++) {
        let f = false;
        for (let a = n; a <= o; a++) if (this.Gt[r + h][a] === PositionArray.cn || this.Gt[r - h][a] === PositionArray.cn) {
          f = true;
          break;
        }
        if (f) return Math.max(0, (2 * h - 1) * this.Si);
      }
      return s;
    }
    JE(t, i, e, s, n, o, r, l) {
      t = t | 0, i = i | 0;
      let h = this.Gt[t][i];
      if (h >= PositionArray.cf && h < PositionArray.hg) for (s ? i += e : t += e, h += 1; n <= t && t <= o && r <= i && i <= l; ) {
        const f = this.Gt[t][i];
        if (h >= f) break;
        this.Gt[t][i] = h, h += 1, s ? i += e : t += e;
      }
      return s ? i : t;
    }
    No(t, i, e, s, n, o, r, l) {
      if (t < n || t > o || i < r || i > l) return;
      const h = this.JE(t, i, e, s, n, o, r, l);
      if (s) if (e > 0) for (let f = i + e; f < h; f += e) this.No(t, f, 1, !s, n, o, r, l), this.No(t, f, -1, !s, n, o, r, l);
      else for (let f = i + e; f > h; f += e) this.No(t, f, 1, !s, n, o, r, l), this.No(t, f, -1, !s, n, o, r, l);
      else if (e > 0) for (let f = t + e; f < h; f += e) this.No(f, i, 1, !s, n, o, r, l), this.No(f, i, -1, !s, n, o, r, l);
      else for (let f = t + e; f > h; f += e) this.No(f, i, 1, !s, n, o, r, l), this.No(f, i, -1, !s, n, o, r, l);
    }
    LS(t, i, e, s, n, o, r, l, h, f) {
      let a = t | 0, c = i | 0, u = PositionArray.cn, d = PositionArray.cf;
      for (this.Gt[a][c] = d; u === PositionArray.cn && a > r && a < l && c > h && c < f; ) d += 1, this.Gt[a][c] = d, o ? c += n : a += n, u = this.Gt[a][c];
      return o ? c : a;
    }
    DS(t, i, e, s, n, o, r, l, h, f) {
      let a = e | 0, c = s | 0, u = PositionArray.cn;
      const d = PositionArray.hg;
      for (this.Gt[a][c] = d; u === PositionArray.cn && a > r && a < l && c > h && c < f; ) this.Gt[a][c] = d, o ? c += n : a += n, u = this.Gt[a][c];
    }
    PF(t, i, e, s, n, o) {
      this.nw = false;
      let r = t.x, l = t.y;
      if (!this.ag(r, l)) return;
      r -= this.ge, r /= this.Si, l -= this.me, l /= this.ki;
      let h = e.x, f = e.y;
      if (!this.ag(h, f)) return;
      if (h -= this.ge, h /= this.Si, f -= this.me, f /= this.ki, Math.abs(r - h) <= 1 && Math.abs(l - f) <= 1) {
        this.nw = true;
        return;
      }
      let a = n.x, c = n.y, u = n.x + n.width, d = n.y + n.height;
      a -= this.ge, a /= this.Si, c -= this.me, c /= this.ki, u -= this.ge, u /= this.Si, d -= this.me, d /= this.ki;
      const m = Math.max(0, Math.min(this.zh, a | 0)), g = Math.min(this.zh, Math.max(0, u | 0)), p = Math.max(0, Math.min(this.Xh, c | 0)), y = Math.min(this.Xh, Math.max(0, d | 0)), x = 0, S = 90, b = 270, k = this.Gt, P = r | 0, A = l | 0, C = h | 0, M = f | 0, N = i === x || i === S ? 1 : -1, L = i === S || i === b;
      k[P][A] === PositionArray.cn ? (this.LS(P, A, C, M, N, L, m, g, p, y), this.LS(P, A, C, M, 1, !L, m, g, p, y), this.LS(P, A, C, M, -1, !L, m, g, p, y)) : this.LS(P, A, C, M, N, L, P, A, P, A), k[C][M] === PositionArray.cn ? (this.DS(P, A, C, M, s === x || s === S ? 1 : -1, s === S || s === b, m, g, p, y), this.DS(P, A, C, M, 1, !(s === S || s === b), m, g, p, y), this.DS(P, A, C, M, -1, !(s === S || s === b), m, g, p, y)) : this.DS(P, A, C, M, N, L, C, M, C, M);
      const T = U.ft();
      if (o && this.MF(C, M, s, P, A, T)) {
        (T[0] !== C || T[1] !== M) && (T.unshift(M), T.unshift(C)), (T[T.length - 2] !== P || T[T.length - 1] !== A) && (T.push(P), T.push(A));
        let D = PositionArray.cf, F = T[T.length - 2], R = T[T.length - 1];
        k[F][R] = D++;
        for (let I = T.length - 4; I >= 0; I -= 2) {
          F = T[I + 2], R = T[I + 3];
          const O = T[I], X = T[I + 1];
          for (; O > F ? F++ : O < F ? F-- : X > R ? R++ : X < R && R--, k[F][R] = D++, !(F === O && R === X); ) ;
        }
      } else this.No(P, A, 1, false, m, g, p, y), this.No(P, A, -1, false, m, g, p, y), this.No(P, A, 1, true, m, g, p, y), this.No(P, A, -1, true, m, g, p, y);
      U.et(T);
    }
    MF(t, i, e, s, n, o) {
      const a = this.Gt;
      let c = t, u = i;
      for (; ; ) {
        if (c === s && u === n) return true;
        let d = c, m = u;
        if (e === 0) if (d < s) d++;
        else break;
        else if (e === 90) if (m < n) m++;
        else break;
        else if (e === 180) if (d > s) d--;
        else break;
        else if (m > n) m--;
        else break;
        const g = a[d][m];
        if (g === 0 || g === PositionArray.UC) break;
        c = d, u = m;
      }
      for (; ; ) {
        let d = e, m = c, g = u;
        e === 0 ? g < n ? (d = 90, g++) : g > n && (d = 270, g--) : e === 90 ? m < s ? (d = 0, m++) : m > s && (d = 180, m--) : e === 180 ? g < n ? (d = 90, g++) : g > n && (d = 270, g--) : m < s ? (d = 0, m++) : m > s && (d = 180, m--);
        const p = a[m][g];
        if (d !== e && p !== 0 && p !== PositionArray.UC) {
          if (o.push(c), o.push(u), this.MF(c, u, d, s, n, o)) return true;
          o.pop(), o.pop();
        }
        if (a[c][u] = PositionArray.UC, e === 0) {
          if (c === t) return false;
          c--;
        } else if (e === 90) {
          if (u === i) return false;
          u--;
        } else if (e === 180) {
          if (c === t) return false;
          c++;
        } else {
          if (u === i) return false;
          u++;
        }
      }
    }
  }
  class Knot {
    Ve;
    Nl;
    Ke;
    fg;
    constructor(t, i) {
      GSet2._i(this), this.Ve = t, this.Nl = i, this.Ke = [], this.fg = false;
    }
    toString() {
      const t = this.Ke;
      let i = this.Ve.toString() + " " + t.length.toString() + ":";
      for (let e = 0; e < t.length; e++) {
        const s = t[e];
        s !== null && (i += `
  ` + s.toString());
      }
      return i;
    }
    $E(t, i, e, s) {
      const n = i.offsetY;
      switch (n) {
        case 8:
          return 90;
        case 2:
          return 180;
        case 1:
          return 270;
        case 4:
          return 0;
      }
      let o = e;
      switch (n) {
        case 9:
          return o > 180 ? 270 : 90;
        case 6:
          return o > 90 && o <= 270 ? 180 : 0;
      }
      const r = Math.atan2(t.height, t.width) * 180 / Math.PI;
      switch (n) {
        case 3:
          return o > r && o <= 180 + r ? 180 : 270;
        case 5:
          return o > 180 - r && o <= 360 - r ? 270 : 0;
        case 12:
          return o > r && o <= 180 + r ? 90 : 0;
        case 10:
          return o > 180 - r && o <= 360 - r ? 180 : 90;
        case 7:
          return o > 90 && o <= 180 + r ? 180 : o > 180 + r && o <= 360 - r ? 270 : 0;
        case 13:
          return o > 180 && o <= 360 - r ? 270 : o > r && o <= 180 ? 90 : 0;
        case 14:
          return o > r && o <= 180 - r ? 90 : o > 180 - r && o <= 270 ? 180 : 0;
        case 11:
          return o > 180 - r && o <= 180 + r ? 180 : o > 180 + r ? 270 : 90;
      }
      return s && n !== 15 && (o -= 15, o < 0 && (o += 360)), o > r && o < 180 - r ? 90 : o >= 180 - r && o <= 180 + r ? 180 : o > 180 + r && o < 360 - r ? 270 : 0;
    }
    tg() {
      this.Ke.length = 0;
    }
    xF(t) {
      let i = this.Ke;
      i.length === 0 && (this.ZE(), i = this.Ke);
      for (let e = 0; e < i.length; e++) {
        const s = i[e];
        if (s !== null && s.os === t) return s;
      }
      return null;
    }
    ZE() {
      if (!this.fg) {
        const t = this.fg;
        this.fg = true;
        let i, e = null;
        const s = this.Ve, n = s instanceof Group2 ? s : null;
        if (n !== null && !n.isSubGraphExpanded) {
          if (!n.actualBounds.isReal()) return this.fg = t, this.Ke;
          e = n, i = e.findExternalLinksConnected();
        } else s.isTreeExpanded ? i = s.findLinksConnected(this.Nl.portId) : i = s.findExternalTreeLinksConnected();
        this.Ke.length = 0;
        let o = 0;
        const r = this.Nl.getDocumentPoint(Spot2.TopLeft, Point2.a()), l = this.Nl.getDocumentPoint(Spot2.BottomRight, Point2.a()), h = Rect2.U(r.x, r.y, 0, 0);
        h.unionPoint(l), Point2.o(r), Point2.o(l);
        const f = Point2.U(h.x + h.width / 2, h.y + h.height / 2), a = this.Nl.getDocumentAngle(), c = i.iterator;
        for (; c.next(); ) {
          const g = c.value;
          if (!g.isVisible() || g.fromPort === g.toPort) continue;
          const p = g.fromPort === this.Nl || e !== null && g.fromNode !== null && g.fromNode.isMemberOf(e), y = g.computeSpot(p, this.Nl);
          if (!y.isSide()) continue;
          let x;
          if (p ? x = g.toPort : x = g.fromPort, x === null) continue;
          let S = x.part;
          if (S === null) continue;
          const b = S.findVisibleNode();
          b !== null && b !== S && (S = b, x = S.port);
          const k = g.computeOtherPoint(S, x);
          let P = f.directionPoint(k);
          a !== 0 && (P = G.Yi(P - a));
          const A = this.$E(h, y, P, g.isOrthogonal);
          let C = 0;
          A === 0 ? (C = 4, P > 180 && (P -= 360)) : A === 90 ? (C = 8, P > 270 && (P -= 360)) : A === 180 ? C = 2 : (C = 1, P < 90 && (P += 360));
          let M = this.Ke[o];
          M === void 0 ? (M = new LinkInfo(g, P, C), this.Ke[o] = M) : (M.os = g, M.vt = P, M.de = C), M.FS.c(k), o++;
        }
        Point2.o(f), this.QE();
        const u = this.Ke.length;
        let d = -1, m = 0;
        for (o = 0; o < u; o++) {
          const g = this.Ke[o];
          g !== void 0 && (g.de !== d && (d = g.de, m = 0), g.cg = m, m++);
        }
        for (d = -1, m = 0, o = u - 1; o >= 0; o--) {
          const g = this.Ke[o];
          g !== void 0 && (g.de !== d && (d = g.de, m = g.cg + 1), g.Jc = m);
        }
        this._E(this.Ke), this.t4(this.Ke), this.fg = t, Rect2.o(h);
      }
      return this.Ke;
    }
    i4(t, i) {
      return t === i ? 0 : t === null ? -1 : i === null ? 1 : t.de < i.de ? -1 : t.de > i.de ? 1 : t.vt < i.vt ? -1 : t.vt > i.vt ? 1 : 0;
    }
    QE() {
      this.Ke.sort(Knot.prototype.i4);
    }
    _E(t) {
      const i = this.Nl, e = this.Ve.portSpreading, s = Point2.a(), n = Point2.a(), o = Point2.a(), r = Point2.a();
      i.getDocumentPoint(Spot2.TopLeft, s), i.getDocumentPoint(Spot2.TopRight, n), i.getDocumentPoint(Spot2.BottomRight, o), i.getDocumentPoint(Spot2.BottomLeft, r);
      let l = 0, h = 0, f = 0, a = 0;
      if (e === 2) for (let x = 0; x < t.length; x++) {
        const S = t[x];
        if (S === null) continue;
        const b = S.os.computeThickness();
        switch (S.de) {
          case 8:
            f += b;
            break;
          case 2:
            a += b;
            break;
          case 1:
            l += b;
            break;
          default:
          case 4:
            h += b;
            break;
        }
      }
      let c = 0, u = 0, d = 1, m = n, g = o, p = 0, y = 0;
      for (let x = 0; x < t.length; x++) {
        const S = t[x];
        if (S === null) continue;
        if (c !== S.de) {
          switch (c = S.de, c) {
            case 8:
              m = o, g = r;
              break;
            case 2:
              m = r, g = s;
              break;
            case 1:
              m = s, g = n;
              break;
            default:
            case 4:
              m = n, g = o;
              break;
          }
          switch (p = g.x - m.x, y = g.y - m.y, c) {
            case 8:
              f > Math.abs(p) ? (d = Math.abs(p) / f, f = Math.abs(p)) : d = 1;
              break;
            case 2:
              a > Math.abs(y) ? (d = Math.abs(y) / a, a = Math.abs(y)) : d = 1;
              break;
            case 1:
              l > Math.abs(p) ? (d = Math.abs(p) / l, l = Math.abs(p)) : d = 1;
              break;
            default:
            case 4:
              h > Math.abs(y) ? (d = Math.abs(y) / h, h = Math.abs(y)) : d = 1;
              break;
          }
          u = 0;
        }
        const b = S.lf;
        if (e === 2) {
          let k = S.os.computeThickness();
          switch (k *= d, b.c(m), c) {
            case 8:
              b.x = m.x + p / 2 + f / 2 - u - k / 2;
              break;
            case 2:
              b.y = m.y + y / 2 + a / 2 - u - k / 2;
              break;
            case 1:
              b.x = m.x + p / 2 - l / 2 + u + k / 2;
              break;
            default:
            case 4:
              b.y = m.y + y / 2 - h / 2 + u + k / 2;
              break;
          }
          u += k;
        } else {
          let k = 0.5;
          e === 1 && (k = (S.cg + 1) / (S.Jc + 1)), b.x = m.x + p * k, b.y = m.y + y * k;
        }
      }
      Point2.o(s), Point2.o(n), Point2.o(o), Point2.o(r);
    }
    t4(t) {
      for (let i = 0; i < t.length; i++) {
        const e = t[i];
        e !== null && (e.AS = this.e4(e, i));
      }
    }
    e4(t, i) {
      const e = t.os, s = e.fromPort === this.Nl;
      let n = 0;
      switch (t.de) {
        case 1:
          n = 270;
          break;
        case 2:
          n = 180;
          break;
        case 4:
          n = 0;
          break;
        case 8:
          n = 90;
          break;
      }
      const o = e.NS(this.Ve, this.Nl, Spot2.None, s, n);
      let r = t.cg;
      if (r < 0) return o;
      const l = t.Jc;
      if (l <= 1 || !e.isOrthogonal) return o;
      const f = t.FS, a = t.lf, c = t.de === 2 || t.de === 8;
      c && (r = l - 1 - r);
      const u = Link2.lF, d = t.de === 2 || t.de === 4, m = r <= 0 ? a : this.Ke[c ? i + 1 : i - 1].lf, g = r >= l - 1 ? a : this.Ke[c ? i - 1 : i + 1].lf;
      return (d ? f.y >= m.y && f.y <= g.y : f.x >= m.x && f.x <= g.x) ? o : (d ? f.y < a.y : f.x < a.x) ? o + r * u : o + (l - 1 - r) * u;
    }
  }
  class LinkInfo {
    os;
    vt;
    de;
    FS;
    cg;
    Jc;
    lf;
    AS;
    constructor(t, i, e) {
      this.os = t, this.vt = i, this.de = e, this.FS = new Point2(), this.cg = 0, this.Jc = 0, this.lf = new Point2(), this.AS = 0;
    }
    toString() {
      return this.os.toString() + " " + this.vt.toString() + " " + this.de.toString() + ":" + this.cg.toString() + "/" + this.Jc.toString() + " " + this.lf.toString() + " " + this.AS.toString() + " " + this.FS.toString();
    }
  }
  class LinkSettings {
    Oa;
    Ea;
    Ba;
    Va;
    za;
    Xa;
    gp;
    cp;
    mp;
    dp;
    constructor() {
      this.Oa = Spot2.Default, this.Ea = Spot2.Default, this.Ba = NaN, this.Va = NaN, this.za = NaN, this.Xa = NaN, this.gp = null, this.cp = null, this.mp = 1 / 0, this.dp = 1 / 0;
    }
    copy() {
      const t = new LinkSettings();
      return t.Oa = this.Oa.T(), t.Ea = this.Ea.T(), t.Ba = this.Ba, t.Va = this.Va, t.za = this.za, t.Xa = this.Xa, t.gp = this.gp, t.cp = this.cp, t.mp = this.mp, t.dp = this.dp, t;
    }
  }
  class LinkElementSettings {
    np;
    op;
    rp;
    sp;
    $p;
    Zp;
    constructor() {
      this.np = -1 / 0, this.op = 0, this.rp = Point2.wn, this.sp = 0, this.$p = "None", this.Zp = "None";
    }
    copy() {
      const t = new LinkElementSettings();
      return t.np = this.np, t.op = this.op, t.rp = this.rp.T(), t.sp = this.sp, t.$p = this.$p, t.Zp = this.Zp, t;
    }
  }
  class Group2 extends Node2 {
    ug;
    Rt;
    La;
    B0;
    ui;
    fe;
    constructor(t, i) {
      let e;
      t === void 0 || t instanceof PanelLayout2 || typeof t == "string" ? e = t : t && (i = t), super(e), this.z = this.z | 4608, this.ug = new GSet2(), this.Rt = null, this.fe = new Layout2(), this.fe.group = this, this.La = new GSet2(), this.B0 = null, this.ui = null, i && Object.assign(this, i);
    }
    cloneProtected(t) {
      super.cloneProtected(t), this.z = this.z & -32769;
      const i = t.findInVisualTree((e) => e instanceof Placeholder2);
      i instanceof Placeholder2 ? t.Rt = i : t.Rt = null, this.fe !== null ? (t.fe = this.fe.copy(), t.fe.group = t) : (t.fe !== null && (t.fe.group = null), t.fe = null), this.ui !== null && (t.ui = this.ui.copy());
    }
    Zo(t) {
      super.Zo(t);
      const i = t.findSubGraphParts(), e = t.memberParts;
      for (; e.next(); ) {
        const s = e.value;
        if (s.g(), s.invalidateLayout(8), s.clearAdornments(), s instanceof Node2) s.invalidateConnectedLinks(i);
        else if (s instanceof Link2) {
          const n = s.labelNodes;
          for (; n.next(); ) n.value.invalidateConnectedLinks(i);
        }
      }
    }
    wc(t, i, e, s, n, o, r) {
      if (t === 3 && i === "elements") {
        if (n instanceof Placeholder2) this.Rt === null ? this.Rt = n : this.Rt !== n && U.n("Cannot insert a second Placeholder into the visual tree of a Group.");
        else if (n instanceof Panel2) {
          const l = n.findInVisualTree((h) => h instanceof Placeholder2);
          l instanceof Placeholder2 && (this.Rt === null ? this.Rt = l : this.Rt !== l && U.n("Cannot insert a second Placeholder into the visual tree of a Group."));
        }
      } else t === 4 && i === "elements" && this.Rt !== null && (s === this.Rt ? this.Rt = null : s instanceof Panel2 && this.Rt.isContainedBy(s) && (this.Rt = null));
      super.wc(t, i, e, s, n, o, r);
    }
    Cd(t, i) {
      if (super.Cd(t, i), this.isClipping && this.type !== Panel2.Spot && this.isSubGraphExpanded) {
        let e = this.resizeObject;
        e instanceof Panel2 && (e = e.findMainElement()), this.ui === null && (this.ui = new Rect2()), e.getDocumentBounds(this.ui), e instanceof Shape2 && this.ui.inflate(-e.strokeWidth, -e.strokeWidth);
      }
    }
    Th(t, i, e, s) {
      this.hasPlaceholder() && (this.rr = this.placeholder), super.Th(t, i, e, s);
    }
    ensureBounds() {
      this.isSubGraphExpanded && this.memberParts.each((i) => {
        i.ensureBounds();
      }), super.ensureBounds();
    }
    nl() {
      if (!super.nl()) return false;
      const t = this.memberParts;
      for (; t.next(); ) {
        const i = t.value;
        if (i instanceof Node2) {
          if (!i.isVisible()) continue;
          if (i.us()) return false;
        } else if (i instanceof Link2) {
          if (!i.isVisible()) continue;
          if (i.us() && i.fromNode !== this && i.toNode !== this) return false;
        }
      }
      return true;
    }
    hasPlaceholder() {
      return this.Rt !== null && this.Rt.isVisibleObject() && this.isSubGraphExpanded;
    }
    get placeholder() {
      return this.Rt;
    }
    get computesBoundsAfterDrag() {
      return (this.z & 2048) !== 0;
    }
    set computesBoundsAfterDrag(t) {
      const i = (this.z & 2048) !== 0;
      i !== t && (Debug && U.i(t, "boolean", Group2, "computesBoundsAfterDrag"), this.z = this.z ^ 2048, this.t("computesBoundsAfterDrag", i, t));
    }
    get computesBoundsIncludingLinks() {
      return (this.z & 4096) !== 0;
    }
    set computesBoundsIncludingLinks(t) {
      const i = (this.z & 4096) !== 0;
      i !== t && (Debug && U.i(t, "boolean", Group2, "computesBoundsIncludingLinks"), this.z = this.z ^ 4096, this.t("computesBoundsIncludingLinks", i, t));
    }
    get computesBoundsIncludingLocation() {
      return (this.z & 8192) !== 0;
    }
    set computesBoundsIncludingLocation(t) {
      const i = (this.z & 8192) !== 0;
      i !== t && (Debug && U.i(t, "boolean", Group2, "computesBoundsIncludingLocation"), this.z = this.z ^ 8192, this.t("computesBoundsIncludingLocation", i, t));
    }
    get handlesDragDropForMembers() {
      return (this.z & 16384) !== 0;
    }
    set handlesDragDropForMembers(t) {
      const i = (this.z & 16384) !== 0;
      i !== t && (Debug && U.i(t, "boolean", Group2, "handlesDragDropForMembers"), this.z = this.z ^ 16384, this.t("handlesDragDropForMembers", i, t));
    }
    get avoidableMembers() {
      return (this.z & 131072) !== 0;
    }
    set avoidableMembers(t) {
      const i = (this.z & 131072) !== 0;
      i !== t && (Debug && U.i(t, "boolean", Group2, "avoidableMembers"), this.z = this.z ^ 131072, this.t("avoidableMembers", i, t));
    }
    get memberParts() {
      return this.ug.iterator;
    }
    wC(t) {
      if (this.ug.add(t)) {
        t instanceof Group2 && this.La.add(t);
        const e = this.memberAdded;
        if (e !== null) {
          let s = true;
          const n = this.diagram;
          n !== null && (s = n.H, n.H = true), e(this, t), n !== null && (n.H = s);
        }
        (!this.isVisible() || !this.isSubGraphExpanded) && t.Hi(false);
      }
      if (t instanceof Link2 && !this.computesBoundsIncludingLinks) return;
      let i = this.Rt;
      i === null && (i = this), i.g();
    }
    yC(t) {
      if (this.ug.delete(t)) {
        t instanceof Group2 && this.La.delete(t);
        const e = this.memberRemoved;
        if (e !== null) {
          let s = true;
          const n = this.diagram;
          n !== null && (s = n.H, n.H = true), e(this, t), n !== null && (n.H = s);
        }
        (!this.isVisible() || !this.isSubGraphExpanded) && t.Hi(true);
      }
      if (t instanceof Link2 && !this.computesBoundsIncludingLinks) return;
      let i = this.Rt;
      i === null && (i = this), i.g();
    }
    uc() {
      if (this.ug.count > 0) {
        const t = this.diagram;
        if (t !== null) {
          const e = this.ug.copy().iterator;
          for (; e.next(); ) {
            const s = e.value;
            t.remove(s);
          }
        }
      }
      super.uc();
    }
    get layout() {
      return this.fe;
    }
    set layout(t) {
      const i = this.fe;
      if (i !== t) {
        t !== null && (U.s(t, Layout2, Group2, "layout"), t.diagram !== null && t.diagram.layout === t && U.n("A layout cannot be both the Diagram.layout and a Group.layout: " + t)), i !== null && (i.diagram = null, i.group = null), this.fe = t;
        const e = this.diagram;
        t !== null && (t.diagram = e, t.group = this), e !== null && (e.il = true), this.t("layout", i, t), e !== null && e.requestUpdate();
      }
    }
    get memberAdded() {
      return this.Bt !== null ? this.Bt.Zy : null;
    }
    set memberAdded(t) {
      const i = this.memberAdded;
      i !== t && (t !== null && U.C(t, Group2, "memberAdded"), this.Pl().Zy = t, this.t("memberAdded", i, t));
    }
    get memberRemoved() {
      return this.Bt !== null ? this.Bt.Qy : null;
    }
    set memberRemoved(t) {
      const i = this.memberRemoved;
      i !== t && (t !== null && U.C(t, Group2, "memberRemoved"), this.Pl().Qy = t, this.t("memberRemoved", i, t));
    }
    get memberValidation() {
      return this.Bt !== null ? this.Bt.xh : null;
    }
    set memberValidation(t) {
      const i = this.memberValidation;
      i !== t && (t !== null && U.C(t, Group2, "memberValidation"), this.Pl().xh = t, this.t("memberValidation", i, t));
    }
    canAddMembers(t) {
      const i = this.diagram;
      if (i === null) return false;
      const e = i.commandHandler, n = e.MN(t).iterator;
      for (; n.next(); ) {
        const o = n.value;
        if (!e.isValidMember(this, o)) return false;
      }
      return true;
    }
    addMembers(t, i) {
      const e = this.diagram;
      if (e === null) return false;
      const s = e.commandHandler, n = s.MN(t);
      let o = true;
      const r = n.iterator;
      for (; r.next(); ) {
        const l = r.value;
        !i || s.isValidMember(this, l) ? l.containingGroup = this : o = false;
      }
      return o;
    }
    get ungroupable() {
      return (this.z & 256) !== 0;
    }
    set ungroupable(t) {
      const i = (this.z & 256) !== 0;
      i !== t && (Debug && U.i(t, "boolean", Group2, "ungroupable"), this.z = this.z ^ 256, this.t("ungroupable", i, t));
    }
    canUngroup() {
      if (!this.ungroupable) return false;
      const t = this.layer;
      if (t === null || !t.allowUngroup) return false;
      const i = t.diagram;
      return !(i !== null && !i.allowUngroup);
    }
    invalidateConnectedLinks(t) {
      const i = this.s4();
      if (super.invalidateConnectedLinks(t), i) return;
      this.gL(true);
      const e = this.findExternalLinksConnected();
      for (; e.next(); ) {
        const s = e.value;
        if (t !== void 0 && t.has(s)) continue;
        const n = s.fromNode;
        if (n !== null && n !== this && n.isMemberOf(this) && !n.isVisible()) n.Ne(s.fromPort), n.Ne(s.toPort), s.ii();
        else {
          const o = s.toNode;
          o !== null && o !== this && o.isMemberOf(this) && !o.isVisible() && (o.Ne(s.fromPort), o.Ne(s.toPort), s.ii());
        }
      }
    }
    findExternalLinksConnected() {
      const t = this.diagram !== null && this.diagram.w2;
      if (t && this.B0 !== null) return this.B0.iterator;
      const i = this.findSubGraphParts();
      i.add(this);
      const e = new GSet2(), s = i.iterator;
      for (; s.next(); ) {
        const n = s.value;
        if (!(n instanceof Node2)) continue;
        const o = n.linksConnected;
        for (; o.next(); ) {
          const r = o.value;
          i.has(r) || e.add(r);
        }
      }
      return t && (this.B0 = e), e.iterator;
    }
    findExternalNodesConnected() {
      const t = this.findSubGraphParts();
      t.add(this);
      const i = new GSet2(), e = t.iterator;
      for (; e.next(); ) {
        const s = e.value;
        if (!(s instanceof Node2)) continue;
        const n = s.linksConnected;
        for (; n.next(); ) {
          const o = n.value, r = o.fromNode;
          r !== null && (!t.has(r) || r === this) && i.add(r);
          const l = o.toNode;
          l !== null && (!t.has(l) || l === this) && i.add(l);
        }
      }
      return i.iterator;
    }
    KB() {
      function t(e, s) {
        e !== null && (s.add(e), t(e.containingGroup, s));
      }
      const i = new GSet2();
      return t(this, i), i;
    }
    findSubGraphParts() {
      const t = new GSet2();
      return Part2.bh(t, this, true, 0, true), t.delete(this), t;
    }
    Hi(t) {
      super.Hi(t);
      const i = this.memberParts;
      for (; i.next(); ) i.value.Hi(t);
    }
    collapseSubGraph() {
      const t = this.diagram;
      if (t === null || t.isCollapsingExpanding) return;
      t.isCollapsingExpanding = true;
      const i = this.findSubGraphParts();
      this.NF(i, t, this), t.isCollapsingExpanding = false;
    }
    NF(t, i, e) {
      const s = this.memberParts;
      for (; s.next(); ) {
        const n = s.value;
        if (n.Hi(false), n instanceof Group2 && n.isSubGraphExpanded && (n.wasSubGraphExpanded = n.isSubGraphExpanded, n.NF(t, i, e)), n instanceof Node2) n.invalidateConnectedLinks(t), i.$f(n, e);
        else if (n instanceof Link2) {
          const o = n.labelNodes;
          for (; o.next(); ) o.value.invalidateConnectedLinks(t);
        }
      }
      this.isSubGraphExpanded = false;
    }
    expandSubGraph() {
      const t = this.diagram;
      if (t === null || t.isCollapsingExpanding) return;
      t.isCollapsingExpanding = true;
      const i = this.findSubGraphParts();
      this.CF(i, t, this), t.isCollapsingExpanding = false;
    }
    CF(t, i, e) {
      const s = this.memberParts;
      for (; s.next(); ) {
        const n = s.value;
        if (n.Hi(true), n instanceof Group2 && n.wasSubGraphExpanded && (n.wasSubGraphExpanded = false, n.CF(t, i, e)), n instanceof Node2) n.invalidateConnectedLinks(t);
        else if (n instanceof Link2) {
          const o = n.labelNodes;
          for (; o.next(); ) o.value.invalidateConnectedLinks(t);
        }
      }
      this.isSubGraphExpanded = true;
    }
    get isSubGraphExpanded() {
      return (this.z & 512) !== 0;
    }
    set isSubGraphExpanded(t) {
      const i = (this.z & 512) !== 0;
      if (i !== t) {
        Debug && U.i(t, "boolean", Group2, "isSubGraphExpanded"), this.z = this.z ^ 512;
        const e = this.diagram;
        this.t("isSubGraphExpanded", i, t);
        const s = this.subGraphExpandedChanged;
        if (s !== null) {
          let n = true;
          e !== null && (n = e.H, e.H = true), s(this), e !== null && (e.H = n);
        }
        if (e !== null && e.undoManager.isUndoingRedoing) {
          this.Rt !== null && this.Rt.g(), this.memberParts.each((n) => n.updateAdornments());
          return;
        }
        t ? this.expandSubGraph() : this.collapseSubGraph();
      }
    }
    get wasSubGraphExpanded() {
      return (this.z & 1024) !== 0;
    }
    set wasSubGraphExpanded(t) {
      const i = (this.z & 1024) !== 0;
      i !== t && (Debug && U.i(t, "boolean", Group2, "wasSubGraphExpanded"), this.z = this.z ^ 1024, this.t("wasSubGraphExpanded", i, t));
    }
    get subGraphExpandedChanged() {
      return this.Bt !== null ? this.Bt._y : null;
    }
    set subGraphExpandedChanged(t) {
      const i = this.subGraphExpandedChanged;
      i !== t && (t !== null && U.C(t, Group2, "subGraphExpandedChanged"), this.Pl()._y = t, this.t("subGraphExpandedChanged", i, t));
    }
    move(t, i) {
      i === void 0 && (i = false);
      const e = i ? this.location : this.position, s = e.x, n = e.y, o = t.x, r = t.y;
      if ((s === o || isNaN(s) && isNaN(o)) && (n === r || isNaN(n) && isNaN(r))) return;
      const l = o - (isNaN(s) ? 0 : s), h = r - (isNaN(n) ? 0 : n), f = Point2.a();
      super.move(t, i);
      const a = new GSet2(), u = this.findSubGraphParts().iterator;
      for (; u.next(); ) {
        const d = u.value;
        d instanceof Link2 && (d.suspendsRouting && a.add(d), !(!d.Be && (d.fromNode === this || d.toNode === this)) && (d.suspendsRouting = true));
      }
      for (u.reset(); u.next(); ) {
        const d = u.value;
        if (d.Rr() || d instanceof Node2 && d.isLinkLabel) continue;
        const m = d.position, g = d.location;
        m.isReal() ? (f.x = m.x + l, f.y = m.y + h, d.position = f) : g.isReal() && (f.x = g.x + l, f.y = g.y + h, d.location = f);
      }
      for (u.reset(); u.next(); ) {
        const d = u.value;
        if (!(d instanceof Link2) || (d.suspendsRouting = a.has(d), !d.Be && (d.fromNode === this || d.toNode === this))) continue;
        const m = d.position;
        f.x = m.x + l, f.y = m.y + h, f.isReal() ? d.move(f) : d.ii();
      }
      Point2.o(f);
    }
    s4() {
      return (this.z & 65536) !== 0;
    }
    gL(t) {
      (this.z & 65536) !== 0 !== t && (this.z = this.z ^ 65536);
    }
    get Da() {
      return (this.z & 32768) !== 0;
    }
    set Da(t) {
      (this.z & 32768) !== 0 !== t && (this.z = this.z ^ 32768);
    }
  }
  class Placeholder2 extends GraphObject2 {
    si;
    dg;
    constructor(t) {
      super(), this.si = Margin2.lm, this.dg = new Rect2(NaN, NaN, NaN, NaN), t && Object.assign(this, t);
    }
    cloneProtected(t) {
      super.cloneProtected(t), t.si = this.si.T(), t.dg = this.dg.copy();
    }
    Ah(t) {
      if (this.background === null) return false;
      const i = this.naturalBounds;
      return Rect2.contains(0, 0, i.width, i.height, t.x, t.y);
    }
    Nd(t, i, e, s) {
      const n = this.part;
      if ((n === null || !(n instanceof Group2) && !(n instanceof Adornment2)) && U.n("Placeholder is not inside a Group or Adornment."), n instanceof Group2) {
        const o = this.computeBorder(this.dg), r = this.minSize, l = isFinite(r.width) ? Math.max(r.width, o.width) : o.width, h = isFinite(r.height) ? Math.max(r.height, o.height) : o.height, f = this.ji;
        f.Zn(l || 0, h || 0), this.co(0, 0, f.width, f.height);
        const a = n.memberParts;
        let c = false;
        for (; a.next(); ) if (a.value.isVisible()) {
          c = true;
          break;
        }
        const u = n.diagram;
        if (c && u !== null && !u.animationManager.FM(n) && !isNaN(o.x) && !isNaN(o.y)) {
          const d = Point2.a();
          d.setRectSpot(o, n.locationSpot), n.location = d, Point2.o(d);
        }
      } else {
        const o = n, r = this.ji, l = this.si, h = l.left + l.right, f = l.top + l.bottom, a = o.adornedObject, c = a.getDocumentAngle();
        o.angle = c;
        let u = 0;
        a instanceof Shape2 && (u = a.strokeWidth);
        const d = a.getDocumentScale(), m = a.naturalBounds, g = (m.width + u) * d, p = (m.height + u) * d;
        if (o.type !== Panel2.Link) {
          const y = o.category === "Selection" ? Spot2.TopLeft : o.locationSpot, x = a.getDocumentPoint(y, Point2.a());
          o.location = x, Point2.o(x);
        }
        if (!isNaN(g) && !isNaN(p)) r.Zn(g + h || 0, p + f || 0), this.co(-l.left, -l.top, r.width, r.height);
        else {
          const y = a.getDocumentPoint(Spot2.TopLeft, Point2.a()), x = Rect2.U(y.x, y.y, 0, 0);
          x.unionPoint(a.getDocumentPoint(Spot2.BottomRight, y)), x.unionPoint(a.getDocumentPoint(Spot2.TopRight, y)), x.unionPoint(a.getDocumentPoint(Spot2.BottomLeft, y)), r.Zn(x.width + h || 0, x.height + f || 0), this.co(-l.left, -l.top, r.width, r.height), Point2.o(y), Rect2.o(x);
        }
      }
    }
    Th(t, i, e, s) {
      this.actualBounds.e(t, i, e, s);
    }
    computeBorder(t) {
      const i = this.part, e = i.diagram;
      if (e === null || e.animationManager.isAnimating) return t;
      if (i instanceof Group2 && !i.layer.isTemporary && i.computesBoundsAfterDrag && this.dg.isReal()) {
        const r = e.toolManager.findTool("Dragging");
        if (r === e.currentTool && r.kR(i, this.dg, t)) return t;
      }
      const s = Rect2.a(), n = this.computeMemberBounds(s), o = this.si;
      return i instanceof Group2 && !i.isSubGraphExpanded ? t.e(n.x - o.left, n.y - o.top, 0, 0) : t.e(n.x - o.left, n.y - o.top, Math.max(n.width + o.left + o.right, 0), Math.max(n.height + o.top + o.bottom, 0)), Rect2.o(s), i instanceof Group2 && i.computesBoundsIncludingLocation && i.location.isReal() && t.unionPoint(i.location), t;
    }
    computeMemberBounds(t) {
      if (!(this.part instanceof Group2)) return t.e(0, 0, 0, 0), t;
      const i = this.part;
      let e = 1 / 0, s = 1 / 0, n = -1 / 0, o = -1 / 0;
      const r = i.memberParts;
      for (; r.next(); ) {
        const l = r.value;
        if (!l.isVisible() || l instanceof Link2 && (!i.computesBoundsIncludingLinks || l.Wo() || l.fromNode === i || l.toNode === i)) continue;
        const h = l.actualBounds;
        h.left < e && (e = h.left), h.top < s && (s = h.top), h.right > n && (n = h.right), h.bottom > o && (o = h.bottom);
      }
      if (!isFinite(e) || !isFinite(s)) {
        const l = i.location;
        t.e(l.x, l.y, 0, 0);
      } else t.e(e, s, n - e, o - s);
      return t;
    }
    get padding() {
      return this.si;
    }
    set padding(t) {
      typeof t == "number" ? t = new Margin2(t) : U.s(t, Margin2, Placeholder2, "padding");
      const i = this.si;
      i.equals(t) || (t = t.T(), this.si = t, this.t("padding", i, t), this.g());
    }
  }
  class Layout2 {
    f;
    Fa;
    gg;
    Or;
    mg;
    pg;
    Go;
    Cl;
    yg;
    wg;
    Co;
    constructor(t) {
      GSet2._i(this), this.f = null, this.Fa = null, this.gg = true, this.Or = true, this.mg = false, this.pg = new Point2(0, 0), this.Go = true, this.Cl = null, this.yg = null, this.wg = false, this.Co = null, t && Object.assign(this, t);
    }
    cloneProtected(t) {
      t.gg = this.gg, t.Or = this.Or, t.mg = this.mg, t.pg.c(this.pg), t.Go = this.Go, t.Cl = this.Cl, t.yg = this.yg, t.wg = true;
    }
    copy() {
      const t = new this.constructor();
      return this.cloneProtected(t), t;
    }
    gi(t) {
      U.xr(this, t);
    }
    toString() {
      let t = U.$n(this.constructor);
      return t += "(", this.group !== null && (t += " in " + this.group), this.diagram !== null && (t += " for " + this.diagram), t += ")", t;
    }
    get diagram() {
      return this.f;
    }
    set diagram(t) {
      Debug && t !== null && U.s(t, Diagram2, Layout2, "diagram"), this.f = t;
    }
    get group() {
      return this.Fa;
    }
    set group(t) {
      this.Fa !== t && (Debug && t !== null && U.s(t, Group2, Layout2, "group"), this.Fa = t, t !== null && (this.f = t.diagram));
    }
    get isOngoing() {
      return this.gg;
    }
    set isOngoing(t) {
      this.gg !== t && (U.i(t, "boolean", Layout2, "isOngoing"), this.gg = t);
    }
    get isInitial() {
      return this.Or;
    }
    set isInitial(t) {
      U.i(t, "boolean", Layout2, "isInitial"), this.Or = t, t || (this.wg = true);
    }
    get isViewportSized() {
      return this.mg;
    }
    set isViewportSized(t) {
      this.mg !== t && (U.i(t, "boolean", Layout2, "isViewportSized"), this.mg = t, t && this.b());
    }
    get isRouting() {
      return this.Go;
    }
    set isRouting(t) {
      this.Go !== t && (U.i(t, "boolean", Layout2, "isRouting"), this.Go = t);
    }
    get isRealtime() {
      return this.Cl;
    }
    set isRealtime(t) {
      this.Cl !== t && (t !== null && U.i(t, "boolean", Layout2, "isRealtime"), this.Cl = t);
    }
    get isValidLayout() {
      return this.wg;
    }
    set isValidLayout(t) {
      if (this.wg !== t && (U.i(t, "boolean", Layout2, "isValidLayout"), this.wg = t, !t)) {
        const i = this.diagram;
        i !== null && (i.il = true);
      }
    }
    invalidateLayout() {
      if (!this.isValidLayout) return;
      const t = this.diagram;
      if (t === null || t.undoManager.isUndoingRedoing) return;
      const i = t.animationManager;
      i.isTicking || (i.defaultAnimation.isAnimating && i.stopAnimation(), (this.isOngoing && t.sa || this.isInitial && !t.sa) && (this.isValidLayout = false, t.requestUpdate()));
    }
    b() {
      this.invalidateLayout();
    }
    get network() {
      return this.Co;
    }
    set network(t) {
      this.Co !== t && (Debug && t !== null && U.s(t, LayoutNetwork2, Layout2, "network"), this.Co = t, t !== null && (t.layout = this));
    }
    createNetwork() {
      return new LayoutNetwork2(this);
    }
    makeNetwork(t) {
      const i = this.createNetwork();
      return t instanceof Diagram2 ? (i.addParts(t.nodes, true), i.addParts(t.links, true)) : t instanceof Group2 ? i.addParts(t.memberParts) : i.addParts(t.iterator), i;
    }
    updateParts() {
      this.isValidLayout = true;
      let t = this.diagram;
      if (t === null && this.network !== null) {
        const i = this.network.vertexes.iterator;
        for (; i.next(); ) {
          const s = i.value.node;
          if (s !== null && (t = s.diagram, t !== null)) break;
        }
      }
      try {
        t !== null && t.startTransaction("Layout"), this.commitLayout();
      } finally {
        t !== null && t.commitTransaction("Layout");
      }
    }
    commitLayout() {
      if (this.network === null) return;
      const t = this.network.vertexes.iterator;
      for (; t.next(); ) t.value.commit();
      if (this.isRouting) {
        const i = this.network.edges.iterator;
        for (; i.next(); ) i.value.commit();
      }
    }
    doLayout(t) {
      Debug && t === null && U.n("Layout.doLayout(collection) argument must not be null but a Diagram, a Group, or an Iterable of Parts");
      const i = new GSet2();
      if (t instanceof Diagram2 ? (this.Yh(i, t.nodes, true, this.Da, true, false, true), this.Yh(i, t.parts, true, this.Da, true, false, true)) : t instanceof Group2 ? this.Yh(i, t.memberParts, false, this.Da, true, false, true) : i.addAll(t.iterator), i.count > 0) {
        const s = this.diagram;
        s !== null && s.startTransaction("Layout"), this.doMinimalNoNetworkLayout(i), s !== null && s.commitTransaction("Layout");
      }
      this.isValidLayout = true;
    }
    doMinimalNoNetworkLayout(t) {
      const i = t.count, e = Math.ceil(Math.sqrt(i));
      this.arrangementOrigin = this.initialOrigin(this.arrangementOrigin);
      const s = this.arrangementOrigin.x, n = this.arrangementOrigin.y;
      let o = s, r = n, l = 0, h = 0;
      const f = t.iterator;
      for (; f.next(); ) {
        const a = f.value;
        a.ensureBounds();
        const c = a.measuredBounds, u = c.width, d = c.height;
        a.moveTo(o, r), a instanceof Group2 && (a.Da = false), o += Math.max(u, 50) + 20, h = Math.max(h, Math.max(d, 50)), l >= e - 1 ? (l = 0, o = s, r += h + 20, h = 0) : l++;
      }
    }
    Da(t) {
      return !!(!t.location.isReal() && !t.position.isReal() || t instanceof Group2 && t.Da);
    }
    Yh(t, i, e, s, n, o, r) {
      const l = i.iterator;
      for (; l.next(); ) {
        const h = l.value;
        if (!(e && !h.isTopLevel) && !(s !== null && !s(h)) && h.canLayout()) if (n && h instanceof Node2) {
          if (h.isLinkLabel) continue;
          h instanceof Group2 && h.layout === null ? this.Yh(t, h.memberParts, false, s, n, o, r) : (h.ensureBounds(), t.add(h));
        } else o && h instanceof Link2 ? t.add(h) : r && h.Oe() && !(h instanceof Node2) && (h.ensureBounds(), t.add(h));
      }
    }
    getLayoutBounds(t, i) {
      const e = this.boundsComputation;
      return e !== null ? (i || (i = new Rect2()), e(t, this, i)) : !i && t.margin.equalTo(0, 0, 0, 0) ? t.actualBounds : (i || (i = new Rect2()), i.set(t.actualBounds), i.addMargin(t.margin), i);
    }
    get boundsComputation() {
      return this.yg;
    }
    set boundsComputation(t) {
      this.yg !== t && (t !== null && U.C(t, Layout2, "boundsComputation"), this.yg = t, this.b());
    }
    collectParts(t) {
      const i = new GSet2();
      return t instanceof Diagram2 ? (this.Yh(i, t.nodes, true, null, true, true, true), this.Yh(i, t.links, true, null, true, true, true), this.Yh(i, t.parts, true, null, true, true, true)) : t instanceof Group2 ? this.Yh(i, t.memberParts, false, null, true, true, true) : this.Yh(i, t.iterator, false, null, true, true, true), i;
    }
    get arrangementOrigin() {
      return this.pg;
    }
    set arrangementOrigin(t) {
      Debug && U.s(t, Point2, Layout2, "arrangementOrigin"), this.pg.equals(t) || (this.pg.c(t), this.b());
    }
    initialOrigin(t) {
      const i = this.group;
      if (i !== null) if (i.hasPlaceholder()) {
        const e = i.placeholder, s = e.getDocumentPoint(Spot2.TopLeft);
        (isNaN(s.x) || isNaN(s.y)) && s.set(t);
        const n = e.padding;
        return s.x += n.left, s.y += n.top, s;
      } else {
        const e = i.position.copy();
        return (isNaN(e.x) || isNaN(e.y)) && e.set(t), e;
      }
      return t;
    }
  }
  class LayoutNetwork2 {
    fe;
    Ao;
    Yn;
    ow;
    lw;
    constructor(t) {
      GSet2._i(this), Debug && !t && U.n("LayoutNetwork constructor requires non-null Layout argument"), this.fe = t, this.Ao = new GSet2(), this.Yn = new GSet2(), this.ow = new GMap2(), this.lw = new GMap2();
    }
    clear() {
      if (this.Ao) {
        const t = this.Ao.iterator;
        for (; t.next(); ) t.value.clear();
      }
      if (this.Yn) {
        const t = this.Yn.iterator;
        for (; t.next(); ) t.value.clear();
      }
      this.Ao = new GSet2(), this.Yn = new GSet2(), this.ow = new GMap2(), this.lw = new GMap2();
    }
    toString(t) {
      t === void 0 && (t = 0);
      let i = "LayoutNetwork" + (this.layout !== null ? "(" + this.layout.toString() + ")" : "");
      if (t <= 0) return i;
      if (i += " vertexes: " + this.Ao.count + " edges: " + this.Yn.count, t > 1) {
        const e = this.Ao.iterator;
        for (; e.next(); ) {
          const n = e.value;
          i += `
    ` + n.toString(t - 1);
        }
        const s = this.Yn.iterator;
        for (; s.next(); ) {
          const n = s.value;
          i += `
    ` + n.toString(t - 1);
        }
      }
      return i;
    }
    get layout() {
      return this.fe;
    }
    set layout(t) {
      t !== null && (this.fe = t);
    }
    get vertexes() {
      return this.Ao;
    }
    get edges() {
      return this.Yn;
    }
    createVertex() {
      return new LayoutVertex2(this);
    }
    createEdge() {
      return new LayoutEdge2(this);
    }
    addParts(t, i, e) {
      if (t === null) return;
      i === void 0 && (i = false), U.i(i, "boolean", LayoutNetwork2, "addParts:toplevelonly"), e === void 0 && (e = null), e === null && (e = (n) => {
        if (n instanceof Node2) return !n.isLinkLabel;
        if (n instanceof Link2) {
          const o = n.fromNode;
          if (o === null || o.isLinkLabel) return false;
          const r = n.toNode;
          return !(r === null || r.isLinkLabel);
        }
        return false;
      });
      const s = t.iterator;
      for (; s.next(); ) {
        const n = s.value;
        if (n instanceof Node2 && !(i && !n.isTopLevel) && n.canLayout() && e(n)) if (n instanceof Group2 && n.layout === null) this.addParts(n.memberParts, false);
        else {
          if (this.findVertex(n) !== null) continue;
          const o = this.createVertex();
          o.node = n, this.addVertex(o);
        }
      }
      for (s.reset(); s.next(); ) {
        const n = s.value;
        if (!(n instanceof Link2) || i && !n.isTopLevel || !n.canLayout() || !e(n) || this.findEdge(n) !== null) continue;
        const o = n.fromNode, r = n.toNode;
        if (o === null || r === null || o === r) continue;
        const l = this.findGroupVertex(o), h = this.findGroupVertex(r);
        this.linkVertexes(l, h, n);
      }
    }
    findGroupVertex(t) {
      const i = t.findVisibleNode();
      if (i === null) return null;
      let e = this.findVertex(i);
      if (e !== null) return e;
      let s = i.containingGroup;
      for (; s !== null; ) {
        if (e = this.findVertex(s), e !== null) return e;
        s = s.containingGroup;
      }
      return null;
    }
    addVertex(t) {
      Debug && U.s(t, LayoutVertex2, LayoutNetwork2, "addVertex:vertex"), this.Ao.add(t);
      const i = t.node;
      i !== null && this.ow.set(i, t), t.network = this;
    }
    addNode(t) {
      Debug && U.s(t, Node2, LayoutNetwork2, "addNode:node");
      let i = this.findVertex(t);
      return i === null && (i = this.createVertex(), i.node = t, this.addVertex(i)), i;
    }
    deleteVertex(t) {
      if (Debug && U.s(t, LayoutVertex2, LayoutNetwork2, "deleteVertex:vertex"), this.AF(t)) {
        let i = t.ar;
        for (let e = i.count - 1; e >= 0; e--) {
          const s = i.elt(e);
          this.deleteEdge(s);
        }
        i = t.fr;
        for (let e = i.count - 1; e >= 0; e--) {
          const s = i.elt(e);
          this.deleteEdge(s);
        }
      }
    }
    AF(t) {
      const i = this.Ao.delete(t);
      if (i) {
        const e = t.node;
        e !== null && this.ow.delete(e);
      }
      return i;
    }
    deleteNode(t) {
      Debug && U.s(t, Node2, LayoutNetwork2, "deleteNode:node");
      const i = this.findVertex(t);
      i !== null && this.deleteVertex(i);
    }
    findVertex(t) {
      return Debug && U.s(t, Node2, LayoutNetwork2, "findVertex:node"), this.ow.get(t);
    }
    addEdge(t) {
      Debug && U.s(t, LayoutEdge2, LayoutNetwork2, "addEdge:edge"), this.GC(t);
      const i = t.toVertex;
      i !== null && i.addSourceEdge(t);
      const e = t.fromVertex;
      e !== null && e.addDestinationEdge(t);
    }
    GC(t) {
      this.Yn.add(t);
      const i = t.link;
      i !== null && this.findEdge(i) === null && this.lw.set(i, t), t.network = this;
    }
    addLink(t) {
      Debug && U.s(t, Link2, LayoutNetwork2, "addLink:link");
      const i = t.fromNode, e = t.toNode;
      let s = this.findEdge(t);
      return s === null ? (s = this.createEdge(), s.link = t, i !== null && (s.fromVertex = this.addNode(i)), e !== null && (s.toVertex = this.addNode(e)), this.addEdge(s)) : (i !== null ? s.fromVertex = this.addNode(i) : s.fromVertex = null, e !== null ? s.toVertex = this.addNode(e) : s.toVertex = null), s;
    }
    deleteEdge(t) {
      Debug && U.s(t, LayoutEdge2, LayoutNetwork2, "deleteEdge:edge");
      const i = t.toVertex;
      i !== null && i.deleteSourceEdge(t);
      const e = t.fromVertex;
      e !== null && e.deleteDestinationEdge(t), this.qC(t);
    }
    qC(t) {
      const i = this.Yn.delete(t);
      if (i) {
        const e = t.link;
        e !== null && this.lw.delete(e);
      }
      return i;
    }
    deleteLink(t) {
      Debug && U.s(t, Link2, LayoutNetwork2, "deleteLink:link");
      const i = this.findEdge(t);
      i !== null && this.deleteEdge(i);
    }
    findEdge(t) {
      return Debug && U.s(t, Link2, LayoutNetwork2, "findEdge:link"), this.lw.get(t);
    }
    linkVertexes(t, i, e) {
      if (t === null || i === null) return null;
      if (Debug && (U.s(t, LayoutVertex2, LayoutNetwork2, "linkVertexes:fromVertex"), U.s(i, LayoutVertex2, LayoutNetwork2, "linkVertexes:toVertex"), e !== null && U.s(e, Link2, LayoutNetwork2, "linkVertexes:link")), t.network === this && i.network === this) {
        const s = this.createEdge();
        return s.link = e, s.fromVertex = t, s.toVertex = i, this.addEdge(s), s;
      }
      return null;
    }
    reverseEdge(t) {
      Debug && U.s(t, LayoutEdge2, LayoutNetwork2, "reverseEdge:edge");
      const i = t.fromVertex, e = t.toVertex;
      i === null || e === null || (i.deleteDestinationEdge(t), e.deleteSourceEdge(t), t.reverseEdge(), i.addSourceEdge(t), e.addDestinationEdge(t));
    }
    deleteSelfEdges() {
      const t = U.ft(), i = this.Yn.iterator;
      for (; i.next(); ) {
        const s = i.value;
        s.fromVertex === s.toVertex && t.push(s);
      }
      const e = t.length;
      for (let s = 0; s < e; s++) this.deleteEdge(t[s]);
      U.et(t);
    }
    deleteArtificialVertexes() {
      const t = U.ft(), i = this.Ao.iterator;
      for (; i.next(); ) {
        const o = i.value;
        o.node === null && o.data === null && t.push(o);
      }
      let e = t.length;
      for (let o = 0; o < e; o++) this.deleteVertex(t[o]);
      const s = U.ft(), n = this.Yn.iterator;
      for (; n.next(); ) {
        const o = n.value;
        o.link === null && o.data === null && s.push(o);
      }
      e = s.length;
      for (let o = 0; o < e; o++) this.deleteEdge(s[o]);
      U.et(t), U.et(s);
    }
    deleteUselessEdges() {
      const t = U.ft(), i = this.Yn.iterator;
      for (; i.next(); ) {
        const s = i.value;
        (s.fromVertex === null || s.toVertex === null) && t.push(s);
      }
      const e = t.length;
      for (let s = 0; s < e; s++) this.deleteEdge(t[s]);
      U.et(t);
    }
    isSingleton(t) {
      return !(t.ar.count > 0 || t.fr.count > 0);
    }
    splitIntoSubNetworks(t) {
      t === void 0 && (t = true), t && (this.deleteArtificialVertexes(), this.deleteUselessEdges(), this.deleteSelfEdges());
      const i = new List2();
      let e = true;
      for (; e; ) {
        e = false;
        const s = this.Ao.iterator;
        for (; s.next(); ) {
          const n = s.value;
          if (this.isSingleton(n)) continue;
          const o = this.layout.createNetwork();
          i.add(o), this.n4(o, n), e = true;
          break;
        }
      }
      return i.sort((s, n) => s === null || n === null || s === n ? 0 : n.vertexes.count - s.vertexes.count), i;
    }
    n4(t, i) {
      if (i === null) return;
      const e = new List2();
      for (e.add(i); e.count > 0; ) {
        const s = e.first();
        if (e.removeAt(0), !s || s.network === t) continue;
        this.AF(s), t.addVertex(s);
        let n = s.sourceEdges;
        for (; n.next(); ) {
          const o = n.value;
          o.network !== t && (this.qC(o), t.GC(o), o.fromVertex && e.add(o.fromVertex));
        }
        for (n = s.destinationEdges; n.next(); ) {
          const o = n.value;
          o.network !== t && (this.qC(o), t.GC(o), o.toVertex && e.add(o.toVertex));
        }
      }
    }
    findAllParts() {
      const t = new GSet2(), i = this.Ao.iterator;
      for (; i.next(); ) {
        const s = i.value;
        s.node && t.add(s.node);
      }
      const e = this.Yn.iterator;
      for (; e.next(); ) {
        const s = e.value;
        s.link && t.add(s.link);
      }
      return t;
    }
  }
  class LayoutVertex2 {
    Co;
    oi;
    Ve;
    Ue;
    rs;
    ar;
    fr;
    constructor(t) {
      GSet2._i(this), Debug && !t && U.n("LayoutVertex constructor requires non-null LayoutNetwork argument"), this.Co = t, this.Ue = new Rect2(0, 0, 10, 10), this.rs = new Point2(5, 5), this.oi = null, this.Ve = null, this.ar = new List2(), this.fr = new List2();
    }
    clear() {
      this.oi = null, this.Ve = null, this.ar = new List2(), this.fr = new List2();
    }
    toString(t) {
      t === void 0 && (t = 0);
      let i = "LayoutVertex#" + GSet2.Ps(this);
      if (t > 0 && (i += this.node !== null ? "(" + this.node.toString() + ")" : "", t > 1)) {
        let e = "", s = true, n = this.ar.iterator;
        for (; n.next(); ) {
          const r = n.value;
          s ? s = false : e += ",", e += r.toString(0);
        }
        let o = "";
        for (s = true, n = this.fr.iterator; n.next(); ) {
          const r = n.value;
          s ? s = false : o += ",", o += r.toString(0);
        }
        i += " sources: " + e + " destinations: " + o;
      }
      return i;
    }
    get To() {
      return this.ar.IA;
    }
    get cr() {
      return this.fr.IA;
    }
    get data() {
      return this.oi;
    }
    set data(t) {
      if (this.oi = t, t !== null && t.bounds) {
        const i = t.bounds, e = i.x, s = i.y, n = i.width, o = i.height;
        this.rs.e(n / 2, o / 2), this.Ue.e(e, s, n, o);
      }
    }
    get node() {
      return this.Ve;
    }
    set node(t) {
      if (this.Ve !== t) {
        if (Debug && t !== null && U.s(t, Node2, LayoutVertex2, "node"), this.Ve = t, t === null) return;
        t.ensureBounds();
        const i = this.network.layout, e = Rect2.a(), s = i.getLayoutBounds(t, e);
        let n = s.x, o = s.y;
        const r = s.width, l = s.height;
        if (isNaN(n) && (n = 0), isNaN(o) && (o = 0), this.Ue.e(n, o, r, l), Rect2.o(e), !(t instanceof Group2)) {
          const h = t.locationObject.getDocumentPoint(Spot2.Center);
          if (h.isReal()) {
            this.rs.e(h.x - n, h.y - o);
            return;
          }
        }
        this.rs.e(r / 2, l / 2);
      }
    }
    get bounds() {
      return this.Ue;
    }
    set bounds(t) {
      this.Ue.equals(t) || (Debug && U.s(t, Rect2, LayoutVertex2, "bounds"), this.Ue.c(t));
    }
    get focus() {
      return this.rs;
    }
    set focus(t) {
      this.rs.equals(t) || (Debug && U.s(t, Point2, LayoutVertex2, "focus"), this.rs.c(t));
    }
    get centerX() {
      return this.Ue.x + this.rs.x;
    }
    set centerX(t) {
      const i = this.Ue;
      i.x + this.rs.x !== t && (Debug && U.r(t, LayoutVertex2, "centerX"), i.x = t - this.rs.x);
    }
    get centerY() {
      return this.Ue.y + this.rs.y;
    }
    set centerY(t) {
      const i = this.Ue;
      i.y + this.rs.y !== t && (Debug && U.r(t, LayoutVertex2, "centerY"), i.y = t - this.rs.y);
    }
    get focusX() {
      return this.rs.x;
    }
    set focusX(t) {
      const i = this.rs;
      i.x !== t && (i.x = t);
    }
    get focusY() {
      return this.rs.y;
    }
    set focusY(t) {
      const i = this.rs;
      i.y !== t && (i.y = t);
    }
    get x() {
      return this.Ue.x;
    }
    set x(t) {
      const i = this.Ue;
      i.x !== t && (i.x = t);
    }
    get y() {
      return this.Ue.y;
    }
    set y(t) {
      const i = this.Ue;
      i.y !== t && (i.y = t);
    }
    get width() {
      return this.Ue.width;
    }
    set width(t) {
      const i = this.Ue;
      i.width !== t && (i.width = t);
    }
    get height() {
      return this.Ue.height;
    }
    set height(t) {
      const i = this.Ue;
      i.height !== t && (i.height = t);
    }
    commit() {
      const t = this.oi;
      if (t !== null) {
        const e = this.bounds, s = t.bounds;
        U.it(s) ? (s.x = e.x, s.y = e.y, s.width = e.width, s.height = e.height) : t.bounds = e.copy();
        return;
      }
      const i = this.node;
      if (i !== null) {
        const e = this.bounds;
        if (!(i instanceof Group2)) {
          const s = Rect2.a();
          i.ensureBounds();
          const n = this.network.layout.getLayoutBounds(i, s), o = i.locationObject.getDocumentPoint(Spot2.Center);
          if (n.isReal() && o.isReal()) {
            i.moveTo(e.x + this.focusX - (o.x - n.x) + i.margin.left, e.y + this.focusY - (o.y - n.y + i.margin.top)), Rect2.o(s);
            return;
          }
          Rect2.o(s);
        }
        i.moveTo(e.x + i.margin.left, e.y + i.margin.top);
      }
    }
    addSourceEdge(t) {
      t !== null && (Debug && U.s(t, LayoutEdge2, LayoutVertex2, "addSourceEdge:edge"), this.ar.has(t) || this.ar.add(t));
    }
    deleteSourceEdge(t) {
      t !== null && (Debug && U.s(t, LayoutEdge2, LayoutVertex2, "deleteSourceEdge:edge"), this.ar.delete(t));
    }
    addDestinationEdge(t) {
      t !== null && (Debug && U.s(t, LayoutEdge2, LayoutVertex2, "addDestinationEdge:edge"), this.fr.has(t) || this.fr.add(t));
    }
    deleteDestinationEdge(t) {
      t !== null && (Debug && U.s(t, LayoutEdge2, LayoutVertex2, "deleteDestinationEdge:edge"), this.fr.delete(t));
    }
    get network() {
      return this.Co;
    }
    set network(t) {
      Debug && U.s(t, LayoutNetwork2, LayoutVertex2, "network"), this.Co = t;
    }
    get sourceVertexes() {
      const t = new GSet2(), i = this.sourceEdges;
      for (; i.next(); ) {
        const e = i.value;
        e.fromVertex && t.add(e.fromVertex);
      }
      return t.iterator;
    }
    get destinationVertexes() {
      const t = new GSet2(), i = this.destinationEdges;
      for (; i.next(); ) {
        const e = i.value;
        e.toVertex && t.add(e.toVertex);
      }
      return t.iterator;
    }
    get vertexes() {
      const t = new GSet2();
      let i = this.sourceEdges;
      for (; i.next(); ) {
        const e = i.value;
        e.fromVertex && t.add(e.fromVertex);
      }
      for (i = this.destinationEdges; i.next(); ) {
        const e = i.value;
        e.toVertex && t.add(e.toVertex);
      }
      return t.iterator;
    }
    get sourceEdges() {
      return this.ar.iterator;
    }
    get destinationEdges() {
      return this.fr.iterator;
    }
    get edges() {
      const t = new List2();
      let i = this.sourceEdges;
      for (; i.next(); ) {
        const e = i.value;
        t.add(e);
      }
      for (i = this.destinationEdges; i.next(); ) {
        const e = i.value;
        t.add(e);
      }
      return t.iterator;
    }
    get edgesCount() {
      return this.ar.count + this.fr.count;
    }
    static standardComparer(t, i) {
      Debug && U.s(t, LayoutVertex2, LayoutVertex2, "standardComparer:m"), Debug && U.s(i, LayoutVertex2, LayoutVertex2, "standardComparer:n");
      const e = t.Ve, s = i.Ve;
      if (e) if (s) {
        const n = e.text, o = s.text;
        return n < o ? -1 : n > o ? 1 : 0;
      } else return 1;
      else return s !== null ? -1 : 0;
    }
    static smartComparer(t, i) {
      if (Debug && U.s(t, LayoutVertex2, LayoutVertex2, "smartComparer:m"), Debug && U.s(i, LayoutVertex2, LayoutVertex2, "smartComparer:n"), t !== null) if (i !== null) {
        const e = t.Ve, s = i.Ve;
        if (e !== null) if (s !== null) {
          const n = e.text.toLocaleLowerCase(), o = s.text.toLocaleLowerCase(), r = n.split(/([+-]?[.]?\d+(?:\.\d*)?(?:e[+-]?\d+)?)/), l = o.split(/([+-]?[.]?\d+(?:\.\d*)?(?:e[+-]?\d+)?)/);
          let h = 0;
          for (; h < r.length; h++) if (l[h] !== "" && l[h] !== void 0) {
            const f = parseFloat(r[h]), a = parseFloat(l[h]);
            if (isNaN(f)) if (isNaN(a)) {
              if (r[h].localeCompare(l[h]) !== 0) return r[h].localeCompare(l[h]);
              continue;
            } else return 1;
            else {
              if (isNaN(a)) return -1;
              if (f - a !== 0) return f - a;
              continue;
            }
          } else {
            if (r[h] === "") continue;
            return 1;
          }
          return l[h] !== "" && l[h] !== void 0 ? -1 : 0;
        } else return 1;
        else return s !== null ? -1 : 0;
      } else return 1;
      else return i !== null ? -1 : 0;
    }
  }
  class LayoutEdge2 {
    Co;
    oi;
    os;
    ls;
    hs;
    constructor(t) {
      GSet2._i(this), Debug && !t && U.n("LayoutEdge constructor requires non-null LayoutNetwork argument"), this.Co = t, this.oi = null, this.os = null, this.ls = null, this.hs = null;
    }
    clear() {
      this.oi = null, this.os = null, this.ls = null, this.hs = null;
    }
    toString(t) {
      t === void 0 && (t = 0);
      let i = "LayoutEdge#" + GSet2.Ps(this);
      return t > 0 && (i += this.os !== null ? "(" + this.os.toString() + ")" : "", t > 1 && (i += " " + (this.ls ? this.ls.toString() : "null") + " --> " + (this.hs ? this.hs.toString() : "null"))), i;
    }
    reverseEdge() {
      const t = this.ls;
      this.ls = this.hs, this.hs = t;
    }
    commit() {
    }
    getOtherVertex(t) {
      return Debug && U.s(t, LayoutVertex2, LayoutEdge2, "getOtherVertex:v"), this.hs === t ? this.ls : this.ls === t ? this.hs : null;
    }
    get network() {
      return this.Co;
    }
    set network(t) {
      Debug && U.s(t, LayoutNetwork2, LayoutEdge2, "network"), this.Co = t;
    }
    get data() {
      return this.oi;
    }
    set data(t) {
      this.oi !== t && (Debug && t !== null && U.Oo(t, LayoutEdge2, "data"), this.oi = t);
    }
    get link() {
      return this.os;
    }
    set link(t) {
      this.os !== t && (Debug && t !== null && U.s(t, Link2, LayoutEdge2, "link"), this.os = t);
    }
    get fromVertex() {
      return this.ls;
    }
    set fromVertex(t) {
      this.ls !== t && (Debug && t !== null && U.s(t, LayoutVertex2, LayoutEdge2, "fromVertex"), this.ls = t);
    }
    get toVertex() {
      return this.hs;
    }
    set toVertex(t) {
      this.hs !== t && (Debug && t !== null && U.s(t, LayoutVertex2, LayoutEdge2, "toVertex"), this.hs = t);
    }
  }
  var GridAlignment2 = ((w) => (w[w.Position = 0] = "Position", w[w.Location = 1] = "Location", w))(GridAlignment2 || {}), GridArrangement2 = ((w) => (w[w.LeftToRight = 10] = "LeftToRight", w[w.RightToLeft = 11] = "RightToLeft", w))(GridArrangement2 || {}), GridSorting2 = ((w) => (w[w.Forwards = 20] = "Forwards", w[w.Reverse = 21] = "Reverse", w[w.Ascending = 22] = "Ascending", w[w.Descending = 23] = "Descending", w))(GridSorting2 || {});
  class GridLayout2 extends Layout2 {
    xg;
    bg;
    Xo;
    Kn;
    pi;
    Ji;
    Ce;
    Ae;
    constructor(t) {
      super(), this.isViewportSized = true, this.xg = NaN, this.bg = NaN, this.Xo = new Size2(NaN, NaN).S(), this.Kn = new Size2(10, 10).S(), this.pi = 1, this.Ji = 10, this.Ce = 22, this.Ae = GridLayout2.standardComparer, t && Object.assign(this, t);
    }
    cloneProtected(t) {
      super.cloneProtected(t), t.xg = this.xg, t.bg = this.bg, t.Xo.c(this.Xo), t.Kn.c(this.Kn), t.pi = this.pi, t.Ji = this.Ji, t.Ce = this.Ce, t.Ae = this.Ae;
    }
    gi(t) {
      t in GridSorting2 ? this.sorting = t : t in GridArrangement2 ? this.arrangement = t : t in GridAlignment2 ? this.alignment = t : super.gi(t);
    }
    doLayout(t) {
      Debug && t === null && U.n("Layout.doLayout(collection) argument must not be null but a Diagram, a Group, or an Iterable of Parts"), this.arrangementOrigin = this.initialOrigin(this.arrangementOrigin);
      const i = this.collectParts(t), e = this.diagram, n = i.copy().iterator;
      for (; n.next(); ) {
        const m = n.value;
        if (m.Rr() && (m.fromNode !== null || m.toNode !== null)) {
          i.delete(m);
          continue;
        }
        if (m.ensureBounds(), m instanceof Group2) {
          const g = m.memberParts;
          for (; g.next(); ) {
            const p = g.value;
            i.delete(p);
          }
        }
      }
      const o = i.toArray();
      if (o.length === 0) return;
      switch (this.sorting) {
        case 20:
          break;
        case 21:
          o.reverse();
          break;
        case 22:
          o.sort(this.comparer);
          break;
        case 23:
          o.sort(this.comparer), o.reverse();
          break;
      }
      let r = this.wrappingColumn;
      isNaN(r) && (r = 0);
      let l = this.wrappingWidth;
      if (isNaN(l) && e !== null) {
        const m = e.viewportBounds, g = e.padding;
        l = Math.max(m.width - g.left - g.right, 0);
      } else l = Math.max(this.wrappingWidth, 0);
      r <= 0 && l <= 0 && (r = 1);
      let h = this.spacing.width;
      isFinite(h) || (h = 0);
      let f = this.spacing.height;
      isFinite(f) || (f = 0), e !== null && e.startTransaction("Layout");
      const a = [];
      switch (this.alignment) {
        case 0:
          this.o4(o, l, r, h, f, a);
          break;
        case 1:
          this.r4(o, l, r, h, f, a);
          break;
      }
      let c = 0, u = 0, d = 0;
      for (let m = 0; m < a.length; m++) {
        const g = a[m];
        c = Math.min(c, g.x), u = Math.min(u, g.y), d = Math.max(d, g.x + g.width);
      }
      this.arrangement === 11 ? this.commitLayers(a, new Point2(c + h / 2 - (d + c), u - f / 2)) : this.commitLayers(a, new Point2(c - h / 2, u - f / 2)), e !== null && e.commitTransaction("Layout"), this.isValidLayout = true;
    }
    o4(t, i, e, s, n, o) {
      const r = Rect2.a();
      let l = Math.max(this.cellSize.width, 1);
      if (!isFinite(l)) {
        l = 0;
        for (let p = 0; p < t.length; p++) {
          const y = t[p], x = this.getLayoutBounds(y, r);
          l = Math.max(l, x.width);
        }
      }
      l += s, l = Math.max(l, 1);
      let h = Math.max(this.cellSize.height, 1);
      if (!isFinite(h)) {
        h = 0;
        for (let p = 0; p < t.length; p++) {
          const y = t[p], x = this.getLayoutBounds(y, r);
          h = Math.max(h, x.height);
        }
      }
      h += n, h = Math.max(h, 1);
      const f = this.arrangement, a = this.arrangementOrigin.x, c = this.arrangementOrigin.y;
      let u = a, d = c, m = 0, g = 0;
      for (let p = 0; p < t.length; p++) {
        const y = t[p], x = this.getLayoutBounds(y, r), S = Math.ceil((x.width + s) / l), b = Math.ceil((x.height + n) / h), k = S * l, P = b * h;
        let A = 0;
        switch (f) {
          case 11:
            A = Math.abs(u - x.width);
            break;
          default:
            A = u + x.width;
            break;
        }
        (e > 0 && m > e - 1 || i > 0 && m > 0 && A - a > i) && (o.push(new Rect2(0, d, i + s, g)), m = 0, u = a, d += g, g = 0), g = Math.max(g, P);
        let C = 0;
        switch (f) {
          case 11:
            C = -x.width;
            break;
          default:
            C = 0;
            break;
        }
        switch (y.moveTo(u + C + y.margin.left, d + y.margin.top), f) {
          case 11:
            u -= k;
            break;
          default:
            u += k;
            break;
        }
        m++;
      }
      o.push(new Rect2(0, d, i + s, g)), Rect2.o(r);
    }
    r4(t, i, e, s, n, o) {
      const r = Rect2.a();
      let l = Math.max(this.cellSize.width, 1), h = 0, f = 0, a = 0;
      const c = Point2.a();
      for (let C = 0; C < t.length; C++) {
        const M = t[C], N = this.getLayoutBounds(M, r), L = M.getRelativePoint(M.locationObject, M.locationSpot, c);
        h = Math.max(h, L.x), f = Math.max(f, N.width - L.x), a = Math.max(a, L.y);
      }
      const u = this.arrangement;
      switch (u) {
        case 11:
          h += s;
          break;
        default:
          f += s;
          break;
      }
      isFinite(l) ? l = Math.max(l + s, 1) : l = Math.max(h + f, 1);
      const d = this.arrangementOrigin.x, m = this.arrangementOrigin.y;
      let g = d, p = m, y = 0;
      i >= h && (i -= h);
      let x = 0, S = 0;
      const b = Math.max(this.cellSize.height, 1);
      a = 0;
      let k = 0, P = true;
      const A = Point2.a();
      for (let C = 0; C < t.length; C++) {
        const M = t[C], N = this.getLayoutBounds(M, r), L = M.getRelativePoint(M.locationObject, M.locationSpot, c);
        if (y > 0) switch (u) {
          case 11: {
            let D = (g - d - (N.width - L.x)) / l;
            G.q(Math.round(D), D) ? D = Math.round(D) : D = Math.floor(D), g = D * l + d;
            break;
          }
          default: {
            let D = (g - d + L.x) / l;
            G.q(Math.round(D), D) ? D = Math.round(D) : D = Math.ceil(D), g = D * l + d;
            break;
          }
        }
        else switch (u) {
          case 11:
            x = g + L.x + N.width;
            break;
          default:
            x = g - L.x;
            break;
        }
        let T = 0;
        switch (u) {
          case 11:
            T = -(g + L.x) + x;
            break;
          default:
            T = g + N.width - L.x - x;
            break;
        }
        if (e > 0 && y > e - 1 || i > 0 && y > 0 && T > i) {
          o.push(new Rect2(0, P ? p - a : p, i + s, k + a + n));
          for (let D = 0; D < y && C !== y; D++) {
            const F = t[C - y + D], R = F.getRelativePoint(F.locationObject, F.locationSpot, A);
            F.moveTo(F.position.x, F.position.y + a - R.y);
          }
          k += n, P ? p += k : p += k + a, a = 0, k = 0, y = 0, g = d, P = false;
        }
        switch (g === d && (u === 11 ? S = Math.max(S, N.width - L.x) : S = Math.min(S, -L.x)), a = Math.max(a, L.y), k = Math.max(k, N.height - L.y), isFinite(b) && (k = Math.max(k, Math.max(N.height, b) - L.y)), P ? M.moveTo(g - L.x, p - L.y) : M.moveTo(g - L.x, p), u) {
          case 11:
            g -= L.x + s;
            break;
          default:
            g += N.width - L.x + s;
            break;
        }
        y++;
      }
      if (o.push(new Rect2(0, p, i + s, (P ? k : k + a) + n)), t.length !== y) for (let C = 0; C < y; C++) {
        const M = t[t.length - y + C], N = M.getRelativePoint(M.locationObject, M.locationSpot, c);
        M.moveTo(M.position.x, M.position.y + a - N.y);
      }
      if (Point2.o(c), Point2.o(A), u === 11) for (let C = 0; C < o.length; C++) {
        const M = o[C];
        M.width += S, M.x -= S;
      }
      else for (let C = 0; C < o.length; C++) {
        const M = o[C];
        M.x > S && (M.width += M.x - S, M.x = S);
      }
      Rect2.o(r);
    }
    commitLayers(t, i) {
    }
    get wrappingWidth() {
      return this.xg;
    }
    set wrappingWidth(t) {
      this.xg !== t && (U.i(t, "number", GridLayout2, "wrappingWidth"), (t > 0 || isNaN(t)) && (this.xg = t, this.isViewportSized = isNaN(t), this.b()));
    }
    get wrappingColumn() {
      return this.bg;
    }
    set wrappingColumn(t) {
      this.bg !== t && (U.i(t, "number", GridLayout2, "wrappingColumn"), (t > 0 || isNaN(t)) && (this.bg = t, this.b()));
    }
    get cellSize() {
      return this.Xo;
    }
    set cellSize(t) {
      U.s(t, Size2, GridLayout2, "cellSize"), this.Xo.equals(t) || (this.Xo.c(t), this.b());
    }
    get spacing() {
      return this.Kn;
    }
    set spacing(t) {
      U.s(t, Size2, GridLayout2, "spacing"), this.Kn.equals(t) || (this.Kn.c(t), this.b());
    }
    get alignment() {
      return this.pi;
    }
    set alignment(t) {
      this.pi !== t && (U.W(t, GridAlignment2, "GridAlignment"), (t === 1 || t === 0) && (this.pi = t, this.b()));
    }
    get arrangement() {
      return this.Ji;
    }
    set arrangement(t) {
      this.Ji !== t && (U.W(t, GridArrangement2, "GridArrangement"), (t === 10 || t === 11) && (this.Ji = t, this.b()));
    }
    get sorting() {
      return this.Ce;
    }
    set sorting(t) {
      this.Ce !== t && (U.W(t, GridSorting2, "GridSorting"), (t === 20 || t === 21 || t === 22 || t === 23) && (this.Ce = t, this.b()));
    }
    get comparer() {
      return this.Ae;
    }
    set comparer(t) {
      this.Ae !== t && (U.C(t, GridLayout2, "comparer"), this.Ae = t, this.b());
    }
    static standardComparer(t, i) {
      Debug && U.s(t, Part2, GridLayout2, "standardComparer:a"), Debug && U.s(i, Part2, GridLayout2, "standardComparer:b");
      const e = t.text, s = i.text;
      return e < s ? -1 : e > s ? 1 : 0;
    }
    static smartComparer(t, i) {
      if (Debug && U.s(t, Part2, GridLayout2, "standardComparer:a"), Debug && U.s(i, Part2, GridLayout2, "standardComparer:b"), t !== null) if (i !== null) {
        const e = t.text.toLocaleLowerCase(), s = i.text.toLocaleLowerCase(), n = e.split(/([+-]?[.]?\d+(?:\.\d*)?(?:e[+-]?\d+)?)/), o = s.split(/([+-]?[.]?\d+(?:\.\d*)?(?:e[+-]?\d+)?)/);
        let r = 0;
        for (; r < n.length; r++) if (o[r] !== "" && o[r] !== void 0) {
          const l = parseFloat(n[r]), h = parseFloat(o[r]);
          if (isNaN(l)) if (isNaN(h)) {
            if (n[r].localeCompare(o[r]) !== 0) return n[r].localeCompare(o[r]);
            continue;
          } else return 1;
          else {
            if (isNaN(h)) return -1;
            if (l - h !== 0) return l - h;
            continue;
          }
        } else {
          if (n[r] === "") continue;
          return 1;
        }
        return o[r] !== "" && o[r] !== void 0 ? -1 : 0;
      } else return 1;
      else return i !== null ? -1 : 0;
    }
    static Position = 0;
    static Location = 1;
    static LeftToRight = 10;
    static RightToLeft = 11;
    static Forward = 20;
    static Reverse = 21;
    static Ascending = 22;
    static Descending = 23;
  }
  class PartManager {
    Sg;
    fn;
    Ft;
    Lo;
    kg;
    Pg;
    f;
    HC;
    constructor() {
      this.Sg = new GSet2(), this.fn = new GSet2(), this.Ft = new GSet2(), this.Lo = new GMap2(), this.kg = new GMap2(), this.Pg = new GMap2(), this.f = null, this.HC = false;
    }
    clear() {
      this.Sg.clear(), this.fn.clear(), this.Ft.clear(), this.Lo.clear(), this.kg.clear(), this.Pg.clear();
    }
    Ko(t) {
      this.f = t;
    }
    da(t) {
      if (t instanceof Node2) {
        if (this.Sg.add(t), t instanceof Group2) {
          const e = t.containingGroup;
          e === null ? this.diagram.el.add(t) : e.La.add(t);
          const s = t.layout;
          s !== null && (s.diagram = this.diagram);
        }
      } else t instanceof Link2 ? (this.fn.add(t), t.isAvoiding && (this.diagram.u0 = true)) : t instanceof Adornment2 || this.Ft.add(t);
      const i = t.data;
      i !== null && (t instanceof Adornment2 || (t instanceof Link2 ? this.TF(i, t) : this.Lo.set(i, t)));
    }
    ae(t) {
      if (t.clearAdornments(), t instanceof Node2) {
        if (this.Sg.delete(t), t instanceof Group2) {
          const e = t.containingGroup;
          e === null ? this.diagram.el.delete(t) : e.La.delete(t);
          const s = t.layout;
          s !== null && (s.diagram = null);
        }
      } else t instanceof Link2 ? this.fn.delete(t) : t instanceof Adornment2 || this.Ft.delete(t);
      const i = t.data;
      i !== null && (t instanceof Adornment2 || (t instanceof Link2 ? this.LF(i, t) : this.Lo.delete(i)));
    }
    TF(t, i) {
      this.kg.set(t, i);
    }
    LF(t, i) {
      this.kg.delete(t);
    }
    rebuildParts() {
      const t = this.diagram;
      if (t === null) return;
      const i = t.nodeTemplateMap.iterator;
      for (; i.next(); ) {
        const u = i.value, d = i.key;
        (!u.Oe() || u instanceof Group2) && U.n(`Invalid node template in Diagram.nodeTemplateMap: template for "${d}" must be a Node or a simple Part, not a Group or Link: ${u}`);
      }
      const e = t.groupTemplateMap.iterator;
      for (; e.next(); ) {
        const u = e.value, d = e.key;
        u instanceof Group2 || U.n(`Invalid group template in Diagram.groupTemplateMap: template for "${d}" must be a Group, not a normal Node or Link: ${u}`);
      }
      const s = t.linkTemplateMap.iterator;
      for (; s.next(); ) {
        const u = s.value, d = s.key;
        u instanceof Link2 || U.n(`Invalid link template in Diagram.linkTemplateMap: template for "${d}" must be a Link, not a normal Node or simple Part: ${u}`);
      }
      const n = U.ft(), o = t.selection.iterator;
      for (; o.next(); ) {
        const d = o.value.data;
        d && n.push(d);
      }
      const r = U.ft(), l = t.highlighteds.iterator;
      for (; l.next(); ) {
        const d = l.value.data;
        d && r.push(d);
      }
      const h = U.ft(), f = this.nodes.iterator;
      for (; f.next(); ) {
        const u = f.value;
        u.data !== null && (h.push(u.data), h.push(u.location));
      }
      const a = this.links.iterator;
      for (; a.next(); ) {
        const u = a.value;
        u.data !== null && (h.push(u.data), h.push(u.location));
      }
      const c = this.parts.iterator;
      for (; c.next(); ) {
        const u = c.value;
        u.data !== null && (h.push(u.data), h.push(u.location));
      }
      this.DF(), this.E2();
      for (let u = 0; u < n.length; u++) {
        const d = this.findPartForData(n[u]);
        d !== null && (d.isSelected = true);
      }
      for (let u = 0; u < r.length; u++) {
        const d = this.findPartForData(r[u]);
        d !== null && (d.isHighlighted = true);
      }
      for (let u = 0; u < h.length; u += 2) {
        const d = this.findPartForData(h[u]);
        d !== null && (d.location = h[u + 1]);
      }
      U.et(n), U.et(r), U.et(h);
    }
    E2() {
      const t = this.diagram.model;
      this.hw(t.nodeDataArray);
    }
    hw(t, i) {
      const e = this.diagram.model;
      t.forEach((s) => {
        e.containsNodeData(s) && this.FF(s, false);
      }), t.forEach((s) => {
        e.containsNodeData(s) && this.IS(s);
      }), i !== false && this.diagram.xb(false);
    }
    FF(t, i) {
      if (t == null || this.diagram.undoManager.isUndoingRedoing || this.Lo.has(t)) return null;
      i === void 0 && (i = true);
      const e = this.l4(t);
      return e !== null && i && this.IS(t), e;
    }
    l4(t) {
      if (t == null || this.diagram.undoManager.isUndoingRedoing || this.Lo.has(t)) return null;
      const i = this.h4(t), e = this.findTemplateForNodeData(t, i);
      if (e !== null) {
        e.Yt();
        const s = e.copy();
        if (s !== null) {
          const n = this.diagram.be;
          return this.diagram.be = true, s.nr = i, s.oi = t, this.addsToTemporaryLayer && (s.xl = "Tool"), this.diagram.add(s), s.oi = null, s.data = t, this.diagram.be = n, s;
        }
      }
      return null;
    }
    insertLink(t, i, e, s) {
      return null;
    }
    IS(t) {
    }
    h4(t) {
      return this.diagram.model.getCategoryForNodeData(t);
    }
    static IF = false;
    static RF = false;
    findTemplateForNodeData(t, i) {
      const e = this.diagram, s = e.model, n = s.Ia() && s.isGroupForData(t);
      let o = null;
      return n ? (o = e.groupTemplateMap.get(i), o === null && (o = e.groupTemplateMap.get(""), o === null && (PartManager.RF || (PartManager.RF = true, U.ot('No Group template found for category "' + i + '"'), U.ot("  Using default group template")), o = e.f2))) : (o = e.nodeTemplateMap.get(i), o === null && (o = e.nodeTemplateMap.get(""), o === null && (PartManager.IF || (PartManager.IF = true, U.ot('No Node template found for category "' + i + '"'), U.ot("  Using default node template")), o = e.l2))), o;
    }
    getLinkCategoryForData(t) {
      return "";
    }
    setLinkCategoryForData(t, i) {
    }
    setFromNodeForLink(t, i, e) {
    }
    setToNodeForLink(t, i, e) {
    }
    static OF = false;
    findLinkTemplateForCategory(t) {
      const i = this.diagram;
      let e = i.linkTemplateMap.get(t);
      return e === null && (e = i.linkTemplateMap.get(""), e === null && (PartManager.OF || (PartManager.OF = true, U.ot('No Link template found for category "' + t + '"'), U.ot("  Using default link template")), e = i.h2)), e;
    }
    _3(t, i, e) {
      t instanceof Link2 ? (i !== null && this.LF(i, t), e !== null && this.TF(e, t)) : t instanceof Part2 && (i !== null && this.Lo.delete(i), e !== null && this.Lo.set(e, t));
    }
    DF() {
      const t = this.diagram.model;
      this.vC(t.nodeDataArray);
    }
    vC(t) {
      t.forEach((i) => {
        this.RS(i);
      });
    }
    RS(t) {
      const i = this.findPartForData(t);
      i !== null && (this.diagram.I2(i, false), this.WC(i));
    }
    WC(t) {
    }
    OC(t) {
    }
    findPartForKey(t) {
      if (t == null) return null;
      const e = this.diagram.model.findNodeDataForKey(t);
      return e !== null ? this.Lo.get(e) : null;
    }
    findNodeForKey(t) {
      if (t == null) return null;
      const e = this.diagram.model.findNodeDataForKey(t);
      if (e === null) return null;
      const s = this.Lo.get(e);
      return s instanceof Node2 ? s : null;
    }
    findLinkForKey(t) {
      return null;
    }
    findPartForData(t) {
      if (t === null) return null;
      let i = this.Lo.get(t);
      return i !== null || (i = this.kg.get(t)), i;
    }
    findNodeForData(t) {
      if (t === null) return null;
      const i = this.Lo.get(t);
      return i instanceof Node2 ? i : null;
    }
    findLinkForData(t, i) {
      return t === null ? null : this.kg.get(t);
    }
    findNodesByExample(...t) {
      const i = new GSet2(), e = this.Sg.iterator;
      for (; e.next(); ) {
        const s = e.value, n = s.data;
        if (n !== null) for (let o = 0; o < arguments.length; o++) {
          const r = arguments[o];
          if (U.it(r) && this.jC(n, r)) {
            i.add(s);
            break;
          }
        }
      }
      return i.iterator;
    }
    findLinksByExample(...t) {
      const i = new GSet2(), e = this.fn.iterator;
      for (; e.next(); ) {
        const s = e.value, n = s.data;
        if (n !== null) for (let o = 0; o < arguments.length; o++) {
          const r = arguments[o];
          if (U.it(r) && this.jC(n, r)) {
            i.add(s);
            break;
          }
        }
      }
      return i.iterator;
    }
    jC(t, i) {
      for (const e in i) {
        const s = t[e], n = i[e];
        if (Array.isArray(n)) {
          if (!Array.isArray(s)) return false;
          const o = s, r = n;
          if (o.length < r.length) return false;
          for (let l = 0; l < o.length; l++) {
            const h = o[l], f = r[l];
            if (f !== void 0 && !this.EF(h, f)) return false;
          }
        } else if (!this.EF(s, n)) return false;
      }
      return true;
    }
    EF(t, i) {
      if (U.at(i)) {
        if (!i(t)) return false;
      } else if (i instanceof RegExp) {
        if (!t || !i.test(t.toString())) return false;
      } else if (U.it(t) && U.it(i)) {
        if (!this.jC(t, i)) return false;
      } else if (t !== i) return false;
      return true;
    }
    doModelDataChanged(t) {
      if (t.model === this.diagram.model && this.diagram.H) {
        this.diagram.H = false;
        try {
          const i = t.change;
          t.modelChange === "" && t.object !== null && i === 2 && this.aw(t.object, t.propertyName);
        } finally {
          this.diagram.H = true;
        }
      }
    }
    doModelChanged(t) {
      const i = this.diagram;
      if (!i || t.model !== i.model) return;
      const e = t.change;
      if (i.OO(t), !!i.H) {
        i.H = false;
        try {
          const s = t.modelChange;
          if (s !== "") if (e === 2) {
            if (s === "nodeCategory") {
              const n = t.object;
              if (n !== null) {
                const o = this.findPartForData(n), r = t.newValue;
                o !== null && typeof r == "string" && (o.category = r);
              }
            } else if (s === "nodeDataArray") {
              const n = t.oldValue;
              this.vC(n);
              const o = t.newValue;
              this.hw(o);
            }
            i.isModified = true;
          } else if (e === 3) {
            const n = t.newValue;
            s === "nodeDataArray" && U.it(n) && this.FF(n), i.isModified = true;
          } else if (e === 4) {
            const n = t.oldValue;
            s === "nodeDataArray" && U.it(n) && this.RS(n), i.isModified = true;
          } else e === 1 && (s === "SourceChanged" ? t.object !== null ? this.aw(t.object, t.propertyName) : (this.updateAllRelationshipsFromData(), this.updateAllTargetBindings()) : s === "ModelDisplaced" && this.rebuildParts());
          else if (e === 2) {
            const n = t.propertyName, o = t.object, r = i.model;
            o === r ? (n === "nodeKeyProperty" || n === "nodeCategoryProperty") && (i.undoManager.isUndoingRedoing || this.rebuildParts()) : o !== null && this.aw(o, n), i.isModified = true;
          } else (e === 3 || e === 4) && (this.a4(t, i.model), i.isModified = true);
        } finally {
          i.H = true;
        }
      }
    }
    updateAllTargetBindings(t) {
      t === void 0 && (t = "");
      let i = this.parts.iterator;
      for (; i.next(); ) i.value.updateTargetBindings(t);
      for (i = this.nodes.iterator; i.next(); ) i.value.updateTargetBindings(t);
      for (i = this.links.iterator; i.next(); ) i.value.updateTargetBindings(t);
    }
    updateAllThemeBindings() {
      let t = this.parts.iterator;
      for (; t.next(); ) t.value.jo();
      for (t = this.nodes.iterator; t.next(); ) t.value.jo();
      for (t = this.links.iterator; t.next(); ) t.value.jo();
    }
    updateAllRelationshipsFromData() {
      const t = this.diagram.model, i = new GSet2(), e = t.nodeDataArray;
      for (let o = 0; o < e.length; o++) {
        const r = e[o];
        i.add(r);
      }
      const s = [];
      this.nodes.each((o) => {
        o.data !== null && !i.has(o.data) && s.push(o.data);
      }), this.parts.each((o) => {
        o.data !== null && !i.has(o.data) && s.push(o.data);
      }), s.forEach((o) => t.BF(o, false));
      for (let o = 0; o < e.length; o++) {
        const r = e[o];
        this.findPartForData(r) === null && t.VF(r, false);
      }
      this.zF();
      let n = this.parts.iterator;
      for (; n.next(); ) n.value.updateRelationshipsFromData();
      for (n = this.nodes.iterator; n.next(); ) n.value.updateRelationshipsFromData();
      for (n = this.links.iterator; n.next(); ) n.value.updateRelationshipsFromData();
    }
    zF() {
    }
    updateRelationshipsFromData(t) {
    }
    aw(t, i) {
      if (typeof i == "string") {
        const e = this.findPartForData(t);
        if (e !== null) e.updateTargetBindings(i);
        else {
          const s = this.f4(t);
          if (s !== null && s.length > 0) {
            for (let o = 0; o < s.length; o++) s[o].updateTargetBindings(i);
            const n = s[0].part;
            if (n !== null) {
              const o = n.adornments;
              for (; o.next(); ) o.value.updateTargetBindings(i);
            }
            U.et(s);
          }
        }
        t === this.diagram.model.modelData && this.updateAllTargetBindings(i);
      }
    }
    f4(t) {
      let i = null;
      const e = this.Pg.iterator;
      for (; e.next(); ) {
        const s = e.value;
        for (let n = 0; n < s.length; n++) {
          const r = s[n].findItemPanelForData(t);
          r !== null && (i === null && (i = U.ft()), i.push(r));
        }
        if (i !== null) break;
      }
      return i;
    }
    JC(t) {
      return this.Pg.get(t);
    }
    a4(t, i) {
      const e = t.object;
      if (!Array.isArray(e)) return;
      const s = t.change === 3, n = s ? t.newParam : t.oldParam, o = s ? t.newValue : t.oldValue, r = this.JC(e);
      if (Array.isArray(r)) for (let l = 0; l < r.length; l++) {
        const h = r[l];
        s ? h.oS(o, n, true) : h.eE(n);
      }
    }
    D2(t, i) {
      i !== null && t.Tn((s) => i.pL(s));
      const e = t.Oh;
      if (Array.isArray(e)) {
        const s = this.JC(e);
        if (s === null) this.Pg.set(e, [t]);
        else {
          for (let n = 0; n < s.length; n++) if (s[n] === t) return;
          s.push(t);
        }
      }
    }
    F2(t, i) {
      t.Tn((s) => i.BO(s));
      const e = t.Oh;
      if (Array.isArray(e)) {
        const s = this.JC(e);
        if (s !== null) {
          for (let n = 0; n < s.length; n++) if (s[n] === t) {
            s.splice(n, 1), s.length === 0 && this.Pg.delete(e);
            return;
          }
        }
      }
    }
    copyParts(t, i, e) {
      e === void 0 && (e = false);
      const s = new GMap2();
      if (Array.isArray(t)) for (let o = 0; o < t.length; o++) this.OS(t[o], i, s, e);
      else {
        const o = t.iterator;
        for (; o.next(); ) this.OS(o.value, i, s, e);
      }
      if (i !== null) {
        const o = i.model, r = i.R0().dragsLink, l = new GSet2(), h = new GMap2(), f = s.iterator;
        for (; f.next(); ) {
          const a = f.value;
          if (a instanceof Link2) !r && (a.fromNode === null || a.toNode === null) && l.add(a);
          else if (a instanceof Node2 && a.data !== null) {
            if (o.Um()) {
              const c = a, u = f.key, d = u.findTreeParentNode();
              if (d !== null) {
                const m = s.get(d);
                if (m !== null) {
                  o.setParentKeyForNodeData(c.data, o.getKeyForNodeData(m.data));
                  const g = i.findLinkForData(c.data), p = u.findTreeParentLink();
                  p !== null && g !== null && h.set(p, g);
                }
              }
            } else if (o.yb()) {
              const c = a, u = f.key, d = o.isRelatedKeysPathTo ? u.findNodesOutOf() : u.findNodesInto();
              for (; d.next(); ) {
                const m = d.value, g = s.get(m);
                if (g !== null) {
                  o.addRelatedKeyForNodeData(c.data, g.key);
                  const p = i.partManager.findLinkForData(c.data, g.key), y = this.findLinkForData(u.data, m.key);
                  y !== null && p !== null && h.set(y, p);
                } else o.removeRelatedKeyForNodeData(c.data, m.key);
              }
            }
          }
        }
        if (l.count > 0 && i.removeParts(l, false), h.count > 0) {
          const a = h.iterator;
          for (; a.next(); ) {
            const c = a.key, u = a.value;
            s.set(c, u);
          }
        }
      }
      if (i !== null && this.diagram !== null) {
        const o = i.model, r = o.afterCopyFunction;
        if (r !== null) {
          const l = new GMap2();
          s.each((f) => {
            f.key.data !== null && l.set(f.key.data, f.value.data);
          });
          const h = this.diagram.model;
          r(l, o, h);
        }
      }
      const n = s.iterator;
      for (; n.next(); ) n.value.updateTargetBindings();
      return s;
    }
    OS(t, i, e, s) {
      if (t === null || s && !t.canCopy()) return null;
      if (e.has(t)) return e.get(t);
      const n = this.$C(t, i);
      if (!(n instanceof Part2)) return null;
      if (n.isSelected = false, n.isHighlighted = false, e.set(t, n), t instanceof Node2) {
        const o = t.linksConnected;
        for (; o.next(); ) {
          const r = o.value;
          if (r.fromNode === t) {
            const l = e.get(r);
            l !== null && (l.fromNode = n);
          }
          if (r.toNode === t) {
            const l = e.get(r);
            l !== null && (l.toNode = n);
          }
        }
        if (t instanceof Group2 && n instanceof Group2) {
          const r = t.memberParts;
          for (; r.next(); ) {
            const l = r.value, h = this.OS(l, i, e, s);
            h instanceof Link2 || h !== null && (h.containingGroup = n);
          }
        }
      } else if (t instanceof Link2 && n instanceof Link2) {
        const o = t.fromNode;
        if (o !== null) {
          const h = e.get(o);
          h !== null && (n.fromNode = h);
        }
        const r = t.toNode;
        if (r !== null) {
          const h = e.get(r);
          h !== null && (n.toNode = h);
        }
        const l = t.labelNodes;
        for (; l.next(); ) {
          const h = l.value, f = this.OS(h, i, e, s);
          f !== null && f instanceof Node2 && (f.labeledLink = n);
        }
      }
      return n;
    }
    $C(t, i) {
      let e = null;
      const s = t.data;
      if (s !== null && i !== null) {
        const n = i.model;
        if (!(t instanceof Link2)) {
          const o = n.copyNodeData(s);
          n.addNodeData(o), e = i.findPartForData(o);
        }
      } else if (t.Yt(), e = t.copy(), e !== null) {
        const n = this.diagram;
        if (i !== null) i.add(e);
        else if (s !== null && n !== null && n.commandHandler !== null && n.commandHandler.copiesClipboardData) {
          const o = n.model;
          let r = null;
          e instanceof Link2 || (r = o.copyNodeData(s)), e.data = r;
        }
      }
      return e;
    }
    get nodes() {
      return this.Sg;
    }
    get links() {
      return this.fn;
    }
    get parts() {
      return this.Ft;
    }
    get diagram() {
      return this.f;
    }
    get addsToTemporaryLayer() {
      return this.HC;
    }
    set addsToTemporaryLayer(t) {
      this.HC = t;
    }
  }
  class GraphLinksPartManager extends PartManager {
    E2() {
      const t = this.diagram.model;
      this.hw(t.nodeDataArray), this.XF(t.linkDataArray);
    }
    hw(t) {
      super.hw(t, false);
      const i = this.links.iterator;
      for (; i.next(); ) i.value._d();
      this.diagram.xb(false);
    }
    XF(t) {
      t.forEach((i) => {
        this.YF(i);
      }), this.diagram.xb(false);
    }
    YF(t) {
      if (t == null || this.diagram.undoManager.isUndoingRedoing || this.findLinkForData(t)) return null;
      const i = this.getLinkCategoryForData(t), e = this.findLinkTemplateForCategory(i);
      if (e !== null) {
        e.Yt();
        const s = e.copy();
        if (s !== null) {
          const n = this.diagram.be;
          this.diagram.be = true, s.nr = i, s.oi = t;
          const o = this.diagram.model, r = o.ES(t, true);
          r !== "" && (s.fromPortId = r);
          const l = o.Ge(t, true);
          if (l !== void 0) {
            const c = this.findNodeForKey(l);
            c instanceof Node2 && (s.fromNode = c);
          }
          const h = o.ES(t, false);
          h !== "" && (s.toPortId = h);
          const f = o.Ge(t, false);
          if (f !== void 0) {
            const c = this.findNodeForKey(f);
            c instanceof Node2 && (s.toNode = c);
          }
          const a = o.getLabelKeysForLinkData(t);
          return Array.isArray(a) && a.forEach((c) => {
            const u = this.findNodeForKey(c);
            u !== null && (u.labeledLink = s);
          }), this.addsToTemporaryLayer && (s.xl = "Tool"), this.diagram.add(s), s.oi = null, s.data = t, this.diagram.be = n, s;
        }
      }
      return null;
    }
    DF() {
      const t = this.diagram.model;
      this.KF(t.linkDataArray), this.vC(t.nodeDataArray);
    }
    KF(t) {
      t.forEach((i) => {
        this.RS(i);
      });
    }
    getLinkCategoryForData(t) {
      return this.diagram.model.getCategoryForLinkData(t);
    }
    setLinkCategoryForData(t, i) {
      return this.diagram.model.setCategoryForLinkData(t, i);
    }
    setFromNodeForLink(t, i, e) {
      const s = this.diagram.model, n = i !== null ? i.data : null;
      s.setFromKeyForLinkData(t.data, s.getKeyForNodeData(n));
    }
    setToNodeForLink(t, i, e) {
      const s = this.diagram.model, n = i !== null ? i.data : null;
      s.setToKeyForLinkData(t.data, s.getKeyForNodeData(n));
    }
    OC(t) {
      this.diagram.model.removeLinkData(t.data);
    }
    findPartForKey(t) {
      const i = super.findPartForKey(t);
      if (i === null) {
        const s = this.diagram.model.findLinkDataForKey(t);
        if (s !== null) return this.findLinkForData(s);
      }
      return i;
    }
    findLinkForKey(t) {
      if (t == null) return null;
      const e = this.diagram.model.findLinkDataForKey(t);
      return e !== null ? this.findLinkForData(e) : null;
    }
    doModelChanged(t) {
      if (super.doModelChanged(t), !this.diagram) return;
      const i = this.diagram;
      if (t.model !== i.model) return;
      const e = t.change;
      if (i.H) {
        i.H = false;
        try {
          const s = t.modelChange;
          if (s !== "") {
            if (e === 2) {
              if (s === "linkFromKey") {
                const n = t.object, o = this.findLinkForData(n);
                if (o !== null) {
                  const r = t.newValue, l = this.findNodeForKey(r);
                  o.fromNode = l;
                }
              } else if (s === "linkToKey") {
                const n = t.object, o = this.findLinkForData(n);
                if (o !== null) {
                  const r = t.newValue, l = this.findNodeForKey(r);
                  o.toNode = l;
                }
              } else if (s === "linkFromPortId") {
                const n = t.object, o = this.findLinkForData(n);
                if (o !== null) {
                  const r = t.newValue;
                  typeof r == "string" && (o.fromPortId = r);
                }
              } else if (s === "linkToPortId") {
                const n = t.object, o = this.findLinkForData(n);
                if (o !== null) {
                  const r = t.newValue;
                  typeof r == "string" && (o.toPortId = r);
                }
              } else if (s === "nodeGroupKey") {
                const n = t.object, o = this.findPartForData(n);
                if (o !== null) {
                  const r = t.newValue;
                  if (r !== void 0) {
                    const l = this.findNodeForKey(r);
                    l instanceof Group2 ? o.containingGroup = l : o.containingGroup = null;
                  } else o.containingGroup = null;
                }
              } else if (s === "linkLabelKeys") {
                const n = t.object, o = this.findLinkForData(n);
                if (o !== null) {
                  const r = t.oldValue, l = t.newValue;
                  Array.isArray(r) && r.forEach((h) => {
                    if (l.indexOf(h) >= 0) return;
                    const f = this.findNodeForKey(h);
                    f !== null && (f.labeledLink = null);
                  }), Array.isArray(l) && l.forEach((h) => {
                    const f = this.findNodeForKey(h);
                    f !== null && (f.labeledLink = o);
                  });
                }
              } else if (s === "linkCategory") {
                const n = t.object, o = this.findLinkForData(n), r = t.newValue;
                o !== null && typeof r == "string" && (o.category = r);
              } else if (s === "linkDataArray") {
                const n = t.oldValue;
                this.KF(n);
                const o = t.newValue;
                this.XF(o);
              }
              i.isModified = true;
            } else if (e === 3) {
              const n = t.newValue;
              if (s === "linkDataArray" && U.it(n)) this.YF(n);
              else if (s === "linkLabelKeys" && t.model.isKeyType(n)) {
                const o = t.object, r = this.findLinkForData(o), l = this.findNodeForKey(n);
                r !== null && l !== null && (l.labeledLink = r);
              }
              i.isModified = true;
            } else if (e === 4) {
              const n = t.oldValue;
              if (s === "linkDataArray" && U.it(n)) this.RS(n);
              else if (s === "linkLabelKeys" && t.model.isKeyType(n)) {
                const o = this.findNodeForKey(n);
                o !== null && (o.labeledLink = null);
              }
              i.isModified = true;
            }
          } else if (e === 2) {
            const n = t.propertyName, o = t.object, r = i.model;
            o === r && (n === "linkFromKeyProperty" || n === "linkToKeyProperty" || n === "linkFromPortIdProperty" || n === "linkToPortIdProperty" || n === "linkLabelKeysProperty" || n === "nodeIsGroupProperty" || n === "nodeGroupKeyProperty" || n === "linkCategoryProperty") && (i.undoManager.isUndoingRedoing || this.rebuildParts()), i.isModified = true;
          }
        } finally {
          i.H = true;
        }
      }
    }
    zF() {
      const t = this.diagram.model, i = /* @__PURE__ */ new Set(), e = t.linkDataArray;
      e.forEach((n) => {
        i.add(n);
      });
      const s = [];
      this.links.each((n) => {
        n.data !== null && !i.has(n.data) && s.push(n.data);
      }), s.forEach((n) => {
        t.UF(n, false);
      }), e.forEach((n) => {
        this.findLinkForData(n) === null && t.GF(n, false);
      });
    }
    updateRelationshipsFromData(t) {
      const i = t.data;
      if (i === null) return;
      const e = t.diagram;
      if (e === null) return;
      const s = e.model;
      if (t instanceof Link2) {
        let n = s.Ge(i, true), o = e.findNodeForKey(n);
        t.fromNode = o, n = s.Ge(i, false), o = e.findNodeForKey(n), t.toNode = o;
        const r = s.getLabelKeysForLinkData(i);
        if (r.length > 0 || t.labelNodes.count > 0) {
          if (r.length === 1 && t.labelNodes.count === 1) {
            const c = r[0], u = t.labelNodes.first();
            if (u !== null && s.getKeyForNodeData(u.data) === c) return;
          }
          const l = new GSet2().addAll(r), h = new GSet2();
          t.labelNodes.each((c) => {
            if (c.data !== null) {
              const u = s.getKeyForNodeData(c.data);
              u !== void 0 && h.add(u);
            }
          });
          const f = h.copy();
          f.removeAll(l);
          const a = l.copy();
          if (a.removeAll(h), f.count > 0 || a.count > 0) {
            const c = t;
            f.each((u) => {
              const d = e.findNodeForKey(u);
              d !== null && d.labeledLink === c && (d.labeledLink = null);
            }), a.each((u) => {
              const d = e.findNodeForKey(u);
              d !== null && d.labeledLink !== c && (d.labeledLink = c);
            });
          }
        }
      } else if (!(t instanceof Adornment2)) {
        const n = s.getGroupKeyForNodeData(i), o = e.findPartForKey(n);
        (o === null || o instanceof Group2) && (t.containingGroup = o);
      }
    }
    IS(t) {
      const i = this.diagram.model, e = i.getKeyForNodeData(t);
      if (e !== void 0) {
        const s = i.fw(e), n = this.findPartForData(t);
        if (s !== null && n !== null) {
          const r = s.iterator;
          for (; r.next(); ) {
            const l = r.value;
            if (i.containsNodeData(l)) {
              if (n instanceof Group2 && i.getGroupKeyForNodeData(l) === e) {
                const h = this.findPartForData(l);
                h !== null && (h.containingGroup = n);
              }
            } else {
              const h = this.findLinkForData(l);
              if (h !== null && n instanceof Node2) {
                i.Ge(l, true) === e && (h.fromNode = n), i.Ge(l, false) === e && (h.toNode = n);
                const f = i.getLabelKeysForLinkData(l);
                Array.isArray(f) && f.some((a) => a === e ? (n.labeledLink = h, true) : false);
              }
            }
          }
          i.un(e);
        }
        const o = i.getGroupKeyForNodeData(t);
        if (o !== void 0) {
          const r = this.findNodeForKey(o);
          n !== null && r instanceof Group2 && (n.containingGroup = r);
        }
      }
    }
    WC(t) {
      const i = this.diagram.model;
      if (t instanceof Node2) {
        const e = i.getKeyForNodeData(t.data);
        if (e !== void 0) {
          const s = t.linksConnected;
          for (; s.next(); ) {
            const n = s.value;
            i.dn(e, n.data);
          }
          if (t.isLinkLabel) {
            const n = t.labeledLink;
            n !== null && i.dn(e, n.data);
          }
          if (t instanceof Group2) {
            const n = t.memberParts;
            for (; n.next(); ) {
              const r = n.value.data;
              i.containsNodeData(r) && i.dn(e, r);
            }
          }
        }
      }
    }
    $C(t, i) {
      let e = super.$C(t, i);
      if (t instanceof Link2) {
        const s = t.data;
        if (s !== null && i !== null) {
          const n = i.model, o = n.copyLinkData(s);
          n.addLinkData(o), e = i.findLinkForData(o);
        } else if (e !== null) {
          const n = this.diagram;
          if (s !== null && n !== null && n.commandHandler !== null && n.commandHandler.copiesClipboardData) {
            const r = n.model.copyLinkData(s);
            e.data = r;
          }
        }
      }
      return e;
    }
    insertLink(t, i, e, s) {
      const n = this.diagram, o = n.model, r = n.toolManager.findTool("Linking");
      let l = "";
      t !== null && (i === null && (i = t), l = i.portId, l === null && (l = ""));
      let h = "";
      e !== null && (s === null && (s = e), h = s.portId, h === null && (h = ""));
      const f = r.archetypeLinkData;
      if (f instanceof Link2) {
        f.Yt();
        const a = f.copy();
        if (a !== null) {
          a.fromNode = t, a.fromPortId = l, a.toNode = e, a.toPortId = h, n.add(a);
          const c = r.archetypeLabelNodeData;
          if (c instanceof Node2) {
            c.Yt();
            const u = c.copy();
            u !== null && (u.labeledLink = a, n.add(u));
          }
          return a;
        }
      } else if (f !== null) {
        const a = o.copyLinkData(f);
        if (U.it(a)) {
          t !== null && o.Mg(a, o.getKeyForNodeData(t.data), true), o.Ng(a, l, true), e !== null && o.Mg(a, o.getKeyForNodeData(e.data), false), o.Ng(a, h, false), o.addLinkData(a);
          const c = r.archetypeLabelNodeData;
          if (c !== null && !(c instanceof Node2)) {
            const d = o.copyNodeData(c);
            o.addNodeData(d);
            const m = o.getKeyForNodeData(d);
            m !== void 0 && o.addLabelKeyForLinkData(a, m);
          }
          return n.findLinkForData(a);
        }
      }
      return null;
    }
  }
  class TreePartManager extends PartManager {
    Kh = null;
    BS(t, i) {
      if (t === null || i === null || i.findTreeParentLink() !== null) return;
      const e = this.diagram.toolManager.findTool("Linking");
      let s = t, n = i;
      if (this.diagram.isTreePathToChildren) {
        if (e !== null && e.qu(s, n, null, true)) return;
      } else if (s = i, n = t, e !== null && e.qu(s, n, null, true)) return;
      const o = this.getLinkCategoryForData(i.data), r = this.findLinkTemplateForCategory(o);
      if (r !== null) {
        r.Yt();
        const l = r.copy();
        if (l !== null) {
          const h = this.diagram.be;
          this.diagram.be = true, l.nr = o, l.oi = i.data, l.fromNode = s, l.toNode = n, this.diagram.add(l), l.oi = null, l.data = i.data, this.diagram.be = h;
        }
      }
    }
    getLinkCategoryForData(t) {
      return this.diagram.model.getParentLinkCategoryForNodeData(t);
    }
    setLinkCategoryForData(t, i) {
      this.diagram.model.setParentLinkCategoryForNodeData(t, i);
    }
    setFromNodeForLink(t, i, e) {
      const s = this.diagram.model;
      e === void 0 && (e = null);
      const n = i !== null ? i.data : null;
      if (this.diagram.isTreePathToChildren) s.setParentKeyForNodeData(t.data, s.getKeyForNodeData(n));
      else {
        const o = this.Kh;
        this.Kh = t, e !== null && s.setParentKeyForNodeData(e.data, void 0);
        const r = t.toNode !== null ? t.toNode.data : null;
        s.setParentKeyForNodeData(n, s.getKeyForNodeData(r)), this.Kh = o;
      }
    }
    setToNodeForLink(t, i, e) {
      const s = this.diagram.model;
      e === void 0 && (e = null);
      const n = i !== null ? i.data : null;
      if (this.diagram.isTreePathToChildren) {
        const o = this.Kh;
        this.Kh = t, e !== null && s.setParentKeyForNodeData(e.data, void 0);
        const r = t.fromNode !== null ? t.fromNode.data : null;
        s.setParentKeyForNodeData(n, s.getKeyForNodeData(r)), this.Kh = o;
      } else s.setParentKeyForNodeData(t.data, s.getKeyForNodeData(n));
    }
    OC(t) {
      this.diagram.model.setParentKeyForNodeData(t.data, void 0);
    }
    findLinkForKey(t) {
      if (t == null) return null;
      const e = this.diagram.model.findNodeDataForKey(t);
      return e !== null ? this.findLinkForData(e) : null;
    }
    doModelChanged(t) {
      if (super.doModelChanged(t), !this.diagram) return;
      const i = this.diagram;
      if (t.model !== i.model) return;
      const e = t.change;
      if (i.H) {
        i.H = false;
        try {
          const s = t.modelChange;
          if (s !== "") {
            if (e === 2) {
              if (s === "nodeParentKey") {
                const n = t.object, o = n ? this.findNodeForData(n) : null, r = t.newValue, l = this.findNodeForKey(r);
                if (n && this.Kh !== null) l !== null && (this.Kh.data = n, this.Kh.category = this.getLinkCategoryForData(n));
                else if (o !== null) {
                  const h = o.findTreeParentLink();
                  h !== null ? l === null ? i.remove(h) : i.isTreePathToChildren ? h.fromNode = l : h.toNode = l : this.BS(l, o);
                }
              } else if (s === "parentLinkCategory") {
                const n = t.object, o = n ? this.findNodeForData(n) : null, r = t.newValue;
                if (o !== null && typeof r == "string") {
                  const l = o.findTreeParentLink();
                  l !== null && (l.category = r);
                }
              }
              i.isModified = true;
            }
          } else e === 2 && (t.object === i.model && t.propertyName === "nodeParentKeyProperty" && (i.undoManager.isUndoingRedoing || this.rebuildParts()), i.isModified = true);
        } finally {
          i.H = true;
        }
      }
    }
    updateRelationshipsFromData(t) {
      const i = t.data;
      if (i === null) return;
      const e = t.diagram;
      if (e === null) return;
      const s = e.model;
      if (t instanceof Node2) {
        const n = s.getParentKeyForNodeData(i), o = e.findNodeForKey(n), r = t.findTreeParentNode();
        if (o !== r) {
          const l = t.findTreeParentLink();
          o !== null ? l !== null ? e.isTreePathToChildren ? l.fromNode = o : l.toNode = o : this.BS(o, t) : l !== null && e.I2(l, false);
        }
      }
    }
    aw(t, i) {
      if (super.aw(t, i), typeof i == "string" && this.findPartForData(t) !== null) {
        const s = this.findLinkForData(t);
        s !== null && s.updateTargetBindings(i);
      }
    }
    IS(t) {
      const i = this.diagram.model, e = i.getKeyForNodeData(t);
      if (e !== void 0) {
        const s = i.fw(e), n = this.findPartForData(t);
        if (s !== null && n !== null) {
          const r = s.iterator;
          for (; r.next(); ) {
            const l = r.value;
            if (i.containsNodeData(l) && n instanceof Node2 && i.getParentKeyForNodeData(l) === e) {
              const h = this.findNodeForData(l);
              this.BS(n, h);
            }
          }
          i.un(e);
        }
        const o = i.getParentKeyForNodeData(t);
        if (o !== void 0 && n instanceof Node2) {
          const r = this.findNodeForKey(o);
          this.BS(r, n);
        }
      }
    }
    WC(t) {
      const i = this.diagram.model;
      if (t instanceof Node2) {
        const e = i.getKeyForNodeData(t.data), s = this.findLinkForData(t.data);
        if (s !== null) {
          s.isSelected = false, s.isHighlighted = false;
          const r = s.layer;
          if (r !== null) {
            const l = r.ae(-1, s, false);
            l >= 0 && this.diagram.raiseChangedEvent(4, "parts", r, s, null, l, null);
            const h = s.layerChanged;
            h !== null && h(s, r, null);
          }
        }
        const n = this.diagram.isTreePathToChildren, o = t.linksConnected;
        for (; o.next(); ) {
          const r = o.value, l = n ? r.toNode : r.fromNode;
          if (l !== null) {
            const h = l.data;
            i.containsNodeData(h) && i.dn(e, h);
          }
        }
      }
    }
    insertLink(t, i, e, s) {
      const n = this.diagram.model;
      let o = t, r = e;
      if (this.diagram.isTreePathToChildren || (o = e, r = t), o !== null && r !== null) {
        const l = o.data, h = r.data;
        return n.setParentKeyForNodeData(h, n.getKeyForNodeData(l)), r.findTreeParentLink();
      }
      return null;
    }
  }
  var BindingMode2 = ((w) => (w[w.OneWay = 1] = "OneWay", w[w.TwoWay = 2] = "TwoWay", w))(BindingMode2 || {});
  class Binding2 {
    l;
    ZC;
    uf;
    $c;
    Uh;
    Zc;
    Qc;
    _c;
    VS;
    Re;
    Yd;
    Ec;
    constructor(t, i, e, s) {
      GSet2._i(this), t === void 0 ? t = "" : U.i(t, "string", Binding2, "constructor:targetprop"), i === void 0 ? i = t : U.i(i, "string", Binding2, "constructor:sourceprop"), e === void 0 ? e = null : e !== null && U.C(e, Binding2, "constructor:conv"), this.ZC = -1, this.Re = null, this.uf = t, this.Yd = 0, this.Ec = 0, this.$c = null, this.Uh = i, this.Zc = e, s === void 0 ? (this.Qc = 1, this._c = null) : (this.Qc = 2, this._c = s), this.VS = new GSet2(), this.l = 2;
    }
    copy() {
      const t = new this.constructor();
      return this.cloneProtected(t), t;
    }
    cloneProtected(t) {
      t.uf = this.uf, t.Yd = this.Yd, t.Ec = this.Ec, t.$c = this.$c, t.Uh = this.Uh, t.Zc = this.Zc, t.Qc = this.Qc, t._c = this._c, t.l = this.l & -2;
    }
    static OneWay = 1;
    static TwoWay = 2;
    static parseEnum(t, i) {
      return U.C(t, Binding2, "parseEnum:ctor"), (e) => {
        let s = parseInt(e);
        return isNaN(s) && (s = U.ta(t, e), s === null) ? i : s;
      };
    }
    gi(t) {
      t in BindingMode2 ? this.mode = t : U.xr(this, t);
    }
    static toString(t) {
      return U.toString(t);
    }
    toString() {
      return "Binding(" + this.targetProperty + ":" + this.sourceProperty + (this.targetId !== -1 ? " " + this.targetId : "") + " " + BindingMode2[this.mode] + ")";
    }
    S() {
      return this.l = this.l | 1, this;
    }
    get targetId() {
      return this.ZC;
    }
    set targetId(t) {
      this.u && U.D(this), this.ZC = t;
    }
    get targetProperty() {
      return this.uf;
    }
    set targetProperty(t) {
      this.u && U.D(this), U.i(t, "string", Binding2, "targetProperty"), this.uf = t;
    }
    get sourceProperty() {
      return this.Uh;
    }
    set sourceProperty(t) {
      this.u && U.D(this), U.i(t, "string", Binding2, "sourceProperty"), this.Uh = t;
    }
    get u() {
      return (this.l & 1) !== 0;
    }
    get isToData() {
      return (this.l & 2) !== 0;
    }
    get isToObject() {
      return (this.l & 4) !== 0;
    }
    get isToModel() {
      return (this.l & 8) !== 0;
    }
    get isToTheme() {
      return (this.l & 16) !== 0;
    }
    get QC() {
      return this.isToTheme && !(this.isToData || this.isToObject || this.isToModel);
    }
    Md() {
      return false;
    }
    get sourceName() {
      return this.$c;
    }
    set sourceName(t) {
      this.u && U.D(this), t !== null && U.i(t, "string", Binding2, "sourceName"), this.$c = t, t !== null ? this.l = this.l & -3 | 4 : this.l = this.l | 2;
    }
    get converter() {
      return this.Zc;
    }
    set converter(t) {
      this.u && U.D(this), t !== null && U.C(t, Binding2, "converter"), this.Zc = t;
    }
    get backConverter() {
      return this._c;
    }
    set backConverter(t) {
      this.u && U.D(this), t !== null && U.C(t, Binding2, "backConverter"), this._c = t;
    }
    get mode() {
      return this.Qc;
    }
    set mode(t) {
      this.u && U.D(this), this.isToTheme && t === 2 && U.n("Theme Bindings cannot be TwoWay."), U.W(t, BindingMode2, "BindingMode"), this.Qc = t;
    }
    makeTwoWay(t) {
      return this.isToTheme && U.n("Theme Bindings cannot be TwoWay."), this.mode = 2, t && (U.C(t, Binding2, "makeTwoWay"), this.backConverter = t), this;
    }
    ofObject(t) {
      return this.u && U.D(this), t === void 0 && (t = ""), Debug && U.i(t, "string", Binding2, "ofObject:srcname"), this.sourceName = t, this;
    }
    ofModel() {
      return this.u && U.D(this), this.l = this.l & -3 & -5 | 8, this.$c = null, this;
    }
    _L(t, i) {
      const e = this.sourceName;
      let s = null;
      return e === null || e === "" ? s = t : e === "/" ? s = i.part : e === "." ? s = i : e === ".." ? s = i.panel : s = t.findObject(e), s;
    }
    check(t) {
      const i = this.uf, e = this.Uh, s = this.Zc;
      (this.Md() && s === null && this.Gh === null && i === "" || s === null && i === "") && U.ot("Binding error: target property is the empty string: " + this.toString()), this.Md() && this.QC && e === "" && s === null && this.Gh === null && U.ot("Binding error: theme bindings require a source property when not using a converter: " + this.toString()), t && typeof i == "string" && (!U.at(["setAttribute"]) && i.length > 0 && i[0] !== "_" && !U.$w(t, i) ? U.ot("Binding error: undefined target property: " + i + " on " + t.toString()) : i === "name" && t instanceof GraphObject2 && U.ot("Binding error: cannot modify GraphObject.name on " + t.toString()));
    }
    updateTarget(t, i, e, s) {
      const n = this.Uh;
      if (e !== void 0 && n !== "" && n !== e || this.isToTheme && t.diagram === null) return;
      const o = this.uf, r = this.Zc;
      let l = i;
      if (n !== "" && !this.QC && (l = Model2.Lt(i, n)), l !== void 0) if (r === null) {
        if (o !== "") {
          if (this.Md()) {
            const h = t.diagram?.themeManager;
            if (l = this.qF(h, l, t, o), l === void 0) return;
          }
          s ? s.rt(t, o, l) : (i instanceof GraphObject2 || i instanceof RowColumnDefinition2) && Model2.rt(t, o, l);
        }
      } else try {
        if (o !== "") {
          let h = r(l, t);
          if (Debug && h === void 0 && U.ot('Binding warning: conversion function returned undefined when setting target property "' + o + '" on ' + t.toString() + ", function is: " + r), this.Md()) {
            const f = t.diagram?.themeManager;
            if (h = this.qF(f, h, t, o), h === void 0) return;
          }
          s ? s.rt(t, o, h) : (i instanceof GraphObject2 || i instanceof RowColumnDefinition2) && Model2.rt(t, o, h);
        } else r(l, t);
      } catch (h) {
        Debug && U.ot("Binding error: " + h.toString() + ' setting target property "' + o + '" on ' + t.toString() + " with conversion function: " + r);
      }
    }
    updateSource(t, i, e, s) {
      if (this.Qc !== 2) return;
      const n = this.uf;
      if (e !== void 0 && n !== e) return;
      const o = this.Uh, r = this._c, l = s !== null ? s.diagram : null, h = l !== null ? l.model : null;
      let f = t;
      if (n !== "" && (f = Model2.Lt(t, n)), f !== void 0 && !this.VS.has(t)) try {
        if (this.VS.add(t), r === null) {
          if (o !== "") h !== null ? (Debug && h.nodeKeyProperty === o && h.containsNodeData(i) && U.ot("Binding error: cannot have TwoWay Binding on node data key property: " + this.toString()), h.setDataProperty(i, o, f)) : (i instanceof GraphObject2 || i instanceof RowColumnDefinition2) && (i[o] = f);
          else if (h !== null && s !== null && s.itemIndex >= 0 && s.panel !== null && Array.isArray(s.panel.itemArray)) {
            const a = s.itemIndex, c = s.panel.itemArray;
            h.removeArrayItem(c, a), h.insertArrayItem(c, a, f);
          }
        } else try {
          if (o !== "") {
            const a = r(f, i, h);
            h !== null ? (Debug && (h.nodeKeyProperty === o && h.containsNodeData(i) && U.ot("Binding error: cannot have TwoWay Binding on node data key property: " + this.toString()), a === void 0 && U.ot(`Binding warning: conversion function returned undefined when setting source property "${o}" on ${i.toString()}, function is: ${r}`)), h.setDataProperty(i, o, a)) : (i instanceof GraphObject2 || i instanceof RowColumnDefinition2) && (i[o] = a);
          } else {
            const a = r(f, i, h);
            if (a !== void 0 && h !== null && s !== null && s.itemIndex >= 0 && s.panel !== null && Array.isArray(s.panel.itemArray)) {
              const c = s.itemIndex, u = s.panel.itemArray;
              h.removeArrayItem(u, c), h.insertArrayItem(u, c, a);
            }
          }
        } catch (a) {
          Debug && U.ot("Binding error: " + a.toString() + ' setting source property "' + o + '" on ' + i.toString() + " with conversion function: " + r);
        }
      } finally {
        this.VS.delete(t);
      }
    }
  }
  class ThemeBinding2 extends Binding2 {
    cw;
    Gh;
    df;
    constructor(t, i, e, s, n) {
      super(t, i, s), e == null && (e = ""), n === void 0 && (n = null), this.cw = e, this.Gh = n, this.df = null, this.l = 16;
    }
    cloneProtected(t) {
      super.cloneProtected(t), t.cw = this.cw, t.Gh = this.Gh, t.df = this.df;
    }
    Md() {
      return true;
    }
    get themeSource() {
      return this.cw;
    }
    set themeSource(t) {
      this.u && U.D(this), t !== null && U.i(t, "string", ThemeBinding2, "themeSource"), this.cw = t, this.df = null, t !== null ? this.l = this.l | 16 : this.l = this.l & -17;
    }
    get themeConverter() {
      return this.Gh;
    }
    set themeConverter(t) {
      this.u && U.D(this), t !== null && U.C(t, ThemeBinding2, "themeConverter"), this.Gh = t;
    }
    ofData() {
      return this.u && U.D(this), this.l = this.l | 2, this.$c = null, this;
    }
    qF(t, i, e, s) {
      if (!t || (this.QC && (i = this.Uh), !i && i !== 0)) return;
      let n = this.themeSource;
      this.df !== null ? n = this.df : typeof n == "string" && n.includes(".") && (this.df = n.split("."), n = this.df);
      let o = t.findValue(i, n, s);
      if (o === void 0 && U.ot(`Theme warning: ${i} could not be found when setting target property ${s}.`), t.readsCssVariables && typeof o == "string" && o.startsWith("var(")) {
        const r = o.match(this.c4);
        r && (o = getComputedStyle(root.document.documentElement).getPropertyValue(r[1]));
      }
      return U.at(this.Gh) && (o = this.Gh(o, e)), o;
    }
    c4 = /var\((.*)\)/;
  }
  class Model2 {
    At;
    Cg;
    Ho;
    _C;
    Te;
    Pi;
    qh;
    tu;
    iu;
    Ag;
    Tg;
    Lg;
    Dg;
    uw;
    gf;
    ur;
    dw;
    qo;
    zS;
    constructor(t, i) {
      if (GSet2._i(this), this.At = "", this.Cg = "", this.Ho = false, this._C = {}, this.Te = [], this.Pi = new GMap2(), this.qh = "key", this.tu = null, this.iu = null, this.Ag = false, this.Tg = false, this.Lg = false, this.Dg = null, this.uw = 100, this.gf = "category", this.ur = new GMap2(), this.dw = [], this.qo = false, this.zS = null, this.undoManager = new UndoManager2(), t !== void 0 && (Array.isArray(t) ? this.nodeDataArray = t : i = t), i) {
        Object.assign(this, i);
        const e = i.Changed;
        e && (delete this.Changed, this.addChangedListener(e));
      }
    }
    cloneProtected(t) {
      t.At = this.At, t.Cg = this.Cg, t.Ho = this.Ho, t.qh = this.qh, t.tu = this.tu, t.iu = this.iu, t.Ag = this.Ag, t.Tg = this.Tg, t.Lg = this.Lg, t.Dg = this.Dg, t.uw = this.uw, t.gf = this.gf;
    }
    copy() {
      const t = new this.constructor();
      return this.cloneProtected(t), t;
    }
    clear() {
      this.Te = [], this.Pi.clear(), this.ur.clear(), this.undoManager.clear();
    }
    toString(t) {
      if (t === void 0 && (t = 0), t > 1) return this.toJson();
      {
        let i = (this.name !== "" ? this.name : "") + " Model";
        if (t > 0) {
          i += `
 node data:`;
          const e = this.nodeDataArray, s = e.length;
          for (let n = 0; n < s; n++) {
            const o = e[n];
            i += " " + this.getKeyForNodeData(o) + ":" + U.toString(o);
          }
        }
        return i;
      }
    }
    toIncrementalData(t) {
      U.s(t, ChangedEvent2, Model2, "toIncrementalData:e"), t.change !== 1 && U.n("Model.toIncrementalData argument is not a Transaction ChangedEvent:" + t.toString());
      const i = t.object;
      if (!t.isTransactionFinished || !(i instanceof Transaction2)) return null;
      const e = this.HF(i);
      return this.tA(i, t.propertyName === "FinishedUndo", e);
    }
    tA(t, i, e) {
      const s = this;
      let n = false;
      const o = new GSet2(), r = new GSet2(), l = new GSet2();
      t.changes.each((u) => {
        if (u.model === s) {
          if (u.modelChange === "nodeDataArray") u.change === 3 ? o.add(u.newValue) : u.change === 4 && l.add(u.oldValue);
          else if (s.containsNodeData(u.object)) u.object !== null && r.add(u.object);
          else if (u.change === 2 && (s.modelData === u.object || u.propertyName === "modelData")) n = true;
          else if (u.object !== null) if (e.has(u.object)) {
            const d = e.get(u.object);
            d && d.each((m) => {
              s.containsNodeData(m) && r.add(m);
            });
          } else {
            if (u.object instanceof Model2 || s._a() && s.containsLinkData(u.object)) return;
            s.vF(u.object).each((m) => {
              r.add(m);
            });
          }
        }
      });
      const h = new GSet2();
      o.each((u) => {
        const d = s.getKeyForNodeData(u);
        d !== void 0 && h.add(d), i || r.add(u);
      });
      const f = new GSet2();
      l.each((u) => {
        const d = s.getKeyForNodeData(u);
        d !== void 0 && f.add(d), i && r.add(u);
      });
      const a = s.cloneDeep(r.toArray());
      let c = null;
      return n && (c === null && (c = {}), c.modelData = this.cloneDeep(this.modelData)), h.count > 0 && (c === null && (c = {}), i ? c.removedNodeKeys = h.toArray() : c.insertedNodeKeys = h.toArray()), a.length > 0 && (c === null && (c = {}), c.modifiedNodeData = a), f.count > 0 && (c === null && (c = {}), i ? c.insertedNodeKeys = f.toArray() : c.removedNodeKeys = f.toArray()), c;
    }
    cloneDeep(t) {
      return this.Fg(t, true);
    }
    Fg(t, i, e, s) {
      if (!U.it(t)) return t;
      e || (e = new GMap2());
      const n = e.get(t);
      if (n) return n;
      let o;
      if (Array.isArray(t)) {
        o = [], e.set(t, o);
        for (let r = 0; r < t.length; r++) {
          const l = t[r];
          o.push(this.Fg(l, false, e, s));
        }
      } else if (t instanceof Point2 || t instanceof Size2 || t instanceof Rect2 || t instanceof Margin2 || t instanceof Spot2) o = t.copy(), e.set(t, o);
      else {
        if (t instanceof Brush2 || t instanceof Geometry2) return t;
        if (t instanceof List2) o = new List2().addAll(this.Fg(t.toArray(), false, e, s)), e.set(t, o);
        else if (t instanceof GSet2) o = new GSet2().addAll(this.Fg(t.toArray(), false, e, s)), e.set(t, o);
        else if (t instanceof GMap2) o = new GMap2().addAll(this.Fg(t.toArray(), false, e, s)), e.set(t, o);
        else if (t instanceof Date) o = new Date(t), e.set(t, o);
        else if (t instanceof RegExp) o = new RegExp(t), e.set(t, o), o.lastIndex = t.lastIndex;
        else if (Model2.iA(null, "", t)) o = t;
        else if (U.at(t.copy)) o = t.copy(), e.set(t, o);
        else {
          o = {}, e.set(t, o);
          for (const r in t) {
            if (r === "__gohashid") continue;
            const l = t[r];
            o[r] = this.Fg(l, false, e, s);
          }
        }
      }
      return o;
    }
    qe(t) {
      return JSON.stringify(t).replace(/[\u007F-\uFFFF]/g, (e) => {
        const s = "0000" + e.charCodeAt(0).toString(16);
        return "\\u" + s.substring(s.length - 4);
      });
    }
    Ig() {
      let t = "";
      return this.name !== "" && (t += `,
  "name": ` + this.qe(this.name)), this.dataFormat !== "" && (t += `,
  "dataFormat": ` + this.qe(this.dataFormat)), this.isReadOnly && (t += `,
  "isReadOnly": ` + this.isReadOnly), this.nodeKeyProperty !== "key" && typeof this.nodeKeyProperty == "string" && (t += `,
  "nodeKeyProperty": ` + this.qe(this.nodeKeyProperty)), this.copiesArrays && (t += `,
  "copiesArrays": true`), this.copiesArrayObjects && (t += `,
  "copiesArrayObjects": true`), this.copiesKey && (t += `,
  "copiesKey": true`), this.pointsDigits !== 100 && (t += `,
  "pointsDigits": ` + this.pointsDigits.toString()), this.nodeCategoryProperty !== "category" && typeof this.nodeCategoryProperty == "string" && (t += `,
  "nodeCategoryProperty": ` + this.qe(this.nodeCategoryProperty)), t;
    }
    gw(t) {
      t.name && (this.name = t.name), t.dataFormat && (this.dataFormat = t.dataFormat), t.isReadOnly && (this.isReadOnly = true), t.nodeKeyProperty && (this.nodeKeyProperty = t.nodeKeyProperty), t.copiesArrays && (this.copiesArrays = true), t.copiesArrayObjects && (this.copiesArrayObjects = true), t.copiesKey !== void 0 && (this.copiesKey = t.copiesKey), t.pointsDigits !== void 0 && (this.pointsDigits = parseInt(t.pointsDigits)), t.nodeCategoryProperty && (this.nodeCategoryProperty = t.nodeCategoryProperty);
    }
    WF() {
      const t = this.modelData;
      return `,
  "modelData": ` + this.jF(t);
    }
    JF(t) {
      const i = t.modelData;
      U.it(i) && (this.replaceJsonObjects(i), this.modelData = i);
    }
    eA() {
      const t = this.modelData;
      let i = false;
      for (const s in t) if (!this.XS(t, s, t[s])) {
        i = true;
        break;
      }
      let e = "";
      return i && (e = this.WF()), e + `,
  "nodeDataArray": ` + this.Hh(this.nodeDataArray, true);
    }
    sA(t) {
      this.JF(t);
      const i = t.nodeDataArray;
      Array.isArray(i) && (this.replaceJsonObjects(i), this.nodeDataArray = i);
    }
    nA(t, i, e) {
      if (t === i) return true;
      if (typeof t != typeof i || U.at(t) || U.at(i)) return false;
      if (Array.isArray(t) && Array.isArray(i)) {
        if (e.get(t) === i) return true;
        if (e.set(t, i), t.length !== i.length) return false;
        for (let s = 0; s < t.length; s++) if (!this.nA(t[s], i[s], e)) return false;
        return true;
      } else if (U.it(t) && U.it(i)) {
        if (e.get(t) === i) return true;
        e.set(t, i);
        for (const s in t) {
          const n = t[s];
          if (this.XS(t, s, n)) continue;
          const o = i[s];
          if (o === void 0 || !this.nA(n, o, e)) return false;
        }
        for (const s in i) {
          const n = i[s];
          if (this.XS(i, s, n)) continue;
          const o = t[s];
          if (o === void 0 || !this.nA(o, n, e)) return false;
        }
        return true;
      }
      return false;
    }
    static $F = `,
  "insertedNodeKeys": `;
    static u4 = `,
  "modifiedNodeData": `;
    static ZF = `,
  "removedNodeKeys": `;
    HF(t) {
      let i = new GMap2();
      const e = (s, n) => {
        const o = n.part;
        if (!o) return;
        const r = o.data;
        if (s === r) return;
        let l = i.get(s);
        l === null ? (l = new GSet2(), l.add(r), i.set(s, l)) : l.add(r);
      };
      return t.changes.each((s) => {
        if (s.diagram !== null) {
          const n = s.change;
          if (n === 2) {
            if (s.object !== null) {
              const o = s.object.panel;
              if (o) {
                const r = o.data;
                r && e(r, o);
              }
            }
          } else if (n === 3 || n === 4) {
            const o = s.object, r = o.itemArray;
            r && e(r, o);
          }
        }
      }), i;
    }
    vF(t) {
      const i = new GSet2();
      for (let e = 0; e < this.nodeDataArray.length; e++) {
        const s = this.nodeDataArray[e];
        this.YS(t, s, s, i);
      }
      return i;
    }
    YS(t, i, e, s) {
      if (Array.isArray(i)) for (let n = 0; n < i.length; n++) {
        const o = i[n];
        if (o === t) return s.add(e), true;
        if (this.YS(t, o, e, s)) return true;
      }
      else if (U.it(i) && Object.getPrototypeOf(i) === Object.prototype) for (const n in i) {
        const o = i[n];
        if (o === t) return s.add(e), true;
        if (this.YS(t, o, e, s)) return true;
      }
      return false;
    }
    oA(t, i, e) {
      const s = this;
      let n = false;
      const o = new GSet2(), r = new GSet2(), l = new GSet2();
      t.changes.each((c) => {
        if (c.model === s) {
          if (c.modelChange === "nodeDataArray") c.change === 3 ? o.add(c.newValue) : c.change === 4 && l.add(c.oldValue);
          else if (s.containsNodeData(c.object)) c.object !== null && r.add(c.object);
          else if (c.change === 2 && (s.modelData === c.object || c.propertyName === "modelData")) n = true;
          else if (c.object !== null) if (e.has(c.object)) {
            const u = e.get(c.object);
            u && u.each((d) => {
              s.containsNodeData(d) && r.add(d);
            });
          } else {
            if (c.object instanceof Model2 || s._a() && s.containsLinkData(c.object)) return;
            s.vF(c.object).each((d) => {
              r.add(d);
            });
          }
        }
      });
      const h = new GSet2();
      o.each((c) => {
        const u = s.getKeyForNodeData(c);
        u !== void 0 && h.add(u), i || r.add(c);
      });
      const f = new GSet2();
      l.each((c) => {
        const u = s.getKeyForNodeData(c);
        u !== void 0 && f.add(u), i && r.add(c);
      });
      let a = "";
      return n && (a += this.WF()), h.count > 0 && (a += (i ? Model2.ZF : Model2.$F) + this.Hh(h.toArray(), true)), r.count > 0 && (a += Model2.u4 + this.Hh(r.toArray(), true)), f.count > 0 && (a += (i ? Model2.$F : Model2.ZF) + this.Hh(f.toArray(), true)), a;
    }
    mw(t) {
      (t.name !== void 0 && t.name !== this.name || t.dataFormat !== void 0 && t.dataFormat !== this.dataFormat || t.isReadOnly !== void 0 && t.isReadOnly !== this.isReadOnly || t.nodeKeyProperty !== void 0 && t.nodeKeyProperty !== this.nodeKeyProperty || t.copiesArrays !== void 0 && t.copiesArrays !== this.copiesArrays || t.copiesArrayObjects !== void 0 && t.copiesArrayObjects !== this.copiesArrayObjects || t.copiesKey !== void 0 && t.copiesKey !== this.copiesKey || t.nodeCategoryProperty !== void 0 && t.nodeCategoryProperty !== this.nodeCategoryProperty) && U.n("applyIncrementalJson cannot change Model properties"), this.JF(t);
      const i = t.insertedNodeKeys, e = t.modifiedNodeData, s = new GMap2();
      if (Array.isArray(e)) for (let o = 0; o < e.length; o++) {
        const r = e[o], l = this.getKeyForNodeData(r);
        l != null && s.set(l, r);
      }
      if (Array.isArray(i)) {
        const o = i.length;
        for (let r = 0; r < o; r++) {
          const l = i[r];
          let h = this.findNodeDataForKey(l);
          if (h === null) {
            const f = s.get(l);
            h = f || this.copyNodeData({}), h !== null && (this.setKeyForNodeData(h, l), this.addNodeData(h));
          }
        }
      }
      if (Array.isArray(e)) {
        const o = e.length;
        for (let r = 0; r < o; r++) {
          const l = e[r], h = this.getKeyForNodeData(l), f = this.findNodeDataForKey(h);
          if (f !== null) {
            for (const a in l) a === "__gohashid" || a === this.nodeKeyProperty || (this.Km() || this.yb()) && a === this.nodeIsGroupProperty || this.setDataProperty(f, a, l[a]);
            this.Rg(l, f);
          }
        }
      }
      const n = t.removedNodeKeys;
      if (Array.isArray(n)) {
        const o = n.length;
        for (let r = 0; r < o; r++) {
          const l = n[r], h = this.findNodeDataForKey(l);
          h !== null && this.removeNodeData(h);
        }
      }
    }
    toIncrementalJson(t, i) {
      U.s(t, ChangedEvent2, Model2, "toIncrementalJson:e"), t.change !== 1 && U.n("Model.toIncrementalJson argument is not a Transaction ChangedEvent:" + t.toString());
      const e = t.object;
      if (!t.isTransactionFinished || !(e instanceof Transaction2)) return '{ "incremental": 0 }';
      i === void 0 && (i = U.$n(this));
      const s = this.HF(e), n = this.oA(e, t.propertyName === "FinishedUndo", s);
      return '{ "class": ' + this.qe(i) + ', "incremental": 1' + this.Ig() + n + "}";
    }
    toIncrementalJSON(t, i) {
      return this.toIncrementalJson(t, i);
    }
    toJson(t) {
      return t === void 0 && (t = U.$n(this)), '{ "class": ' + this.qe(t) + this.Ig() + this.eA() + "}";
    }
    toJSON(t) {
      return this.toJson(t);
    }
    applyIncrementalJson(t) {
      let i = null;
      if (typeof t == "string") try {
        i = root.JSON.parse(t);
      } catch (s) {
        Debug && U.ot("JSON.parse error: " + s.toString());
      }
      else U.it(t) ? i = t : U.n("Unable to modify a Model from: " + t);
      const e = i.incremental;
      typeof e != "number" && U.n("Unable to apply non-incremental changes to Model: " + t), e !== 0 && (this.startTransaction("applyIncrementalJson"), this.mw(i), this.commitTransaction("applyIncrementalJson"));
    }
    applyIncrementalJSON(t) {
      return this.applyIncrementalJson(t);
    }
    static fromJson(t, i) {
      i === void 0 && (i = null), i !== null && U.s(i, Model2, Model2, "fromJson:model");
      let e = null;
      if (typeof t == "string") try {
        e = root.JSON.parse(t);
      } catch (s) {
        Debug && U.ot("JSON.parse error: " + s.toString());
      }
      else U.it(t) ? e = t : U.n("Unable to construct a Model from: " + t);
      if (i === null) {
        const s = Model2.d4(e);
        s === null || s instanceof Model2 ? i = s : U.n("Unable to construct a Model of declared class: " + e.class);
      }
      return i === null && (i = Model2.QF()), i.gw(e), i.sA(e), i;
    }
    static fromJSON(t, i) {
      return this.fromJson(t, i);
    }
    static QF() {
      return Debug && U.n("Unable to construct a Model. Provided JSON requires GraphLinksModel, which is not loaded."), new Model2();
    }
    static d4(t) {
      let i = null, e = t.class;
      if (typeof e == "string") try {
        let s = null;
        e.indexOf("go.") === 0 ? s = Model2.rA(e.substring(3)) : (s = Model2.rA(e), s === null && (s = root[e])), U.at(s) && (i = new s());
      } catch {
      }
      return i;
    }
    replaceJsonObjects(t) {
      if (Array.isArray(t)) {
        const i = t.length;
        for (let e = 0; e < i; e++) {
          const s = t[e];
          U.it(s) && this._F(t, e, this.replaceJsonObjects(s));
        }
      } else if (U.it(t)) {
        for (const i in t) {
          const e = t[i];
          if (U.it(e)) {
            const s = this.replaceJsonObjects(e);
            t[i] = s, this.replaceJsonPropertyValue(t, i, s);
          }
        }
        return this.g4(t);
      }
      return t;
    }
    replaceJsonPropertyValue(t, i, e) {
      if (i === "points" && Array.isArray(e)) {
        let s = e.length % 2 === 0;
        for (let n = 0; n < e.length; n++) if (typeof e[n] != "number") {
          s = false;
          break;
        }
        if (s) {
          const n = new List2();
          for (let o = 0; o < e.length / 2; o++) n.add(new Point2(e[o * 2], e[o * 2 + 1]));
          t[i] = n;
        }
      }
    }
    writeJsonValue(t) {
      return t === void 0 ? "undefined" : t === null ? "null" : t === true ? "true" : t === false ? "false" : typeof t == "string" ? this.qe(t) : typeof t == "number" ? t === 1 / 0 ? "9e9999" : t === -1 / 0 ? "-9e9999" : isNaN(t) ? '{"class":"NaN"}' : t.toString() : t instanceof Boolean ? this.writeJsonValue(t.valueOf()) : t instanceof String ? this.writeJsonValue(t.valueOf()) : t instanceof Number ? this.writeJsonValue(t.valueOf()) : t instanceof Date ? '{"class":"Date", "value":"' + t.toJSON() + '"}' : Array.isArray(t) ? this.Hh(t) : U.it(t) ? this.jF(t) : U.at(t) ? "null" : '"' + t.toString() + '"';
    }
    Hh(t, i) {
      i === void 0 && (i = false);
      const e = t.length;
      if (e <= 0) return "[]";
      const s = new StringBuilder();
      s.add("["), i && e > 1 && s.add(`
`);
      for (let n = 0; n < e; n++) {
        const o = t[n];
        o !== void 0 && (n > 0 && (s.add(","), i && s.add(`
`)), s.add(this.writeJsonValue(o)));
      }
      return i && e > 1 && s.add(`
`), s.add("]"), s.toString();
    }
    XS(t, i, e) {
      return !!(e === void 0 || i === "__gohashid" || i[0] === "_" || U.at(e));
    }
    $i(t) {
      return isNaN(t) ? "NaN" : t === 1 / 0 ? "9e9999" : t === -1 / 0 ? "-9e9999" : t;
    }
    jF(t) {
      const i = t;
      if (i instanceof Point2) t = { class: "go.Point", x: this.$i(i.x), y: this.$i(i.y) };
      else if (i instanceof Size2) t = { class: "go.Size", width: this.$i(i.width), height: this.$i(i.height) };
      else if (i instanceof Rect2) t = { class: "go.Rect", x: this.$i(i.x), y: this.$i(i.y), width: this.$i(i.width), height: this.$i(i.height) };
      else if (i instanceof Margin2) t = { class: "go.Margin", top: this.$i(i.top), right: this.$i(i.right), bottom: this.$i(i.bottom), left: this.$i(i.left) };
      else if (i instanceof Spot2) i.isSpot() ? t = { class: "go.Spot", x: this.$i(i.x), y: this.$i(i.y), offsetX: this.$i(i.offsetX), offsetY: this.$i(i.offsetY) } : t = { class: "go.Spot", enum: i.toString() };
      else if (i instanceof Brush2) {
        if (t = { class: "go.Brush", type: BrushType2[i.type] }, i.type === 1 ? t.color = i.color : (i.type === 2 || i.type === 3) && (t.start = i.start, t.end = i.end, i.type === 3 && (i.startRadius !== 0 && (t.startRadius = this.$i(i.startRadius)), isNaN(i.endRadius) || (t.endRadius = this.$i(i.endRadius)))), i.colorStops !== null) {
          const n = {}, o = i.colorStops.iterator;
          for (; o.next(); ) {
            const r = o.key, l = o.value;
            n[r] = l;
          }
          t.colorStops = n;
        }
      } else if (i instanceof Geometry2) t = { class: "go.Geometry", type: GeometryType2[i.type] }, i.startX !== 0 && (t.startX = this.$i(i.startX)), i.startY !== 0 && (t.startY = this.$i(i.startY)), i.endX !== 0 && (t.endX = this.$i(i.endX)), i.endY !== 0 && (t.endY = this.$i(i.endY)), i.spot1.equals(Spot2.TopLeft) || (t.spot1 = i.spot1), i.spot2.equals(Spot2.BottomRight) || (t.spot2 = i.spot2), i.type === 4 && (t.path = Geometry2.stringify(i));
      else if (Model2.iA(null, "", i)) return "{}";
      let e = "{", s = true;
      for (const n in t) {
        const o = this.Lt(t, n);
        this.XS(t, n, o) || (s ? s = false : e += ",", e += this.qe(n) + ":" + this.writeJsonPropertyValue(n, o));
      }
      return e += "}", e;
    }
    writeJsonPropertyValue(t, i) {
      if (t === "points" && i instanceof List2) {
        const e = i;
        let s = "[";
        const n = e.iterator;
        for (; n.next(); ) {
          const o = n.value;
          s.length > 1 && (s += ","), s += this.tI(o.x), s += ",", s += this.tI(o.y);
        }
        return s += "]", s;
      } else return this.writeJsonValue(i);
    }
    tI(t) {
      if (t === 1 / 0) return "9e9999";
      if (t === -1 / 0) return "-9e9999";
      if (isNaN(t)) return "0";
      const i = this.pointsDigits;
      return i > 16 ? t.toString() : t.toFixed(i);
    }
    get pointsDigits() {
      return this.uw;
    }
    set pointsDigits(t) {
      t < 0 ? t = 0 : t > 100 && (t = 100), this.uw = t;
    }
    Zi(t) {
      return typeof t == "number" ? t : t === "NaN" ? NaN : t === "9e9999" ? 1 / 0 : t === "-9e9999" ? -1 / 0 : parseFloat(t);
    }
    g4(t) {
      if (!U.it(t)) return t;
      let i = t.class || "";
      if (typeof i != "string" || i === "") return t;
      if (i === "NaN") return NaN;
      if (i === "Date") return new Date(t.value);
      if (i.indexOf("go.") !== 0) return t;
      i = i.substring(3);
      let e = t;
      if (i === "Point") e = new Point2(this.Zi(t.x), this.Zi(t.y));
      else if (i === "Size") e = new Size2(this.Zi(t.width), this.Zi(t.height));
      else if (i === "Rect") e = new Rect2(this.Zi(t.x), this.Zi(t.y), this.Zi(t.width), this.Zi(t.height));
      else if (i === "Margin") e = new Margin2(this.Zi(t.top), this.Zi(t.right), this.Zi(t.bottom), this.Zi(t.left));
      else if (i === "Spot") typeof t.enum == "string" ? e = Spot2.parse(t.enum) : e = new Spot2(this.Zi(t.x), this.Zi(t.y), this.Zi(t.offsetX), this.Zi(t.offsetY));
      else if (i === "Brush") {
        const s = new Brush2();
        s.type = U.ta(BrushType2, t.type) ?? 1, typeof t.color == "string" && (s.color = t.color), t.start instanceof Spot2 && (s.start = t.start), t.end instanceof Spot2 && (s.end = t.end), typeof t.startRadius == "number" && (s.startRadius = this.Zi(t.startRadius)), typeof t.endRadius == "number" && (s.endRadius = this.Zi(t.endRadius));
        const n = t.colorStops;
        if (U.it(n)) for (const o in n) {
          const r = parseFloat(o);
          s.addColorStop(r, n[o]);
        }
        e = s;
      } else if (i === "Geometry") {
        let s = null;
        typeof t.path == "string" ? s = Geometry2.parse(t.path) : s = new Geometry2(), s.type = U.ta(GeometryType2, t.type) ?? 1, typeof t.startX == "number" && (s.startX = this.Zi(t.startX)), typeof t.startY == "number" && (s.startY = this.Zi(t.startY)), typeof t.endX == "number" && (s.endX = this.Zi(t.endX)), typeof t.endY == "number" && (s.endY = this.Zi(t.endY)), t.spot1 instanceof Spot2 && (s.spot1 = t.spot1), t.spot2 instanceof Spot2 && (s.spot2 = t.spot2), e = s;
      } else if (i === "EnumValue") {
        let s = t.classType;
        s.indexOf("go.") === 0 && (s = s.substring(3));
        const n = Model2.rA(s);
        U.at(n) && (e = U.ta(n, t.name));
      }
      return e;
    }
    get name() {
      return this.At;
    }
    set name(t) {
      const i = this.At;
      i !== t && (U.i(t, "string", Model2, "name"), this.At = t, this.t("name", i, t));
    }
    get dataFormat() {
      return this.Cg;
    }
    set dataFormat(t) {
      const i = this.Cg;
      i !== t && (U.i(t, "string", Model2, "dataFormat"), this.Cg = t, this.t("dataFormat", i, t));
    }
    get isReadOnly() {
      return this.Ho;
    }
    set isReadOnly(t) {
      const i = this.Ho;
      i !== t && (U.i(t, "boolean", Model2, "isReadOnly"), this.Ho = t, this.t("isReadOnly", i, t));
    }
    get modelData() {
      return this._C;
    }
    set modelData(t) {
      const i = this.modelData;
      i !== t && (U.Oo(t, Model2, "modelData"), this.containsNodeData(t) && U.n("Model.modelData Object must not be used by the rest of the model: " + t), this._C = t, this.t("modelData", i, t), this.updateTargetBindings(t));
    }
    addChangedListener(t) {
      return U.C(t, Model2, "addChangedListener:listener"), this.dw.push(t), this;
    }
    removeChangedListener(t) {
      U.C(t, Model2, "removeChangedListener:listener");
      const i = this.dw.indexOf(t);
      i >= 0 && this.dw.splice(i, 1);
    }
    O2(t) {
      this.skipsUndoManager || this.undoManager.handleChanged(t), this.iI(t);
    }
    iI(t) {
      this.dw.forEach((i) => i(t));
    }
    dR(t) {
      this.iI(t);
    }
    raiseChangedEvent(t, i, e, s, n, o, r) {
      this.Vt("", t, i, e, s, n, o, r);
    }
    raiseChanged(t, i, e, s, n) {
      this.Vt("", 2, t, this, i, e, s, n);
    }
    t(t, i, e, s, n) {
      this.Vt("", 2, t, this, i, e, s, n);
    }
    raiseDataChanged(t, i, e, s, n, o) {
      this.Vt("", 2, i, t, e, s, n, o);
    }
    Vt(t, i, e, s, n, o, r, l) {
      r === void 0 && (r = null), l === void 0 && (l = null);
      const h = new ChangedEvent2();
      h.model = this, h.change = i, h.modelChange = t, h.propertyName = e, h.object = s, h.oldValue = n, h.oldParam = r, h.newValue = o, h.newParam = l, this.O2(h);
    }
    get undoManager() {
      return this.zS;
    }
    set undoManager(t) {
      const i = this.zS;
      i !== t && (U.s(t, UndoManager2, Model2, "undoManager"), i && i.removeModel(this), this.zS = t, t.addModel(this));
    }
    get skipsUndoManager() {
      return this.qo;
    }
    set skipsUndoManager(t) {
      U.i(t, "boolean", Model2, "skipsUndoManager"), this.qo = t;
    }
    changeState(t, i) {
      if (t !== null && t.model === this) if (t.change === 2) {
        const e = t.object, s = t.propertyName, n = t.getValue(i);
        if (e !== null && s === this.nodeKeyProperty && this.containsNodeData(e)) {
          const o = t.getValue(!i);
          o !== void 0 && this.Pi.delete(o), n !== void 0 && this.Pi.set(n, e);
        }
        this.rt(e, s, n);
      } else if (t.change === 3) {
        const e = t.newParam;
        if (t.modelChange === "nodeDataArray") {
          const s = t.newValue;
          if (U.it(s) && typeof e == "number") {
            const n = this.getKeyForNodeData(s);
            i ? (this.Te[e] === s && this.Do(this.Te, e), n !== void 0 && this.Pi.delete(n)) : (this.Te[e] !== s && this.dr(this.Te, e, s), n !== void 0 && this.Pi.set(n, s));
          }
        } else if (t.modelChange === "") {
          let s = t.object;
          if (s && !Array.isArray(s) && t.propertyName && (s = this.Lt(s, t.propertyName)), Array.isArray(s) && typeof e == "number") {
            const n = t.newValue;
            i ? this.Do(s, e) : this.dr(s, e, n);
          }
        } else U.n("unknown ChangeType.Insert modelChange: " + t.toString());
      } else if (t.change === 4) {
        const e = t.oldParam;
        if (t.modelChange === "nodeDataArray") {
          const s = t.oldValue;
          if (U.it(s) && typeof e == "number") {
            const n = this.getKeyForNodeData(s);
            i ? (this.Te[e] !== s && this.dr(this.Te, e, s), n !== void 0 && this.Pi.set(n, s)) : (this.Te[e] === s && this.Do(this.Te, e), n !== void 0 && this.Pi.delete(n));
          }
        } else if (t.modelChange === "") {
          let s = t.object;
          if (s && !Array.isArray(s) && t.propertyName && (s = this.Lt(s, t.propertyName)), Array.isArray(s) && typeof e == "number") {
            const n = t.oldValue;
            i ? this.dr(s, e, n) : this.Do(s, e);
          }
        } else U.n("unknown ChangeType.Remove modelChange: " + t.toString());
      } else t.change === 1 || U.n("unknown ChangedEvent: " + t.toString());
    }
    startTransaction(t) {
      return this.undoManager.startTransaction(t);
    }
    commitTransaction(t) {
      return this.undoManager.commitTransaction(t);
    }
    rollbackTransaction() {
      return this.undoManager.rollbackTransaction();
    }
    commit(t, i) {
      let e = i;
      e === void 0 && (e = "");
      const s = this.skipsUndoManager;
      e === null && (this.skipsUndoManager = true, e = ""), this.undoManager.startTransaction(e);
      let n = false;
      try {
        t(this), n = true;
      } finally {
        n ? this.undoManager.commitTransaction(e) : this.undoManager.rollbackTransaction(), this.skipsUndoManager = s;
      }
    }
    updateTargetBindings(t, i) {
      i === void 0 && (i = ""), this.Vt("SourceChanged", 1, i, t, null, null);
    }
    get nodeKeyProperty() {
      return this.qh;
    }
    set nodeKeyProperty(t) {
      const i = this.qh;
      i !== t && (this.Un(t, Model2, "nodeKeyProperty"), t === "" && U.n("Model.nodeKeyProperty may not be the empty string"), this.Pi.count > 0 && U.n("Cannot set Model.nodeKeyProperty when there is existing node data"), this.qh = t, this.t("nodeKeyProperty", i, t));
    }
    Un(t, i, e) {
      typeof t != "string" && !U.at(t) && U.Ti(t, "string or function", i, e);
    }
    getKeyForNodeData(t) {
      if (t === null) return;
      const i = this.qh;
      if (i === "") return;
      const e = this.Lt(t, i);
      if (e !== void 0) {
        if (this.isKeyType(e)) return e;
        U.n("Key value for node data " + t + " is not a number or a string: " + e);
      }
    }
    setKeyForNodeData(t, i) {
      if ((i == null || !this.isKeyType(i)) && U.Ti(i, "number or string", Model2, "setKeyForNodeData:key"), t === null) return;
      const e = this.qh;
      if (e === "") return;
      if (!this.containsNodeData(t)) {
        this.rt(t, e, i);
        return;
      }
      const s = this.Lt(t, e);
      if (s !== i) {
        if (this.findNodeDataForKey(i) !== null) return;
        this.rt(t, e, i), s !== void 0 && this.Pi.delete(s), this.Pi.set(i, t), this.Vt("nodeKey", 2, e, t, s, i), typeof e == "string" && this.updateTargetBindings(t, e), this.pw(s, i);
      }
    }
    get makeUniqueKeyFunction() {
      return this.tu;
    }
    set makeUniqueKeyFunction(t) {
      const i = this.tu;
      i !== t && (t !== null && U.C(t, Model2, "makeUniqueKeyFunction"), this.tu = t, this.t("makeUniqueKeyFunction", i, t));
    }
    isKeyType(t) {
      return typeof t == "number" || typeof t == "string";
    }
    containsNodeData(t) {
      if (t === null) return false;
      const i = this.getKeyForNodeData(t);
      return i === void 0 ? false : this.Pi.get(i) === t;
    }
    findNodeDataForKey(t) {
      return t === null && U.n("Model.findNodeDataForKey:key must not be null"), t === void 0 || !this.isKeyType(t) ? null : this.Pi.get(t);
    }
    get nodeDataArray() {
      return this.Te;
    }
    set nodeDataArray(t) {
      const i = this.Te;
      if (i !== t) {
        this.yw(t, Model2, "nodeDataArray"), this.Pi.clear(), this.lA();
        const e = t.length;
        for (let o = 0; o < e; o++) {
          const r = t[o];
          U.it(r) || U.n("Model.nodeDataArray must only contain Objects, not: " + r), r === this.modelData && U.n("nodeDataArray Objects must not be the shared Model.modelData");
        }
        this.Te = t;
        const s = new List2();
        for (let o = 0; o < e; o++) {
          const r = t[o], l = this.getKeyForNodeData(r);
          l === void 0 || this.Pi.get(l) !== null ? s.add(r) : this.Pi.set(l, r);
        }
        const n = s.iterator;
        for (; n.next(); ) {
          const o = n.value;
          this.makeNodeDataKeyUnique(o);
          const r = this.getKeyForNodeData(o);
          r !== void 0 && this.Pi.set(r, o);
        }
        this.Vt("nodeDataArray", 2, "nodeDataArray", this, i, t);
        for (let o = 0; o < e; o++) {
          const r = t[o];
          this.Og(r), this.Eg(r);
        }
      }
    }
    KS(t) {
      return t === void 0 ? false : this.Pi.has(t);
    }
    makeNodeDataKeyUnique(t) {
      if (t === null) return;
      const i = this.qh;
      if (i === "") return;
      let e = this.getKeyForNodeData(t);
      if (e !== void 0 && !this.KS(e)) return;
      const s = this.tu;
      if (s !== null && (e = s(this, t), e != null && !this.KS(e))) {
        this.rt(t, i, e);
        return;
      }
      if (typeof e == "string") {
        let n = 2;
        for (; this.KS(e + n); ) n++;
        this.rt(t, i, e + n);
      } else if (e === void 0 || typeof e == "number") {
        let n = -this.Pi.count - 1;
        for (; this.KS(n); ) n--;
        this.rt(t, i, n);
      } else Debug && U.n("Model.getKeyForNodeData returned something other than a string or a number: " + e);
    }
    addNodeData(t) {
      t !== null && (t === this.modelData && U.n("Model.addNodeData cannot add the shared Model.modelData Object"), this.containsNodeData(t) || this.VF(t, true));
    }
    VF(t, i) {
      let e = this.getKeyForNodeData(t);
      if (e === void 0) this.makeNodeDataKeyUnique(t), e = this.getKeyForNodeData(t);
      else {
        if (this.Pi.get(e) === t) return;
        this.makeNodeDataKeyUnique(t), e = this.getKeyForNodeData(t);
      }
      e === void 0 && U.n("Model.makeNodeDataKeyUnique failed on " + t + ".  Data not added to Model."), this.Pi.set(e, t);
      let s = null;
      i && (s = this.Te.length, this.dr(this.Te, s, t)), this.Vt("nodeDataArray", 3, "nodeDataArray", this, null, t, null, s), this.Og(t), this.Eg(t);
    }
    addNodeDataCollection(t) {
      if (Array.isArray(t)) {
        const i = t.length;
        for (let e = 0; e < i; e++) this.addNodeData(t[e]);
      } else {
        const i = t.iterator;
        for (; i.next(); ) {
          const e = i.value;
          this.addNodeData(e);
        }
      }
    }
    removeNodeData(t) {
      t !== null && this.BF(t, true);
    }
    BF(t, i) {
      const e = this.getKeyForNodeData(t);
      e !== void 0 && this.Pi.delete(e);
      let s = null;
      if (i) {
        if (s = this.Te.indexOf(t), s < 0) return;
        this.Do(this.Te, s);
      }
      this.Vt("nodeDataArray", 4, "nodeDataArray", this, t, null, s, null), this.ww(t);
    }
    removeNodeDataCollection(t) {
      if (Array.isArray(t)) {
        const i = t.length;
        for (let e = 0; e < i; e++) this.removeNodeData(t[e]);
      } else {
        const i = t.iterator;
        for (; i.next(); ) {
          const e = i.value;
          this.removeNodeData(e);
        }
      }
    }
    mergeNodeDataArray(t) {
      if (t === this.nodeDataArray || !Array.isArray(t)) return;
      const i = new GSet2();
      i.addAll(this.Pi.iteratorKeys);
      const e = new GSet2(), s = t.length;
      for (let o = 0; o < s; o++) {
        const r = t[o], l = this.getKeyForNodeData(r);
        if (l !== void 0) {
          e.add(l);
          const h = this.findNodeDataForKey(l);
          if (h === r) continue;
          if (h !== null) this.assignAllDataProperties(h, r), this.Rg(r, h);
          else {
            const f = this.cloneDeep(r);
            this.setKeyForNodeData(f, l), this.addNodeData(f);
          }
        } else {
          const h = this.cloneDeep(r);
          this.addNodeData(h);
          const f = this.getKeyForNodeData(h);
          f !== void 0 && e.add(f);
        }
      }
      const n = i.iterator;
      for (; n.next(); ) {
        const o = n.value;
        if (!e.has(o)) {
          const r = this.findNodeDataForKey(o);
          r && this.removeNodeData(r);
        }
      }
    }
    pw(t, i) {
      if (i === void 0) return;
      const e = this.fw(t);
      e instanceof GSet2 && this.ur.set(i, e);
    }
    lA() {
    }
    Og(t) {
    }
    Eg(t) {
    }
    ww(t) {
    }
    dn(t, i) {
      if (t === void 0) return;
      let e = this.ur.get(t);
      e === null && (e = new GSet2(), this.ur.set(t, e)), e.add(i);
    }
    un(t, i) {
      if (t === void 0) return;
      const e = this.ur.get(t);
      e instanceof GSet2 && (i == null ? this.ur.delete(t) : (e.delete(i), e.count === 0 && this.ur.delete(t)));
    }
    fw(t) {
      if (t === void 0) return null;
      const i = this.ur.get(t);
      return i instanceof GSet2 ? i : null;
    }
    UB(t) {
      t === void 0 ? this.ur.clear() : this.ur.delete(t);
    }
    get copyNodeDataFunction() {
      return this.iu;
    }
    set copyNodeDataFunction(t) {
      const i = this.iu;
      i !== t && (t !== null && U.C(t, Model2, "copyNodeDataFunction"), this.iu = t, this.t("copyNodeDataFunction", i, t));
    }
    get copiesArrays() {
      return this.Ag;
    }
    set copiesArrays(t) {
      const i = this.Ag;
      i !== t && (t !== null && U.i(t, "boolean", Model2, "copiesArrays"), this.Ag = t, this.t("copiesArrays", i, t));
    }
    get copiesArrayObjects() {
      return this.Tg;
    }
    set copiesArrayObjects(t) {
      const i = this.Tg;
      i !== t && (t !== null && U.i(t, "boolean", Model2, "copiesArrayObjects"), this.Tg = t, this.t("copiesArrayObjects", i, t));
    }
    get copiesKey() {
      return this.Lg;
    }
    set copiesKey(t) {
      const i = this.Lg;
      i !== t && (t !== null && U.i(t, "boolean", Model2, "copiesKey"), this.Lg = t, this.t("copiesKey", i, t));
    }
    copyNodeData(t) {
      let i = null;
      const e = this.iu;
      return e !== null ? i = e(t, this) : i = this.US(t, true), i;
    }
    US(t, i) {
      if (U.it(t)) if (Array.isArray(t)) if (this.copiesArrays) {
        const e = t, s = [];
        for (let n = 0; n < e.length; n++) {
          const o = e[n], r = this.US(o, this.copiesArrayObjects);
          s.push(r);
        }
        return s;
      } else return t;
      else {
        if (t instanceof Point2 || t instanceof Size2 || t instanceof Rect2 || t instanceof Margin2 || t instanceof Spot2) return t.copy();
        if (i) {
          const e = t, s = e.constructor, n = s ? new s() : {}, o = !this.copiesKey && typeof this.nodeKeyProperty == "string" ? this.nodeKeyProperty : null;
          for (const r in e) {
            if (r === "__gohashid") {
              n.__gohashid = void 0;
              continue;
            }
            if (r === o) {
              n[o] = void 0;
              continue;
            }
            const l = this.Lt(e, r);
            if (!U.it(l)) n[r] = l;
            else if (Model2.iA(e, r, l)) this.rt(n, r, l);
            else {
              const h = this.US(l, false);
              this.rt(n, r, h);
            }
          }
          return n;
        } else return t;
      }
      else return t;
    }
    get afterCopyFunction() {
      return this.Dg;
    }
    set afterCopyFunction(t) {
      const i = this.Dg;
      i !== t && (t !== null && U.C(t, Model2, "afterCopyFunction"), this.Dg = t, this.t("afterCopyFunction", i, t));
    }
    static iA(t, i, e) {
      const s = U.$n(e);
      return e instanceof Model2 || e instanceof UndoManager2 || e instanceof Transaction2 || e instanceof ChangedEvent2 || e instanceof GraphObject2 || e instanceof RowColumnDefinition2 || e instanceof Diagram2 || e instanceof EventTarget || s === "Layer" || s === "RowColumnDefinition" || s.indexOf("Animation") >= 0 || s.indexOf("Tool") >= 0 || s.indexOf("CommandHandler") >= 0 || s.indexOf("Layout") >= 0 ? (Debug && i[0] !== "_" && (t && i && U.ot('Warning: found GraphObject or Diagram or HTML DOM reference when copying model data on property "' + i + '" of data object: ' + t.toString()), U.ot(`  
Model data should not have any references to a Diagram or any part of a diagram, such as: ` + e.toString())), true) : false;
    }
    static eI = false;
    setDataProperty(t, i, e) {
      if (Debug && (U.Oo(t, Model2, "setDataProperty:data"), U.i(i, "string", Model2, "setDataProperty:propname"), i === "" && U.n("Model.setDataProperty: property name must not be an empty string when setting " + t + " to " + e)), this.containsNodeData(t)) {
        if (i === this.nodeKeyProperty) {
          this.setKeyForNodeData(t, e);
          return;
        } else if (i === this.nodeCategoryProperty) {
          this.setCategoryForNodeData(t, e);
          return;
        }
      } else !Model2.eI && t instanceof GraphObject2 && (Model2.eI = true, U.ot('Model.setDataProperty is modifying a GraphObject, "' + t.toString() + '"'), U.ot("  Is that really your intent?"));
      const s = this.Lt(t, i);
      s !== e && (this.rt(t, i, e), this.raiseDataChanged(t, i, s, e));
    }
    set(t, i, e) {
      this.setDataProperty(t, i, e);
    }
    assignAllDataProperties(t, i) {
      if (!i) return;
      const e = this.containsNodeData(t);
      for (const s in i) s !== "__gohashid" && (e && s === this.nodeKeyProperty || this.setDataProperty(t, s, i[s]));
    }
    addArrayItem(t, i) {
      this.insertArrayItem(t, -1, i);
    }
    insertArrayItem(t, i, e) {
      Debug && (this.yw(t, Model2, "insertArrayItem:arr"), U.r(i, Model2, "insertArrayItem:idx"), t === this.Te && U.n("Model.insertArrayItem or Model.addArrayItem should not be called on the Model.nodeDataArray")), i < 0 && (i = t.length), t = this.dr(t, i, e), this.Vt("", 3, "", t, null, e, null, i);
    }
    removeArrayItem(t, i) {
      i === void 0 && (i = -1), Debug && (this.yw(t, Model2, "removeArrayItem:arr"), U.r(i, Model2, "removeArrayItem:idx")), t === this.Te && U.n("Model.removeArrayItem should not be called on the Model.nodeDataArray"), i === -1 && (i = t.length - 1);
      const e = t[i];
      t = this.Do(t, i), this.Vt("", 4, "", t, e, null, i, null);
    }
    get nodeCategoryProperty() {
      return this.gf;
    }
    set nodeCategoryProperty(t) {
      const i = this.gf;
      i !== t && (this.Un(t, Model2, "nodeCategoryProperty"), this.gf = t, this.t("nodeCategoryProperty", i, t));
    }
    getCategoryForNodeData(t) {
      if (t === null) return "";
      const i = this.gf;
      if (i === "") return "";
      const e = this.Lt(t, i);
      if (e === void 0) return "";
      if (typeof e == "string") return e;
      U.n("getCategoryForNodeData found a non-string category for " + t + ": " + e);
    }
    setCategoryForNodeData(t, i) {
      if (U.i(i, "string", Model2, "setCategoryForNodeData:cat"), t === null) return;
      const e = this.gf;
      if (e === "") return;
      if (!this.containsNodeData(t)) {
        this.rt(t, e, i);
        return;
      }
      let s = this.Lt(t, e);
      s === void 0 && (s = ""), s !== i && (this.rt(t, e, i), this.Vt("nodeCategory", 2, e, t, s, i));
    }
    Rg(t, i) {
      this.setCategoryForNodeData(i, this.getCategoryForNodeData(t));
    }
    get type() {
      return "Model";
    }
    Um() {
      return false;
    }
    Km() {
      return false;
    }
    yb() {
      return false;
    }
    _a() {
      return false;
    }
    Ex() {
      return false;
    }
    Ia() {
      return false;
    }
    static k2() {
      return new Model2();
    }
    Lt(t, i) {
      return Model2.Lt(t, i);
    }
    static Lt(t, i) {
      if (!t || !i) return null;
      let e;
      try {
        U.at(i) ? e = i(t) : U.at(t.getAttribute) ? (e = t.getAttribute(i), e === null && (e = void 0)) : e = t[i];
      } catch (s) {
        Debug && U.ot("property get error: " + s.toString());
      }
      return e;
    }
    rt(t, i, e) {
      Model2.rt(t, i, e);
    }
    static rt(t, i, e) {
      if (!(!t || !i)) {
        try {
          U.at(i) ? i(t, e) : U.at(t.setAttribute) ? t.setAttribute(i, e) : t[i] = e;
        } catch (s) {
          Debug && U.ot("property set error: " + s.toString());
        }
        return t;
      }
    }
    yw(t, i, e) {
      Array.isArray(t) || U.Ti(t, "Array", i, e);
    }
    _F(t, i, e) {
      return t[i] = e, t;
    }
    dr(t, i, e) {
      return i >= t.length ? t.push(e) : t.splice(i, 0, e), t;
    }
    Do(t, i) {
      return i >= t.length ? t.pop() : t.splice(i, 1), t;
    }
    static rA(t) {
      return Model2.hA[t] ? Model2.hA[t] : root.go !== void 0 && root.go[t] ? root.go[t] : null;
    }
    static Al(t, i) {
      Model2.hA[i] = t;
    }
    static hA = {};
  }
  Model2.fromJSON = Model2.fromJson = Model2.fromJson, Model2.Al(Brush2, "Brush"), Model2.Al(Geometry2, "Geometry"), Model2.Al(Margin2, "Margin"), Model2.Al(Point2, "Point"), Model2.Al(Rect2, "Rect"), Model2.Al(Size2, "Size"), Model2.Al(Spot2, "Spot"), Model2.Al(Model2, "Model");
  class GraphLinksModel2 extends Model2 {
    Xs;
    gr;
    zi;
    vh;
    eu;
    su;
    Ul;
    Fo;
    Io;
    mf;
    pf;
    yf;
    gn;
    nu;
    Gn;
    Bg;
    constructor(t, i, e) {
      if (super(), this.Xs = [], this.gr = new GSet2(), this.zi = new GMap2(), this.vh = "", this.eu = null, this.su = null, this.Ul = null, this.Fo = "from", this.Io = "to", this.mf = "", this.pf = "", this.yf = "category", this.gn = "", this.nu = "isGroup", this.Gn = "group", this.Bg = false, i !== void 0 && (this.linkDataArray = i), t !== void 0 && (Array.isArray(t) ? this.nodeDataArray = t : e = t), e) {
        Object.assign(this, e);
        const s = e.Changed;
        s && (delete this.Changed, this.addChangedListener(s));
      }
    }
    cloneProtected(t) {
      super.cloneProtected(t), t.vh = this.vh, t.eu = this.eu, t.su = this.su, t.Fo = this.Fo, t.Io = this.Io, t.mf = this.mf, t.pf = this.pf, t.yf = this.yf, t.gn = this.gn, t.nu = this.nu, t.Gn = this.Gn, t.Bg = this.Bg;
    }
    clear() {
      this.Xs = [], this.zi.clear(), this.gr.clear(), super.clear();
    }
    toString(t) {
      if (t === void 0 && (t = 0), t >= 2) return this.toJson();
      {
        let i = (this.name !== "" ? this.name : "") + " GraphLinksModel";
        if (t > 0) {
          i += `
 node data:`;
          let e = this.nodeDataArray, s = e.length, n = 0;
          for (n = 0; n < s; n++) {
            const o = e[n];
            i += " " + this.getKeyForNodeData(o) + ":" + Binding2.toString(o);
          }
          for (i += `
 link data:`, e = this.linkDataArray, s = e.length, n = 0; n < s; n++) {
            const o = e[n];
            i += " " + this.Ge(o, true) + "-->" + this.Ge(o, false);
          }
        }
        return i;
      }
    }
    tA(t, i, e) {
      if (this.linkKeyProperty === "") {
        const c = this.skipsUndoManager;
        this.skipsUndoManager = true, this.linkKeyProperty = "key", this.skipsUndoManager = c;
      }
      let s = super.tA(t, i, e);
      const n = this, o = new GSet2(), r = new GSet2(), l = new GSet2();
      t.changes.each((c) => {
        if (c.model === n) {
          if (c.modelChange === "linkDataArray") c.change === 3 ? o.add(c.newValue) : c.change === 4 && l.add(c.oldValue);
          else if (n.containsLinkData(c.object)) c.object !== null && r.add(c.object);
          else if (c.object !== null) if (c.object !== null && e.has(c.object)) {
            const u = e.get(c.object);
            u && u.each((d) => {
              n.containsLinkData(d) && r.add(d);
            });
          } else {
            if (c.object instanceof Model2 || n.containsNodeData(c.object)) return;
            n.sI(c.object).each((d) => r.add(d));
          }
        }
      });
      const h = new GSet2();
      o.each((c) => {
        const u = n.getKeyForLinkData(c);
        u !== void 0 && h.add(u), i || r.add(c);
      });
      const f = new GSet2();
      l.each((c) => {
        const u = n.getKeyForLinkData(c);
        u !== void 0 && f.add(u), i && r.add(c);
      });
      const a = n.cloneDeep(r.toArray());
      return h.count > 0 && (s === null && (s = {}), i ? s.removedLinkKeys = h.toArray() : s.insertedLinkKeys = h.toArray()), a.length > 0 && (s === null && (s = {}), s.modifiedLinkData = a), f.count > 0 && (s === null && (s = {}), i ? s.insertedLinkKeys = f.toArray() : s.removedLinkKeys = f.toArray()), s;
    }
    Ig() {
      const t = super.Ig();
      let i = "";
      return this.linkCategoryProperty !== "category" && typeof this.linkCategoryProperty == "string" && (i += `,
  "linkCategoryProperty": ` + this.qe(this.linkCategoryProperty)), this.linkKeyProperty !== "" && typeof this.linkKeyProperty == "string" && (i += `,
  "linkKeyProperty": ` + this.qe(this.linkKeyProperty)), this.linkFromKeyProperty !== "from" && typeof this.linkFromKeyProperty == "string" && (i += `,
  "linkFromKeyProperty": ` + this.qe(this.linkFromKeyProperty)), this.linkToKeyProperty !== "to" && typeof this.linkToKeyProperty == "string" && (i += `,
  "linkToKeyProperty": ` + this.qe(this.linkToKeyProperty)), this.linkFromPortIdProperty !== "" && typeof this.linkFromPortIdProperty == "string" && (i += `,
  "linkFromPortIdProperty": ` + this.qe(this.linkFromPortIdProperty)), this.linkToPortIdProperty !== "" && typeof this.linkToPortIdProperty == "string" && (i += `,
  "linkToPortIdProperty": ` + this.qe(this.linkToPortIdProperty)), this.linkLabelKeysProperty !== "" && typeof this.linkLabelKeysProperty == "string" && (i += `,
  "linkLabelKeysProperty": ` + this.qe(this.linkLabelKeysProperty)), this.nodeIsGroupProperty !== "isGroup" && typeof this.nodeIsGroupProperty == "string" && (i += `,
  "nodeIsGroupProperty": ` + this.qe(this.nodeIsGroupProperty)), this.nodeGroupKeyProperty !== "group" && typeof this.nodeGroupKeyProperty == "string" && (i += `,
  "nodeGroupKeyProperty": ` + this.qe(this.nodeGroupKeyProperty)), t + i;
    }
    gw(t) {
      super.gw(t), t.linkKeyProperty && (this.linkKeyProperty = t.linkKeyProperty), t.linkFromKeyProperty && (this.linkFromKeyProperty = t.linkFromKeyProperty), t.linkToKeyProperty && (this.linkToKeyProperty = t.linkToKeyProperty), t.linkFromPortIdProperty && (this.linkFromPortIdProperty = t.linkFromPortIdProperty), t.linkToPortIdProperty && (this.linkToPortIdProperty = t.linkToPortIdProperty), t.linkCategoryProperty && (this.linkCategoryProperty = t.linkCategoryProperty), t.linkLabelKeysProperty && (this.linkLabelKeysProperty = t.linkLabelKeysProperty), t.nodeIsGroupProperty && (this.nodeIsGroupProperty = t.nodeIsGroupProperty), t.nodeGroupKeyProperty && (this.nodeGroupKeyProperty = t.nodeGroupKeyProperty);
    }
    eA() {
      const t = super.eA(), i = `,
  "linkDataArray": ` + this.Hh(this.linkDataArray, true);
      return t + i;
    }
    sA(t) {
      super.sA(t);
      const i = t.linkDataArray;
      Array.isArray(i) && (this.replaceJsonObjects(i), this.linkDataArray = i);
    }
    nI = `,
  "insertedLinkKeys": `;
    m4 = `,
  "modifiedLinkData": `;
    oI = `,
  "removedLinkKeys": `;
    sI(t) {
      const i = new GSet2();
      for (let e = 0; e < this.linkDataArray.length; e++) {
        const s = this.linkDataArray[e];
        this.YS(t, s, s, i);
      }
      return i;
    }
    oA(t, i, e) {
      if (this.linkKeyProperty === "") {
        const c = this.skipsUndoManager;
        this.skipsUndoManager = true, this.linkKeyProperty = "key", this.skipsUndoManager = c;
      }
      const s = super.oA(t, i, e), n = this, o = new GSet2(), r = new GSet2(), l = new GSet2();
      t.changes.each((c) => {
        if (c.model === n) {
          if (c.modelChange === "linkDataArray") c.change === 3 ? o.add(c.newValue) : c.change === 4 && l.add(c.oldValue);
          else if (n.containsLinkData(c.object)) c.object !== null && r.add(c.object);
          else if (c.object !== null) if (c.object !== null && e.has(c.object)) {
            const u = e.get(c.object);
            u && u.each((d) => {
              n.containsLinkData(d) && r.add(d);
            });
          } else {
            if (c.object instanceof Model2 || n.containsNodeData(c.object)) return;
            n.sI(c.object).each((d) => r.add(d));
          }
        }
      });
      const h = new GSet2();
      o.each((c) => {
        const u = n.getKeyForLinkData(c);
        u !== void 0 && h.add(u), i || r.add(c);
      });
      const f = new GSet2();
      l.each((c) => {
        const u = n.getKeyForLinkData(c);
        u !== void 0 && f.add(u), i && r.add(c);
      });
      let a = s;
      return h.count > 0 && (a += (i ? this.oI : this.nI) + this.Hh(h.toArray(), true)), r.count > 0 && (a += this.m4 + this.Hh(r.toArray(), true)), f.count > 0 && (a += (i ? this.nI : this.oI) + this.Hh(f.toArray(), true)), a;
    }
    mw(t) {
      (t.linkCategoryProperty !== void 0 && t.linkCategoryProperty !== this.linkCategoryProperty || t.linkKeyProperty !== void 0 && t.linkKeyProperty !== this.linkKeyProperty || t.linkFromKeyProperty !== void 0 && t.linkFromKeyProperty !== this.linkFromKeyProperty || t.linkToKeyProperty !== void 0 && t.linkToKeyProperty !== this.linkToKeyProperty || t.linkFromPortIdProperty !== void 0 && t.linkFromPortIdProperty !== this.linkFromPortIdProperty || t.linkToPortIdProperty !== void 0 && t.linkToPortIdProperty !== this.linkToPortIdProperty || t.linkLabelKeysProperty !== void 0 && t.linkLabelKeysProperty !== this.linkLabelKeysProperty || t.nodeIsGroupProperty !== void 0 && t.nodeIsGroupProperty !== this.nodeIsGroupProperty || t.nodeGroupKeyProperty !== void 0 && t.nodeGroupKeyProperty !== this.nodeGroupKeyProperty) && U.n("applyIncrementalJson cannot change Model properties"), super.mw(t);
      const i = t.insertedLinkKeys;
      if (Array.isArray(i)) {
        const n = i.length;
        for (let o = 0; o < n; o++) {
          const r = i[o];
          let l = this.findLinkDataForKey(r);
          l === null && (l = this.copyLinkData({}), this.setKeyForLinkData(l, r), this.addLinkData(l));
        }
      }
      const e = t.modifiedLinkData;
      if (Array.isArray(e)) {
        const n = e.length;
        for (let o = 0; o < n; o++) {
          const r = e[o], l = this.getKeyForLinkData(r), h = this.findLinkDataForKey(l);
          if (h !== null) {
            for (const f in r) f === "__gohashid" || f === this.linkKeyProperty || this.setDataProperty(h, f, r[f]);
            this.rI(r, h);
          }
        }
      }
      const s = t.removedLinkKeys;
      if (Array.isArray(s)) {
        const n = s.length;
        for (let o = 0; o < n; o++) {
          const r = s[o], l = this.findLinkDataForKey(r);
          l !== null && this.removeLinkData(l);
        }
      }
    }
    changeState(t, i) {
      if (!(t === null || t.model !== this)) {
        if (t.change === 2) {
          const e = t.object, s = t.propertyName;
          if (e !== null && s === this.linkKeyProperty && this.containsLinkData(e)) {
            const n = t.getValue(i), o = t.getValue(!i);
            o !== void 0 && this.zi.delete(o), n !== void 0 && this.zi.set(n, e), this.rt(e, s, n);
            return;
          }
        } else if (t.change === 3) {
          let e = t.newParam;
          if (t.modelChange === "linkDataArray") {
            const s = t.newValue;
            if (U.it(s) && typeof e == "number") {
              const n = this.getKeyForLinkData(s);
              i ? (this.gr.delete(s), this.Xs[e] === s && this.Do(this.linkDataArray, e), n !== void 0 && this.zi.delete(n)) : (this.gr.add(s), this.Xs[e] !== s && this.dr(this.Xs, e, s), n !== void 0 && this.zi.set(n, s));
            }
            return;
          } else if (t.modelChange === "linkLabelKeys") {
            const s = t.object, n = s !== null ? this.getLabelKeysForLinkData(s) : null;
            Array.isArray(n) && typeof e == "number" && (i ? (e = n.indexOf(t.newValue), e >= 0 && this.Do(n, e)) : n.indexOf(t.newValue) < 0 && this.dr(n, e, t.newValue));
            return;
          }
        } else if (t.change === 4) {
          let e = t.oldParam;
          if (t.modelChange === "linkDataArray") {
            const s = t.oldValue;
            if (U.it(s) && typeof e == "number") {
              const n = this.getKeyForLinkData(s);
              i ? (this.gr.add(s), this.Xs[e] !== s && this.dr(this.Xs, e, s), n !== void 0 && this.zi.set(n, s)) : (this.gr.delete(s), this.Xs[e] === s && this.Do(this.linkDataArray, e), n !== void 0 && this.zi.delete(n));
            }
            return;
          } else if (t.modelChange === "linkLabelKeys") {
            const s = t.object, n = s !== null ? this.getLabelKeysForLinkData(s) : null;
            Array.isArray(n) && typeof e == "number" && (i ? n.indexOf(t.oldValue) < 0 && this.dr(n, e, t.oldValue) : (e = n.indexOf(t.oldValue), e >= 0 && this.Do(n, e)));
            return;
          }
        }
        super.changeState(t, i);
      }
    }
    get archetypeNodeData() {
      return this.Ul;
    }
    set archetypeNodeData(t) {
      const i = this.Ul;
      i !== t && (t !== null && U.Oo(t, GraphLinksModel2, "archetypeNodeData"), this.Ul = t, this.t("archetypeNodeData", i, t));
    }
    aA(t) {
      if (t === void 0) return;
      const i = this.Ul;
      if (i !== null) {
        let e = this.findNodeDataForKey(t);
        e === null && (e = this.copyNodeData(i), this.rt(e, this.nodeKeyProperty, t), this.addNodeData(e));
      }
      return t;
    }
    get linkFromKeyProperty() {
      return this.Fo;
    }
    set linkFromKeyProperty(t) {
      const i = this.Fo;
      i !== t && (this.Un(t, GraphLinksModel2, "linkFromKeyProperty"), this.Fo = t, this.t("linkFromKeyProperty", i, t));
    }
    getFromKeyForLinkData(t) {
      return this.Ge(t, true);
    }
    setFromKeyForLinkData(t, i) {
      this.Mg(t, i, true);
    }
    get linkToKeyProperty() {
      return this.Io;
    }
    set linkToKeyProperty(t) {
      const i = this.Io;
      i !== t && (this.Un(t, GraphLinksModel2, "linkToKeyProperty"), this.Io = t, this.t("linkToKeyProperty", i, t));
    }
    getToKeyForLinkData(t) {
      return this.Ge(t, false);
    }
    setToKeyForLinkData(t, i) {
      this.Mg(t, i, false);
    }
    Ge(t, i) {
      if (t === null) return;
      const e = i ? this.Fo : this.Io;
      if (e === "") return;
      const s = this.Lt(t, e);
      if (s !== void 0) {
        if (this.isKeyType(s)) return s;
        U.n((i ? "FromKey" : "ToKey") + " value for link data " + t + " is not a number or a string: " + s);
      }
    }
    Mg(t, i, e) {
      if (i === null && (i = void 0), i !== void 0 && !this.isKeyType(i) && U.Ti(i, "number or string", GraphLinksModel2, e ? "setFromKeyForLinkData:key" : "setToKeyForLinkData:key"), t === null) return;
      const s = e ? this.Fo : this.Io;
      if (s === "") return;
      if (i = this.aA(i), !this.containsLinkData(t)) {
        this.rt(t, s, i);
        return;
      }
      const n = this.Lt(t, s);
      n !== i && (this.un(n, t), this.rt(t, s, i), this.findNodeDataForKey(i) === null && this.dn(i, t), this.Vt(e ? "linkFromKey" : "linkToKey", 2, s, t, n, i), typeof s == "string" && this.updateTargetBindings(t, s));
    }
    get linkFromPortIdProperty() {
      return this.mf;
    }
    set linkFromPortIdProperty(t) {
      const i = this.mf;
      i !== t && (this.Un(t, GraphLinksModel2, "linkFromPortIdProperty"), Debug && (t === this.linkFromKeyProperty || t === this.linkToKeyProperty) && U.n("linkFromPortIdProperty name must not be the same as the GraphLinksModel.linkFromKeyProperty or linkToKeyProperty: " + t), this.mf = t, this.t("linkFromPortIdProperty", i, t));
    }
    getFromPortIdForLinkData(t) {
      return this.ES(t, true);
    }
    setFromPortIdForLinkData(t, i) {
      this.Ng(t, i, true);
    }
    get linkToPortIdProperty() {
      return this.pf;
    }
    set linkToPortIdProperty(t) {
      const i = this.pf;
      i !== t && (this.Un(t, GraphLinksModel2, "linkToPortIdProperty"), Debug && (t === this.linkFromKeyProperty || t === this.linkToKeyProperty) && U.n("linkFromPortIdProperty name must not be the same as the GraphLinksModel.linkFromKeyProperty or linkToKeyProperty: " + t), this.pf = t, this.t("linkToPortIdProperty", i, t));
    }
    getToPortIdForLinkData(t) {
      return this.ES(t, false);
    }
    setToPortIdForLinkData(t, i) {
      this.Ng(t, i, false);
    }
    ES(t, i) {
      if (t === null) return "";
      const e = i ? this.mf : this.pf;
      if (e === "") return "";
      const s = this.Lt(t, e);
      return s === void 0 ? "" : s;
    }
    Ng(t, i, e) {
      if (U.i(i, "string", GraphLinksModel2, e ? "setFromPortIdForLinkData:portname" : "setToPortIdForLinkData:portname"), t === null) return;
      const s = e ? this.mf : this.pf;
      if (s === "") return;
      if (!this.containsLinkData(t)) {
        this.rt(t, s, i);
        return;
      }
      let n = this.Lt(t, s);
      n === void 0 && (n = ""), n !== i && (this.rt(t, s, i), this.Vt(e ? "linkFromPortId" : "linkToPortId", 2, s, t, n, i), typeof s == "string" && this.updateTargetBindings(t, s));
    }
    get linkLabelKeysProperty() {
      return this.gn;
    }
    set linkLabelKeysProperty(t) {
      const i = this.gn;
      i !== t && (this.Un(t, GraphLinksModel2, "linkLabelKeysProperty"), this.gn = t, this.t("linkLabelKeysProperty", i, t));
    }
    getLabelKeysForLinkData(t) {
      if (t === null) return GraphLinksModel2.EmptyArray;
      const i = this.gn;
      if (i === "") return GraphLinksModel2.EmptyArray;
      const e = this.Lt(t, i);
      return e === void 0 ? GraphLinksModel2.EmptyArray : e;
    }
    setLabelKeysForLinkData(t, i) {
      if (this.yw(i, GraphLinksModel2, "setLabelKeysForLinkData:arr"), t === null) return;
      const e = this.gn;
      if (e === "") return;
      if (!this.containsLinkData(t)) {
        this.rt(t, e, i);
        return;
      }
      let s = this.Lt(t, e);
      if (s === void 0 && (s = GraphLinksModel2.EmptyArray), s !== i) {
        if (Array.isArray(s)) {
          const o = s.length;
          for (let r = 0; r < o; r++) {
            const l = s[r];
            this.un(l, t);
          }
        }
        this.rt(t, e, i);
        const n = i.length;
        for (let o = 0; o < n; o++) {
          const r = i[o];
          this.findNodeDataForKey(r) === null && this.dn(r, t);
        }
        this.Vt("linkLabelKeys", 2, e, t, s, i), typeof e == "string" && this.updateTargetBindings(t, e);
      }
    }
    addLabelKeyForLinkData(t, i) {
      if (i == null || (this.isKeyType(i) || U.Ti(i, "number or string", GraphLinksModel2, "addLabelKeyForLinkData:key"), t === null)) return;
      const e = this.gn;
      if (e === "") return;
      const s = this.Lt(t, e);
      if (s === void 0) {
        const n = [];
        n.push(i), this.setLabelKeysForLinkData(t, n);
      } else if (Array.isArray(s)) {
        let n = s.indexOf(i);
        if (n >= 0) return;
        n = s.length, s.push(i), this.containsLinkData(t) && (this.findNodeDataForKey(i) === null && this.dn(i, t), this.Vt("linkLabelKeys", 3, e, t, null, i, null, n));
      } else U.n(e + " property is not an Array; cannot addLabelKeyForLinkData: " + t);
    }
    removeLabelKeyForLinkData(t, i) {
      if (i == null || (this.isKeyType(i) || U.Ti(i, "number or string", GraphLinksModel2, "removeLabelKeyForLinkData:key"), t === null)) return;
      const e = this.gn;
      if (e === "") return;
      const s = this.Lt(t, e);
      if (Array.isArray(s)) {
        const n = s.indexOf(i);
        if (n < 0) return;
        this.Do(s, n), this.containsLinkData(t) && (this.un(i, t), this.Vt("linkLabelKeys", 4, e, t, i, null, n, null));
      } else s !== void 0 && U.n(e + " property is not an Array; cannot removeLabelKeyforLinkData: " + t);
    }
    get linkDataArray() {
      return this.Xs;
    }
    set linkDataArray(t) {
      const i = this.Xs;
      if (i !== t) {
        this.yw(t, GraphLinksModel2, "linkDataArray"), this.zi.clear();
        const e = t.length;
        for (let n = 0; n < e; n++) {
          const o = t[n];
          U.it(o) || U.n("GraphLinksModel.linkDataArray must only contain Objects, not: " + o);
        }
        if (this.Xs = t, this.linkKeyProperty !== "") {
          const n = new List2();
          for (let r = 0; r < e; r++) {
            const l = t[r], h = this.getKeyForLinkData(l);
            h === void 0 || this.zi.get(h) !== null ? n.add(l) : this.zi.set(h, l);
          }
          const o = n.iterator;
          for (; o.next(); ) {
            const r = o.value;
            this.makeLinkDataKeyUnique(r);
            const l = this.getKeyForLinkData(r);
            l !== void 0 && this.zi.set(l, r);
          }
        }
        const s = new GSet2();
        for (let n = 0; n < e; n++) {
          const o = t[n];
          s.add(o);
        }
        this.gr = s, this.Vt("linkDataArray", 2, "linkDataArray", this, i, t);
        for (let n = 0; n < e; n++) {
          const o = t[n];
          this.fA(o);
        }
      }
    }
    get linkKeyProperty() {
      return this.vh;
    }
    set linkKeyProperty(t) {
      const i = this.vh;
      if (i !== t) {
        this.Un(t, GraphLinksModel2, "linkKeyProperty"), this.vh = t, this.zi.clear();
        const e = this.linkDataArray.length;
        for (let s = 0; s < e; s++) {
          const n = this.linkDataArray[s];
          let o = this.getKeyForLinkData(n);
          o === void 0 && (this.makeLinkDataKeyUnique(n), o = this.getKeyForLinkData(n)), o !== void 0 && this.zi.set(o, n);
        }
        this.t("linkKeyProperty", i, t);
      }
    }
    getKeyForLinkData(t) {
      if (t === null) return;
      const i = this.vh;
      if (i === "") return;
      const e = this.Lt(t, i);
      if (e !== void 0) {
        if (this.isKeyType(e)) return e;
        U.n("Key value for link data " + t + " is not a number or a string: " + e);
      }
    }
    setKeyForLinkData(t, i) {
      if ((i == null || !this.isKeyType(i)) && U.Ti(i, "number or string", GraphLinksModel2, "setKeyForLinkData:key"), t === null) return;
      const e = this.vh;
      if (e === "") return;
      if (!this.containsLinkData(t)) {
        this.rt(t, e, i);
        return;
      }
      const s = this.Lt(t, e);
      if (s !== i) {
        if (this.findLinkDataForKey(i) !== null) return;
        this.rt(t, e, i), s !== void 0 && this.zi.delete(s), this.zi.set(i, t), this.Vt("linkKey", 2, e, t, s, i), typeof e == "string" && this.updateTargetBindings(t, e);
      }
    }
    get makeUniqueLinkKeyFunction() {
      return this.eu;
    }
    set makeUniqueLinkKeyFunction(t) {
      const i = this.eu;
      i !== t && (t !== null && U.C(t, GraphLinksModel2, "makeUniqueLinkKeyFunction"), this.eu = t, this.t("makeUniqueLinkKeyFunction", i, t));
    }
    findLinkDataForKey(t) {
      return t === null && U.n("GraphLinksModel.findLinkDataForKey:key must not be null"), t === void 0 || !this.isKeyType(t) ? null : this.zi.get(t);
    }
    GS(t) {
      return t === void 0 ? false : this.zi.has(t);
    }
    makeLinkDataKeyUnique(t) {
      if (t === null) return;
      const i = this.vh;
      if (i === "") return;
      let e = this.getKeyForLinkData(t);
      if (e !== void 0 && !this.GS(e)) return;
      const s = this.eu;
      if (s !== null && (e = s(this, t), e != null && !this.GS(e))) {
        this.rt(t, i, e);
        return;
      }
      if (typeof e == "string") {
        let n = 2;
        for (; this.GS(e + n); ) n++;
        this.rt(t, i, e + n);
      } else if (e === void 0 || typeof e == "number") {
        let n = -this.zi.count - 1;
        for (; this.GS(n); ) n--;
        this.rt(t, i, n);
      } else Debug && U.n("GraphLinksModel.getKeyForLinkData returned something other than a string or a number: " + e);
    }
    containsLinkData(t) {
      return t === null ? false : this.gr.has(t);
    }
    addLinkData(t) {
      t !== null && (this.containsLinkData(t) || this.GF(t, true));
    }
    GF(t, i) {
      if (this.linkKeyProperty !== "") {
        let s = this.getKeyForLinkData(t);
        if (s === void 0) this.makeLinkDataKeyUnique(t), s = this.getKeyForLinkData(t);
        else {
          if (this.zi.get(s) === t) return;
          this.makeLinkDataKeyUnique(t), s = this.getKeyForLinkData(t);
        }
        s === void 0 && U.n("GraphLinksModel.makeLinkDataKeyUnique failed on " + t + ". Data not added to model."), this.zi.set(s, t);
      }
      this.gr.add(t);
      let e = null;
      i && (e = this.Xs.length, this.dr(this.Xs, e, t)), this.Vt("linkDataArray", 3, "linkDataArray", this, null, t, null, e), this.fA(t);
    }
    addLinkDataCollection(t) {
      if (Array.isArray(t)) {
        const i = t.length;
        for (let e = 0; e < i; e++) this.addLinkData(t[e]);
      } else {
        const i = t.iterator;
        for (; i.next(); ) {
          const e = i.value;
          this.addLinkData(e);
        }
      }
    }
    removeLinkData(t) {
      t !== null && this.UF(t, true);
    }
    UF(t, i) {
      this.gr.delete(t);
      const e = this.getKeyForLinkData(t);
      e !== void 0 && this.zi.delete(e);
      let s = null;
      if (i) {
        if (s = this.Xs.indexOf(t), s < 0) return;
        this.Do(this.Xs, s);
      }
      this.Vt("linkDataArray", 4, "linkDataArray", this, t, null, s, null), this.p4(t);
    }
    removeLinkDataCollection(t) {
      if (Array.isArray(t)) {
        const i = t.length;
        for (let e = 0; e < i; e++) this.removeLinkData(t[e]);
      } else {
        const i = t.iterator;
        for (; i.next(); ) {
          const e = i.value;
          this.removeLinkData(e);
        }
      }
    }
    mergeLinkDataArray(t) {
      if (this.linkKeyProperty === "" && U.n("GraphLinksModel.linkKeyProperty must not be an empty string for .mergeLinkDataArray() to succeed."), t === this.linkDataArray || !Array.isArray(t)) return;
      const i = new GSet2();
      i.addAll(this.zi.iteratorKeys);
      const e = new GSet2(), s = t.length;
      for (let o = 0; o < s; o++) {
        const r = t[o], l = this.getKeyForLinkData(r);
        if (l !== void 0) {
          e.add(l);
          const h = this.findLinkDataForKey(l);
          if (h === r) continue;
          if (h !== null) this.assignAllDataProperties(h, r), this.rI(r, h);
          else {
            const f = this.cloneDeep(r);
            this.setKeyForLinkData(f, l), this.addLinkData(f);
          }
        } else {
          const h = this.cloneDeep(r);
          this.addLinkData(h);
          const f = this.getKeyForLinkData(h);
          f !== void 0 && e.add(f);
        }
      }
      const n = i.iterator;
      for (; n.next(); ) {
        const o = n.value;
        if (!e.has(o)) {
          const r = this.findLinkDataForKey(o);
          r && this.removeLinkData(r);
        }
      }
    }
    fA(t) {
      let i = this.Ge(t, true);
      i = this.aA(i), this.findNodeDataForKey(i) === null && this.dn(i, t), i = this.Ge(t, false), i = this.aA(i), this.findNodeDataForKey(i) === null && this.dn(i, t);
      const e = this.getLabelKeysForLinkData(t);
      if (Array.isArray(e)) {
        const s = e.length;
        for (let n = 0; n < s; n++) i = e[n], this.findNodeDataForKey(i) === null && this.dn(i, t);
      }
    }
    p4(t) {
      let i = this.Ge(t, true);
      this.un(i, t), i = this.Ge(t, false), this.un(i, t);
      const e = this.getLabelKeysForLinkData(t);
      if (Array.isArray(e)) {
        const s = e.length;
        for (let n = 0; n < s; n++) i = e[n], this.un(i, t);
      }
    }
    get copyLinkDataFunction() {
      return this.su;
    }
    set copyLinkDataFunction(t) {
      const i = this.su;
      i !== t && (t !== null && U.C(t, GraphLinksModel2, "copyLinkDataFunction"), this.su = t, this.t("copyLinkDataFunction", i, t));
    }
    copyLinkData(t) {
      let i = null;
      const e = this.su;
      return e !== null ? i = e(t, this) : i = this.US(t, true), U.it(i) && (this.Fo !== "" && this.rt(i, this.Fo, void 0), this.Io !== "" && this.rt(i, this.Io, void 0), this.gn !== "" && this.rt(i, this.gn, [])), i;
    }
    get nodeIsGroupProperty() {
      return this.nu;
    }
    set nodeIsGroupProperty(t) {
      const i = this.nu;
      i !== t && (this.Un(t, GraphLinksModel2, "nodeIsGroupProperty"), this.nu = t, this.t("nodeIsGroupProperty", i, t));
    }
    isGroupForNodeData(t) {
      if (t === null) return false;
      const i = this.nu;
      return i === "" ? false : !!this.Lt(t, i);
    }
    isGroupForData(t) {
      return this.isGroupForNodeData(t);
    }
    get nodeGroupKeyProperty() {
      return this.Gn;
    }
    set nodeGroupKeyProperty(t) {
      const i = this.Gn;
      i !== t && (this.Un(t, GraphLinksModel2, "nodeGroupKeyProperty"), this.Gn = t, this.t("nodeGroupKeyProperty", i, t));
    }
    get copiesGroupKeyOfNodeData() {
      return this.Bg;
    }
    set copiesGroupKeyOfNodeData(t) {
      this.Bg !== t && (U.i(t, "boolean", GraphLinksModel2, "copiesGroupKeyOfNodeData"), this.Bg = t);
    }
    getGroupKeyForNodeData(t) {
      if (t === null) return;
      const i = this.Gn;
      if (i === "") return;
      const e = this.Lt(t, i);
      if (e !== void 0) {
        if (this.isKeyType(e)) return e;
        U.n("GroupKey value for node data " + t + " is not a number or a string: " + e);
      }
    }
    getGroupForData(t) {
      return this.getGroupKeyForNodeData(t);
    }
    setGroupKeyForNodeData(t, i) {
      if (i === null && (i = void 0), i !== void 0 && !this.isKeyType(i) && U.Ti(i, "number or string", GraphLinksModel2, "setGroupKeyForNodeData:key"), t === null) return;
      const e = this.Gn;
      if (e === "") return;
      if (!this.containsNodeData(t)) {
        this.rt(t, e, i);
        return;
      }
      const s = this.Lt(t, e);
      s !== i && (this.un(s, t), this.rt(t, e, i), this.findNodeDataForKey(i) === null && this.dn(i, t), this.Vt("nodeGroupKey", 2, e, t, s, i), typeof e == "string" && this.updateTargetBindings(t, e));
    }
    setGroupForData(t, i) {
      this.setGroupKeyForNodeData(t, i);
    }
    copyNodeData(t) {
      const i = super.copyNodeData(t);
      return !this.copiesGroupKeyOfNodeData && this.Gn !== "" && this.Lt(i, this.Gn) !== void 0 && this.rt(i, this.Gn, void 0), i;
    }
    setDataProperty(t, i, e) {
      if (Debug && (U.Oo(t, GraphLinksModel2, "setDataProperty:data"), U.i(i, "string", GraphLinksModel2, "setDataProperty:propname"), i === "" && U.n("GraphLinksModel.setDataProperty: property name must not be an empty string when setting " + t + " to " + e)), this.containsNodeData(t)) if (i === this.nodeKeyProperty) {
        this.setKeyForNodeData(t, e);
        return;
      } else if (i === this.nodeCategoryProperty) {
        this.setCategoryForNodeData(t, e);
        return;
      } else if (i === this.nodeGroupKeyProperty) {
        this.setGroupKeyForNodeData(t, e);
        return;
      } else Debug && i === this.nodeIsGroupProperty && U.n("GraphLinksModel.setDataProperty: property name must not be the nodeIsGroupProperty: " + i);
      else if (this.containsLinkData(t)) {
        if (i === this.linkFromKeyProperty) {
          this.Mg(t, e, true);
          return;
        } else if (i === this.linkToKeyProperty) {
          this.Mg(t, e, false);
          return;
        } else if (i === this.linkFromPortIdProperty) {
          this.Ng(t, e, true);
          return;
        } else if (i === this.linkToPortIdProperty) {
          this.Ng(t, e, false);
          return;
        } else if (i === this.linkKeyProperty) {
          this.setKeyForLinkData(t, e);
          return;
        } else if (i === this.linkCategoryProperty) {
          this.setCategoryForLinkData(t, e);
          return;
        } else if (i === this.linkLabelKeysProperty) {
          this.setLabelKeysForLinkData(t, e);
          return;
        }
      }
      const s = this.Lt(t, i);
      s !== e && (this.rt(t, i, e), this.raiseDataChanged(t, i, s, e));
    }
    assignAllDataProperties(t, i) {
      if (!i) return;
      const e = this.containsNodeData(t), s = this.containsLinkData(t);
      for (const n in i) if (n !== "__gohashid" && !(e && n === this.nodeKeyProperty)) {
        {
          if (e && n === this.nodeIsGroupProperty && this.Lt(t, n) === i[n]) continue;
          if (s && n === this.linkKeyProperty) continue;
        }
        this.setDataProperty(t, n, i[n]);
      }
    }
    pw(t, i) {
      super.pw(t, i);
      const e = this.Pi.iterator;
      for (; e.next(); ) {
        const n = e.value;
        this.cA(n, t, i);
      }
      const s = this.gr.iterator;
      for (; s.next(); ) {
        const n = s.value;
        this.y4(n, t, i);
      }
    }
    cA(t, i, e) {
      if (this.getGroupKeyForNodeData(t) === i) {
        const n = this.Gn;
        this.rt(t, n, e), this.Vt("nodeGroupKey", 2, n, t, i, e), typeof n == "string" && this.updateTargetBindings(t, n);
      }
    }
    y4(t, i, e) {
      if (this.Ge(t, true) === i) {
        const r = this.Fo;
        this.rt(t, r, e), this.Vt("linkFromKey", 2, r, t, i, e), typeof r == "string" && this.updateTargetBindings(t, r);
      }
      if (this.Ge(t, false) === i) {
        const r = this.Io;
        this.rt(t, r, e), this.Vt("linkToKey", 2, r, t, i, e), typeof r == "string" && this.updateTargetBindings(t, r);
      }
      const o = this.getLabelKeysForLinkData(t);
      if (Array.isArray(o)) {
        const r = o.length, l = this.gn;
        for (let h = 0; h < r; h++) o[h] === i && (this._F(o, h, e), this.Vt("linkLabelKeys", 3, l, t, i, e, h, h));
      }
    }
    lA() {
      super.lA();
      const t = this.linkDataArray, i = t.length;
      for (let e = 0; e < i; e++) {
        const s = t[e];
        this.fA(s);
      }
    }
    Og(t) {
      super.Og(t);
      const i = this.getKeyForNodeData(t), e = this.fw(i);
      if (e !== null) {
        const s = U.ft(), n = e.iterator;
        for (; n.next(); ) {
          const o = n.value;
          if (this.containsNodeData(o)) {
            if (this.getGroupKeyForNodeData(o) === i) {
              const l = this.Gn;
              this.Vt("nodeGroupKey", 2, l, o, i, i), typeof l == "string" && this.updateTargetBindings(o, l), s.push(o);
            }
          } else {
            if (this.Ge(o, true) === i) {
              const f = this.Fo;
              this.Vt("linkFromKey", 2, f, o, i, i), typeof f == "string" && this.updateTargetBindings(o, f), s.push(o);
            }
            if (this.Ge(o, false) === i) {
              const f = this.Io;
              this.Vt("linkToKey", 2, f, o, i, i), typeof f == "string" && this.updateTargetBindings(o, f), s.push(o);
            }
            const h = this.getLabelKeysForLinkData(o);
            if (Array.isArray(h)) {
              const f = h.length, a = this.gn;
              for (let c = 0; c < f; c++) h[c] === i && (this.Vt("linkLabelKeys", 3, a, o, i, i, c, c), s.push(o));
            }
          }
        }
        for (let o = 0; o < s.length; o++) this.un(i, s[o]);
        U.et(s);
      }
    }
    Eg(t) {
      super.Eg(t);
      const i = this.getGroupKeyForNodeData(t);
      this.findNodeDataForKey(i) === null && this.dn(i, t);
    }
    ww(t) {
      super.ww(t);
      const i = this.getGroupKeyForNodeData(t);
      this.un(i, t);
    }
    get linkCategoryProperty() {
      return this.yf;
    }
    set linkCategoryProperty(t) {
      const i = this.yf;
      i !== t && (this.Un(t, GraphLinksModel2, "linkCategoryProperty"), this.yf = t, this.t("linkCategoryProperty", i, t));
    }
    getCategoryForLinkData(t) {
      if (t === null) return "";
      const i = this.yf;
      if (i === "") return "";
      const e = this.Lt(t, i);
      if (e === void 0) return "";
      if (typeof e == "string") return e;
      U.n("getCategoryForLinkData found a non-string category for " + t + ": " + e);
    }
    getLinkCategoryForData(t) {
      return this.getCategoryForLinkData(t);
    }
    setCategoryForLinkData(t, i) {
      if (U.i(i, "string", GraphLinksModel2, "setCategoryForLinkData:cat"), t === null) return;
      const e = this.yf;
      if (e === "") return;
      if (!this.containsLinkData(t)) {
        this.rt(t, e, i);
        return;
      }
      let s = this.Lt(t, e);
      s === void 0 && (s = ""), s !== i && (this.rt(t, e, i), this.Vt("linkCategory", 2, e, t, s, i), typeof e == "string" && this.updateTargetBindings(t, e));
    }
    setLinkCategoryForData(t, i) {
      this.setCategoryForLinkData(t, i);
    }
    Rg(t, i) {
      super.Rg(t, i), this.setGroupKeyForNodeData(i, this.getGroupKeyForNodeData(t));
    }
    rI(t, i) {
      this.setCategoryForLinkData(i, this.getCategoryForLinkData(t)), this.setFromKeyForLinkData(i, this.getFromKeyForLinkData(t)), this.setToKeyForLinkData(i, this.getToKeyForLinkData(t)), this.setLabelKeysForLinkData(i, this.getLabelKeysForLinkData(t)), this.setFromPortIdForLinkData(i, this.getFromPortIdForLinkData(t)), this.setToPortIdForLinkData(i, this.getToPortIdForLinkData(t));
    }
    get type() {
      return "GraphLinksModel";
    }
    Km() {
      return true;
    }
    _a() {
      return true;
    }
    Ex() {
      return true;
    }
    Ia() {
      return true;
    }
    static EmptyArray = Object.freeze([]);
  }
  Model2.Al(GraphLinksModel2, "GraphLinksModel"), Model2.QF = () => new GraphLinksModel2(), Model2.k2 = () => new GraphLinksModel2();
  class TreeModel2 extends Model2 {
    qn;
    Vg;
    wf;
    constructor(t, i) {
      if (super(), this.qn = "parent", this.Vg = false, this.wf = "parentLinkCategory", t !== void 0 && (Array.isArray(t) ? this.nodeDataArray = t : i = t), i) {
        Object.assign(this, i);
        const e = i.Changed;
        e && (delete this.Changed, this.addChangedListener(e));
      }
    }
    cloneProtected(t) {
      super.cloneProtected(t), t.qn = this.qn, t.Vg = this.Vg, t.wf = this.wf;
    }
    toString(t) {
      if (t === void 0 && (t = 0), t >= 2) return this.toJson();
      {
        let i = (this.name !== "" ? this.name : "") + " TreeModel";
        if (t > 0) {
          i += `
 node data:`;
          const e = this.nodeDataArray, s = e.length;
          for (let n = 0; n < s; n++) {
            const o = e[n];
            i += " " + this.getKeyForNodeData(o) + ":" + Binding2.toString(o);
          }
        }
        return i;
      }
    }
    Ig() {
      const t = super.Ig();
      let i = "";
      return this.nodeParentKeyProperty !== "parent" && typeof this.nodeParentKeyProperty == "string" && (i += `,
  "nodeParentKeyProperty": ` + this.qe(this.nodeParentKeyProperty)), t + i;
    }
    gw(t) {
      super.gw(t), t.nodeParentKeyProperty && (this.nodeParentKeyProperty = t.nodeParentKeyProperty);
    }
    mw(t) {
      t.nodeParentKeyProperty !== void 0 && t.nodeParentKeyProperty !== this.nodeParentKeyProperty && U.n("applyIncrementalJson cannot change Model properties"), super.mw(t);
    }
    maybeEnsureLinkReference(t) {
      return t;
    }
    get nodeParentKeyProperty() {
      return this.qn;
    }
    set nodeParentKeyProperty(t) {
      const i = this.qn;
      i !== t && (this.Un(t, TreeModel2, "nodeParentKeyProperty"), this.qn = t, this.t("nodeParentKeyProperty", i, t));
    }
    get copiesParentKeyOfNodeData() {
      return this.Vg;
    }
    set copiesParentKeyOfNodeData(t) {
      this.Vg !== t && (U.i(t, "boolean", TreeModel2, "copiesParentKeyOfNodeData"), this.Vg = t);
    }
    getParentKeyForNodeData(t) {
      if (t === null) return;
      const i = this.qn;
      if (i === "") return;
      const e = this.Lt(t, i);
      if (e !== void 0) {
        if (this.isKeyType(e)) return e;
        U.n("ParentKey value for node data " + t + " is not a number or a string: " + e);
      }
    }
    setParentKeyForNodeData(t, i) {
      if (i === null && (i = void 0), i !== void 0 && !this.isKeyType(i) && U.Ti(i, "number or string", TreeModel2, "setParentKeyForNodeData:key"), t === null) return;
      const e = this.qn;
      if (e === "") return;
      if (i = this.maybeEnsureLinkReference(i), !this.containsNodeData(t)) {
        this.rt(t, e, i);
        return;
      }
      const s = this.Lt(t, e);
      s !== i && (this.un(s, t), this.rt(t, e, i), this.findNodeDataForKey(i) === null && this.dn(i, t), this.Vt("nodeParentKey", 2, e, t, s, i), typeof e == "string" && this.updateTargetBindings(t, e));
    }
    get parentLinkCategoryProperty() {
      return this.wf;
    }
    set parentLinkCategoryProperty(t) {
      const i = this.wf;
      i !== t && (this.Un(t, TreeModel2, "parentLinkCategoryProperty"), this.wf = t, this.t("parentLinkCategoryProperty", i, t));
    }
    get linkCategoryProperty() {
      return this.parentLinkCategoryProperty;
    }
    set linkCategoryProperty(t) {
      this.parentLinkCategoryProperty = t;
    }
    getParentLinkCategoryForNodeData(t) {
      if (t === null) return "";
      const i = this.wf;
      if (i === "") return "";
      const e = this.Lt(t, i);
      if (e === void 0) return "";
      if (typeof e == "string") return e;
      U.n("getParentLinkCategoryForNodeData found a non-string category for " + t + ": " + e);
    }
    getLinkCategoryForData(t) {
      return this.getParentLinkCategoryForNodeData(t);
    }
    setParentLinkCategoryForNodeData(t, i) {
      if (U.i(i, "string", TreeModel2, "setParentLinkCategoryForNodeData:cat"), t === null) return;
      const e = this.wf;
      if (e === "") return;
      if (!this.containsNodeData(t)) {
        this.rt(t, e, i);
        return;
      }
      let s = this.Lt(t, e);
      s === void 0 && (s = ""), s !== i && (this.rt(t, e, i), this.Vt("parentLinkCategory", 2, e, t, s, i), typeof e == "string" && this.updateTargetBindings(t, e));
    }
    setLinkCategoryForData(t, i) {
      this.setParentLinkCategoryForNodeData(t, i);
    }
    copyNodeData(t) {
      const i = super.copyNodeData(t);
      return !this.copiesParentKeyOfNodeData && this.qn !== "" && this.Lt(i, this.qn) !== void 0 && this.rt(i, this.qn, void 0), i;
    }
    setDataProperty(t, i, e) {
      if (Debug && (U.Oo(t, TreeModel2, "setDataProperty:data"), U.i(i, "string", TreeModel2, "setDataProperty:propname"), i === "" && U.n("TreeModel.setDataProperty: property name must not be an empty string when setting " + t + " to " + e)), this.containsNodeData(t)) {
        if (i === this.nodeKeyProperty) {
          this.setKeyForNodeData(t, e);
          return;
        } else if (i === this.nodeCategoryProperty) {
          this.setCategoryForNodeData(t, e);
          return;
        } else if (i === this.nodeParentKeyProperty) {
          this.setParentKeyForNodeData(t, e);
          return;
        } else if (i === this.parentLinkCategoryProperty) {
          this.setParentLinkCategoryForNodeData(t, e);
          return;
        }
      }
      const s = this.Lt(t, i);
      s !== e && (this.rt(t, i, e), this.raiseDataChanged(t, i, s, e));
    }
    pw(t, i) {
      super.pw(t, i);
      const e = this.Pi.iterator;
      for (; e.next(); ) {
        const s = e.value;
        this.cA(s, t, i);
      }
    }
    cA(t, i, e) {
      if (this.getParentKeyForNodeData(t) === i) {
        const n = this.qn;
        this.rt(t, n, e), this.Vt("nodeParentKey", 2, n, t, i, e), typeof n == "string" && this.updateTargetBindings(t, n);
      }
    }
    Og(t) {
      super.Og(t);
      const i = this.getKeyForNodeData(t), e = this.fw(i);
      if (e !== null) {
        const s = U.ft(), n = e.iterator;
        for (; n.next(); ) {
          const o = n.value;
          if (this.containsNodeData(o) && this.getParentKeyForNodeData(o) === i) {
            const l = this.qn;
            this.Vt("nodeParentKey", 2, l, o, i, i), typeof l == "string" && this.updateTargetBindings(o, l), s.push(o);
          }
        }
        for (let o = 0; o < s.length; o++) this.un(i, s[o]);
        U.et(s);
      }
    }
    Eg(t) {
      super.Eg(t);
      let i = this.getParentKeyForNodeData(t);
      i = this.maybeEnsureLinkReference(i), this.findNodeDataForKey(i) === null && this.dn(i, t);
    }
    ww(t) {
      super.ww(t);
      const i = this.getParentKeyForNodeData(t);
      this.un(i, t);
    }
    Rg(t, i) {
      super.Rg(t, i), this.setParentLinkCategoryForNodeData(i, this.getParentLinkCategoryForNodeData(t)), this.setParentKeyForNodeData(i, this.getParentKeyForNodeData(t));
    }
    get type() {
      return "TreeModel";
    }
    Um() {
      return true;
    }
    Ex() {
      return true;
    }
  }
  Model2.Al(TreeModel2, "TreeModel");
  var CircularArrangement2 = ((w) => (w[w.ConstantSpacing = 0] = "ConstantSpacing", w[w.ConstantDistance = 1] = "ConstantDistance", w[w.ConstantAngle = 2] = "ConstantAngle", w[w.Packed = 3] = "Packed", w))(CircularArrangement2 || {}), CircularDirection2 = ((w) => (w[w.Clockwise = 10] = "Clockwise", w[w.Counterclockwise = 11] = "Counterclockwise", w[w.BidirectionalLeft = 12] = "BidirectionalLeft", w[w.BidirectionalRight = 13] = "BidirectionalRight", w))(CircularDirection2 || {}), CircularSorting2 = ((w) => (w[w.Forwards = 20] = "Forwards", w[w.Reverse = 21] = "Reverse", w[w.Ascending = 22] = "Ascending", w[w.Descending = 23] = "Descending", w[w.Optimized = 24] = "Optimized", w))(CircularSorting2 || {}), CircularNodeDiameterFormula2 = ((w) => (w[w.Pythagorean = 30] = "Pythagorean", w[w.Circular = 31] = "Circular", w))(CircularNodeDiameterFormula2 || {});
  class CircularLayout2 extends Layout2 {
    pe;
    ou;
    qS;
    zg;
    HS;
    Wh;
    uA;
    dA;
    gA;
    Ys;
    xw;
    bw;
    xf;
    Sw;
    lI;
    Xg;
    Yg;
    Kg;
    ru;
    Ji;
    N;
    Ce;
    Ae;
    Kn;
    Ug;
    constructor(t) {
      super(), this.pe = 0, this.ou = 0, this.qS = 0, this.zg = 360, this.HS = 0, this.Wh = 0, this.uA = new Point2(), this.dA = 30, this.gA = 0, this.Ys = 0, this.xw = 0, this.bw = new VertexArrangement(), this.xf = 0, this.Sw = 0, this.lI = 600, this.Xg = NaN, this.Yg = 1, this.Kg = 0, this.ru = 360, this.Ji = 0, this.N = 10, this.Ce = 24, this.Ae = LayoutVertex2.standardComparer, this.Kn = 6, this.Ug = 30, t && Object.assign(this, t);
    }
    cloneProtected(t) {
      super.cloneProtected(t), t.Xg = this.Xg, t.Yg = this.Yg, t.Kg = this.Kg, t.ru = this.ru, t.Ji = this.Ji, t.N = this.N, t.Ce = this.Ce, t.Ae = this.Ae, t.Kn = this.Kn, t.Ug = this.Ug;
    }
    gi(t) {
      t in CircularSorting2 ? this.sorting = t : t in CircularDirection2 ? this.direction = t : t in CircularArrangement2 ? this.arrangement = t : t in CircularNodeDiameterFormula2 ? this.nodeDiameterFormula = t : super.gi(t);
    }
    createNetwork() {
      return new CircularNetwork2(this);
    }
    w4(t, i, e) {
      t = this.x4(t);
      let s = this.HS, n = this.dA, o = this.pe, r = this.ou, l = this.qS, h = this.zg, f = this.Wh, a = this.gA, c = this.Ys, u = this.xw;
      if (s = this.arrangement, n = this.nodeDiameterFormula, o = this.radius, (!isFinite(o) || o <= 0) && (o = NaN), r = this.aspectRatio, (!isFinite(r) || r <= 0) && (r = 1), l = this.startAngle, isFinite(l) || (l = 0), h = this.sweepAngle, (!isFinite(h) || h > 360 || h < 1) && (h = 360), f = this.spacing, isFinite(f) || (f = NaN), s === 3 && n === 31 ? s = 0 : s === 3 && n !== 31 && (n = 31, s = this.arrangement), (this.direction === 12 || this.direction === 13) && this.sorting !== 24) {
        for (let g = 0; !(g >= t.length || (i.add(t.elt(g)), g + 1 >= t.length)); g += 2) e.add(t.elt(g + 1));
        this.direction === 12 ? (this.arrangement === 3 && i.reverse(), t = new List2(), t.addAll(i), t.addAll(e)) : (this.arrangement === 3 && e.reverse(), t = new List2(), t.addAll(e), t.addAll(i));
      }
      const d = t.length;
      a = 0;
      let m = 0;
      for (let g = 0; g < t.length; g++) {
        const p = l + h * m * (this.direction === 10 ? 1 : -1) / d;
        let y = t.elt(g).diameter;
        isNaN(y) && (y = t.elt(g).jh(p)), h < 360 && (g === 0 || g === t.length - 1) && (y /= 2), a += y, m++;
      }
      if (isNaN(o) || s === 3) {
        if (isNaN(f) && (f = 6), s !== 0 && s !== 3) {
          let g = -1 / 0;
          for (let p = 0; p < d; p++) {
            const y = t.elt(p), x = t.elt(p === d - 1 ? 0 : p + 1);
            isNaN(y.diameter) && y.jh(0), isNaN(x.diameter) && x.jh(0), g = Math.max(g, (y.diameter + x.diameter) / 2);
          }
          if (u = g + f, s === 2) {
            const p = 2 * Math.PI / d, y = (g + f) / p;
            r > 1 ? (o = y, c = o * r) : (c = y, o = c);
          } else o = this.vS(u * (h >= 360 ? d : d - 1), r, l * Math.PI / 180, h * Math.PI / 180);
        } else o = this.vS(a + (h >= 360 ? d : d - 1) * (s !== 3 ? f : f * 1.6), r, l * Math.PI / 180, h * Math.PI / 180);
        c = o * r;
      } else {
        c = o * r;
        const g = this.mA(o, c, l * Math.PI / 180, h * Math.PI / 180);
        if (isNaN(f)) s === 0 && (f = (g - a) / (h >= 360 ? d : d - 1));
        else if (s === 0) {
          const p = (g - a) / (h >= 360 ? d : d - 1);
          p < f ? (o = this.vS(a + f * (h >= 360 ? d : d - 1), r, l * Math.PI / 180, h * Math.PI / 180), c = o * r) : f = p;
        } else {
          let p = -1 / 0;
          for (let S = 0; S < d; S++) {
            const b = t.elt(S), k = t.elt(S === d - 1 ? 0 : S + 1);
            isNaN(b.diameter) && b.jh(0), isNaN(k.diameter) && k.jh(0), p = Math.max(p, (b.diameter + k.diameter) / 2);
          }
          const y = p + f, x = this.vS(y * (h >= 360 ? d : d - 1), r, l * Math.PI / 180, h * Math.PI / 180);
          x > o ? (o = x, c = o * r, u = y) : u = g / (h >= 360 ? d : d - 1);
        }
      }
      return this.HS = s, this.dA = n, this.pe = o, this.ou = r, this.qS = l, this.zg = h, this.Wh = f, this.gA = a, this.Ys = c, this.xw = u, t;
    }
    doLayout(t) {
      Debug && t === null && U.n("Layout.doLayout(collection) argument must not be null but a Diagram, a Group, or an Iterable of Parts"), this.network === null && (this.network = this.makeNetwork(t)), this.arrangementOrigin = this.initialOrigin(this.arrangementOrigin);
      const i = this.network.vertexes;
      if (i.count <= 1) {
        if (i.count === 1) {
          const u = i.first();
          u.centerX = 0, u.centerY = 0;
        }
        this.updateParts(), this.network = null, this.isValidLayout = true;
        return;
      }
      let e = new List2();
      e.addAll(i.iterator);
      const s = new List2(), n = new List2();
      e = this.w4(e, s, n);
      const o = this.HS, r = this.pe, l = this.qS, h = this.zg, f = this.Wh, a = this.Ys, c = this.xw;
      if ((this.direction === 12 || this.direction === 13) && o === 3) this.hI(e, h, l - h / 2, 10);
      else if (this.direction === 12 || this.direction === 13) {
        let u = 0;
        switch (o) {
          case 1:
            u = this.WS(r, a, l, c) * 180 / Math.PI;
            break;
          case 0: {
            let d = 0, m = 0;
            const g = s.first();
            g !== null && (d = g.jh(Math.PI / 2));
            const p = n.first();
            p !== null && (m = p.jh(Math.PI / 2)), u = this.WS(r, a, l, f + (d + m) / 2) * 180 / Math.PI;
            break;
          }
          case 2:
            u = h / e.length;
            break;
        }
        if (this.direction === 12) {
          switch (o) {
            case 1:
              this.kw(s, h / 2, l, 11);
              break;
            case 0:
              this.Pw(s, h / 2, l, 11);
              break;
            case 2:
              this.Mw(s, h / 2, l, 11);
              break;
          }
          switch (o) {
            case 1:
              this.kw(n, h / 2, l + u, 10);
              break;
            case 0:
              this.Pw(n, h / 2, l + u, 10);
              break;
            case 2:
              this.Mw(n, h / 2, l + u, 10);
              break;
          }
        } else {
          switch (o) {
            case 1:
              this.kw(n, h / 2, l, 11);
              break;
            case 0:
              this.Pw(n, h / 2, l, 11);
              break;
            case 2:
              this.Mw(n, h / 2, l, 11);
              break;
          }
          switch (o) {
            case 1:
              this.kw(s, h / 2, l + u, 10);
              break;
            case 0:
              this.Pw(s, h / 2, l + u, 10);
              break;
            case 2:
              this.Mw(s, h / 2, l + u, 10);
              break;
          }
        }
      } else switch (o) {
        case 1:
          this.kw(e, h, l, this.direction);
          break;
        case 0:
          this.Pw(e, h, l, this.direction);
          break;
        case 2:
          this.Mw(e, h, l, this.direction);
          break;
        case 3:
          this.hI(e, h, l, this.direction);
          break;
      }
      this.updateParts(), this.network = null, this.isValidLayout = true;
    }
    Mw(t, i, e, s) {
      const n = this.zg, o = this.pe, r = this.Ys, l = e * Math.PI / 180, h = i * Math.PI / 180, f = t.length;
      for (let a = 0; a < f; a++) {
        const c = l + (s === 10 ? a * h / (n >= 360 ? f : f - 1) : -(a * h) / f), u = t.elt(a), d = o * Math.tan(c) / r, m = Math.sqrt((o * o + r * r * d * d) / (1 + d * d));
        u.centerX = m * Math.cos(c), u.centerY = m * Math.sin(c), u.actualAngle = c * 180 / Math.PI;
      }
    }
    Pw(t, i, e, s) {
      const n = this.pe, o = this.Ys, r = this.Wh;
      let l = e * Math.PI / 180;
      const h = t.length;
      for (let f = 0; f < h; f++) {
        const a = t.elt(f), c = t.elt(f === h - 1 ? 0 : f + 1), u = n * Math.cos(l), d = o * Math.sin(l);
        a.centerX = u, a.centerY = d, a.actualAngle = l * 180 / Math.PI, isNaN(a.diameter) && a.jh(0), isNaN(c.diameter) && c.jh(0);
        const m = (a.diameter + c.diameter) / 2, g = this.WS(n, o, s === 10 ? l : -l, m + r);
        l += s === 10 ? g : -g;
      }
    }
    kw(t, i, e, s) {
      const n = this.pe, o = this.Ys, r = this.xw;
      let l = e * Math.PI / 180;
      const h = t.length;
      for (let f = 0; f < h; f++) {
        const a = t.elt(f);
        a.centerX = n * Math.cos(l), a.centerY = o * Math.sin(l), a.actualAngle = l * 180 / Math.PI;
        const c = this.WS(n, o, s === 10 ? l : -l, r);
        l += s === 10 ? c : -c;
      }
    }
    hI(t, i, e, s) {
      let n = this.Sw;
      const o = this.zg;
      if (this.xf = 0, this.bw = new VertexArrangement(), i < 360) {
        for (n = e + (s === 10 ? o : -o); n < 0; ) n += 360;
        n %= 360, n > 180 && (n -= 360), n *= Math.PI / 180, this.Sw = n, this.aI(t, i, e, s);
      } else this.fI(t, i, e, s);
      this.bw.commit(t);
    }
    fI(t, i, e, s) {
      const n = this.pe, o = this.Ys, r = this.Wh, l = this.ou;
      let h = n * Math.cos(e * Math.PI / 180), f = o * Math.sin(e * Math.PI / 180);
      const a = t.toArray();
      if (a.length === 3) {
        a[0].centerX = n, a[0].centerY = 0, a[1].centerX = a[0].centerX - a[0].width / 2 - a[1].width / 2 - r, a[1].y = a[0].y, a[2].centerX = (a[0].centerX + a[1].centerX) / 2, a[2].y = a[0].y - a[2].height - r;
        return;
      } else if (a.length === 4) {
        a[0].centerX = n, a[0].centerY = 0, a[2].centerX = -a[0].centerX, a[2].centerY = a[0].centerY, a[1].centerX = 0, a[1].y = Math.min(a[0].y, a[2].y) - a[1].height - r, a[3].centerX = 0, a[3].y = Math.max(a[0].y + a[0].height + r, a[2].y + a[2].height + r);
        return;
      }
      const c = Point2.a();
      for (let b = 0; b < a.length && (a[b].centerX = h, a[b].centerY = f, !(b >= a.length - 1)); b++) this.cI(h, f, a, b, s, c) || this.uI(h, f, a, b, s, c), h = c.x, f = c.y;
      if (Point2.o(c), this.xf++, this.xf > 23) return;
      const u = a[0].centerX, d = a[0].centerY, m = a[a.length - 1].centerX, g = a[a.length - 1].centerY;
      let p = Math.abs(u - m) - ((a[0].width + a[a.length - 1].width) / 2 + r);
      const y = Math.abs(d - g) - ((a[0].height + a[a.length - 1].height) / 2 + r);
      let x = 0;
      if (Math.abs(y) < 1) {
        const b = Math.abs(u - m), k = (a[0].width + a[a.length - 1].width) / 2;
        b < k && (x = 0), p = b - k;
      } else y > 0 ? x = y : Math.abs(p) < 1 ? x = 0 : x = p;
      let S = false;
      Math.abs(m) > Math.abs(g) ? S = m > 0 != d > g : S = g > 0 != u < m, S = s === 10 ? S : !S, S && (x = -Math.abs(x), x = Math.min(x, -a[a.length - 1].width), x = Math.min(x, -a[a.length - 1].height)), this.bw.b4(x, a), Math.abs(x) > 1 && (this.xf < 8 ? this.pe -= x / (2 * Math.PI) : a.length < 5 && x > 10 ? this.pe /= 2 : this.pe -= x > 0 ? 1.7 : -2.3, this.Ys = this.pe * l, this.fI(t, i, e, s));
    }
    aI(t, i, e, s) {
      const n = this.pe, o = this.Ys, r = this.ou;
      let l = n * Math.cos(e * Math.PI / 180), h = o * Math.sin(e * Math.PI / 180);
      const f = Point2.a(), a = t.toArray();
      for (let m = 0; m < a.length && (a[m].centerX = l, a[m].centerY = h, !(m >= a.length - 1)); m++) this.cI(l, h, a, m, s, f) || this.uI(l, h, a, m, s, f), l = f.x, h = f.y;
      if (Point2.o(f), this.xf++, this.xf > 23) return;
      const c = Math.atan2(h, l);
      let u = s === 10 ? this.Sw - c : c - this.Sw;
      u = Math.abs(u) < Math.abs(u - 2 * Math.PI) ? u : u - 2 * Math.PI;
      const d = u * (n + o) / 2;
      this.bw.S4(d, a), Math.abs(d) > 1 && (this.xf < 8 ? this.pe -= d / (2 * Math.PI) : this.pe -= d > 0 ? 1.7 : -2.3, this.Ys = this.pe * r, this.aI(t, i, e, s));
    }
    cI(t, i, e, s, n, o) {
      const r = this.Wh, l = this.pe, h = this.Ys;
      let f = 0, a = 0;
      const c = (e[s].width + e[s + 1].width) / 2 + r;
      let u = false;
      if (i >= 0 != (n === 10)) {
        if (f = t + c, f > l) {
          if (f = t - c, f < -l) return o.x = f, o.y = a, false;
          u = true;
        }
      } else if (f = t - c, f < -l) {
        if (f = t + c, f > l) return o.x = f, o.y = a, false;
        u = true;
      }
      return a = Math.sqrt(1 - Math.min(1, f * f / (l * l))) * h, i < 0 !== u && (a = -a), Math.abs(i - a) > (e[s].height + e[s + 1].height) / 2 ? (o.x = f, o.y = a, false) : (o.x = f, o.y = a, true);
    }
    uI(t, i, e, s, n, o) {
      const r = this.Wh, l = this.pe, h = this.Ys;
      let f = 0, a = 0;
      const c = (e[s].height + e[s + 1].height) / 2 + r;
      let u = false;
      if (t >= 0 != (n === 10)) {
        if (a = i - c, a < -h) {
          if (a = i + c, a > h) return o.x = f, o.y = a, false;
          u = true;
        }
      } else if (a = i + c, a > h) {
        if (a = i - c, a < -h) return o.x = f, o.y = a, false;
        u = true;
      }
      return f = Math.sqrt(1 - Math.min(1, a * a / (h * h))) * l, t < 0 !== u && (f = -f), Math.abs(t - f) > (e[s].width + e[s + 1].width) / 2 ? (o.x = f, o.y = a, false) : (o.x = f, o.y = a, true);
    }
    commitLayout() {
      this.commitNodes(), this.isRouting && this.commitLinks();
    }
    commitNodes() {
      const t = this.group !== null && this.group.hasPlaceholder(), i = t ? this.group.location.copy() : null;
      let e = this.actualCenter;
      if (t ? e = new Point2(0, 0) : (e.x = this.arrangementOrigin.x + this.pe, e.y = this.arrangementOrigin.y + this.Ys), this.network !== null) {
        const s = this.network.vertexes.iterator;
        for (; s.next(); ) {
          const n = s.value;
          n.x += e.x, n.y += e.y, n.commit();
        }
      }
      if (t && this.group && i) {
        this.group.ensureBounds();
        const s = this.group.position.copy(), n = this.group.location.copy(), o = i.subtract(n.subtract(s));
        this.group.move(o), this.uA = o.subtract(s);
      }
    }
    commitLinks() {
      if (this.network !== null) {
        const t = this.network.edges.iterator;
        for (; t.next(); ) t.value.commit();
      }
    }
    mA(t, i, e, s) {
      const n = this.lI;
      if (Math.abs(this.ou - 1) < 1e-3) return e !== void 0 && s !== void 0 ? s * t : 2 * Math.PI * t;
      const o = t > i ? Math.sqrt(t * t - i * i) / t : Math.sqrt(i * i - t * t) / i;
      let r = 0, l = 0;
      e !== void 0 && s !== void 0 ? l = s / (n + 1) : l = Math.PI / (2 * (n + 1));
      let h = 0;
      for (let f = 0; f <= n; f++) {
        e !== void 0 && s !== void 0 ? h = e + f * s / n : h = f * Math.PI / (2 * n);
        const a = Math.sin(h);
        r += Math.sqrt(1 - o * o * a * a) * l;
      }
      return e !== void 0 && s !== void 0 ? (t > i ? t : i) * r : 4 * (t > i ? t : i) * r;
    }
    vS(t, i, e, s) {
      let n = 0;
      return e !== void 0 && s !== void 0 ? n = this.mA(1, i, e, s) : n = this.mA(1, i), t / n;
    }
    WS(t, i, e, s) {
      if (Math.abs(this.ou - 1) < 1e-3) return s / t;
      const n = t > i ? Math.sqrt(t * t - i * i) / t : Math.sqrt(i * i - t * t) / i;
      let o = 0;
      const r = 2 * Math.PI / (this.network.vertexes.count * 700);
      t > i && (e += Math.PI / 2);
      for (let l = 0; ; l++) {
        const h = e + l * r, f = Math.sin(h);
        if (o += (t > i ? t : i) * Math.sqrt(1 - n * n * f * f) * r, o >= s) return l * r;
      }
    }
    x4(t) {
      switch (this.sorting) {
        case 20:
          break;
        case 21:
          t.reverse();
          break;
        case 22:
          t.sort(this.comparer);
          break;
        case 23:
          t.sort(this.comparer), t.reverse();
          break;
        case 24:
          return this.k4(this.P4(t));
        default:
          U.n("Invalid sorting type.");
      }
      return t;
    }
    P4(t) {
      const i = [];
      for (let s = 0; s < t.length; s++) i.push(0);
      const e = new List2();
      for (let s = 0; s < t.length; s++) {
        let n = -1, o = -1;
        if (s === 0) for (let a = 0; a < t.length; a++) {
          const u = t.elt(a).edgesCount;
          u > n && (n = u, o = a);
        }
        else for (let a = 0; a < t.length; a++) {
          const c = i[a];
          c > n && (n = c, o = a);
        }
        e.add(t.elt(o)), i[o] = -1;
        const r = t.elt(o);
        let l = 0;
        const h = r.sourceEdges;
        for (; h.next(); ) {
          const c = h.value.fromVertex;
          l = t.indexOf(c), !(l < 0) && i[l] >= 0 && i[l]++;
        }
        const f = r.destinationEdges;
        for (; f.next(); ) {
          const c = f.value.toVertex;
          l = t.indexOf(c), !(l < 0) && i[l] >= 0 && i[l]++;
        }
      }
      return e;
    }
    k4(t) {
      const i = [];
      for (let c = 0; c < t.length; c++) {
        const u = t.elt(c);
        i[c] = [];
        let d = 0;
        const m = u.destinationEdges;
        for (; m.next(); ) {
          const p = m.value.toVertex;
          d = t.indexOf(p), d !== c && i[c].indexOf(d) < 0 && i[c].push(d);
        }
        const g = u.sourceEdges;
        for (; g.next(); ) {
          const p = g.value.fromVertex;
          d = t.indexOf(p), d !== c && i[c].indexOf(d) < 0 && i[c].push(d);
        }
      }
      const e = [];
      for (let c = 0; c < i.length; c++) e[c] = 0;
      const s = [], n = [], o = [], r = [], l = new List2();
      let h = 0;
      for (let c = 0; c < i.length; c++) {
        const u = i[c].length;
        if (u === 1) {
          r.push(c);
          continue;
        }
        if (u === 0) {
          l.add(t.elt(c));
          continue;
        }
        if (h === 0) {
          s.push(c), h++;
          continue;
        }
        let d = 1 / 0, m = 1 / 0, g = -1;
        const p = [];
        for (let y = 0; y < s.length; y++) i[s[y]].indexOf(s[y === s.length - 1 ? 0 : y + 1]) < 0 && p.push(y === s.length - 1 ? 0 : y + 1);
        if (p.length === 0) for (let y = 0; y < s.length; y++) p.push(y);
        for (let y = 0; y < p.length; y++) {
          const x = p[y], S = this.M4(i[c], n, o, e, x, s);
          let b = 0;
          for (let k = 0; k < i[c].length; k++) {
            const P = i[c][k], A = s.indexOf(P);
            if (A >= 0) {
              const C = Math.abs(x - (A >= x ? A + 1 : A));
              b += C < s.length + 1 - C ? C : s.length + 1 - C;
            }
          }
          for (let k = 0; k < n.length; k++) {
            let P = e[n[k]], A = e[o[k]];
            if (P >= x && P++, A >= x && A++, P > A) {
              const C = A;
              A = P, P = C;
            }
            A - P < (s.length + 2) / 2 == (P < x && x <= A) && b++;
          }
          (S < d || S === d && b < m) && (d = S, m = b, g = x);
        }
        s.splice(g, 0, c);
        for (let y = 0; y < s.length; y++) e[s[y]] = y;
        for (let y = 0; y < i[c].length; y++) {
          const x = i[c][y];
          s.indexOf(x) >= 0 && (n.push(c), o.push(x));
        }
        h++;
      }
      let f = false;
      const a = s.length;
      for (; ; ) {
        f = true;
        for (let c = 0; c < r.length; c++) {
          const u = r[c], d = i[u][0], m = s.indexOf(d);
          if (m >= 0) {
            let g = 0;
            for (let p = 0; p < i[d].length; p++) {
              const y = i[d][p], x = s.indexOf(y);
              if (x < 0 || x === m) continue;
              const S = x > m ? x - m : m - x, b = a - S;
              g += x < m != S > b ? 1 : -1;
            }
            s.splice(g < 0 ? m : m + 1, 0, u), r.splice(c, 1), c--;
          } else f = false;
        }
        if (f) break;
        s.push(r[0]), r.splice(0, 1);
      }
      for (let c = 0; c < s.length; c++) {
        const u = s[c];
        l.add(t.elt(u));
      }
      return l;
    }
    M4(t, i, e, s, n, o) {
      let r = 0;
      for (let l = 0; l < i.length; l++) {
        const h = i[l], f = e[l], a = s[h], c = s[f];
        let u = 0, d = 0;
        if (a < c ? (u = a, d = c) : (u = c, d = a), u < n && n <= d) for (let m = 0; m < t.length; m++) {
          const g = t[m];
          o.indexOf(g) < 0 || u < s[g] && s[g] < d || u === s[g] || d === s[g] || r++;
        }
        else for (let m = 0; m < t.length; m++) {
          const g = t[m];
          o.indexOf(g) < 0 || !(u < s[g] && s[g] < d) || u === s[g] || d === s[g] || r++;
        }
      }
      return r;
    }
    get radius() {
      return this.Xg;
    }
    set radius(t) {
      this.Xg !== t && (U.i(t, "number", CircularLayout2, "radius"), (t > 0 || isNaN(t)) && (this.Xg = t, this.b()));
    }
    get aspectRatio() {
      return this.Yg;
    }
    set aspectRatio(t) {
      this.Yg !== t && (U.i(t, "number", CircularLayout2, "aspectRatio"), t > 0 && (this.Yg = t, this.b()));
    }
    get startAngle() {
      return this.Kg;
    }
    set startAngle(t) {
      this.Kg !== t && (U.i(t, "number", CircularLayout2, "startAngle"), this.Kg = t, this.b());
    }
    get sweepAngle() {
      return this.ru;
    }
    set sweepAngle(t) {
      this.ru !== t && (U.i(t, "number", CircularLayout2, "sweepAngle"), t > 0 && t <= 360 ? this.ru = t : this.ru = 360, this.b());
    }
    get arrangement() {
      return this.Ji;
    }
    set arrangement(t) {
      this.Ji !== t && (U.W(t, CircularArrangement2, "CircularArrangement"), (t === 3 || t === 0 || t === 1 || t === 2) && (this.Ji = t, this.b()));
    }
    get direction() {
      return this.N;
    }
    set direction(t) {
      this.N !== t && (U.W(t, CircularDirection2, "CircularDirection"), (t === 10 || t === 11 || t === 12 || t === 13) && (this.N = t, this.b()));
    }
    get sorting() {
      return this.Ce;
    }
    set sorting(t) {
      this.Ce !== t && (U.W(t, CircularSorting2, "CircularSorting"), this.Ce = t, this.b());
    }
    get comparer() {
      return this.Ae;
    }
    set comparer(t) {
      this.Ae !== t && (U.C(t, CircularLayout2, "comparer"), this.Ae = t, this.b());
    }
    get spacing() {
      return this.Kn;
    }
    set spacing(t) {
      this.Kn !== t && (U.i(t, "number", CircularLayout2, "spacing"), this.Kn = t, this.b());
    }
    get nodeDiameterFormula() {
      return this.Ug;
    }
    set nodeDiameterFormula(t) {
      this.Ug !== t && (U.W(t, CircularNodeDiameterFormula2, "CircularNodeDiameterFormula"), (t === 30 || t === 31) && (this.Ug = t, this.b()));
    }
    get actualXRadius() {
      return this.pe;
    }
    get actualYRadius() {
      return this.Ys;
    }
    get actualSpacing() {
      return this.Wh;
    }
    get actualCenter() {
      return this.uA;
    }
    static ConstantSpacing = 0;
    static ConstantDistance = 1;
    static ConstantAngle = 2;
    static Packed = 3;
    static Clockwise = 10;
    static Counterclockwise = 11;
    static BidirectionalLeft = 12;
    static BidirectionalRight = 13;
    static Forwards = 20;
    static Reverse = 21;
    static Ascending = 22;
    static Descending = 23;
    static Optimized = 24;
    static Pythagorean = 30;
    static Circular = 31;
  }
  class VertexArrangement {
    lu;
    bf;
    hu;
    constructor() {
      this.lu = -1 / 0, this.bf = null, this.hu = null;
    }
    b4(t, i) {
      if (t > 0 && this.lu < 0 || Math.abs(t) < Math.abs(this.lu) && !(t < 0 && this.lu > 0)) {
        this.lu = t, this.bf = [], this.hu = [];
        for (let e = 0; e < i.length; e++) this.bf[e] = i[e].bounds.x, this.hu[e] = i[e].bounds.y;
      }
    }
    S4(t, i) {
      if (Math.abs(t) < Math.abs(this.lu)) {
        this.lu = t, this.bf = [], this.hu = [];
        for (let e = 0; e < i.length; e++) this.bf[e] = i[e].bounds.x, this.hu[e] = i[e].bounds.y;
      }
    }
    commit(t) {
      if (!(this.bf === null || this.hu === null)) for (let i = 0; i < this.bf.length; i++) {
        const e = t.elt(i);
        e.x = this.bf[i], e.y = this.hu[i];
      }
    }
  }
  class CircularNetwork2 extends LayoutNetwork2 {
    constructor(t) {
      super(t);
    }
    createVertex() {
      return new CircularVertex2(this);
    }
    createEdge() {
      return new CircularEdge2(this);
    }
  }
  class CircularVertex2 extends LayoutVertex2 {
    Ro;
    jS;
    constructor(t) {
      super(t), this.Ro = NaN, this.jS = NaN;
    }
    jh(t) {
      const i = this.network;
      if (i === null) return NaN;
      const e = i.layout;
      if (e === null) return NaN;
      if (e.arrangement === 3) {
        if (e.nodeDiameterFormula === 31) return this.Ro = Math.max(this.width, this.height), this.Ro;
        {
          const s = Math.abs(Math.sin(t)), n = Math.abs(Math.cos(t));
          return s === 0 ? this.width : n === 0 ? this.height : (this.Ro = Math.min(this.height / s, this.width / n), this.Ro);
        }
      } else return e.nodeDiameterFormula === 31 ? (this.Ro = Math.max(this.width, this.height), this.Ro) : (this.Ro = Math.sqrt(this.width * this.width + this.height * this.height), this.Ro);
    }
    get diameter() {
      return this.Ro;
    }
    set diameter(t) {
      this.Ro !== t && (U.i(t, "number", CircularVertex2, "diameter"), this.Ro = t);
    }
    get actualAngle() {
      return this.jS;
    }
    set actualAngle(t) {
      this.jS !== t && (U.i(t, "number", CircularVertex2, "actualAngle"), this.jS = t);
    }
  }
  class CircularEdge2 extends LayoutEdge2 {
    constructor(t) {
      super(t);
    }
  }
  class ForceDirectedLayout2 extends Layout2 {
    Nw;
    Jh;
    Ks;
    Gg;
    Hn;
    He;
    qg;
    Hg;
    vg;
    au;
    Wg;
    jg;
    fu;
    cu;
    uu;
    du;
    Jg;
    $g;
    gu;
    Sf;
    constructor(t) {
      super(), this.Nw = 0, this.Jh = 0, this.Ks = new Size2(100, 100).S(), this.Gg = false, this.Hn = true, this.He = false, this.qg = 100, this.Hg = 300, this.vg = 1, this.au = 1e3, this.Wg = 10, this.jg = Math, this.fu = 0.05, this.cu = 50, this.uu = 150, this.du = 0, this.Jg = 10, this.$g = 5, this.gu = NaN, this.Sf = 10, t && Object.assign(this, t);
    }
    cloneProtected(t) {
      super.cloneProtected(t), t.Ks.c(this.Ks), t.Gg = this.Gg, t.Hn = this.Hn, t.He = this.He, t.qg = this.qg, t.Hg = this.Hg, t.vg = this.vg, t.au = this.au, t.Wg = this.Wg, t.jg = this.jg, t.fu = this.fu, t.cu = this.cu, t.uu = this.uu, t.du = this.du, t.Jg = this.Jg, t.$g = this.$g, t.gu = this.gu, t.Sf = this.Sf;
    }
    createNetwork() {
      return new ForceDirectedNetwork2(this);
    }
    doLayout(t) {
      Debug && t === null && U.n("Layout.doLayout(collection) argument must not be null but a Diagram, a Group, or an Iterable of Parts"), this.network = this.makeNetwork(t);
      let i = this.network.vertexes.iterator;
      const e = this.maxIterations;
      if (this.network.vertexes.count > 0) {
        for (this.network.deleteSelfEdges(), i = this.network.vertexes.iterator; i.next(); ) {
          const o = i.value;
          o.charge = this.electricalCharge(o), o.mass = this.gravitationalMass(o);
        }
        const s = this.network.edges.iterator;
        for (; s.next(); ) {
          const o = s.value;
          o.stiffness = this.springStiffness(o), o.length = this.springLength(o);
        }
        if (this.pA(), this.Jh = 0, this.needsPrelayout()) {
          const o = this.network, r = o.splitIntoSubNetworks(false);
          let l = r.iterator;
          for (; l.next(); ) {
            const h = l.value;
            this.doConnectedSubnetLayout(h);
          }
          for (l = r.iterator, this.N4(l, o), l = r.iterator; l.next(); ) {
            const h = l.value, f = h.vertexes.iterator;
            for (; f.next(); ) {
              const c = f.value;
              o.addVertex(c);
            }
            const a = h.edges.iterator;
            for (; a.next(); ) {
              const c = a.value;
              o.addEdge(c);
            }
          }
        } else this.dI(this.network, this.maxIterations);
        this.updateParts();
      }
      this.maxIterations = e, this.isValidLayout = true;
    }
    needsPrelayout() {
      if (this.network === null || this.network.vertexes.count < 3) return false;
      let t = 0, i = 0;
      const e = this.network.vertexes.first().bounds, s = this.network.vertexes.iterator;
      for (; s.next(); ) {
        const n = s.value, o = n.bounds;
        if (isNaN(n.x) || isNaN(n.y) || o.intersectsRect(e) && (t++, t > 2)) return true;
        if (i > 10) return false;
        i++;
      }
      return false;
    }
    doConnectedSubnetLayout(t) {
      let i = t.vertexes.iterator;
      for (; i.next(); ) {
        const l = i.value;
        l.hierarchicalVertexes.add(l);
      }
      let e = t, s = this.gu;
      if (isNaN(s) && (s = t.edges.count / t.vertexes.count), s < t.vertexes.count) for (; e.vertexes.count > Math.max(100, Math.sqrt(s * t.vertexes.count)); ) e = this.coarsenNetwork(e);
      let n = 0;
      i = e.vertexes.iterator;
      let o = this.randomNumberGenerator;
      for (o === null && (this.randomNumberGenerator = o = new RandomNumberGenerator(0)); i.next(); ) {
        i.value.idInCluster = n++;
        const l = 10 * (o.random() - 0.5), h = 10 * (o.random() - 0.5);
        this.isFixed(i.value) || (i.value.x = l, i.value.y = h);
        const f = i.value.hierarchicalVertexes.iterator;
        for (; f.next(); ) this.isFixed(f.value) || (f.value.x = l, f.value.y = h);
      }
      const r = this.computePairwiseDistances(e);
      this.C4(e, r, this.maxPrelayoutIterations, t.vertexes.count), this.dI(t, this.maxIterations);
    }
    computePairwiseDistances(t) {
      const i = t.vertexes.count, e = new Array(i);
      for (let r = 0; r < i; r++) e[r] = new Array(i).fill(-1), e[r][r] = 0;
      const s = t.vertexes.iterator;
      let n = /* @__PURE__ */ new Map(), o = [];
      for (; s.next(); ) {
        const r = s.value;
        for (o = [r], n = /* @__PURE__ */ new Map(), n.set(r.idInCluster, 0); o.length > 0; ) {
          const l = o.shift(), h = l.vertexes.iterator;
          for (; h.next(); ) {
            const f = h.value;
            n.has(f.idInCluster) || (n.set(f.idInCluster, n.get(l.idInCluster) + 1), o.push(f));
          }
        }
        for (let l = 0; l < i; l++) {
          const h = Math.min(e[r.idInCluster][l], e[l][r.idInCluster]), f = n.get(l);
          (h < 0 || f < h) && (e[r.idInCluster][l] = f, e[l][r.idInCluster] = f);
        }
      }
      return e;
    }
    coarsenNetwork(t) {
      const i = this.createNetwork(), e = /* @__PURE__ */ new Map();
      let s = 0, n = t.vertexes.iterator;
      for (; n.next(); ) n.value.idInCluster = s++;
      for (n = t.vertexes.iterator; n.next(); ) {
        const r = n.value;
        if (e.has(r.idInCluster)) continue;
        let l = Number.MAX_SAFE_INTEGER, h = null;
        const f = r.vertexes.iterator;
        for (; f.next(); ) {
          const c = f.value;
          e.has(c.idInCluster) || c.hierarchicalVertexes.length < l && (l = c.hierarchicalVertexes.length, h = c);
        }
        const a = i.createVertex();
        a.hierarchicalVertexes.addAll(r.hierarchicalVertexes), h != null && a.hierarchicalVertexes.addAll(h.hierarchicalVertexes), e.set(r.idInCluster, a), h != null && e.set(h.idInCluster, a), i.addVertex(a);
      }
      const o = t.edges.iterator;
      for (; o.next(); ) {
        const r = o.value, l = e.get(r.fromVertex.idInCluster), h = e.get(r.toVertex.idInCluster);
        if (l === h) continue;
        const f = i.createEdge();
        f.fromVertex = l || null, f.toVertex = h || null, i.addEdge(f);
      }
      return i;
    }
    wx(t, i) {
      let e = true;
      const s = t.vertexes.iterator;
      for (; s.next(); ) {
        const n = s.value;
        e ? (e = false, i.set(n.bounds)) : i.unionRect(n.bounds);
      }
      return i;
    }
    N4(t, i) {
      Debug && U.s(i, ForceDirectedNetwork2, ForceDirectedLayout2, "arrangeConnectedGraphs:singletons");
      const e = this.arrangementSpacing, s = t.count;
      let n = true, o = 0, r = 0;
      const l = U.ft();
      for (let c = 0; c < s + i.vertexes.count + 2; c++) l[c] = null;
      let h = 0;
      t.reset();
      const f = Rect2.a();
      let a;
      for (; t.next(); ) {
        const c = t.value;
        if (this.wx(c, f), n) n = false, o = f.x + f.width / 2, r = f.y + f.height / 2, l[0] = new Point2(f.x + f.width + e.width, f.y), l[1] = new Point2(f.x, f.y + f.height + e.height), h = 2;
        else {
          const u = this.gI(l, h, o, r, f.width, f.height, e), d = l[u], m = new Point2(d.x + f.width + e.width, d.y), g = new Point2(d.x, d.y + f.height + e.height);
          u + 1 < h && l.splice(u + 1, 0, null), l[u] = m, l[u + 1] = g, h++;
          const p = d.x - f.x, y = d.y - f.y;
          for (a = c.vertexes.iterator; a.next(); ) {
            const x = a.value;
            this.isFixed(x) || (x.centerX += p, x.centerY += y);
          }
        }
      }
      for (Rect2.o(f), a = i.vertexes.iterator; a.next(); ) {
        const c = a.value, u = c.bounds;
        if (h < 2) {
          o = u.x + u.width / 2, r = u.y + u.height / 2, l[0] = new Point2(u.x + u.width + e.width, u.y), l[1] = new Point2(u.x, u.y + u.height + e.height), h = 2;
          continue;
        }
        const d = this.gI(l, h, o, r, u.width, u.height, e), m = l[d], g = new Point2(m.x + u.width + e.width, m.y), p = new Point2(m.x, m.y + u.height + e.height);
        d + 1 < h && l.splice(d + 1, 0, null), l[d] = g, l[d + 1] = p, h++, this.isFixed(c) || (c.centerX = m.x + c.width / 2, c.centerY = m.y + c.height / 2);
      }
      U.et(l);
    }
    gI(t, i, e, s, n, o, r) {
      let l = 9e19, h = -1;
      t: for (let f = 0; f < i; f++) {
        const a = t[f], c = a.x - e, u = a.y - s, d = c * c + u * u;
        if (d < l) {
          for (let m = f - 1; m >= 0; m--) if (t[m].y > a.y && t[m].x - a.x < n + r.width) continue t;
          for (let m = f + 1; m < i; m++) if (t[m].x > a.x && t[m].y - a.y < o + r.height) continue t;
          h = f, l = d;
        }
      }
      return h;
    }
    pA() {
      if (this.network === null || !this.comments) return;
      const t = this.network.vertexes.iterator;
      for (; t.next(); ) {
        const i = t.value;
        this.addComments(i);
      }
    }
    addComments(t) {
      if (this.network === null) return;
      const i = t.node;
      if (i !== null) {
        const e = i.findNodesConnected();
        for (; e.next(); ) {
          const s = e.value;
          if (s.category !== "Comment" || !s.isVisible()) continue;
          let n = this.network.findVertex(s);
          n === null && (n = this.network.addNode(s)), n.charge = this.defaultCommentElectricalCharge;
          let o = null;
          const r = n.destinationEdges;
          for (; r.next(); ) {
            const l = r.value;
            if (l.toVertex === t) {
              o = l;
              break;
            }
          }
          if (o === null) {
            const l = n.sourceEdges;
            for (; l.next(); ) {
              const h = l.value;
              if (h.fromVertex === t) {
                o = h;
                break;
              }
            }
          }
          o === null && (o = this.network.linkVertexes(t, n, null)), o.length = this.defaultCommentSpringLength;
        }
      }
    }
    mI(t, i) {
      const e = t.bounds, s = e.x, n = e.y, o = e.width, r = e.height, l = i.bounds, h = l.x, f = l.y, a = l.width, c = l.height;
      if (s + o < h) if (n > f + c) {
        const u = s + o - h, d = n - f - c;
        return G.ux(u * u + d * d);
      } else if (n + r < f) {
        const u = s + o - h, d = n + r - f;
        return G.ux(u * u + d * d);
      } else return h - (s + o);
      else if (s > h + a) if (n > f + c) {
        const u = s - h - a, d = n - f - c;
        return G.ux(u * u + d * d);
      } else if (n + r < f) {
        const u = s - h - a, d = n + r - f;
        return G.ux(u * u + d * d);
      } else return s - (h + a);
      else return n > f + c ? n - (f + c) : n + r < f ? f - (n + r) : 0.1;
    }
    dI(t, i) {
      Debug && U.r(i, ForceDirectedLayout2, "performIterations:num");
      const e = this.Jh + i;
      for (; this.Jh < e && (this.Jh++, !!this.A4(t)); ) ;
    }
    A4(t) {
      const i = t.vertexes.toArray();
      if (i.length <= 0) return false;
      const e = i[0];
      e.forceX = 0, e.forceY = 0;
      let s = e.centerX, n = s, o = e.centerY, r = o;
      for (let m = 1; m < i.length; m++) {
        const g = i[m];
        g.forceX = 0, g.forceY = 0;
        const p = g.centerX, y = g.centerY;
        s = Math.min(s, p), n = Math.max(n, p), o = Math.min(o, y), r = Math.max(r, y);
      }
      const l = n - s > r - o;
      l ? i.sort((m, g) => m === null || g === null || m === g ? 0 : m.centerX - g.centerX) : i.sort((m, g) => m === null || g === null || m === g ? 0 : m.centerY - g.centerY);
      const h = this.au;
      let f = 0, a = 0, c = 0;
      for (let m = 0; m < i.length; m++) {
        const g = i[m], p = g.bounds, y = g.focus, x = p.x + y.x, S = p.y + y.y;
        a = g.charge * this.electricalFieldX(x, S), c = g.charge * this.electricalFieldY(x, S), a += g.mass * this.gravitationalFieldX(x, S), c += g.mass * this.gravitationalFieldY(x, S), g.forceX += a, g.forceY += c;
        for (let b = m + 1; b < i.length; b++) {
          const k = i[b];
          if (!this.shouldInteract(g, k) || b === m) continue;
          const P = k.bounds, A = k.focus, C = P.x + A.x, M = P.y + A.y;
          if (x - C > h || C - x > h) {
            if (l) break;
            continue;
          }
          if (S - M > h || M - S > h) {
            if (!l) break;
            continue;
          }
          const N = this.mI(g, k), L = 2 * g.charge, T = 2 * k.charge;
          if (N > 1) f = L * T / (N * N), a = f * (x - C) / N, c = f * (S - M) / N;
          else {
            let D = this.randomNumberGenerator;
            D === null && (this.randomNumberGenerator = D = new RandomNumberGenerator(0));
            const F = D.random(), R = D.random();
            if (x > C) a = Math.abs(k.bounds.right - g.bounds.x), a = L * T * (1 + a) * F;
            else if (x < C) a = Math.abs(k.bounds.x - g.bounds.right), a = -(L * T) * (1 + a) * F;
            else {
              const I = Math.max(k.width, g.width);
              a = L * T * ((1 + I) * F - I / 2);
            }
            if (S > M) c = Math.abs(k.bounds.bottom - g.bounds.y), c = L * T * (1 + c) * R;
            else if (x < C) c = Math.abs(k.bounds.y - g.bounds.bottom), c = -(L * T) * (1 + c) * R;
            else {
              const I = Math.max(k.height, g.height);
              c = L * T * ((1 + I) * R - I / 2);
            }
          }
          g.forceX += a, g.forceY += c, k.forceX -= a, k.forceY -= c;
        }
      }
      const u = t.edges.iterator;
      for (; u.next(); ) {
        const m = u.value, g = m.fromVertex, p = m.toVertex, y = g.bounds, x = g.focus, S = y.x + x.x, b = y.y + x.y, k = p.bounds, P = p.focus, A = k.x + P.x, C = k.y + P.y, M = this.mI(g, p);
        M > 1 && (f = 0.1 * m.stiffness * (M - m.length), a = f * 0.5 * (g.width + p.height) * (S - A) / M, c = f * 0.5 * (g.width + p.height) * (b - C) / M), g.forceX -= a, g.forceY -= c, p.forceX += a, p.forceY += c;
      }
      let d = 0;
      for (let m = 0; m < i.length; m++) {
        const g = i[m];
        this.isFixed(g) ? this.moveFixedVertex(g) : d = Math.max(d, this.moveVertex(g) || 0);
      }
      return d > this.epsilonDistance * this.epsilonDistance;
    }
    C4(t, i, e, s) {
      Debug && U.r(e, ForceDirectedLayout2, "performIterations:num");
      const n = this.Jh + e, o = Math.sqrt(s);
      this.Nw = this.Sf * t.vertexes.count;
      const r = t.vertexes.toArray();
      let l = 0, h = 0, f = 0;
      for (; this.Jh < n; ) {
        this.Jh++, h = l, l = 0;
        for (let a = 0; a < r.length; a++) {
          r[a].forceX = 0, r[a].forceY = 0;
          for (let u = 0; u < r.length; u++) {
            if (a === u) continue;
            const d = Math.sqrt((r[a].centerX - r[u].centerX) ** 2 + (r[a].centerY - r[u].centerY) ** 2), m = i[r[a].idInCluster][r[u].idInCluster], g = (d - this.Sf * o * m) / d;
            r[a].forceX += g * (r[u].x - r[a].x), r[a].forceY += g * (r[u].y - r[a].y);
          }
          const c = Math.sqrt(r[a].forceX * r[a].forceX + r[a].forceY * r[a].forceY);
          if (c > 0) {
            r[a].forceX = this.Nw * r[a].forceX / c, r[a].forceY = this.Nw * r[a].forceY / c, this.isFixed(r[a]) || (r[a].x += r[a].forceX, r[a].y += r[a].forceY);
            const u = r[a].hierarchicalVertexes.iterator;
            for (; u.next(); ) {
              const d = u.value;
              this.isFixed(d) || (d.centerX += r[a].forceX, d.centerY += r[a].forceY);
            }
          }
          l += c * c;
        }
        if (l >= h) {
          if (f++, f >= 5) break;
        } else f = 0;
        this.Nw *= 0.95;
      }
    }
    moveVertex(t) {
      let i = t.forceX, e = t.forceY;
      const s = this.moveLimit;
      return i < -s ? i = -s : i > s && (i = s), e < -s ? e = -s : e > s && (e = s), t.centerX += i, t.centerY += e, i * i + e * e;
    }
    shouldInteract(t, i) {
      return true;
    }
    moveFixedVertex(t) {
    }
    commitLayout() {
      this.Cw(), this.commitNodes(), this.isRouting && this.commitLinks();
    }
    Cw() {
      if (this.network === null || !this.setsPortSpots) return;
      const t = this.network.edges.iterator;
      for (; t.next(); ) {
        const e = t.value.link;
        e !== null && (e.fromSpot = Spot2.Default, e.toSpot = Spot2.Default);
      }
    }
    commitNodes() {
      if (!this.network) return;
      let t = 0, i = 0;
      if (this.arrangesToOrigin) {
        const n = Rect2.a();
        this.wx(this.network, n);
        const o = this.arrangementOrigin;
        t = o.x - n.x, i = o.y - n.y, Rect2.o(n);
      }
      const e = Rect2.a(), s = this.network.vertexes.iterator;
      for (; s.next(); ) {
        const n = s.value;
        (t !== 0 || i !== 0) && (e.c(n.bounds), e.x += t, e.y += i, n.bounds = e), n.commit();
      }
      Rect2.o(e);
    }
    commitLinks() {
      if (!this.network) return;
      const t = this.network.edges.iterator;
      for (; t.next(); ) t.value.commit();
    }
    springStiffness(t) {
      const i = t.stiffness;
      return isNaN(i) ? this.fu : i;
    }
    springLength(t) {
      const i = t.length;
      return isNaN(i) ? this.cu : i;
    }
    electricalCharge(t) {
      const i = t.charge;
      return isNaN(i) ? this.uu : i;
    }
    electricalFieldX(t, i) {
      return 0;
    }
    electricalFieldY(t, i) {
      return 0;
    }
    gravitationalMass(t) {
      const i = t.mass;
      return isNaN(i) ? this.du : i;
    }
    gravitationalFieldX(t, i) {
      return 0;
    }
    gravitationalFieldY(t, i) {
      return 0;
    }
    isFixed(t) {
      return t.isFixed;
    }
    get currentIteration() {
      return this.Jh;
    }
    get arrangementSpacing() {
      return this.Ks;
    }
    set arrangementSpacing(t) {
      U.s(t, Size2, ForceDirectedLayout2, "arrangementSpacing"), this.Ks.equals(t) || (this.Ks.c(t), this.b());
    }
    get arrangesToOrigin() {
      return this.Gg;
    }
    set arrangesToOrigin(t) {
      this.Gg !== t && (U.i(t, "boolean", ForceDirectedLayout2, "arrangesToOrigin"), this.Gg = t, this.b());
    }
    get setsPortSpots() {
      return this.Hn;
    }
    set setsPortSpots(t) {
      this.Hn !== t && (U.i(t, "boolean", ForceDirectedLayout2, "setsPortSpots"), this.Hn = t, this.b());
    }
    get comments() {
      return this.He;
    }
    set comments(t) {
      this.He !== t && (U.i(t, "boolean", ForceDirectedLayout2, "comments"), this.He = t, this.b());
    }
    get maxPrelayoutIterations() {
      return this.qg;
    }
    set maxPrelayoutIterations(t) {
      this.qg !== t && (U.i(t, "number", ForceDirectedLayout2, "maxPrelayoutIterations"), t >= 0 && (this.qg = t, this.b()));
    }
    get maxIterations() {
      return this.Hg;
    }
    set maxIterations(t) {
      this.Hg !== t && (U.i(t, "number", ForceDirectedLayout2, "maxIterations"), t >= 0 && (this.Hg = t, this.b()));
    }
    get epsilonDistance() {
      return this.vg;
    }
    set epsilonDistance(t) {
      this.vg !== t && (U.i(t, "number", ForceDirectedLayout2, "epsilonDistance"), t > 0 && (this.vg = t, this.b()));
    }
    get infinityDistance() {
      return this.au;
    }
    set infinityDistance(t) {
      this.au !== t && (U.i(t, "number", ForceDirectedLayout2, "infinityDistance"), t > 1 && (this.au = t, this.b()));
    }
    get moveLimit() {
      return this.Wg;
    }
    set moveLimit(t) {
      this.Wg !== t && (U.i(t, "number", ForceDirectedLayout2, "moveLimit"), this.Wg = t, this.b());
    }
    get randomNumberGenerator() {
      return this.jg;
    }
    set randomNumberGenerator(t) {
      this.jg !== t && (t !== null && !U.at(t.random) && U.n('ForceDirectedLayout.randomNumberGenerator must have a "random()" function on it: ' + t), this.jg = t);
    }
    get defaultSpringStiffness() {
      return this.fu;
    }
    set defaultSpringStiffness(t) {
      this.fu !== t && (U.i(t, "number", ForceDirectedLayout2, "defaultSpringStiffness"), this.fu = t, this.b());
    }
    get defaultSpringLength() {
      return this.cu;
    }
    set defaultSpringLength(t) {
      this.cu !== t && (U.i(t, "number", ForceDirectedLayout2, "defaultSpringLength"), this.cu = t, this.b());
    }
    get defaultElectricalCharge() {
      return this.uu;
    }
    set defaultElectricalCharge(t) {
      this.uu !== t && (U.i(t, "number", ForceDirectedLayout2, "defaultElectricalCharge"), this.uu = t, this.b());
    }
    get defaultGravitationalMass() {
      return this.du;
    }
    set defaultGravitationalMass(t) {
      this.du !== t && (U.i(t, "number", ForceDirectedLayout2, "defaultGravitationalMass"), this.du = t, this.b());
    }
    get defaultCommentSpringLength() {
      return this.Jg;
    }
    set defaultCommentSpringLength(t) {
      this.Jg !== t && (U.i(t, "number", ForceDirectedLayout2, "defaultCommentSpringLength"), this.Jg = t, this.b());
    }
    get defaultCommentElectricalCharge() {
      return this.$g;
    }
    set defaultCommentElectricalCharge(t) {
      this.$g !== t && (U.i(t, "number", ForceDirectedLayout2, "defaultCommentElectricalCharge"), this.$g = t, this.b());
    }
    get prelayoutQuality() {
      return this.gu;
    }
    set prelayoutQuality(t) {
      this.gu !== t && (U.i(t, "number", ForceDirectedLayout2, "prelayoutQuality"), this.gu = t, this.b());
    }
    get prelayoutSpread() {
      return this.Sf;
    }
    set prelayoutSpread(t) {
      this.Sf !== t && (U.i(t, "number", ForceDirectedLayout2, "prelayoutSpread"), this.Sf = t, this.b());
    }
  }
  class ForceDirectedNetwork2 extends LayoutNetwork2 {
    constructor(t) {
      super(t);
    }
    createVertex() {
      return new ForceDirectedVertex2(this);
    }
    createEdge() {
      return new ForceDirectedEdge2(this);
    }
  }
  class ForceDirectedVertex2 extends LayoutVertex2 {
    JS;
    $S;
    ZS;
    QS;
    _S;
    hierarchicalVertexes;
    idInCluster;
    constructor(t) {
      super(t), this.JS = false, this.$S = NaN, this.ZS = NaN, this.QS = 0, this._S = 0, this.hierarchicalVertexes = new List2(), this.idInCluster = -1;
    }
    get isFixed() {
      return this.JS;
    }
    set isFixed(t) {
      this.JS !== t && (U.i(t, "boolean", ForceDirectedVertex2, "isFixed"), this.JS = t);
    }
    get charge() {
      return this.$S;
    }
    set charge(t) {
      this.$S !== t && (U.i(t, "number", ForceDirectedVertex2, "charge"), this.$S = t);
    }
    get mass() {
      return this.ZS;
    }
    set mass(t) {
      this.ZS !== t && (U.i(t, "number", ForceDirectedVertex2, "mass"), this.ZS = t);
    }
    get forceX() {
      return this.QS;
    }
    set forceX(t) {
      this.QS !== t && (U.i(t, "number", ForceDirectedVertex2, "forceX"), this.QS = t);
    }
    get forceY() {
      return this._S;
    }
    set forceY(t) {
      this._S !== t && (U.i(t, "number", ForceDirectedVertex2, "forceY"), this._S = t);
    }
  }
  class ForceDirectedEdge2 extends LayoutEdge2 {
    tk;
    ik;
    constructor(t) {
      super(t), this.tk = NaN, this.ik = NaN;
    }
    get stiffness() {
      return this.tk;
    }
    set stiffness(t) {
      this.tk !== t && (U.i(t, "number", ForceDirectedEdge2, "stiffness"), this.tk = t);
    }
    get length() {
      return this.ik;
    }
    set length(t) {
      this.ik !== t && (U.i(t, "number", ForceDirectedEdge2, "length"), this.ik = t);
    }
  }
  class RandomNumberGenerator {
    I;
    R;
    Q;
    M;
    A;
    seed;
    constructor(t) {
      t === void 0 && (t = 42), this.seed = t, this.A = 48271, this.M = 2147483647, this.Q = this.M / this.A, this.R = this.M % this.A, this.I = 1 / this.M, this.random();
    }
    random() {
      const t = this.seed / this.Q, i = this.seed % this.Q, e = this.A * i - this.R * t;
      return e > 0 ? this.seed = e : this.seed = e + this.M, this.seed * this.I;
    }
  }
  var LayeredDigraphCycleRemove2 = ((w) => (w[w.DepthFirst = 0] = "DepthFirst", w[w.Greedy = 1] = "Greedy", w[w.FromLayers = 2] = "FromLayers", w))(LayeredDigraphCycleRemove2 || {}), LayeredDigraphLayering2 = ((w) => (w[w.OptimalLinkLength = 10] = "OptimalLinkLength", w[w.LongestPathSink = 11] = "LongestPathSink", w[w.LongestPathSource = 12] = "LongestPathSource", w))(LayeredDigraphLayering2 || {}), LayeredDigraphInit2 = ((w) => (w[w.DepthFirstOut = 20] = "DepthFirstOut", w[w.DepthFirstIn = 21] = "DepthFirstIn", w[w.Naive = 22] = "Naive", w))(LayeredDigraphInit2 || {}), LayeredDigraphAggressive2 = ((w) => (w[w.None = 30] = "None", w[w.Less = 31] = "Less", w[w.More = 32] = "More", w))(LayeredDigraphAggressive2 || {}), LayeredDigraphPack2 = ((w) => (w[w.None = 0] = "None", w[w.Expand = 1] = "Expand", w[w.Straighten = 2] = "Straighten", w[w.Median = 4] = "Median", w[w.MaybeExpand = 8] = "MaybeExpand", w[w.All = 15] = "All", w))(LayeredDigraphPack2 || {}), LayeredDigraphAlign2 = ((w) => (w[w.None = 0] = "None", w[w.UpperLeft = 1] = "UpperLeft", w[w.UpperRight = 2] = "UpperRight", w[w.LowerLeft = 4] = "LowerLeft", w[w.LowerRight = 8] = "LowerRight", w[w.All = 15] = "All", w))(LayeredDigraphAlign2 || {});
  class LayeredDigraphLayout2 extends Layout2 {
    Us;
    ne;
    N;
    mu;
    pu;
    yu;
    kf;
    wu;
    pr;
    xu;
    Hn;
    st;
    Aw;
    qt;
    Zg;
    Gs;
    li;
    qs;
    xs;
    bs;
    zt;
    Qg;
    _g;
    ek;
    mn;
    bu;
    yr;
    vn;
    Wn;
    yA;
    $h;
    constructor(t) {
      super(), this.Us = 25, this.ne = 25, this.N = 0, this.mu = 0, this.pu = 10, this.yu = 20, this.kf = 4, this.wu = 31, this.pr = 15, this.xu = 10, this.Hn = true, this.st = -1, this.Aw = -1, this.qt = -1, this.Zg = 0, this.Gs = 0, this.li = new Int16Array(0), this.qs = new Float32Array(0), this.xs = new Float32Array(0), this.bs = new Float32Array(0), this.zt = new Float32Array(0), this.Qg = 0, this._g = new Int16Array(0), this.ek = new Int16Array(0), this.mn = 0, this.bu = null, this.yr = new Point2(), this.vn = [], this.vn.length = 100, this.Wn = 15, this.yA = 0, this.$h = true, t && Object.assign(this, t);
    }
    cloneProtected(t) {
      super.cloneProtected(t), t.Us = this.Us, t.ne = this.ne, t.N = this.N, t.mu = this.mu, t.pu = this.pu, t.yu = this.yu, t.kf = this.kf, t.wu = this.wu, t.pr = this.pr, t.xu = this.xu, t.Hn = this.Hn, t.Wn = this.Wn, t.$h = this.$h;
    }
    gi(t) {
      t in LayeredDigraphAggressive2 ? this.aggressiveOption = t : t in LayeredDigraphCycleRemove2 ? this.cycleRemoveOption = t : t in LayeredDigraphInit2 ? this.initializeOption = t : t in LayeredDigraphLayering2 ? this.layeringOption = t : super.gi(t);
    }
    createNetwork() {
      return new LayeredDigraphNetwork2(this);
    }
    doLayout(t) {
      Debug && t === null && U.n("Layout.doLayout(collection) argument must not be null but a Diagram, a Group, or an Iterable of Parts"), this.network === null && (this.network = this.makeNetwork(t)), this.arrangementOrigin = this.initialOrigin(this.arrangementOrigin), this.T4(), this.network.vertexes.count > 0 && (this.network.deleteSelfEdges(), this.cycleRemoveOption !== 2 && this.removeCycles(), this.L4(), this.cycleRemoveOption === 2 && this.removeCycles(), this.D4(), this.F4(), this.I4(), this.reduceCrossings(), this.straightenAndPack(), this.updateParts()), this.network = null, this.isValidLayout = true;
    }
    linkMinLength(t) {
      return 1;
    }
    linkLengthWeight(t) {
      return 1;
    }
    linkStraightenWeight(t) {
      const i = t.fromVertex.node || t.fromVertex.data, e = t.toVertex.node || t.toVertex.data;
      return i === null && e === null ? 8 : i === null || e === null ? 4 : 1;
    }
    nodeMinLayerSpace(t, i) {
      return t.node === null && t.data === null ? 0 : this.N === 90 || this.N === 270 ? i ? t.focus.y + 10 : t.bounds.height - t.focus.y + 10 : i ? t.focus.x + 10 : t.bounds.width - t.focus.x + 10;
    }
    nodeMinColumnSpace(t, i) {
      if (t.node === null && t.data === null) return 0;
      const e = i ? t.sk : t.nk;
      if (e !== null) return e;
      const s = this.N;
      return s === 90 || s === 270 ? i ? t.sk = t.focus.x / this.ne + 1 | 0 : t.nk = (t.bounds.width - t.focus.x) / this.ne + 1 | 0 : i ? t.sk = t.focus.y / this.ne + 1 | 0 : t.nk = (t.bounds.height - t.focus.y) / this.ne + 1 | 0;
    }
    oe() {
      const t = this.network.vertexes.count;
      this._g.length < t * 2 && (this._g = new Int16Array(t * 2));
      let i = 0;
      const e = this.network.vertexes.iterator;
      for (; e.next(); ) {
        const s = e.value;
        this._g[i] = s.column, i++, this._g[i] = s.index, i++;
      }
      return this._g;
    }
    as(t) {
      let i = 0;
      const e = this.network.vertexes.iterator;
      for (; e.next(); ) {
        const s = e.value;
        s.column = t[i], i++, s.index = t[i], i++;
      }
    }
    pI(t, i) {
      Debug && (U.r(t, LayeredDigraphLayout2, "crossingMatrix:unfixedLayer"), U.r(i, LayeredDigraphLayout2, "crossingMatrix:direction"));
      const e = this.Zh(t), s = this.li[t];
      this.ek.length < s * s && (this.ek = new Int16Array(s * s));
      const n = this.ek;
      for (let o = 0; o < s; o++) {
        let r = 0;
        const l = e[o], h = l.near;
        let f = 0;
        h !== null && h !== l && h.layer === l.layer && (r += Math.max(0, Math.abs(h.index - l.index) - 1));
        let a, c = 0, u, d = 0, m = 0, g = 0, p, y = 0, x, S = 0, b = 0, k = 0, P;
        if (i >= 0) {
          for (a = e[o].To, c = 0; c < a.length; c++) if (u = a[c], u.valid && u.fromVertex.layer !== t) for (d = u.fromVertex.index, m = u.portToPos, g = u.portFromPos, y = c + 1; y < a.length; y++) x = a[y], x.valid && x.fromVertex.layer !== t && (S = x.fromVertex.index, b = x.portToPos, k = x.portFromPos, m < b && (d > S || d === S && g > k) && r++, b < m && (S > d || S === d && k > g) && r++);
        }
        if (i <= 0) {
          for (a = e[o].cr, c = 0; c < a.length; c++) if (u = a[c], u.valid && u.toVertex.layer !== t) for (d = u.toVertex.index, m = u.portToPos, g = u.portFromPos, y = c + 1; y < a.length; y++) x = a[y], x.valid && x.toVertex.layer !== t && (S = x.toVertex.index, b = x.portToPos, k = x.portFromPos, g < k && (d > S || d === S && m > b) && r++, k < g && (S > d || S === d && b > m) && r++);
        }
        for (n[o * s + o] = r, f = o + 1; f < s; f++) {
          let A = 0, C = 0;
          if (i >= 0) {
            for (p = e[o].To, P = e[f].To, c = 0; c < p.length; c++) if (u = p[c], u.valid && u.fromVertex.layer !== t) for (d = u.fromVertex.index, m = u.portToPos, g = u.portFromPos, y = 0; y < P.length; y++) x = P[y], x.valid && x.fromVertex.layer !== t && (S = x.fromVertex.index, b = x.portToPos, k = x.portFromPos, (d < S || d === S && g < k) && C++, (S < d || S === d && k < g) && A++);
          }
          if (i <= 0) {
            for (p = e[o].cr, P = e[f].cr, c = 0; c < p.length; c++) if (u = p[c], u.valid && u.toVertex.layer !== t) for (d = u.toVertex.index, m = u.portToPos, g = u.portFromPos, y = 0; y < P.length; y++) x = P[y], x.valid && x.toVertex.layer !== t && (S = x.toVertex.index, b = x.portToPos, k = x.portFromPos, (d < S || d === S && m < b) && C++, (S < d || S === d && b < m) && A++);
          }
          n[o * s + f] = A, n[f * s + o] = C;
        }
      }
      return this.Qh(t, e), n;
    }
    countCrossings() {
      let t = 0;
      for (let i = 0; i <= this.st; i++) {
        const e = this.pI(i, 1), s = this.li[i];
        for (let n = 0; n < s; n++) for (let o = n; o < s; o++) t += e[n * s + o];
      }
      return t;
    }
    R4(t, i, e) {
      const s = this.Zh(t), n = this.li[t];
      let o = 0;
      for (let r = 0; r < n; r++) {
        let l = null;
        i <= 0 && (l = s[r].To);
        let h = null;
        i >= 0 && (h = s[r].cr);
        let f, a = 0, c = 0;
        if (l !== null) for (let u = 0; u < l.length; u++) f = l[u], f.valid && f.fromVertex.layer !== t && (a = f.fromVertex.column + f.portFromColOffset, c = f.toVertex.column + f.portToColOffset, e ? o += Math.abs(a - c) * this.linkStraightenWeight(f) : o += Math.abs(a - c));
        if (h !== null) for (let u = 0; u < h.length; u++) f = h[u], f.valid && f.toVertex.layer !== t && (a = f.fromVertex.column + f.portFromColOffset, c = f.toVertex.column + f.portToColOffset, e ? o += (Math.abs(a - c) + 1) * this.linkStraightenWeight(f) : o += Math.abs(a - c));
      }
      return this.Qh(t, s), o;
    }
    ok(t) {
      let i = 0;
      for (let e = 0; e <= this.st; e++) i += this.R4(e, 1, t);
      return i;
    }
    Tw() {
      let t = 1 / 0;
      this.qt = -1;
      const i = this.network.vertexes.iterator;
      for (; i.next(); ) {
        const e = i.value;
        t = Math.min(t, e.column - this.nodeMinColumnSpace(e, true)), this.qt = Math.max(this.qt, e.column + this.nodeMinColumnSpace(e, false));
      }
      for (i.reset(); i.next(); ) {
        const e = i.value;
        e.column -= t;
      }
      this.qt -= t;
    }
    Lw(t, i) {
      Debug && (U.r(t, LayeredDigraphLayout2, "barycenters:unfixedLayer"), U.r(i, LayeredDigraphLayout2, "barycenters:direction"));
      const e = this.Zh(t), s = this.li[t], n = new Float32Array(s);
      for (let o = 0; o < s; o++) {
        const r = e[o];
        let l = null;
        i <= 0 && (l = r.To);
        let h = null;
        i >= 0 && (h = r.cr);
        let f = 0, a = 0;
        const c = r.near;
        c !== null && c.layer === r.layer && (f += c.column - 1, a++);
        let u;
        if (l !== null) for (let d = 0; d < l.length; d++) {
          u = l[d];
          const m = u.fromVertex;
          u.valid && !u.rev && m.layer !== t && (f += m.column, a++);
        }
        if (h !== null) for (let d = 0; d < h.length; d++) {
          u = h[d];
          const m = u.toVertex;
          u.valid && !u.rev && m.layer !== t && (f += m.column, a++);
        }
        a === 0 ? n[o] = -1 : n[o] = f / a;
      }
      return this.Qh(t, e), n;
    }
    yI(t, i) {
      Debug && (U.r(t, LayeredDigraphLayout2, "medians:unfixedLayer"), U.r(i, LayeredDigraphLayout2, "medians:direction"));
      const e = this.Zh(t), s = this.li[t], n = new Int16Array(s);
      for (let o = 0; o < s; o++) {
        const r = e[o];
        let l = null;
        i <= 0 && (l = r.To);
        let h = null;
        i >= 0 && (h = r.cr);
        let f = 0;
        const a = [], c = r.near;
        c !== null && c.layer === r.layer && (a[f] = c.column - 1, f++);
        let u;
        if (l !== null) for (let d = 0; d < l.length; d++) {
          u = l[d];
          const m = u.fromVertex;
          u.valid && !u.rev && m.layer !== t && (a[f] = m.column + u.portFromColOffset, f++);
        }
        if (h !== null) for (let d = 0; d < h.length; d++) {
          u = h[d];
          const m = u.toVertex;
          u.valid && !u.rev && m.layer !== t && (a[f] = m.column + u.portToColOffset, f++);
        }
        if (f === 0) n[o] = -1;
        else {
          a.sort((m, g) => m - g);
          const d = f >> 1;
          (f & 1) !== 0 ? n[o] = a[d] : n[o] = a[d - 1] + a[d] >> 1;
        }
      }
      return this.Qh(t, e), n;
    }
    Dw(t, i, e, s, n) {
      if (t.component === e) {
        t.component = i;
        let o = 0, r = 0;
        if (s) {
          const l = t.destinationEdges;
          for (; l.next(); ) {
            const h = l.value, f = h.toVertex;
            o = t.layer - f.layer, r = this.linkMinLength(h), o === r && this.Dw(f, i, e, s, n);
          }
        }
        if (n) {
          const l = t.sourceEdges;
          for (; l.next(); ) {
            const h = l.value, f = h.fromVertex;
            o = f.layer - t.layer, r = this.linkMinLength(h), o === r && this.Dw(f, i, e, s, n);
          }
        }
      }
    }
    wA(t, i, e, s, n) {
      if (t.component === e) {
        if (t.component = i, s) {
          const o = t.destinationEdges;
          for (; o.next(); ) {
            const l = o.value.toVertex;
            this.wA(l, i, e, s, n);
          }
        }
        if (n) {
          const o = t.sourceEdges;
          for (; o.next(); ) {
            const l = o.value.fromVertex;
            this.wA(l, i, e, s, n);
          }
        }
      }
    }
    removeCycles() {
      const t = this.network.edges.iterator;
      for (; t.next(); ) {
        const i = t.value;
        i.rev = false;
      }
      switch (this.mu) {
        default:
        case 1:
          this.O4();
          break;
        case 0:
          this.E4();
          break;
        case 2:
          this.B4();
          break;
      }
    }
    B4() {
      const t = this.network, i = t.vertexes.iterator;
      let e = 1 / 0;
      for (; i.next(); ) {
        const s = i.value;
        e = Math.min(e, s.layer);
      }
      if (e < 1 / 0) {
        if (e < 0) for (i.reset(); i.next(); ) {
          const r = i.value;
          r.layer -= e;
        }
        const s = [];
        for (i.reset(); i.next(); ) {
          const r = i.value, l = s[r.layer];
          l === void 0 ? s[r.layer] = [r] : l.push(r);
        }
        let n = 0;
        for (let r = 0; r < s.length; r++) {
          const l = s[r];
          if (!l || l.length === 0) n++;
          else if (r > 0) for (let h = 0; h < l.length; h++) {
            const f = l[h];
            f.layer -= n;
          }
        }
        const o = t.edges.iterator;
        for (; o.next(); ) {
          const r = o.value, l = r.fromVertex, h = r.toVertex;
          l.layer < h.layer && (t.reverseEdge(r), r.rev = true);
        }
      }
    }
    O4() {
      const t = this.network;
      let i = 0, e = t.vertexes.count - 1;
      const s = [];
      s.length = e + 1;
      const n = t.vertexes.iterator;
      for (; n.next(); ) {
        const r = n.value;
        r.re = true;
      }
      for (; this.V4(t) !== null; ) {
        let r;
        for (r = this.wI(t); r !== null; ) s[e] = r, e--, r.re = false, r = this.wI(t);
        for (r = this.xI(t); r !== null; ) s[i] = r, i++, r.re = false, r = this.xI(t);
        r = this.z4(t), r !== null && (s[i] = r, i++, r.re = false);
      }
      for (let r = 0; r < t.vertexes.count; r++) s[r].index = r;
      const o = t.edges.iterator;
      for (; o.next(); ) {
        const r = o.value, l = r.fromVertex, h = r.toVertex;
        l.index > h.index && (t.reverseEdge(r), r.rev = true);
      }
    }
    V4(t) {
      const i = t.vertexes.iterator;
      for (; i.next(); ) {
        const e = i.value;
        if (e.re) return e;
      }
      return null;
    }
    wI(t) {
      const i = t.vertexes.iterator;
      for (; i.next(); ) {
        const e = i.value;
        if (e.re) {
          let s = true;
          const n = e.destinationEdges;
          for (; n.next(); ) if (n.value.toVertex.re) {
            s = false;
            break;
          }
          if (s) return e;
        }
      }
      return null;
    }
    xI(t) {
      const i = t.vertexes.iterator;
      for (; i.next(); ) {
        const e = i.value;
        if (e.re) {
          let s = true;
          const n = e.sourceEdges;
          for (; n.next(); ) if (n.value.fromVertex.re) {
            s = false;
            break;
          }
          if (s) return e;
        }
      }
      return null;
    }
    z4(t) {
      let i = null, e = 0;
      const s = this.network.vertexes.iterator;
      for (; s.next(); ) {
        const n = s.value;
        if (n.re) {
          let o = 0;
          const r = n.destinationEdges;
          for (; r.next(); ) r.value.toVertex.re && o++;
          let l = 0;
          const h = n.sourceEdges;
          for (; h.next(); ) h.value.fromVertex.re && l++;
          (i === null || e < o - l) && (i = n, e = o - l);
        }
      }
      return i;
    }
    E4() {
      const t = this.network.vertexes.iterator;
      for (; t.next(); ) {
        const e = t.value;
        e.Su = -1, e.no = -1;
      }
      const i = this.network.edges.iterator;
      for (; i.next(); ) {
        const e = i.value;
        e.forest = false;
      }
      for (this.Qg = 0, t.reset(); t.next(); ) {
        const e = t.value;
        e.sourceEdges.count === 0 && this.xA(e);
      }
      for (t.reset(); t.next(); ) {
        const e = t.value;
        e.Su === -1 && this.xA(e);
      }
      for (i.reset(); i.next(); ) {
        const e = i.value;
        if (!e.forest) {
          const s = e.fromVertex, n = s.Su, o = s.no, r = e.toVertex, l = r.Su, h = r.no;
          l < n && o < h && (this.network.reverseEdge(e), e.rev = true);
        }
      }
    }
    xA(t) {
      t.Su = this.Qg, this.Qg++;
      const i = t.destinationEdges;
      for (; i.next(); ) {
        const e = i.value, s = e.toVertex;
        s.Su === -1 && (e.forest = true, this.xA(s));
      }
      t.no = this.Qg, this.Qg++;
    }
    L4() {
      const t = this.network.vertexes.iterator;
      for (; t.next(); ) {
        const s = t.value;
        s.layer = -1;
      }
      for (this.st = -1, this.assignLayers(), t.reset(); t.next(); ) {
        const s = t.value;
        this.st = Math.max(this.st, s.layer);
      }
      this.st >= 9999 && U.n("LayeredDigraphLayout, too many layers: " + this.st);
      const i = this.direction == 0 || this.direction == 180, e = [];
      for (const s = this.network.vertexes.iterator; s.next(); ) {
        const n = s.value;
        if (n.node === null || n.centered) continue;
        const o = n.layer;
        let r = e[o];
        r === void 0 && (r = 0);
        const l = i ? n.width : n.height;
        l > r && (e[o] = l);
      }
      for (const s = this.network.vertexes.iterator; s.next(); ) {
        const n = s.value;
        if (n.node === null || n.centered) continue;
        const o = e[n.layer];
        i ? (n.focusX = o / 2, n.focusY = n.focus.y, n.width = o) : (n.focusX = n.focus.x, n.focusY = o / 2, n.height = o);
      }
    }
    assignLayers() {
      switch (this.pu) {
        case 11:
          this.bI();
          break;
        case 12:
          this.X4();
          break;
        default:
        case 10:
          this.Y4();
          break;
      }
    }
    bI() {
      const t = this.network.vertexes.iterator;
      for (; t.next(); ) {
        const i = t.value, e = this.SI(i);
        this.st = Math.max(e, this.st);
      }
    }
    SI(t) {
      let i = 0;
      if (t.layer === -1) {
        const e = t.destinationEdges;
        for (; e.next(); ) {
          const s = e.value, n = s.toVertex, o = this.linkMinLength(s);
          i = Math.max(i, this.SI(n) + o);
        }
        t.layer = i;
      } else i = t.layer;
      return i;
    }
    X4() {
      let t = 0;
      const i = this.network.vertexes.iterator;
      for (; i.next(); ) {
        const e = i.value;
        t = this.kI(e), this.st = Math.max(t, this.st);
      }
      for (i.reset(); i.next(); ) {
        const e = i.value;
        e.layer = this.st - e.layer;
      }
    }
    kI(t) {
      let i = 0;
      if (t.layer === -1) {
        const e = t.sourceEdges;
        for (; e.next(); ) {
          const s = e.value, n = s.fromVertex, o = this.linkMinLength(s);
          i = Math.max(i, this.kI(n) + o);
        }
        t.layer = i;
      } else i = t.layer;
      return i;
    }
    Y4() {
      this.bI();
      const t = this.network.vertexes.iterator;
      for (; t.next(); ) {
        const e = t.value;
        e.re = false;
      }
      for (t.reset(); t.next(); ) {
        const e = t.value;
        e.sourceEdges.count === 0 && this.MI(e);
      }
      let i = 1 / 0;
      for (t.reset(); t.next(); ) {
        const e = t.value;
        i = Math.min(i, e.layer);
      }
      for (this.st = -1, t.reset(); t.next(); ) {
        const e = t.value;
        e.layer -= i, this.st = Math.max(this.st, e.layer);
      }
    }
    MI(t) {
      if (!t.re) {
        t.re = true;
        const i = t.destinationEdges;
        for (; i.next(); ) {
          const s = i.value.toVertex;
          this.MI(s);
        }
        this.K4(t), this.U4(t);
      }
    }
    K4(t) {
      const i = this.network.vertexes.iterator;
      for (; i.next(); ) {
        const r = i.value;
        r.component = -1;
      }
      const e = 0, s = 1, n = t.To;
      let o = n.length;
      for (let r = 0; r < o; r++) {
        const l = n[r], h = l.fromVertex, f = l.toVertex, a = this.linkMinLength(l);
        h.layer - f.layer > a && this.Dw(h, e, -1, true, false);
      }
      for (this.Dw(t, s, -1, true, true); t.component !== e; ) {
        let r = 0, l = 1 / 0, h = 0, f = null;
        const a = this.network.vertexes.iterator;
        for (; a.next(); ) {
          const c = a.value;
          if (c.component === s) {
            let u = 0, d = false;
            const m = c.To;
            o = m.length;
            for (let p = 0; p < o; p++) {
              const y = m[p], x = y.fromVertex;
              if (u += this.linkLengthWeight(y), x.component !== s) {
                r += this.linkLengthWeight(y);
                const S = x.layer - c.layer, b = this.linkMinLength(y);
                l = Math.min(l, S - b);
              }
            }
            const g = c.cr;
            o = g.length;
            for (let p = 0; p < o; p++) {
              const y = g[p], x = y.toVertex;
              u -= this.linkLengthWeight(y), x.component !== s ? r -= this.linkLengthWeight(y) : d = true;
            }
            (f === null || u < h) && !d && (f = c, h = u);
          }
        }
        if (r > 0) {
          for (i.reset(); i.next(); ) {
            const c = i.value;
            c.component === s && (c.layer += l);
          }
          t.component = e;
        } else f.component = e;
      }
    }
    U4(t) {
      const i = this.network.vertexes.iterator;
      for (; i.next(); ) {
        const n = i.value;
        n.component = -1;
      }
      const e = 0, s = 1;
      for (this.Dw(t, s, -1, true, false); t.component !== e; ) {
        let n = 0, o = 1 / 0, r = 0, l = null;
        const h = this.network.vertexes.iterator;
        for (; h.next(); ) {
          const f = h.value;
          if (f.component === s) {
            let a = 0, c = false;
            const u = f.To;
            let d = u.length;
            for (let g = 0; g < d; g++) {
              const p = u[g], y = p.fromVertex;
              a += this.linkLengthWeight(p), y.component !== s ? n += this.linkLengthWeight(p) : c = true;
            }
            const m = f.cr;
            d = m.length;
            for (let g = 0; g < d; g++) {
              const p = m[g], y = p.toVertex;
              if (a -= this.linkLengthWeight(p), y.component !== s) {
                n -= this.linkLengthWeight(p);
                const x = f.layer - y.layer, S = this.linkMinLength(p);
                o = Math.min(o, x - S);
              }
            }
            (l === null || a > r) && !c && (l = f, r = a);
          }
        }
        if (n < 0) {
          for (i.reset(); i.next(); ) {
            const f = i.value;
            f.component === s && (f.layer -= o);
          }
          t.component = e;
        } else l.component = e;
      }
    }
    D4() {
      const t = this.network, i = [], e = t.edges.iterator;
      for (; e.next(); ) {
        const s = e.value;
        s.valid = false, i.push(s);
      }
      for (let s = 0; s < i.length; s++) {
        const n = i[s];
        let o = n.fromVertex;
        const r = n.toVertex;
        if (n.valid || (o.node === null && o.data === null || r.node === null && r.data === null) && o.layer === r.layer) continue;
        let l = 0, h = 0, f = 0, a = 0;
        if (n.link !== null) {
          const k = n.link;
          if (k === null) continue;
          const P = o.node, A = r.node;
          if (P === null || A === null) continue;
          let C = k.fromNode, M = k.toNode, N = k.fromPort;
          for (; N !== null && !N.isVisibleObject(); ) N = N.panel;
          let L = k.toPort;
          for (; L !== null && !L.isVisibleObject(); ) L = L.panel;
          if (n.rev) {
            const X = C, K = N;
            C = M, N = L, M = X, L = K;
          }
          const T = o.focus, D = r.focus, F = n.rev ? r.bounds : o.bounds, R = Point2.a();
          P !== C ? F.isReal() && C.isVisible() ? C.actualBounds.isReal() ? (C.getRelativePoint(N, Spot2.Center, R), R.x += C.actualBounds.x - F.x, R.y += C.actualBounds.y - F.y) : (C.getRelativePoint(N, Spot2.Center, R), R.isReal() || R.c(T)) : R.c(T) : F.isReal() ? (C.getRelativePoint(N, Spot2.Center, R), R.isReal() || R.c(T)) : R.c(T);
          const I = n.rev ? o.bounds : r.bounds, O = Point2.a();
          A !== M ? I.isReal() && M.isVisible() ? M.actualBounds.isReal() ? (M.getRelativePoint(L, Spot2.Center, O), O.x += M.actualBounds.x - I.x, O.y += M.actualBounds.y - I.y) : (M.getRelativePoint(L, Spot2.Center, O), O.isReal() || O.c(D)) : O.c(D) : I.isReal() ? (M.getRelativePoint(L, Spot2.Center, O), O.isReal() || O.c(D)) : O.c(D), this.N === 90 || this.N === 270 ? (l = Math.round((R.x - T.x) / this.ne), f = R.x, h = Math.round((O.x - D.x) / this.ne), a = O.x) : (l = Math.round((R.y - T.y) / this.ne), f = R.y, h = Math.round((O.y - D.y) / this.ne), a = O.y), Point2.o(R), Point2.o(O), n.portFromColOffset = l, n.portFromPos = f, n.portToColOffset = h, n.portToPos = a;
        } else n.portFromColOffset = 0, n.portFromPos = 0, n.portToColOffset = 0, n.portToPos = 0;
        let c = o.layer;
        const u = r.layer, d = this.G4(n), m = d === 1 || d === 3, g = d === 2 || d === 3;
        let p, y, x = null, S;
        g && (x = this.q4(o, r), S = 1, y = t.createVertex(), y.node = null, y.rk = 1, y.layer = c, y.near = o, t.addVertex(y), p = t.linkVertexes(o, y, n.link), p.valid = false, p.rev = n.rev, p.portFromColOffset = l, p.portToColOffset = 0, p.portFromPos = f, p.portToPos = 0, o = y);
        let b = 1;
        if (m && b--, c - u > b && c > 0) {
          for (n.valid = false, y = t.createVertex(), y.node = null, y.rk = 2, y.layer = c - 1, x && S < x.length && y.layer === x[S].layer && (y.near = x[S++]), t.addVertex(y), p = t.linkVertexes(o, y, n.link), p.valid = true, p.rev = n.rev, p.portFromColOffset = g ? 0 : l, p.portToColOffset = 0, p.portFromPos = g ? 0 : f, p.portToPos = 0, o = y, c--; c - u > b && c > 0; ) y = t.createVertex(), y.node = null, y.rk = 3, y.layer = c - 1, x && S < x.length && y.layer === x[S].layer && (y.near = x[S++]), t.addVertex(y), p = t.linkVertexes(o, y, n.link), p.valid = true, p.rev = n.rev, p.portFromColOffset = 0, p.portToColOffset = 0, p.portFromPos = 0, p.portToPos = 0, o = y, c--;
          p = t.linkVertexes(y, r, n.link), p.valid = !m, m && (y.near = r), p.rev = n.rev, p.portFromColOffset = 0, p.portToColOffset = h, p.portFromPos = 0, p.portToPos = a;
        } else n.valid = true;
      }
    }
    G4(t) {
      let i = 0;
      const e = t.link;
      if (e !== null) {
        const s = e.fromPort, n = e.toPort;
        if (s !== null && n !== null) {
          const o = e.fromNode, r = e.toNode;
          if (o !== null && r !== null) {
            const l = this.lk(true), h = this.lk(false), f = this.setsPortSpots ? l : e.computeSpot(true, s), a = this.setsPortSpots ? h : e.computeSpot(false, n), c = e.isOrthogonal;
            if (f.isSide() && f.includesSide(h) && a.isSide() && a.includesSide(l)) return 0;
            const u = e.getLinkPoint(o, s, f, true, c, r, n, Point2.a()), d = e.getLinkDirection(o, s, u, f, true, c, r, n);
            Point2.o(u), (!f.isNone() && d === this.NI(t, true) || this.setsPortSpots && o !== null && o.ports.count === 1 && t.rev) && (i += 1);
            const m = e.getLinkPoint(r, n, a, false, c, o, s, Point2.a()), g = e.getLinkDirection(r, n, m, a, false, c, o, s);
            Point2.o(m), (!a.isNone() && g === this.NI(t, false) || this.setsPortSpots && r !== null && r.ports.count === 1 && t.rev) && (i += 2);
          }
        }
      }
      return i;
    }
    NI(t, i) {
      return this.N === 90 ? i && !t.rev || !i && t.rev ? 270 : 90 : this.N === 180 ? i && !t.rev || !i && t.rev ? 0 : 180 : this.N === 270 ? i && !t.rev || !i && t.rev ? 90 : 270 : i && !t.rev || !i && t.rev ? 180 : 0;
    }
    q4(t, i) {
      const e = [];
      return e.push(i), this.CI(t, e) ? e.reverse() : [];
    }
    CI(t, i) {
      const e = i[i.length - 1].sourceEdges.iterator;
      for (; e.next(); ) {
        const s = e.value;
        if (s.rev || !s.valid) continue;
        const n = s.fromVertex;
        if (i.push(n), n === t || this.CI(t, i)) return true;
        i.pop();
      }
      return false;
    }
    F4() {
      this.li.length !== this.st + 1 && (this.li = new Int16Array(this.st + 1));
      const t = this.li;
      for (let e = 0; e <= this.st; e++) t[e] = 0;
      const i = this.network.vertexes.iterator;
      for (; i.next(); ) {
        const e = i.value;
        e.index = -1;
      }
      this.initializeIndices(), this.Aw = -1, this.Zg = 0, this.Gs = 0;
      for (let e = 0; e <= this.st; e++) t[e] > t[this.Gs] && (this.Aw = t[e] - 1, this.Gs = e), t[e] < t[this.Zg] && (this.Zg = e);
      this.bu = [];
      for (let e = 0; e < t.length; e++) this.bu[e] = [];
      for (i.reset(); i.next(); ) {
        const e = i.value, s = e.layer, n = this.bu[s];
        n[e.index] = e;
      }
    }
    initializeIndices() {
      switch (this.yu) {
        default:
        case 22:
          this.H4();
          break;
        case 20:
          this.v4();
          break;
        case 21:
          this.W4();
          break;
      }
    }
    H4() {
      let t = null;
      const i = this.network.vertexes.iterator;
      for (; i.next(); ) {
        const e = i.value;
        if (e.near && (t === null && (t = /* @__PURE__ */ new Map()), e.layer === e.near.layer)) {
          const s = t.get(e.near) || [];
          s.push(e), t.set(e.near, s);
        }
      }
      for (i.reset(); i.next(); ) {
        const e = i.value;
        if (e.near) continue;
        const s = e.layer;
        if (e.index = this.li[s], this.li[s]++, !t) continue;
        const n = t.get(e);
        Array.isArray(n) && n.forEach((o) => {
          o.index = this.li[s], this.li[s]++;
        });
      }
    }
    v4() {
      let t = null;
      const i = this.network.vertexes.iterator;
      for (; i.next(); ) {
        const e = i.value;
        if (e.near && (t === null && (t = /* @__PURE__ */ new Map()), e.layer === e.near.layer)) {
          const s = t.get(e.near) || [];
          s.push(e), t.set(e.near, s);
        }
      }
      for (let e = this.st; e >= 0; e--) for (i.reset(); i.next(); ) {
        const s = i.value;
        s.layer === e && s.index === -1 && this.AI(s, t);
      }
    }
    AI(t, i) {
      if (t.near) return;
      const e = t.layer;
      if (t.index = this.li[e], this.li[e]++, i) {
        const o = i.get(t);
        Array.isArray(o) && o.forEach((r) => {
          r.index = this.li[e], this.li[e]++;
        });
      }
      const s = t.cr;
      let n = true;
      for (; n; ) {
        n = false;
        for (let o = 0; o < s.length - 1; o++) {
          const r = s[o], l = s[o + 1];
          r.portFromColOffset > l.portFromColOffset && (n = true, s[o] = l, s[o + 1] = r);
        }
      }
      for (let o = 0; o < s.length; o++) {
        const r = s[o];
        if (r.valid) {
          const l = r.toVertex;
          l.index === -1 && this.AI(l, i);
        }
      }
    }
    W4() {
      let t = null;
      const i = this.network.vertexes.iterator;
      for (; i.next(); ) {
        const e = i.value;
        if (e.near && (t === null && (t = /* @__PURE__ */ new Map()), e.layer === e.near.layer)) {
          const s = t.get(e.near) || [];
          s.push(e), t.set(e.near, s);
        }
      }
      for (let e = 0; e <= this.st; e++) for (i.reset(); i.next(); ) {
        const s = i.value;
        s.layer === e && s.index === -1 && this.TI(s, t);
      }
    }
    TI(t, i) {
      if (t.near) return;
      const e = t.layer;
      if (t.index = this.li[e], this.li[e]++, i) {
        const h = i.get(t);
        Array.isArray(h) && h.forEach((f) => {
          f.index = this.li[e], this.li[e]++;
        });
      }
      const s = t.To;
      let n = true, o = 0;
      for (; n; ) for (n = false, o = 0; o < s.length - 1; o++) {
        const h = s[o], f = s[o + 1];
        h.portToColOffset > f.portToColOffset && (n = true, s[o] = f, s[o + 1] = h);
      }
      let r, l;
      for (o = 0; o < s.length; o++) l = s[o], l.valid && (r = l.fromVertex, r.index === -1 && this.TI(r, i));
    }
    I4() {
      this.qt = -1;
      for (let t = 0; t <= this.st; t++) {
        const i = this.Zh(t);
        let e = 0;
        const s = this.li[t];
        for (let n = 0; n < s; n++) {
          const o = i[n];
          e += this.nodeMinColumnSpace(o, true), o.column = e, e += 1, e += this.nodeMinColumnSpace(o, false);
        }
        this.qt = Math.max(this.qt, e - 1), this.Qh(t, i);
      }
    }
    reduceCrossings() {
      let t = this.countCrossings(), i = this.oe(), e = 0, s = 0, n = 0;
      for (e = 0; e < this.kf; e++) {
        for (s = 0; s <= this.st; s++) this.hk(s, 1), this.Ss(s, 1, false, 1);
        for (n = this.countCrossings(), n < t && (t = n, i = this.oe()), s = this.st; s >= 0; s--) this.hk(s, -1), this.Ss(s, -1, false, -1);
        n = this.countCrossings(), n < t && (t = n, i = this.oe());
      }
      for (this.as(i), e = 0; e < this.kf; e++) {
        for (s = 0; s <= this.st; s++) this.hk(s, 0), this.Ss(s, 0, false, 0);
        for (n = this.countCrossings(), n < t && (t = n, i = this.oe()), s = this.st; s >= 0; s--) this.hk(s, 0), this.Ss(s, 0, false, 0);
        n = this.countCrossings(), n < t && (t = n, i = this.oe());
      }
      this.as(i);
      let o = false, r = 0, l = 0, h = 0, f = 0;
      switch (this.wu) {
        case 30:
          break;
        case 32:
          for (h = t + 1; (f = this.countCrossings()) < h; ) for (h = f, r = this.st; r >= 0; r--) for (l = 0; l <= r; l++) {
            for (o = true; o; ) for (o = false, s = r; s >= l; s--) o = this.Ss(s, -1, false, -1) || o;
            for (n = this.countCrossings(), n >= t ? this.as(i) : (t = n, i = this.oe()), o = true; o; ) for (o = false, s = r; s >= l; s--) o = this.Ss(s, 1, false, 1) || o;
            for (n = this.countCrossings(), n >= t ? this.as(i) : (t = n, i = this.oe()), o = true; o; ) for (o = false, s = l; s <= r; s++) o = this.Ss(s, 1, false, 1) || o;
            for (n >= t ? this.as(i) : (t = n, i = this.oe()), o = true; o; ) for (o = false, s = l; s <= r; s++) o = this.Ss(s, -1, false, -1) || o;
            for (n >= t ? this.as(i) : (t = n, i = this.oe()), o = true; o; ) for (o = false, s = r; s >= l; s--) o = this.Ss(s, 0, false, 0) || o;
            for (n >= t ? this.as(i) : (t = n, i = this.oe()), o = true; o; ) for (o = false, s = l; s <= r; s++) o = this.Ss(s, 0, false, 0) || o;
            n >= t ? this.as(i) : (t = n, i = this.oe());
          }
          break;
        default:
        case 31:
          for (r = this.st, l = 0, h = t + 1; (f = this.countCrossings()) < h; ) {
            for (h = f, o = true; o; ) for (o = false, s = r; s >= l; s--) o = this.Ss(s, -1, false, -1) || o;
            for (n = this.countCrossings(), n >= t ? this.as(i) : (t = n, i = this.oe()), o = true; o; ) for (o = false, s = r; s >= l; s--) o = this.Ss(s, 1, false, 1) || o;
            for (n = this.countCrossings(), n >= t ? this.as(i) : (t = n, i = this.oe()), o = true; o; ) for (o = false, s = l; s <= r; s++) o = this.Ss(s, 1, false, 1) || o;
            for (n >= t ? this.as(i) : (t = n, i = this.oe()), o = true; o; ) for (o = false, s = l; s <= r; s++) o = this.Ss(s, -1, false, -1) || o;
            for (n >= t ? this.as(i) : (t = n, i = this.oe()), o = true; o; ) for (o = false, s = r; s >= l; s--) o = this.Ss(s, 0, false, 0) || o;
            for (n >= t ? this.as(i) : (t = n, i = this.oe()), o = true; o; ) for (o = false, s = l; s <= r; s++) o = this.Ss(s, 0, false, 0) || o;
            n >= t ? this.as(i) : (t = n, i = this.oe());
          }
          break;
      }
      this.as(i);
    }
    hk(t, i) {
      Debug && (U.r(t, LayeredDigraphLayout2, "medianBarycenterCrossingReduction:unfixedLayer"), U.r(i, LayeredDigraphLayout2, "medianBarycenterCrossingReduction:direction"));
      let e = 0, s = false;
      const n = this.Zh(t), o = this.li[t], r = this.yI(t, i), l = this.Lw(t, i);
      for (e = 0; e < o; e++) l[e] === -1 && (l[e] = n[e].column), r[e] === -1 && (r[e] = n[e].column);
      let h = true, f;
      for (; h; ) for (h = false, e = 0; e < o - 1; e++) if (r[e + 1] < r[e] || r[e + 1] === r[e] && l[e + 1] < l[e]) {
        s = true, h = true;
        const c = r[e];
        r[e] = r[e + 1], r[e + 1] = c;
        const u = l[e];
        l[e] = l[e + 1], l[e + 1] = u, f = n[e], n[e] = n[e + 1], n[e + 1] = f;
      }
      let a = 0;
      for (e = 0; e < o; e++) f = n[e], f.index = e, a += this.nodeMinColumnSpace(f, true), f.column = a, a += 1, a += this.nodeMinColumnSpace(f, false);
      return this.Qh(t, n), s;
    }
    Ss(t, i, e, s) {
      const n = this.Zh(t), o = this.li[t], r = this.pI(t, i);
      let l = 0, h;
      if (!e || s > 0) for (h = new Float32Array(o), l = 0; l < o; l++) h[l] = -1;
      else h = this.Lw(t, -1);
      let f;
      if (!e || s < 0) for (f = new Float32Array(o), l = 0; l < o; l++) f[l] = -1;
      else f = this.Lw(t, 1);
      let a = false, c = true;
      for (; c; ) for (c = false, l = 0; l < o - 1; l++) {
        const u = r[n[l].index * o + n[l + 1].index], d = r[n[l + 1].index * o + n[l].index];
        let m = 0, g = 0;
        const p = n[l].column, y = n[l + 1].column, x = this.nodeMinColumnSpace(n[l], true), S = this.nodeMinColumnSpace(n[l], false), b = this.nodeMinColumnSpace(n[l + 1], true), k = this.nodeMinColumnSpace(n[l + 1], false), P = p - x + b, A = y - S + k;
        let C = 0, M = 0, N = 0, L = 0, T = 0, D = 0, F = 0, R, I = 0, O, X = 0;
        const K = n[l].sourceEdges.iterator;
        if (e && s <= 0) for (; K.next(); ) {
          const J = K.value;
          R = J.fromVertex, J.valid && R.layer !== t && (N = this.linkStraightenWeight(J), L = J.portFromColOffset, T = J.portToColOffset, D = R.column, C += (Math.abs(p + T - (D + L)) + 1) * N, M += (Math.abs(A + T - (D + L)) + 1) * N);
        }
        for (K.reset(); K.next(); ) {
          const J = K.value;
          if (R = J.fromVertex, J.valid && R.layer === t) {
            for (I = 0; I < n.length && n[I] !== R; ) I++;
            I < l && (m += 2 * (l - I), g += 2 * (l + 1 - I)), I === l + 1 && (m += 1), I > l + 1 && (m += 4 * (I - l), g += 4 * (I - (l + 1)));
          }
        }
        const B = n[l].destinationEdges.iterator;
        if (e && s >= 0) for (; B.next(); ) {
          const J = B.value;
          O = J.toVertex, J.valid && O.layer !== t && (N = this.linkStraightenWeight(J), L = J.portFromColOffset, T = J.portToColOffset, F = O.column, C += (Math.abs(p + L - (F + T)) + 1) * N, M += (Math.abs(A + L - (F + T)) + 1) * N);
        }
        for (B.reset(); B.next(); ) {
          const J = B.value;
          if (O = J.toVertex, J.valid && O.layer === t) {
            for (X = 0; X < n.length && n[X] !== O; ) X++;
            X === l + 1 && (g += 1);
          }
        }
        const Y = n[l + 1].sourceEdges.iterator;
        if (e && s <= 0) for (; Y.next(); ) {
          const J = Y.value;
          R = J.fromVertex, J.valid && R.layer !== t && (N = this.linkStraightenWeight(J), L = J.portFromColOffset, T = J.portToColOffset, D = R.column, C += (Math.abs(y + T - (D + L)) + 1) * N, M += (Math.abs(P + T - (D + L)) + 1) * N);
        }
        for (Y.reset(); Y.next(); ) {
          const J = Y.value;
          if (R = J.fromVertex, J.valid && R.layer === t) {
            for (I = 0; I < n.length && n[I] !== R; ) I++;
            I < l && (m += 2 * (l + 1 - I), g += 2 * (l - I)), I === l && (g += 1), I > l + 1 && (m += 4 * (I - (l + 1)), g += 4 * (I - l));
          }
        }
        const z = n[l + 1].destinationEdges.iterator;
        if (e && s >= 0) for (; z.next(); ) {
          const J = z.value;
          O = J.toVertex, J.valid && O.layer !== t && (N = this.linkStraightenWeight(J), L = J.portFromColOffset, T = J.portToColOffset, F = O.column, C += (Math.abs(y + L - (F + T)) + 1) * N, M += (Math.abs(P + L - (F + T)) + 1) * N);
        }
        for (z.reset(); z.next(); ) {
          const J = z.value;
          if (O = J.toVertex, J.valid && O.layer === t) {
            for (X = 0; X < n.length && n[X] !== O; ) X++;
            X === l && (m += 1);
          }
        }
        let H = 0, W = 0;
        const j = h[n[l].index], Z = f[n[l].index], V = h[n[l + 1].index], $ = f[n[l + 1].index];
        if (j !== -1 && (H += Math.abs(j - p), W += Math.abs(j - A)), Z !== -1 && (H += Math.abs(Z - p), W += Math.abs(Z - A)), V !== -1 && (H += Math.abs(V - y), W += Math.abs(V - P)), $ !== -1 && (H += Math.abs($ - y), W += Math.abs($ - P)), g < m - 0.5 || g === m && d < u - 0.5 || g === m && d === u && M < C - 0.5 || g === m && d === u && M === C && W < H - 0.5) {
          a = true, c = true, n[l].column = A, n[l + 1].column = P;
          const J = n[l];
          n[l] = n[l + 1], n[l + 1] = J;
        }
      }
      for (l = 0; l < o; l++) n[l].index = l;
      return this.Qh(t, n), a;
    }
    straightenAndPack() {
      if (this.Wn !== 0) {
        this.j4();
        return;
      }
      let t = 0, i = false, e = (this.pr & 1) !== 0;
      const s = (this.pr & 8) !== 0;
      if (this.network.edges.count > 1e3 && s && (e = false), e) {
        const n = [];
        let o = 0;
        for (o = 0; o <= this.st; o++) n[o] = 0;
        let r = 0;
        const l = this.network.vertexes.iterator;
        for (; l.next(); ) {
          const f = l.value;
          t = f.layer, r = f.column;
          const a = this.nodeMinColumnSpace(f, false);
          n[t] = Math.max(n[t], r + a);
        }
        const h = 8;
        for (l.reset(); l.next(); ) {
          const f = l.value;
          t = f.layer, r = f.column, f.column = ((this.qt - n[t]) * h >> 1) + r * h;
        }
        this.qt *= h;
      }
      if ((this.pr & 2) !== 0) {
        i = true;
        let n = 0;
        for (; i && n < this.xu; ) {
          for (i = false, t = this.Gs + 1; t <= this.st; t++) i = this.tm(t, 1) || i;
          for (t = this.Gs - 1; t >= 0; t--) i = this.tm(t, -1) || i;
          i = this.tm(this.Gs, 0) || i, n++;
        }
      }
      if ((this.pr & 4) !== 0) {
        for (t = this.Gs + 1; t <= this.st; t++) this.bA(t, 1);
        for (t = this.Gs - 1; t >= 0; t--) this.bA(t, -1);
        this.bA(this.Gs, 0);
      }
      if (e && (this.LI(-1), this.LI(1)), (this.pr & 2) !== 0) {
        i = true;
        let n = 0;
        for (; i && n < this.xu; ) {
          for (i = false, i = this.tm(this.Gs, 0) || i, t = this.Gs + 1; t <= this.st; t++) i = this.tm(t, 0) || i;
          for (t = this.Gs - 1; t >= 0; t--) i = this.tm(t, 0) || i;
          n++;
        }
      }
    }
    tm(t, i) {
      Debug && (U.r(t, LayeredDigraphLayout2, "bendStraighten:unfixedLayer"), U.r(i, LayeredDigraphLayout2, "bendStraighten:direction"));
      let e = false;
      for (; this.J4(t, i); ) e = true;
      return e;
    }
    J4(t, i) {
      Debug && (U.r(t, LayeredDigraphLayout2, "shiftbendStraighten:unfixedLayer"), U.r(i, LayeredDigraphLayout2, "shiftbendStraighten:direction"));
      let e = 0;
      const s = this.Zh(t), n = this.li[t], o = this.Lw(t, -1);
      if (i > 0) for (e = 0; e < n; e++) o[e] = -1;
      const r = this.Lw(t, 1);
      if (i < 0) for (e = 0; e < n; e++) r[e] = -1;
      let l = false, h = true;
      for (; h; ) for (h = false, e = 0; e < n; e++) {
        const f = s[e].column, a = this.nodeMinColumnSpace(s[e], true), c = this.nodeMinColumnSpace(s[e], false);
        let u = 0;
        e - 1 < 0 || f - s[e - 1].column - 1 > a + this.nodeMinColumnSpace(s[e - 1], false) ? u = f - 1 : u = f;
        let d = 0;
        e + 1 >= n || s[e + 1].column - f - 1 > c + this.nodeMinColumnSpace(s[e + 1], true) ? d = f + 1 : d = f;
        let m = 0, g = 0, p = 0, y = 0, x = 0, S = 0;
        if (i <= 0) {
          const M = s[e].sourceEdges.iterator;
          for (; M.next(); ) {
            const N = M.value, L = N.fromVertex;
            if (N.valid && L.layer !== t) {
              y = this.linkStraightenWeight(N), x = N.portFromColOffset, S = N.portToColOffset;
              const T = L.column;
              m += (Math.abs(f + S - (T + x)) + 1) * y, g += (Math.abs(u + S - (T + x)) + 1) * y, p += (Math.abs(d + S - (T + x)) + 1) * y;
            }
          }
        }
        if (i >= 0) {
          const M = s[e].destinationEdges.iterator;
          for (; M.next(); ) {
            const N = M.value, L = N.toVertex;
            if (N.valid && L.layer !== t) {
              y = this.linkStraightenWeight(N), x = N.portFromColOffset, S = N.portToColOffset;
              const T = L.column;
              m += (Math.abs(f + x - (T + S)) + 1) * y, g += (Math.abs(u + x - (T + S)) + 1) * y, p += (Math.abs(d + x - (T + S)) + 1) * y;
            }
          }
        }
        let b = 0, k = 0, P = 0;
        const A = o[s[e].index], C = r[s[e].index];
        A !== -1 && (b += Math.abs(A - f), k += Math.abs(A - u), P += Math.abs(A - d)), C !== -1 && (b += Math.abs(C - f), k += Math.abs(C - u), P += Math.abs(C - d)), g < m || g === m && k < b ? (l = true, h = true, s[e].column = u) : (p < m || p === m && P < b) && (l = true, h = true, s[e].column = d);
      }
      return this.Qh(t, s), this.Tw(), l;
    }
    bA(t, i) {
      Debug && (U.r(t, LayeredDigraphLayout2, "medianStraighten:unfixedLayer"), U.r(i, LayeredDigraphLayout2, "medianStraighten:direction"));
      let e = 0;
      const s = this.Zh(t), n = this.li[t], o = this.yI(t, i), r = new Int16Array(o);
      let l = false, h = true;
      for (; h; ) for (h = false, e = 0; e < n; e++) {
        const f = s[e].column, a = this.nodeMinColumnSpace(s[e], true), c = this.nodeMinColumnSpace(s[e], false);
        let u = 0, d = 0, m = 0, g = 0, p = 0;
        r[e] === -1 ? e === 0 && e === n - 1 ? u = f : e === 0 ? (d = s[e + 1].column, d - f === c + this.nodeMinColumnSpace(s[e + 1], true) ? u = f - 1 : u = f) : e === n - 1 ? (m = s[e - 1].column, f - m === a + this.nodeMinColumnSpace(s[e - 1], false) ? u = f + 1 : u = f) : (m = s[e - 1].column, p = m + this.nodeMinColumnSpace(s[e - 1], false) + a + 1, d = s[e + 1].column, g = d - this.nodeMinColumnSpace(s[e + 1], true) - c - 1, u = (p + g) / 2 | 0) : e === 0 && e === n - 1 ? u = r[e] : e === 0 ? (d = s[e + 1].column, g = d - this.nodeMinColumnSpace(s[e + 1], true) - c - 1, u = Math.min(r[e], g)) : e === n - 1 ? (m = s[e - 1].column, p = m + this.nodeMinColumnSpace(s[e - 1], false) + a + 1, u = Math.max(r[e], p)) : (m = s[e - 1].column, p = m + this.nodeMinColumnSpace(s[e - 1], false) + a + 1, d = s[e + 1].column, g = d - this.nodeMinColumnSpace(s[e + 1], true) - c - 1, p < r[e] && r[e] < g ? u = r[e] : p >= r[e] ? u = p : g <= r[e] && (u = g)), u !== f && (l = true, h = true, s[e].column = u);
      }
      return this.Qh(t, s), this.Tw(), l;
    }
    $4() {
      for (let t = 0; t <= this.qt; t++) for (; this.Z4(t, 1); ) ;
      this.Tw();
    }
    Z4(t, i) {
      Debug && (U.r(t, LayeredDigraphLayout2, "packAux:column"), U.r(i, LayeredDigraphLayout2, "packAux:direction"));
      let e = true;
      const s = this.network.vertexes.iterator;
      for (; s.next(); ) {
        const o = s.value, r = this.nodeMinColumnSpace(o, true), l = this.nodeMinColumnSpace(o, false);
        if (o.column - r <= t && o.column + l >= t) {
          e = false;
          break;
        }
      }
      let n = false;
      if (e) {
        if (i > 0) for (s.reset(); s.next(); ) {
          const o = s.value;
          o.column > t && (o.column -= 1, n = true);
        }
        if (i < 0) for (s.reset(); s.next(); ) {
          const o = s.value;
          o.column < t && (o.column += 1, n = true);
        }
      }
      return n;
    }
    Q4() {
      this.$4();
      for (let t = 0; t < this.qt; t++) for (; this._4(t, 1); ) ;
      this.Tw();
    }
    _4(t, i) {
      Debug && (U.r(t, LayeredDigraphLayout2, "tightPackAux:column"), U.r(i, LayeredDigraphLayout2, "tightPackAux:direction"));
      let e = t;
      i > 0 && (e = t + 1), i < 0 && (e = t - 1);
      let s = 0;
      const n = [], o = [];
      for (s = 0; s <= this.st; s++) n[s] = false, o[s] = false;
      const r = this.network.vertexes.iterator;
      for (; r.next(); ) {
        const f = r.value, a = f.column - this.nodeMinColumnSpace(f, true), c = f.column + this.nodeMinColumnSpace(f, false);
        a <= t && c >= t && (n[f.layer] = true), a <= e && c >= e && (o[f.layer] = true);
      }
      let l = true, h = false;
      for (s = 0; s <= this.st; s++) l = l && !(n[s] && o[s]);
      if (l) {
        if (i > 0) for (r.reset(); r.next(); ) {
          const f = r.value;
          f.column > t && (f.column -= 1, h = true);
        }
        if (i < 0) for (r.reset(); r.next(); ) {
          const f = r.value;
          f.column < t && (f.column += 1, h = true);
        }
      }
      return h;
    }
    LI(t) {
      Debug && U.r(t, LayeredDigraphLayout2, "componentPack:direction"), this.Q4();
      let i = 0, e, s = 0, n = 0, o = 0;
      if (t > 0) for (i = 0; i <= this.qt; i++) for (e = this.oe(), s = this.ok(true), n = s + 1; s < n; ) n = s, this.DI(i, 1), o = this.ok(true), o > s ? this.as(e) : o < s && (s = o, e = this.oe());
      if (t < 0) for (i = this.qt; i >= 0; i--) for (e = this.oe(), s = this.ok(true), n = s + 1; s < n; ) n = s, this.DI(i, -1), o = this.ok(true), o > s ? this.as(e) : o < s && (s = o, e = this.oe());
      this.Tw();
    }
    DI(t, i) {
      this.mn = 0;
      const e = this.network.vertexes.iterator;
      for (; e.next(); ) {
        const a = e.value;
        a.component = -1;
      }
      if (i > 0) for (e.reset(); e.next(); ) {
        const a = e.value;
        a.column - this.nodeMinColumnSpace(a, true) <= t && (a.component = this.mn);
      }
      if (i < 0) for (e.reset(); e.next(); ) {
        const a = e.value;
        a.column + this.nodeMinColumnSpace(a, false) >= t && (a.component = this.mn);
      }
      for (this.mn++, e.reset(); e.next(); ) {
        const a = e.value;
        a.component === -1 && (this.wA(a, this.mn, -1, true, true), this.mn++);
      }
      let s = 0;
      const n = [];
      for (s = 0; s < this.mn * this.mn; s++) n[s] = false;
      const o = [];
      for (s = 0; s < (this.st + 1) * (this.qt + 1); s++) o[s] = -1;
      for (e.reset(); e.next(); ) {
        const a = e.value, c = a.layer, u = Math.max(0, a.column - this.nodeMinColumnSpace(a, true)), d = Math.min(this.qt, a.column + this.nodeMinColumnSpace(a, false));
        for (let m = u; m <= d; m++) o[c * (this.qt + 1) + m] = a.component;
      }
      for (let a = 0; a <= this.st; a++) {
        if (i > 0) for (let c = 0; c < this.qt; c++) o[a * (this.qt + 1) + c] !== -1 && o[a * (this.qt + 1) + c + 1] !== -1 && o[a * (this.qt + 1) + c] !== o[a * (this.qt + 1) + c + 1] && (n[o[a * (this.qt + 1) + c] * this.mn + o[a * (this.qt + 1) + c + 1]] = true);
        if (i < 0) for (let c = this.qt; c > 0; c--) o[a * (this.qt + 1) + c] !== -1 && o[a * (this.qt + 1) + c - 1] !== -1 && o[a * (this.qt + 1) + c] !== o[a * (this.qt + 1) + c - 1] && (n[o[a * (this.qt + 1) + c] * this.mn + o[a * (this.qt + 1) + c - 1]] = true);
      }
      const r = [];
      for (s = 0; s < this.mn; s++) r[s] = true;
      const l = [];
      l.push(0);
      let h = 0;
      for (; l.length !== 0; ) if (h = l[l.length - 1], l.pop(), r[h]) for (r[h] = false, s = 0; s < this.mn; s++) n[h * this.mn + s] && l.splice(0, 0, s);
      let f = false;
      if (i > 0) for (e.reset(); e.next(); ) {
        const a = e.value;
        r[a.component] && (a.column -= 1, f = true);
      }
      if (i < 0) for (e.reset(); e.next(); ) {
        const a = e.value;
        r[a.component] && (a.column += 1, f = true);
      }
      return f;
    }
    j4() {
      const t = U.ft(), i = this.bu.length;
      for (let u = 0; u <= i; u++) t[u] = [];
      const e = this.network.vertexes.iterator;
      for (; e.next(); ) {
        const u = e.value, d = i - u.layer, m = t[d];
        m[u.index] = u;
      }
      const s = new GSet2();
      this.tB(t, s);
      let n = null, o = null, r = null, l = null;
      const h = (this.Wn & 1) !== 0, f = (this.Wn & 2) !== 0, a = (this.Wn & 4) !== 0, c = (this.Wn & 8) !== 0;
      h && (this.gl(t, s, true), n = this.ak(t, true, false)), t.reverse(), a && (this.gl(t, s, false), r = this.ak(t, false, false));
      for (const u of t) u.reverse();
      c && (this.gl(t, s, false), l = this.ak(t, false, true)), t.reverse(), f && (this.gl(t, s, true), o = this.ak(t, true, true)), U.et(t), this.iB(n, o, r, l), this.network.vertexes.each((u) => {
        const d = u, m = U.ft();
        h && m.push(n.get(d)), f && m.push(o.get(d)), a && m.push(r.get(d)), c && m.push(l.get(d)), m.sort((S, b) => S - b);
        const g = m.length, p = Math.floor((g - 1) / 2), y = Math.ceil((g - 1) / 2), x = (m[p] + m[y]) / 2;
        U.et(m), d.ye = x;
      });
    }
    tB(t, i) {
      const e = t.length;
      for (let s = 1; s < e - 1; s++) {
        let n = 0, o = 0;
        const r = t[s], l = t[s + 1];
        for (let h = 0; o < l.length; h++) {
          const f = l[h], a = this.eB(f);
          if (h === l.length - 1 || a) {
            let c = r.length - 1;
            for (a && (c = f.getProperSourceVertexes()[0].index); o <= h; ) {
              const d = l[o].getProperSourceEdges();
              for (const m of d) {
                const p = m.fromVertex.index;
                (p < n || p > c) && i.add(m);
              }
              o++;
            }
            n = c;
          }
        }
      }
    }
    eB(t) {
      if (t.node === null) {
        const i = t.getProperSourceVertexes();
        if (i.length > 0) return i[0].node === null;
      }
      return false;
    }
    gl(t, i, e) {
      this.sB(t);
      for (const s of t) {
        let n = -1;
        for (const o of s) {
          const r = e ? o.getProperSourceVertexes() : o.getProperDestinationVertexes(), l = r.length;
          if (l > 0) {
            r.sort((f, a) => f._h - a._h);
            const h = (l - 1) / 2;
            for (let f = Math.floor(h), a = Math.ceil(h); f <= a; f++) if (o.jn === o) {
              const c = r[f];
              let u;
              e ? u = c.getDestinationEdge(o) : u = o.getDestinationEdge(c), !i.has(u) && n < c._h && (c.jn = o, o.Pf = c.Pf, o.jn = c.Pf, n = c._h);
            }
          }
        }
      }
    }
    sB(t) {
      for (let i = 0; i < t.length; i++) {
        const e = t[i];
        for (let s = 0; s < e.length; s++) {
          const n = e[s];
          n.Pf = n, n.jn = n, n.FI = i, n._h = s;
        }
      }
    }
    ak(t, i, e) {
      const s = this.N === 90 || this.N === 270;
      for (const o of t) for (const r of o) r.fs = r, r.ku = 1 / 0, r.ye = NaN, r.Jn = 0;
      this.nB(t, i, e);
      for (const o of t) for (const r of o) r.Pf === r && this.II(r, t);
      for (let o = 0; o < t.length; o++) {
        if (t[o].length <= 0) continue;
        const r = t[o][0];
        if (r.fs === r) {
          r.fs.ku === 1 / 0 && (r.fs.ku = 0);
          let l = o, h = 0, f;
          do {
            for (f = t[l][h]; f.jn !== f.Pf; ) if (f = f.jn, l++, f._h > 0) {
              const a = this.RI(f, t), c = s ? a.width : a.height, u = f.fs.ku + f.ye + f.Jn - (a.ye + a.Jn + c + this.columnSpacing);
              a.fs.ku = Math.min(a.fs.ku, u);
            }
            h = f._h + 1;
          } while (l < t.length && h < t[l].length && f.fs === t[l][h].fs);
        }
      }
      const n = new GMap2();
      for (const o of t) for (const r of o) {
        r.ye = r.ye + r.fs.ku + r.Jn;
        const l = s ? r.width : r.height;
        n.set(r, e ? -r.ye - l : r.ye);
      }
      return n;
    }
    nB(t, i, e) {
      const s = this.N === 90 || this.N === 270;
      for (const n of t) for (const o of n) if (o.Pf === o) {
        let r = 0, l = o;
        for (; l.jn !== o; ) {
          const h = l.jn, f = s ? l.width : l.height, a = s ? h.width : h.height;
          let c, u, d, m;
          i ? (d = l.getDestinationEdge(h), c = d.portFromPos, u = d.portToPos, d.link !== null && (l.node && l.node !== d.link.fromNode && (c = s ? l.focusX : l.focusY), h.node && h.node !== d.link.toNode && (u = s ? h.focusX : h.focusY)), e ? m = l.Jn + (f - c) - (a - u) : m = l.Jn + c - u) : (d = h.getDestinationEdge(l), c = d.portToPos, u = d.portFromPos, d.link !== null && (l.node && l.node !== d.link.toNode && (c = s ? l.focusX : l.focusY), h.node && h.node !== d.link.fromNode && (u = s ? h.focusX : h.focusY)), e ? m = l.Jn + (f - c) - (a - u) : m = l.Jn + c - u), h.Jn = m, r = Math.min(r, m), l = l.jn;
        }
        l = o;
        do
          l.Jn = l.Jn - r, l = l.jn;
        while (l !== o);
      }
    }
    II(t, i) {
      if (!isNaN(t.ye)) return;
      t.ye = 0;
      let e = t;
      do {
        if (e._h > 0) {
          const s = this.RI(e, i), n = s.Pf;
          this.II(n, i), t.fs === t && (t.fs = n.fs);
          const o = this.N === 90 || this.N === 270 ? s.width : s.height;
          if (t.fs === n.fs) {
            const r = n.ye + s.Jn + o - e.Jn + this.columnSpacing;
            t.ye = Math.max(t.ye, r);
          }
        }
        e = e.jn;
      } while (e !== t);
      for (; e.jn !== t; ) e = e.jn, e.ye = t.ye, e.fs = t.fs;
    }
    RI(t, i) {
      const e = t.FI, s = t._h;
      return s < 1 && U.n("Could not determine previous vertex in layer"), i[e][s - 1];
    }
    iB(...t) {
      let i = -1;
      const e = U.ft(), s = U.ft();
      let n = 1 / 0;
      for (let o = 0; o < 4; o++) {
        if (!t[o]) continue;
        const r = this.oB(t[o], e, s, o);
        r < n && (i = o, n = r);
      }
      for (let o = 0; o < 4; o++) {
        const r = t[o];
        if (!r) continue;
        const l = o === 0 || o === 2 ? e[i] - e[o] : s[i] - s[o];
        l !== 0 && r.each((h) => {
          r.set(h.key, h.value + l);
        });
      }
      U.et(e), U.et(s);
    }
    oB(t, i, e, s) {
      if (!t || t.count === 0) return i[s] = 0, e[s] = 0, 1 / 0;
      let n = 1 / 0, o = -1 / 0;
      return t.each((r) => {
        const l = r.key, h = r.value, f = this.N === 90 || this.N === 270 ? l.width : l.height;
        h < n && (n = h), h + f > o && (o = h + f);
      }), i[s] = n, e[s] = o, o - n;
    }
    commitLayout() {
      this.Cw(), this.commitNodes(), this.SA(), this.isRouting && this.commitLinks();
    }
    Cw() {
      if (!this.setsPortSpots) return;
      const t = this.lk(true), i = this.lk(false), e = this.network.edges.iterator;
      for (; e.next(); ) {
        const n = e.value.link;
        n !== null && (n.fromSpot = t, n.toSpot = i);
      }
    }
    lk(t) {
      return this.N === 270 ? t ? Spot2.MiddleTop : Spot2.MiddleBottom : this.N === 90 ? t ? Spot2.MiddleBottom : Spot2.MiddleTop : this.N === 180 ? t ? Spot2.MiddleLeft : Spot2.MiddleRight : t ? Spot2.MiddleRight : Spot2.MiddleLeft;
    }
    commitNodes() {
      this.qs.length !== this.st + 1 && (this.qs = new Float32Array(this.st + 1)), this.xs.length !== this.st + 1 && (this.xs = new Float32Array(this.st + 1)), this.bs.length !== this.st + 1 && (this.bs = new Float32Array(this.st + 1)), this.zt.length !== this.st + 1 && (this.zt = new Float32Array(this.st + 1));
      for (let d = 0; d <= this.st; d++) this.qs[d] = 0, this.xs[d] = 0, this.bs[d] = 0, this.zt[d] = 0;
      const t = this.network.vertexes.iterator;
      for (; t.next(); ) {
        const d = t.value, m = d.layer;
        this.qs[m] = Math.max(this.qs[m], this.nodeMinLayerSpace(d, true)), this.xs[m] = Math.max(this.xs[m], this.nodeMinLayerSpace(d, false));
      }
      let i = 0;
      const e = this.Us;
      for (let d = 0; d <= this.st; d++) {
        let m = e;
        this.qs[d] + this.xs[d] <= 0 && (m = 0), d > 0 && (i += m / 2), this.N === 90 || this.N === 0 ? (i += this.xs[d], this.bs[d] = i, i += this.qs[d]) : (i += this.qs[d], this.bs[d] = i, i += this.xs[d]), d < this.st && (i += m / 2), this.zt[d] = i;
      }
      const s = i, n = this.arrangementOrigin;
      for (let d = 0; d <= this.st; d++) this.N === 270 ? this.bs[d] = n.y + this.bs[d] : this.N === 90 ? (this.bs[d] = n.y + s - this.bs[d], this.zt[d] = s - this.zt[d]) : this.N === 180 ? this.bs[d] = n.x + this.bs[d] : (this.bs[d] = n.x + s - this.bs[d], this.zt[d] = s - this.zt[d]);
      const o = this.Wn !== 0;
      t.reset();
      const r = this.N === 270 || this.N === 90;
      let l = 1 / 0, h = 1 / 0, f = 1 / 0, a = -1 / 0;
      for (; t.next(); ) {
        const d = t.value, m = d.layer, g = d.column | 0;
        let p = 0, y = 0;
        r ? (p = n.x + this.ne * g, y = this.bs[m]) : (p = this.bs[m], y = n.y + this.ne * g), d.centerX = p, d.centerY = y, o && isFinite(d.ye) && (r ? d.node ? d.x = n.x + d.ye : d.centerX = n.x + d.ye : d.node ? d.y = n.y + d.ye : d.centerY = n.y + d.ye), l = Math.min(d.x, l), h = Math.min(d.y, h), r ? (f = l, a = Math.max(a, d.bounds.right)) : (f = h, a = Math.max(a, d.bounds.bottom));
      }
      this.yA = a - f;
      const c = n.x - l, u = n.y - h;
      for (this.yr = new Point2(o && r ? 0 : c, o && !r ? 0 : u), t.reset(); t.next(); ) {
        const d = t.value;
        d.x += c, d.y += u, d.commit();
      }
    }
    SA() {
      let t = 0;
      const i = this.Us;
      for (let n = 0; n <= this.st; n++) t += this.qs[n], t += this.xs[n];
      t += this.st * i;
      const e = [], s = this.Wn !== 0 ? this.yA : this.ne * this.qt;
      for (let n = this.maxLayer; n >= 0; n--) this.N === 270 ? n === 0 ? e.push(new Rect2(0, 0, s, Math.abs(this.zt[0]))) : e.push(new Rect2(0, this.zt[n - 1], s, Math.abs(this.zt[n - 1] - this.zt[n]))) : this.N === 90 ? n === 0 ? e.push(new Rect2(0, this.zt[0], s, Math.abs(this.zt[0] - t))) : e.push(new Rect2(0, this.zt[n], s, Math.abs(this.zt[n - 1] - this.zt[n]))) : this.N === 180 ? n === 0 ? e.push(new Rect2(0, 0, Math.abs(this.zt[0]), s)) : e.push(new Rect2(this.zt[n - 1], 0, Math.abs(this.zt[n - 1] - this.zt[n]), s)) : n === 0 ? e.push(new Rect2(this.zt[0], 0, Math.abs(this.zt[0] - t), s)) : e.push(new Rect2(this.zt[n], 0, Math.abs(this.zt[n - 1] - this.zt[n]), s));
      this.commitLayers(e, this.yr);
    }
    commitLayers(t, i) {
    }
    commitLinks() {
      const t = this.network.edges.iterator;
      let i = null;
      for (; t.next(); ) i = t.value.link, i !== null && i.pointsCount > 0 && (i.startRoute(), i.clearPoints(), i.commitRoute());
      for (t.reset(); t.next(); ) i = t.value.link, i !== null && i.updateRoute();
      for (t.reset(); t.next(); ) {
        const e = t.value;
        if (i = e.link, i === null || i.pointsCount === 0) continue;
        i.startRoute();
        const s = i;
        let n = s.fromNode, o = s.toNode, r = s.fromPort, l = s.toPort;
        if (n !== null) {
          const N = n.findVisibleNode();
          N !== null && N !== n && (n = N, r = N.port);
        }
        if (o !== null) {
          const N = o.findVisibleNode();
          N !== null && N !== o && (o = N, l = N.port);
        }
        const h = i.computeSpot(true, r), f = i.computeSpot(false, l);
        let a = e.fromVertex, c = e.toVertex;
        if (e.valid) {
          if (i.curve === 9 && i.pointsCount === 4) if (a.column === c.column && this.alignOption === 0) {
            const N = i.getLinkPoint(n, r, h, true, false, o, l), L = i.getLinkPoint(o, l, f, false, false, n, r);
            N.isReal() || N.set(n.actualBounds.center), L.isReal() || L.set(o.actualBounds.center), i.clearPoints(), i.addPointAt(N.x, N.y), i.addPointAt((2 * N.x + L.x) / 3, (2 * N.y + L.y) / 3), i.addPointAt((N.x + 2 * L.x) / 3, (N.y + 2 * L.y) / 3), i.addPointAt(L.x, L.y);
          } else {
            let N = false, L = false;
            if (r !== null && h === Spot2.None && (N = true), l !== null && f === Spot2.None && (L = true), N || L) {
              let T = null;
              N && (T = i.getLinkPointFromPoint(n, r, r.getDocumentPoint(Spot2.Center), i.getPoint(3), true), T.isReal() || T.set(n.actualBounds.center), i.setPointAt(0, T.x, T.y));
              let D = null;
              if (L && (D = i.getLinkPointFromPoint(o, l, l.getDocumentPoint(Spot2.Center), i.getPoint(0), false), D.isReal() || D.set(o.actualBounds.center), i.setPointAt(3, D.x, D.y)), T) {
                const F = i.getPoint(2);
                i.setPointAt(1, (T.x * 2 + F.x) / 3, (T.y * 2 + F.y) / 3);
              }
              if (D) {
                const F = i.getPoint(1);
                i.setPointAt(2, (D.x * 2 + F.x) / 3, (D.y * 2 + F.y) / 3);
              }
            }
          }
          i.commitRoute();
          continue;
        }
        if (a.layer === c.layer) {
          i.commitRoute();
          continue;
        }
        let u = false, d = false;
        const m = this.Us;
        let g = 0, p = i.firstPickIndex + 1;
        if (i.isOrthogonal) d = true, g = i.pointsCount, g > 4 && i.points.removeRange(2, g - 3);
        else if (i.curve === 9) u = true, g = i.pointsCount, g > 4 && i.points.removeRange(2, g - 3), g === 4 && (p = 2);
        else {
          g = i.pointsCount;
          const N = h === Spot2.None, L = f === Spot2.None;
          g > 2 && N && L ? i.points.removeRange(1, g - 2) : g > 3 && N && !L ? i.points.removeRange(1, g - 3) : g > 3 && !N && L ? i.points.removeRange(2, g - 2) : g > 4 && !N && !L && i.points.removeRange(2, g - 3);
        }
        let y, x, S = 0, b = 0, k = 0, P = 0, A = 0, C = 0, M = 0;
        if (e.rev) {
          let N = 0;
          for (; c !== null && a !== c; ) {
            y = null, x = null;
            const L = c.sourceEdges.iterator;
            for (; L.next(); ) {
              const T = L.value;
              if (T.link === e.link && (y = T.fromVertex, x = T.toVertex, y.node === null)) break;
            }
            if (y === null) break;
            if (y !== a) if (S = i.getPoint(p - 1).x, b = i.getPoint(p - 1).y, k = y.centerX, P = y.centerY, d) this.N === 180 || this.N === 0 ? p === i.firstPickIndex + 1 ? (i.insertPointAt(p++, S, b), i.insertPointAt(p++, S, P)) : (x !== null ? x.centerY : b) !== P && (A = this.zt[y.layer - 1] + this.yr.x, i.insertPointAt(p++, A, b), i.insertPointAt(p++, A, P)) : p === i.firstPickIndex + 1 ? (i.insertPointAt(p++, S, b), i.insertPointAt(p++, k, b)) : (x !== null ? x.centerX : S) !== k && (A = this.zt[y.layer - 1] + this.yr.y, i.insertPointAt(p++, S, A), i.insertPointAt(p++, k, A));
            else if (p === i.firstPickIndex + 1) if (C = Math.max(10, this.qs[c.layer]), M = Math.max(10, this.xs[c.layer]), u) this.N === 180 ? k <= c.bounds.x ? (N = c.bounds.x, i.insertPointAt(p++, N - C, P), i.insertPointAt(p++, N, P), i.insertPointAt(p++, N + M, P)) : (i.insertPointAt(p++, k - C, P), i.insertPointAt(p++, k, P), i.insertPointAt(p++, k + M, P)) : this.N === 90 ? P >= c.bounds.bottom ? (N = c.bounds.y + c.bounds.height, i.insertPointAt(p++, k, N + M), i.insertPointAt(p++, k, N), i.insertPointAt(p++, k, N - C)) : (i.insertPointAt(p++, k, P + M), i.insertPointAt(p++, k, P), i.insertPointAt(p++, k, P - C)) : this.N === 270 ? P <= c.bounds.y ? (N = c.bounds.y, i.insertPointAt(p++, k, N - C), i.insertPointAt(p++, k, N), i.insertPointAt(p++, k, N + M)) : (i.insertPointAt(p++, k, P - C), i.insertPointAt(p++, k, P), i.insertPointAt(p++, k, P + M)) : this.N === 0 && (k >= c.bounds.right ? (N = c.bounds.x + c.bounds.width, i.insertPointAt(p++, N + M, P), i.insertPointAt(p++, N, P), i.insertPointAt(p++, N - C, P)) : (i.insertPointAt(p++, k + M, P), i.insertPointAt(p++, k, P), i.insertPointAt(p++, k - C, P)));
            else {
              i.insertPointAt(p++, S, b);
              let T = 0;
              this.N === 180 || this.N === 0 ? ((this.N === 180 ? k >= c.bounds.right : k <= c.bounds.x) && (T = (this.N === 0 ? -C : M) / 2), i.insertPointAt(p++, S + T, P)) : ((this.N === 270 ? P >= c.bounds.bottom : P <= c.bounds.y) && (T = (this.N === 90 ? -C : M) / 2), i.insertPointAt(p++, k, b + T)), i.insertPointAt(p++, k, P);
            }
            else C = Math.max(10, this.qs[y.layer]), M = Math.max(10, this.xs[y.layer]), u ? this.N === 180 ? (i.insertPointAt(p++, k - C - Math.max(10, m), P), i.insertPointAt(p++, Math.min(k - C + m / 2, k), P), i.insertPointAt(p++, k, P), i.insertPointAt(p++, k, P), i.insertPointAt(p++, Math.max(k + M - m / 2, k), P), i.insertPointAt(p++, k + M + m, P)) : this.N === 90 ? (i.insertPointAt(p++, k, P + M + Math.max(10, m)), i.insertPointAt(p++, k, Math.max(P + M - m / 2, P)), i.insertPointAt(p++, k, P), i.insertPointAt(p++, k, P), i.insertPointAt(p++, k, Math.min(P - C + m / 2, P)), i.insertPointAt(p++, k, P - C - m)) : this.N === 270 ? (i.insertPointAt(p++, k, P - C - Math.max(10, m)), i.insertPointAt(p++, k, Math.min(P - C + m / 2, P)), i.insertPointAt(p++, k, P), i.insertPointAt(p++, k, P), i.insertPointAt(p++, k, Math.max(P + M - m / 2, P)), i.insertPointAt(p++, k, P + M + m)) : (i.insertPointAt(p++, k + M + Math.max(10, m), P), i.insertPointAt(p++, Math.max(k + M - m / 2, k), P), i.insertPointAt(p++, k, P), i.insertPointAt(p++, k, P), i.insertPointAt(p++, Math.min(k - C + m / 2, k), P), i.insertPointAt(p++, k - C - m, P)) : (this.N === 180 || this.N === 90 || this.N, i.insertPointAt(p++, k, P));
            c = y;
          }
          if (l === null || h !== Spot2.None || d) if (S = i.getPoint(p - 1).x, b = i.getPoint(p - 1).y, k = i.getPoint(p).x, P = i.getPoint(p).y, d) {
            const L = this.xs[a.layer];
            let T = 0;
            this.N === 180 || this.N === 0 ? (T = b, T >= a.bounds.y && T <= a.bounds.bottom && (this.N === 180 ? k >= a.bounds.x : k <= a.bounds.right) && (N = a.centerX + (this.N === 180 ? -L : L), T < a.bounds.y + a.bounds.height / 2 ? T = a.bounds.y - this.ne / 2 : T = a.bounds.bottom + this.ne / 2, i.insertPointAt(p++, N, b), i.insertPointAt(p++, N, T)), i.insertPointAt(p++, k, T), i.insertPointAt(p++, k, P)) : (T = S, T >= a.bounds.x && T <= a.bounds.right && (this.N === 270 ? P >= a.bounds.y : P <= a.bounds.bottom) && (N = a.centerY + (this.N === 270 ? -L : L), T < a.bounds.x + a.bounds.width / 2 ? T = a.bounds.x - this.ne / 2 : T = a.bounds.right + this.ne / 2, i.insertPointAt(p++, S, N), i.insertPointAt(p++, T, N)), i.insertPointAt(p++, T, P), i.insertPointAt(p++, k, P));
          } else if (u) C = Math.max(10, this.qs[a.layer]), M = Math.max(10, this.xs[a.layer]), this.N === 180 && k >= a.bounds.x ? (N = a.bounds.x + a.bounds.width, i.setPointAt(p - 2, N, b), i.setPointAt(p - 1, N + M, b)) : this.N === 90 && P <= a.bounds.bottom ? (N = a.bounds.y, i.setPointAt(p - 2, S, N), i.setPointAt(p - 1, S, N - C)) : this.N === 270 && P >= a.bounds.y ? (N = a.bounds.y + a.bounds.height, i.setPointAt(p - 2, S, N), i.setPointAt(p - 1, S, N + M)) : this.N === 0 && k <= a.bounds.right && (N = a.bounds.x, i.setPointAt(p - 2, N, b), i.setPointAt(p - 1, N - C, b));
          else {
            C = Math.max(10, this.qs[a.layer]), M = Math.max(10, this.xs[a.layer]);
            let L = 0;
            this.N === 180 || this.N === 0 ? ((this.N === 180 ? k <= a.bounds.x : k >= a.bounds.right) && (L = (this.N === 0 ? M : -C) / 2), i.insertPointAt(p++, k + L, b)) : ((this.N === 270 ? P <= a.bounds.y : P >= a.bounds.bottom) && (L = (this.N === 90 ? M : -C) / 2), i.insertPointAt(p++, S, P + L)), i.insertPointAt(p++, k, P);
          }
        } else {
          for (; a !== null && a !== c; ) {
            y = null, x = null;
            const N = a.destinationEdges.iterator;
            for (; N.next(); ) {
              const L = N.value;
              if (L.link === e.link && (y = L.toVertex, x = L.fromVertex, x.node !== null && (x = null), y.node === null)) break;
            }
            if (y === null) break;
            y !== c && (S = i.getPoint(p - 1).x, b = i.getPoint(p - 1).y, k = y.centerX, P = y.centerY, d ? this.N === 180 || this.N === 0 ? (x !== null ? x.centerY : b) !== P && (A = this.zt[y.layer] + this.yr.x, p === i.firstPickIndex + 1 && (this.N === 0 ? A = Math.max(A, S) : A = Math.min(A, S)), i.insertPointAt(p++, A, b), i.insertPointAt(p++, A, P)) : (x !== null ? x.centerX : S) !== k && (A = this.zt[y.layer] + this.yr.y, p === i.firstPickIndex + 1 && (this.N === 90 ? A = Math.max(A, b) : A = Math.min(A, b)), i.insertPointAt(p++, S, A), i.insertPointAt(p++, k, A)) : (C = Math.max(10, this.qs[y.layer]), M = Math.max(10, this.xs[y.layer]), u ? this.N === 180 ? (i.insertPointAt(p++, k + M + Math.max(10, m), P), i.insertPointAt(p++, Math.max(k + M - m / 2, k), P), i.insertPointAt(p++, k, P), i.insertPointAt(p++, k, P), i.insertPointAt(p++, Math.min(k - C + m / 2, k), P), i.insertPointAt(p++, k - C - m, P)) : this.N === 90 ? (i.insertPointAt(p++, k, P - C - Math.max(10, m)), i.insertPointAt(p++, k, Math.min(P - C + m / 2, P)), i.insertPointAt(p++, k, P), i.insertPointAt(p++, k, P), i.insertPointAt(p++, k, Math.max(P + M - m / 2, P)), i.insertPointAt(p++, k, P + M + m)) : this.N === 270 ? (i.insertPointAt(p++, k, P + M + Math.max(10, m)), i.insertPointAt(p++, k, Math.max(P + M - m / 2, P)), i.insertPointAt(p++, k, P), i.insertPointAt(p++, k, P), i.insertPointAt(p++, k, Math.min(P - C + m / 2, P)), i.insertPointAt(p++, k, P - C - m)) : (i.insertPointAt(p++, k - C - Math.max(10, m), P), i.insertPointAt(p++, Math.min(k - C + m / 2, k), P), i.insertPointAt(p++, k, P), i.insertPointAt(p++, k, P), i.insertPointAt(p++, Math.max(k + M - m / 2, k), P), i.insertPointAt(p++, k + M + m, P)) : this.N === 180 ? (i.insertPointAt(p++, k + M, P), i.insertPointAt(p++, k - C, P)) : this.N === 90 ? (i.insertPointAt(p++, k, P - C), i.insertPointAt(p++, k, P + M)) : this.N === 270 ? (i.insertPointAt(p++, k, P + M), i.insertPointAt(p++, k, P - C)) : (i.insertPointAt(p++, k - C, P), i.insertPointAt(p++, k + M, P)))), a = y;
          }
          d && (S = i.getPoint(p - 1).x, b = i.getPoint(p - 1).y, k = i.getPoint(p).x, P = i.getPoint(p).y, this.N === 180 || this.N === 0 ? b !== P && (this.N === 0 ? A = Math.min(Math.max((k + S) / 2, this.zt[c.layer] + this.yr.x), k) : A = Math.max(Math.min((k + S) / 2, this.zt[c.layer] + this.yr.x), k), i.insertPointAt(p++, A, b), i.insertPointAt(p++, A, P)) : S !== k && (this.N === 90 ? A = Math.min(Math.max((P + b) / 2, this.zt[c.layer] + this.yr.y), P) : A = Math.max(Math.min((P + b) / 2, this.zt[c.layer] + this.yr.y), P), i.insertPointAt(p++, S, A), i.insertPointAt(p++, k, A)));
        }
        if (s !== null && u && i.pointsCount >= 4) {
          if (n !== null && r !== null && (h === Spot2.None || s.rf(h))) {
            const N = r.getDocumentPoint(Spot2.Center);
            N.isReal() || N.setTo(n.actualBounds.centerX, n.actualBounds.centerY);
            const L = i.getPoint(3), T = i.getLinkPointFromPoint(n, r, N, L, true), D = i.getPoint(2);
            this.direction === 90 || this.direction === 270 ? (i.setPointAt(1, (T.x + D.x) / 2, D.y), i.setPointAt(2, L.x, (D.y + L.y) / 2)) : (i.setPointAt(1, D.x, (T.y + D.y) / 2), i.setPointAt(2, (D.x + L.x) / 2, L.y));
            const F = i.getLinkPointFromPoint(n, r, N, i.getPoint(1), true);
            i.setPointAt(0, F.x, F.y);
          }
          if (o !== null && l !== null && (f === Spot2.None || s.rf(f))) {
            const N = l.getDocumentPoint(Spot2.Center);
            N.isReal() || N.setTo(o.actualBounds.centerX, o.actualBounds.centerY);
            const L = i.getPoint(i.pointsCount - 4), T = i.getLinkPointFromPoint(o, l, N, L, false), D = i.getPoint(i.pointsCount - 3);
            this.direction === 90 || this.direction === 270 ? (i.setPointAt(i.pointsCount - 2, (T.x + D.x) / 2, (D.y + T.y) / 2), i.setPointAt(i.pointsCount - 3, L.x, (D.y + T.y) / 2)) : (i.setPointAt(i.pointsCount - 2, (D.x + T.x) / 2, (T.y + D.y) / 2), i.setPointAt(i.pointsCount - 3, (D.x + T.x) / 2, L.y));
            const F = i.getLinkPointFromPoint(o, l, N, i.getPoint(i.pointsCount - 2), false);
            i.setPointAt(i.pointsCount - 1, F.x, F.y);
          }
        }
        i.commitRoute(), e.commit();
      }
    }
    T4() {
      this.Aw = -1, this.Zg = 0, this.Gs = 0, this.bu = null;
      for (let t = 0; t < this.vn.length; t++) this.vn[t] = null;
    }
    Zh(t) {
      let i;
      const e = this.li[t];
      if (e >= this.vn.length) {
        const n = [];
        for (let o = 0; o < this.vn.length; o++) n[o] = this.vn[o];
        this.vn = n;
      }
      this.vn[e] === void 0 || this.vn[e] === null ? i = [] : (i = this.vn[e], this.vn[e] = null);
      const s = this.bu[t];
      for (let n = 0; n < s.length; n++) {
        const o = s[n];
        i[o.index] = o;
      }
      return i;
    }
    Qh(t, i) {
      this.vn[this.li[t]] = i;
    }
    get layerSpacing() {
      return this.Us;
    }
    set layerSpacing(t) {
      this.Us !== t && (U.i(t, "number", LayeredDigraphLayout2, "layerSpacing"), t >= 0 && (this.Us = t, this.b()));
    }
    get columnSpacing() {
      return this.ne;
    }
    set columnSpacing(t) {
      this.ne !== t && (U.i(t, "number", LayeredDigraphLayout2, "columnSpacing"), t > 0 && (this.ne = t, this.b()));
    }
    get direction() {
      return this.N;
    }
    set direction(t) {
      this.N !== t && (U.i(t, "number", LayeredDigraphLayout2, "direction"), t === 0 || t === 90 || t === 180 || t === 270 ? (this.N = t, this.b()) : U.n("LayeredDigraphLayout.direction must be 0, 90, 180, or 270"));
    }
    get cycleRemoveOption() {
      return this.mu;
    }
    set cycleRemoveOption(t) {
      this.mu !== t && (U.W(t, LayeredDigraphCycleRemove2, "LayeredDigraphCycleRemove"), (t === 1 || t === 0 || t === 2) && (this.mu = t, this.b()));
    }
    get layeringOption() {
      return this.pu;
    }
    set layeringOption(t) {
      this.pu !== t && (U.W(t, LayeredDigraphLayering2, "LayeredDigraphLayering"), (t === 10 || t === 11 || t === 12) && (this.pu = t, this.b()));
    }
    get initializeOption() {
      return this.yu;
    }
    set initializeOption(t) {
      this.yu !== t && (U.W(t, LayeredDigraphInit2, "LayeredDigraphInit"), (t === 20 || t === 21 || t === 22) && (this.yu = t, this.b()));
    }
    get iterations() {
      return this.kf;
    }
    set iterations(t) {
      this.kf !== t && (U.r(t, LayeredDigraphNetwork2, "iterations"), t >= 0 && (this.kf = t, this.b()));
    }
    get aggressiveOption() {
      return this.wu;
    }
    set aggressiveOption(t) {
      this.wu !== t && (U.W(t, LayeredDigraphAggressive2, "LayeredDigraphAggressive"), (t === 30 || t === 31 || t === 32) && (this.wu = t, this.b()));
    }
    get packOption() {
      return this.pr;
    }
    set packOption(t) {
      this.pr !== t && (U.i(t, "number", LayeredDigraphLayout2, "packOption"), t >= 0 && t < 8 && (this.pr = t, this.b()));
    }
    get packIterations() {
      return this.xu;
    }
    set packIterations(t) {
      this.xu = t;
    }
    get alignOption() {
      return this.Wn;
    }
    set alignOption(t) {
      this.Wn !== t && (U.i(t, "number", LayeredDigraphLayout2, "align"), t >= 0 && t < 16 && (this.Wn = t, this.b()));
    }
    get centered() {
      return this.$h;
    }
    set centered(t) {
      this.centered !== t && (U.i(t, "boolean", LayeredDigraphLayout2, "centered"), this.$h = t, this.b());
    }
    get setsPortSpots() {
      return this.Hn;
    }
    set setsPortSpots(t) {
      this.Hn !== t && (U.i(t, "boolean", LayeredDigraphLayout2, "setsPortSpots"), this.Hn = t, this.b());
    }
    get maxLayer() {
      return this.st;
    }
    get maxIndex() {
      return this.Aw;
    }
    get maxColumn() {
      return this.qt;
    }
    get minIndexLayer() {
      return this.Zg;
    }
    get maxIndexLayer() {
      return this.Gs;
    }
    static CycleDepthFirst = 0;
    static CycleGreedy = 1;
    static CycleFromLayers = 2;
    static LayerOptimalLinkLength = 10;
    static LayerLongestPathSink = 11;
    static LayerLongestPathSource = 12;
    static InitDepthFirstOut = 20;
    static InitDepthFirstIn = 21;
    static InitNaive = 22;
    static AggressiveNone = 30;
    static AggressiveLess = 31;
    static AggressiveMore = 32;
    static PackNone = 0;
    static PackExpand = 1;
    static PackStraighten = 2;
    static PackMedian = 4;
    static PackAll = 15;
    static AlignNone = 0;
    static AlignUpperLeft = 1;
    static AlignUpperRight = 2;
    static AlignLowerLeft = 4;
    static AlignLowerRight = 8;
    static AlignAll = 15;
  }
  class SegInfo {
    Sl;
    rB;
    lb;
    lB;
    hB;
    Et;
    os;
    aB;
    constructor() {
      this.Sl = 0, this.rB = 0, this.lb = 0, this.lB = 0, this.hB = 0, this.Et = 0, this.os = null, this.aB = 0;
    }
  }
  class LayeredDigraphNetwork2 extends LayoutNetwork2 {
    constructor(t) {
      super(t);
    }
    createVertex() {
      const t = new LayeredDigraphVertex2(this);
      return t.centered = this.layout.centered, t;
    }
    createEdge() {
      return new LayeredDigraphEdge2(this);
    }
  }
  class LayeredDigraphVertex2 extends LayoutVertex2 {
    Sl;
    kh;
    Et;
    fk;
    ck;
    $h;
    re;
    Su;
    no;
    rk;
    sk;
    nk;
    Pf;
    jn;
    FI;
    _h;
    fs;
    ku;
    ye;
    Jn;
    Fw = null;
    Iw = null;
    Rw = null;
    Ow = null;
    constructor(t) {
      super(t), this.Sl = -1, this.kh = -1, this.Et = -1, this.fk = NaN, this.ck = null, this.$h = true, this.re = false, this.Su = NaN, this.no = NaN, this.rk = 0, this.sk = null, this.nk = null;
    }
    static OI(t, i) {
      return t.index - i.index;
    }
    getProperSourceEdges() {
      if (!this.Rw) {
        const t = [];
        for (const i of this.To) {
          const e = i;
          e.valid && t.push(e);
        }
        this.Rw = t;
      }
      return this.Rw;
    }
    getProperDestinationEdges() {
      if (!this.Ow) {
        const t = [];
        for (const i of this.cr) {
          const e = i;
          e.valid && t.push(e);
        }
        this.Ow = t;
      }
      return this.Ow;
    }
    getDestinationEdge(t) {
      const i = this.getProperDestinationEdges();
      for (const e of i) if (e.toVertex === t) return e;
      U.n("Unable to find destination edge to given vertex");
    }
    getProperSourceVertexes() {
      if (!this.Fw) {
        const t = [];
        for (const i of this.To) {
          const e = i;
          !e.valid || e.fromVertex.layer <= e.toVertex.layer || t.push(e.fromVertex);
        }
        t.sort(LayeredDigraphVertex2.OI), this.Fw = t;
      }
      return this.Fw;
    }
    getProperDestinationVertexes() {
      if (!this.Iw) {
        const t = [];
        for (const i of this.cr) {
          const e = i;
          !e.valid || e.fromVertex.layer <= e.toVertex.layer || t.push(e.toVertex);
        }
        t.sort(LayeredDigraphVertex2.OI), this.Iw = t;
      }
      return this.Iw;
    }
    addSourceEdge(t) {
      super.addSourceEdge(t), this.Fw = null, this.Rw = null;
    }
    deleteSourceEdge(t) {
      super.deleteSourceEdge(t), this.Fw = null, this.Rw = null;
    }
    addDestinationEdge(t) {
      super.addDestinationEdge(t), this.Iw = null, this.Ow = null;
    }
    deleteDestinationEdge(t) {
      super.deleteDestinationEdge(t), this.Iw = null, this.Ow = null;
    }
    commit() {
      if (this.centered) super.commit();
      else {
        const t = this.node;
        if (t !== null) {
          const i = this.network.layout;
          if (!i) return;
          i.direction === 180 || i.direction === 270 ? t.moveTo(this.bounds.right - t.actualBounds.width, this.bounds.bottom - t.actualBounds.height) : t.moveTo(this.bounds.x, this.bounds.y);
        }
      }
    }
    get layer() {
      return this.Sl;
    }
    set layer(t) {
      this.Sl = t;
    }
    get column() {
      return this.kh;
    }
    set column(t) {
      this.kh = t;
    }
    get index() {
      return this.Et;
    }
    set index(t) {
      this.Et = t;
    }
    get component() {
      return this.fk;
    }
    set component(t) {
      this.fk !== t && (U.i(t, "number", LayeredDigraphVertex2, "component"), this.fk = t);
    }
    get near() {
      return this.ck;
    }
    set near(t) {
      this.ck !== t && (Debug && t !== null && U.s(t, LayeredDigraphVertex2, LayeredDigraphVertex2, "near"), this.ck = t);
    }
    get centered() {
      return this.$h;
    }
    set centered(t) {
      this.$h = t;
    }
  }
  class LayeredDigraphEdge2 extends LayoutEdge2 {
    re;
    uk;
    dk;
    gk;
    mk;
    pk;
    yk;
    constructor(t) {
      super(t), this.re = false, this.uk = false, this.dk = false, this.gk = NaN, this.mk = NaN, this.pk = 0, this.yk = 0;
    }
    get fromVertex() {
      return this.ls;
    }
    set fromVertex(t) {
      this.ls !== t && (Debug && t !== null && U.s(t, LayeredDigraphVertex2, LayeredDigraphEdge2, "fromVertex"), this.ls = t);
    }
    get toVertex() {
      return this.hs;
    }
    set toVertex(t) {
      this.hs !== t && (Debug && t !== null && U.s(t, LayeredDigraphVertex2, LayeredDigraphEdge2, "toVertex"), this.hs = t);
    }
    get valid() {
      return this.re;
    }
    set valid(t) {
      this.re !== t && (U.i(t, "boolean", LayeredDigraphEdge2, "valid"), this.re = t);
    }
    get rev() {
      return this.uk;
    }
    set rev(t) {
      this.uk !== t && (U.i(t, "boolean", LayeredDigraphEdge2, "rev"), this.uk = t);
    }
    get forest() {
      return this.dk;
    }
    set forest(t) {
      this.dk !== t && (U.i(t, "boolean", LayeredDigraphEdge2, "forest"), this.dk = t);
    }
    get portFromPos() {
      return this.gk;
    }
    set portFromPos(t) {
      this.gk !== t && (U.i(t, "number", LayeredDigraphEdge2, "portFromPos"), this.gk = t);
    }
    get portToPos() {
      return this.mk;
    }
    set portToPos(t) {
      this.mk !== t && (U.i(t, "number", LayeredDigraphEdge2, "portToPos"), this.mk = t);
    }
    get portFromColOffset() {
      return this.pk;
    }
    set portFromColOffset(t) {
      this.pk !== t && (U.i(t, "number", LayeredDigraphEdge2, "portFromColOffset"), this.pk = t);
    }
    get portToColOffset() {
      return this.yk;
    }
    set portToColOffset(t) {
      this.yk !== t && (U.i(t, "number", LayeredDigraphEdge2, "portToColOffset"), this.yk = t);
    }
  }
  var TreePath2 = ((w) => (w[w.Default = 0] = "Default", w[w.Destination = 1] = "Destination", w[w.Source = 2] = "Source", w))(TreePath2 || {}), TreeSorting2 = ((w) => (w[w.Forwards = 10] = "Forwards", w[w.Reverse = 11] = "Reverse", w[w.Ascending = 12] = "Ascending", w[w.Descending = 13] = "Descending", w))(TreeSorting2 || {}), TreeAlignment2 = ((w) => (w[w.CenterSubtrees = 20] = "CenterSubtrees", w[w.CenterChildren = 21] = "CenterChildren", w[w.Start = 22] = "Start", w[w.End = 23] = "End", w[w.Bus = 24] = "Bus", w[w.BusBranching = 25] = "BusBranching", w[w.TopLeftBus = 26] = "TopLeftBus", w[w.BottomRightBus = 27] = "BottomRightBus", w[w.Custom = 28] = "Custom", w))(TreeAlignment2 || {}), TreeCompaction2 = ((w) => (w[w.None = 30] = "None", w[w.Block = 31] = "Block", w))(TreeCompaction2 || {}), TreeStyle2 = ((w) => (w[w.Layered = 40] = "Layered", w[w.LastParents = 41] = "LastParents", w[w.Alternating = 42] = "Alternating", w[w.RootOnly = 43] = "RootOnly", w))(TreeStyle2 || {}), TreeArrangement2 = ((w) => (w[w.Vertical = 50] = "Vertical", w[w.Horizontal = 51] = "Horizontal", w[w.FixedRoots = 52] = "FixedRoots", w))(TreeArrangement2 || {}), TreeLayerStyle2 = ((w) => (w[w.Individual = 60] = "Individual", w[w.Siblings = 61] = "Siblings", w[w.Uniform = 62] = "Uniform", w))(TreeLayerStyle2 || {});
  class TreeLayout2 extends Layout2 {
    Xi;
    Bi;
    Pu;
    im;
    kA;
    He;
    Ji;
    Ks;
    Y;
    K;
    wk;
    ks;
    constructor(t) {
      super(), this.Xi = new GSet2(), this.Bi = 0, this.ks = 1, this.Pu = 40, this.im = 60, this.kA = [], this.He = true, this.Ji = 50, this.Ks = new Size2(10, 10).S();
      const i = new TreeNetwork2(this);
      this.Y = new TreeVertex2(i), this.K = new TreeVertex2(i), this.wk = [], t && Object.assign(this, t);
    }
    cloneProtected(t) {
      super.cloneProtected(t), t.Bi = this.Bi, t.Pu = this.Pu, t.im = this.im, t.He = this.He, t.Ji = this.Ji, t.Ks.c(this.Ks), t.Y.copyInheritedPropertiesFrom(this.Y), t.K.copyInheritedPropertiesFrom(this.K);
    }
    gi(t) {
      t in TreeAlignment2 ? this.alignment = t : t in TreeArrangement2 ? this.arrangement = t : t in TreeCompaction2 ? this.compaction = t : t in TreePath2 ? this.path = t : t in TreeSorting2 ? this.sorting = t : t in TreeStyle2 ? this.treeStyle = t : super.gi(t);
    }
    createNetwork() {
      return new TreeNetwork2(this);
    }
    makeNetwork(t) {
      const i = this.createNetwork(), e = (s) => {
        if (s instanceof Node2) return !s.isLinkLabel && s.category !== "Comment";
        if (s instanceof Link2) {
          const n = s.fromNode;
          if (n === null || n.isLinkLabel || n.category === "Comment") return false;
          const o = s.toNode;
          return !(o === null || o.isLinkLabel || o.category === "Comment");
        }
        return false;
      };
      return t instanceof Diagram2 ? (i.addParts(t.nodes, true, e), i.addParts(t.links, true, e)) : t instanceof Group2 ? i.addParts(t.memberParts, false, e) : i.addParts(t.iterator, false, e), i;
    }
    doLayout(t) {
      Debug && t === null && U.n("Layout.doLayout(collection) argument must not be null but a Diagram, a Group, or an Iterable of Parts"), this.network === null && (this.network = this.makeNetwork(t)), this.arrangement !== 52 && (this.arrangementOrigin = this.initialOrigin(this.arrangementOrigin));
      let i = this.diagram;
      i === null && t instanceof Diagram2 && (i = t), this.path === 0 && i !== null ? this.ks = i.isTreePathToChildren ? 1 : 2 : this.ks = this.path === 0 ? 1 : this.path, this.network.vertexes.count > 0 && (this.fB(), this.cB(), this.uB(), this.dB(), this.pA(), this.gB(), this.arrangeTrees(), this.updateParts()), this.network = null, this.Xi = new GSet2(), this.isValidLayout = true;
    }
    fB() {
      if (this.network === null) return;
      this.network.deleteSelfEdges();
      const t = this.network.vertexes.iterator;
      for (; t.next(); ) {
        const n = t.value;
        n.initialized = false, n.level = 0, n.parent = null, n.children = [];
      }
      if (this.Xi.count > 0) {
        const n = new GSet2(), o = this.Xi.iterator;
        for (; o.next(); ) {
          const r = o.value;
          if (r instanceof Node2) {
            const l = this.network.findVertex(r);
            l !== null && n.add(l);
          } else r instanceof TreeVertex2 && n.add(r);
        }
        this.Xi = n;
      }
      this.Xi.count === 0 && this.findRoots();
      const i = this.Xi.copy().iterator;
      for (; i.next(); ) {
        const n = i.value;
        n.initialized || (n.initialized = true, this.PA(n));
      }
      let e = this.network.vertexes, s = null;
      for (; s = this.mB(e), s.count > 0; ) {
        const n = this.EI(s);
        n !== null && (this.Xi.add(n), n.initialized = true, this.PA(n)), e = s;
      }
    }
    mB(t) {
      const i = new GSet2(), e = t.iterator;
      for (; e.next(); ) {
        const s = e.value;
        s.initialized || i.add(s);
      }
      return i;
    }
    findRoots() {
      if (this.network === null) return;
      const t = this.network.vertexes, i = t.iterator;
      for (; i.next(); ) {
        const e = i.value;
        switch (this.ks) {
          case 1:
            e.sourceEdges.count === 0 && this.Xi.add(e);
            break;
          case 2:
            e.destinationEdges.count === 0 && this.Xi.add(e);
            break;
          default:
            U.n("Unhandled path value " + this.ks.toString());
        }
      }
      if (this.Xi.count === 0) {
        const e = this.EI(t);
        e !== null && this.Xi.add(e);
      }
    }
    EI(t) {
      let i = 999999, e = null;
      const s = t.iterator;
      for (; s.next(); ) {
        const n = s.value;
        switch (this.ks) {
          case 1:
            n.sourceEdges.count < i && (i = n.sourceEdges.count, e = n);
            break;
          case 2:
            n.destinationEdges.count < i && (i = n.destinationEdges.count, e = n);
            break;
          default:
            U.n("Unhandled path value " + this.ks.toString());
        }
      }
      return e;
    }
    PA(t) {
      if (t === null) return;
      switch (Debug && U.s(t, TreeVertex2, TreeLayout2, "walkTree:v"), this.ks) {
        case 1:
          if (t.destinationEdges.count > 0) {
            const s = new List2(), n = t.destinationVertexes;
            for (; n.next(); ) {
              const o = n.value;
              this.BI(t, o) && s.add(o);
            }
            s.count > 0 && (t.children = s.toArray());
          }
          break;
        case 2:
          if (t.sourceEdges.count > 0) {
            const s = new List2(), n = t.sourceVertexes;
            for (; n.next(); ) {
              const o = n.value;
              this.BI(t, o) && s.add(o);
            }
            s.count > 0 && (t.children = s.toArray());
          }
          break;
        default:
          U.n("Unhandled path value" + this.ks.toString());
      }
      const i = t.children, e = i.length;
      for (let s = 0; s < e; s++) {
        const n = i[s];
        n.initialized = true, n.level = t.level + 1, n.parent = t, this.Xi.delete(n);
      }
      for (let s = 0; s < e; s++) {
        const n = i[s];
        this.PA(n);
      }
    }
    BI(t, i) {
      return Debug && U.s(t, TreeVertex2, TreeLayout2, "walkOK:v"), Debug && U.s(i, TreeVertex2, TreeLayout2, "walkOK:c"), i.initialized ? this.pB(i, t) || i.level > t.level ? false : (this.yB(i.parent, i), true) : true;
    }
    pB(t, i) {
      if (i === null) return false;
      Debug && U.s(t, TreeVertex2, TreeLayout2, "isAncestor:a"), Debug && U.s(i, TreeVertex2, TreeLayout2, "isAncestor:b");
      let e = i.parent;
      for (; e !== null && e !== t; ) e = e.parent;
      return e === t;
    }
    yB(t, i) {
      if (t === null || i === null) return;
      Debug && U.s(t, TreeVertex2, TreeLayout2, "removeChild:p"), Debug && U.s(i, TreeVertex2, TreeLayout2, "removeChild:c");
      const e = t.children;
      let s = 0;
      for (let n = 0; n < e.length; n++) e[n] === i && s++;
      if (s > 0) {
        const n = new Array(e.length - s);
        let o = 0;
        for (let r = 0; r < e.length; r++) e[r] !== i && (n[o++] = e[r]);
        t.children = n;
      }
    }
    cB() {
      const t = this.Xi.iterator;
      for (; t.next(); ) {
        const i = t.value;
        i instanceof TreeVertex2 && this.VI(i);
      }
    }
    VI(t) {
      if (t === null) return;
      Debug && U.s(t, TreeVertex2, TreeLayout2, "initializeTree:v"), this.initializeTreeVertexValues(t), t.alignment === 25 && this.sortTreeVertexChildren(t);
      let i = 0, e = t.childrenCount, s = 0;
      const n = t.children, o = n.length;
      for (let r = 0; r < o; r++) {
        const l = n[r];
        this.VI(l), i += l.descendantCount + 1, e = Math.max(e, l.maxChildrenCount), s = Math.max(s, l.maxGenerationCount);
      }
      t.descendantCount = i, t.maxChildrenCount = e, t.maxGenerationCount = e > 0 ? s + 1 : 0;
    }
    wB(t) {
      switch (Debug && U.s(t, TreeVertex2, TreeLayout2, "mom:v"), this.Pu) {
        default:
        case 40:
          return t.parent !== null ? t.parent : this.Y;
        case 43:
          return t.parent === null ? this.Y : t.parent.parent === null ? this.K : t.parent;
        case 42:
          return t.parent !== null ? t.parent.parent !== null ? t.parent.parent : this.K : this.Y;
        case 41: {
          let i = true;
          if (t.childrenCount === 0) i = false;
          else {
            const e = t.children, s = e.length;
            for (let n = 0; n < s; n++) if (e[n].childrenCount > 0) {
              i = false;
              break;
            }
          }
          return i && t.parent !== null ? this.K : t.parent !== null ? t.parent : this.Y;
        }
      }
    }
    initializeTreeVertexValues(t) {
      Debug && U.s(t, TreeVertex2, TreeLayout2, "initializeTreeVertexValues:v");
      const i = this.wB(t);
      if (t.copyInheritedPropertiesFrom(i), t.parent !== null && t.parent.alignment === 25) {
        let e = t.angle;
        const s = t.parent.children;
        let n = 0;
        for (; n < s.length && t !== s[n]; ) n++;
        n % 2 === 0 ? n !== s.length - 1 && (e === 90 ? e = 180 : e === 180 ? e = 270 : e === 270 ? e = 180 : e = 270) : e === 90 ? e = 0 : e === 180 ? e = 90 : e === 270 ? e = 0 : e = 90, t.angle = e;
      }
      t.initialized = true;
    }
    uB() {
      const t = this.Xi.iterator;
      for (; t.next(); ) {
        const i = t.value;
        i instanceof TreeVertex2 && this.zI(i);
      }
    }
    zI(t) {
      if (t === null) return;
      Debug && U.s(t, TreeVertex2, TreeLayout2, "assignTree:v"), this.assignTreeVertexValues(t);
      const i = t.children, e = i.length;
      for (let s = 0; s < e; s++) {
        const n = i[s];
        this.zI(n);
      }
    }
    assignTreeVertexValues(t) {
    }
    dB() {
      const t = this.Xi.iterator;
      for (; t.next(); ) {
        const i = t.value;
        i instanceof TreeVertex2 && this.XI(i);
      }
    }
    XI(t) {
      if (t === null) return;
      Debug && U.s(t, TreeVertex2, TreeLayout2, "sortTree:v"), t.alignment !== 25 && this.sortTreeVertexChildren(t);
      const i = t.children, e = i.length;
      for (let s = 0; s < e; s++) {
        const n = i[s];
        this.XI(n);
      }
    }
    sortTreeVertexChildren(t) {
      switch (Debug && U.s(t, TreeVertex2, TreeLayout2, "sortTreeVertexChildren:v"), t.sorting) {
        default:
        case 10:
          break;
        case 11:
          t.children.reverse();
          break;
        case 12:
          t.children.sort(t.comparer);
          break;
        case 13:
          t.children.sort(t.comparer), t.children.reverse();
          break;
      }
    }
    pA() {
      if (!this.comments || this.network === null) return;
      const t = this.network.vertexes.iterator;
      for (; t.next(); ) {
        const i = t.value;
        this.addComments(i);
      }
    }
    addComments(t) {
      Debug && U.s(t, TreeVertex2, TreeLayout2, "addComments:v");
      const i = t.angle, e = t.parent;
      let s = 0, n = 21, o = false;
      e !== null && (s = e.angle, n = e.alignment, o = this.isBusAlignment(n));
      const r = i === 90 || i === 270, l = s === 90 || s === 270, h = t.childrenCount === 0;
      let f = 0, a = 0, c = 0;
      const u = t.commentSpacing;
      if (t.node !== null) {
        const d = t.node.findNodesConnected();
        for (; d.next(); ) {
          const m = d.value;
          if (m.category !== "Comment" || !m.canLayout()) continue;
          t.comments === null && (t.comments = []), t.comments.push(m), m.ensureBounds();
          const g = m.measuredBounds;
          r && !h || !o && !l && h || o && l && h ? (f = Math.max(f, g.width), a += g.height + Math.abs(c)) : (f += g.width + Math.abs(c), a = Math.max(a, g.height)), c = u;
        }
      }
      if (t.comments !== null) {
        r && !h || !o && !l && h || o && l && h ? (f += Math.abs(t.commentMargin), a = Math.max(0, a - t.height)) : (a += Math.abs(t.commentMargin), f = Math.max(0, f - t.width));
        const d = Rect2.U(0, 0, t.bounds.width + f, t.bounds.height + a);
        t.bounds = d, Rect2.o(d);
      }
    }
    isBusAlignment(t) {
      return t === 24 || t === 25 || t === 26 || t === 27;
    }
    Ew(t) {
      return t === 24 || t === 25;
    }
    MA(t) {
      Debug && U.s(t, TreeVertex2, TreeLayout2, "isLeftSideBus:v");
      const i = t.parent;
      if (i !== null) {
        const e = i.alignment;
        if (this.isBusAlignment(e)) if (this.Ew(e)) {
          const s = i.children;
          let n = 0;
          for (; n < s.length && t !== s[n]; ) n++;
          return n % 2 === 0;
        } else return e === 26;
      }
      return false;
    }
    layoutComments(t) {
      if (Debug && U.s(t, TreeVertex2, TreeLayout2, "layoutComments:v"), t.comments !== null) {
        const e = t.node.measuredBounds, s = t.parent, n = t.angle;
        let o = 0, r = 21, l = false;
        s !== null && (o = s.angle, r = s.alignment, l = this.isBusAlignment(r));
        const h = n === 90 || n === 270, f = o === 90 || o === 270, a = t.childrenCount === 0, c = this.MA(t);
        let u = 0;
        const d = t.comments, m = d.length, g = Point2.a();
        for (let y = 0; y < m; y++) {
          const x = d[y], S = x.measuredBounds;
          if (h && !a || !l && !f && a || l && f && a) {
            if (o > 135 && !l || f && c) if (t.commentMargin >= 0) {
              g.e(t.bounds.x - t.commentMargin - S.width, t.bounds.y + u), x.move(g);
              const b = x.findLinksInto();
              for (; b.next(); ) {
                const k = b.value;
                k.fromSpot = Spot2.MiddleLeft, k.toSpot = Spot2.MiddleRight;
              }
            } else {
              g.e(t.bounds.x + t.focus.x * 2 - t.commentMargin, t.bounds.y + u), x.move(g);
              const b = x.findLinksInto();
              for (; b.next(); ) {
                const k = b.value;
                k.fromSpot = Spot2.MiddleRight, k.toSpot = Spot2.MiddleLeft;
              }
            }
            else if (t.commentMargin >= 0) {
              g.e(t.bounds.x + t.focus.x * 2 + t.commentMargin, t.bounds.y + u), x.move(g);
              const b = x.findLinksInto();
              for (; b.next(); ) {
                const k = b.value;
                k.fromSpot = Spot2.MiddleRight, k.toSpot = Spot2.MiddleLeft;
              }
            } else {
              g.e(t.bounds.x + t.commentMargin - S.width, t.bounds.y + u), x.move(g);
              const b = x.findLinksInto();
              for (; b.next(); ) {
                const k = b.value;
                k.fromSpot = Spot2.MiddleLeft, k.toSpot = Spot2.MiddleRight;
              }
            }
            t.commentSpacing >= 0 ? u += S.height + t.commentSpacing : u += t.commentSpacing - S.height;
          } else {
            if (o > 135 && !l || !f && c) if (t.commentMargin >= 0) {
              g.e(t.bounds.x + u, t.bounds.y - t.commentMargin - S.height), x.move(g);
              const b = x.findLinksInto();
              for (; b.next(); ) {
                const k = b.value;
                k.fromSpot = Spot2.MiddleTop, k.toSpot = Spot2.MiddleBottom;
              }
            } else {
              g.e(t.bounds.x + u, t.bounds.y + t.focus.y * 2 - t.commentMargin), x.move(g);
              const b = x.findLinksInto();
              for (; b.next(); ) {
                const k = b.value;
                k.fromSpot = Spot2.MiddleBottom, k.toSpot = Spot2.MiddleTop;
              }
            }
            else if (t.commentMargin >= 0) {
              g.e(t.bounds.x + u, t.bounds.y + t.focus.y * 2 + t.commentMargin), x.move(g);
              const b = x.findLinksInto();
              for (; b.next(); ) {
                const k = b.value;
                k.fromSpot = Spot2.MiddleBottom, k.toSpot = Spot2.MiddleTop;
              }
            } else {
              g.e(t.bounds.x + u, t.bounds.y + t.commentMargin - S.height), x.move(g);
              const b = x.findLinksInto();
              for (; b.next(); ) {
                const k = b.value;
                k.fromSpot = Spot2.MiddleTop, k.toSpot = Spot2.MiddleBottom;
              }
            }
            t.commentSpacing >= 0 ? u += S.width + t.commentSpacing : u += t.commentSpacing - S.width;
          }
        }
        Point2.o(g);
        const p = u - t.commentSpacing - (h ? e.height : e.width);
        if (this.ks === 1) {
          const y = t.destinationEdges;
          for (; y.next(); ) {
            const S = y.value.link;
            S !== null && !S.isAvoiding && (S.fromEndSegmentLength = p > 0 ? p : NaN);
          }
        } else {
          const y = t.sourceEdges;
          for (; y.next(); ) {
            const S = y.value.link;
            S !== null && !S.isAvoiding && (S.toEndSegmentLength = p > 0 ? p : NaN);
          }
        }
      }
    }
    gB() {
      if (this.network === null) return;
      if (this.layerStyle === 62) {
        const i = [];
        let e = this.network.vertexes.iterator;
        for (; e.next(); ) {
          const s = e.value;
          let n = s.parent;
          n === null && (n = s);
          const o = n.angle === 0 || n.angle === 180;
          let r = i[s.level];
          r === void 0 && (r = 0), i[s.level] = Math.max(r, o ? s.width : s.height);
        }
        for (let s = 0; s < i.length; s++) i[s] === void 0 && (i[s] = 0);
        for (this.kA = i, e = this.network.vertexes.iterator; e.next(); ) {
          const s = e.value;
          let n = s.parent;
          n === null && (n = s), n.angle === 0 || n.angle === 180 ? (n.angle === 180 && (s.focusX += i[s.level] - s.width), s.width = i[s.level]) : (n.angle === 270 && (s.focusY += i[s.level] - s.height), s.height = i[s.level]);
        }
      } else if (this.layerStyle === 61) {
        const i = this.network.vertexes.iterator;
        for (; i.next(); ) {
          const e = i.value, s = e.angle === 0 || e.angle === 180;
          let n = -1;
          for (let o = 0; o < e.children.length; o++) {
            const r = e.children[o];
            n = Math.max(n, s ? r.width : r.height);
          }
          if (n >= 0) for (let o = 0; o < e.children.length; o++) {
            const r = e.children[o];
            s ? (e.angle === 180 && (r.focusX += n - r.width), r.width = n) : (e.angle === 270 && (r.focusY += n - r.height), r.height = n);
          }
        }
      }
      const t = this.Xi.iterator;
      for (; t.next(); ) {
        const i = t.value;
        i instanceof TreeVertex2 && this.layoutTree(i);
      }
    }
    layoutTree(t) {
      if (t === null) return;
      Debug && U.s(t, TreeVertex2, TreeLayout2, "layoutTree:v");
      const i = t.children, e = i.length;
      for (let s = 0; s < e; s++) {
        const n = i[s];
        this.layoutTree(n);
      }
      switch (t.compaction) {
        case 30:
          this.YI(t);
          break;
        default:
        case 31:
          t.alignment === 25 ? this.YI(t) : this.xB(t);
          break;
      }
    }
    YI(t) {
      if (Debug && U.s(t, TreeVertex2, TreeLayout2, "layoutTreeNone:v"), t.childrenCount === 0) {
        let R = false, I = 0, O = 21;
        t.parent !== null && (I = t.parent.angle, O = t.parent.alignment, R = this.isBusAlignment(O));
        const X = this.MA(t);
        t.X.e(0, 0), t.bt.e(t.width, t.height), t.parent !== null && t.comments !== null && ((I === 180 || I === 270) && !R || X) ? I === 180 && !R || (I === 90 || I === 270) && X ? t.dt.e(t.width - t.focus.x * 2, 0) : t.dt.e(0, t.height - t.focus.y * 2) : t.dt.e(0, 0);
        return;
      }
      const i = this.orthoAngle(t), e = i === 90 || i === 270;
      let s = 0;
      const n = t.children, o = n.length;
      for (let R = 0; R < o; R++) {
        const I = n[R];
        s = Math.max(s, e ? I.bt.width : I.bt.height);
      }
      const r = t.alignment, l = r === 22, h = r === 23, f = this.isBusAlignment(r), a = Math.max(0, t.breadthLimit), c = this.computeLayerSpacing(t), u = t.nodeSpacing, d = this.computeNodeIndent(t), m = l || h ? 0 : d / 2, g = t.rowSpacing;
      let p = 0;
      (l || h) && (p = Math.max(0, t.rowIndent));
      const y = t.width, x = t.height;
      let S = 0, b = 0, k = 0, P = 0, A = 0, C = 0, M = 0, N = 0, L = 0, T = 0;
      if (f && !this.Ew(r) && i > 135 && n.reverse(), this.Ew(r)) if (o > 1) for (let R = 0; R < o; R++) {
        const I = n[R], O = I.bt;
        R % 2 === 0 && R !== o - 1 ? L = Math.max(L, (e ? O.width : O.height) + this.computeBusNodeSpacing(I) - u) : R % 2 !== 0 && (T = Math.max(T, (e ? O.width : O.height) + this.computeBusNodeSpacing(I) - u));
      }
      else o === 1 && (L = e ? n[0].bt.width : n[0].bt.height);
      if (f) switch (r) {
        case 24:
        case 25:
          const R = Rect2.a();
          i < 135 ? this.KI(t, n, L, T, S, b, R) : this.UI(t, n, L, T, S, b, R), L = R.x, S = R.width, b = R.height, Rect2.o(R);
          break;
        case 26:
          for (let I = 0; I < o; I++) {
            const O = n[I], X = O.bt, K = M === 0 ? 0 : g;
            e ? (O.X.e(s - X.width, A + K), S = Math.max(S, X.width), b = Math.max(b, A + K + X.height), A += K + X.height) : (O.X.e(P + K, s - X.height), S = Math.max(S, P + K + X.width), b = Math.max(b, X.height), P += K + X.width), M++;
          }
          break;
        case 27:
          for (let I = 0; I < o; I++) {
            const O = n[I], X = O.bt, K = M === 0 ? 0 : g;
            e ? (O.X.e(u / 2 + t.focus.x, A + K), S = Math.max(S, X.width), b = Math.max(b, A + K + X.height), A += K + X.height) : (O.X.e(P + K, u / 2 + t.focus.y), S = Math.max(S, P + K + X.width), b = Math.max(b, X.height), P += K + X.width), M++;
          }
          break;
      }
      else for (let R = 0; R < o; R++) {
        const I = n[R], O = I.bt;
        if (e) {
          a > 0 && M > 0 && P + u + O.width > a && (P < s && this.Mf(t, r, s - P, 0, N, R - 1), C++, M = 0, N = R, k = b, P = 0, A = i > 135 ? -b - g : b + g);
          const X = M === 0 ? m : u;
          this.xk(I, 0, A), I.X.e(P + X, A), S = Math.max(S, P + X + O.width), b = Math.max(b, k + (C === 0 ? 0 : g) + O.height), P += X + O.width;
        } else {
          a > 0 && M > 0 && A + u + O.height > a && (A < s && this.Mf(t, r, 0, s - A, N, R - 1), C++, M = 0, N = R, k = S, A = 0, P = i > 135 ? -S - g : S + g);
          const X = M === 0 ? m : u;
          this.xk(I, P, 0), I.X.e(P, A + X), b = Math.max(b, A + X + O.height), S = Math.max(S, k + (C === 0 ? 0 : g) + O.width), A += X + O.height;
        }
        M++;
      }
      C > 0 && (e ? (b += Math.max(0, c), P < S && this.Mf(t, r, S - P, 0, N, o - 1), p > 0 && (h || this.Mu(t, p, 0, 0, o - 1), S += p)) : (S += Math.max(0, c), A < b && this.Mf(t, r, 0, b - A, N, o - 1), p > 0 && (h || this.Mu(t, 0, p, 0, o - 1), b += p)));
      let D = 0, F = 0;
      switch (r) {
        case 20:
          e ? D += S / 2 - t.focus.x - d / 2 : F += b / 2 - t.focus.y - d / 2;
          break;
        default:
        case 21:
          if (C > 0) e ? D += S / 2 - t.focus.x - d / 2 : F += b / 2 - t.focus.y - d / 2;
          else {
            const I = o;
            if (e) {
              const O = n[0].X.x + n[0].dt.x, X = n[I - 1].X.x + n[I - 1].dt.x + n[I - 1].focus.x * 2;
              D += O + (X - O) / 2 - t.focus.x - d / 2;
            } else {
              const O = n[0].X.y + n[0].dt.y, X = n[I - 1].X.y + n[I - 1].dt.y + n[I - 1].focus.y * 2;
              F += O + (X - O) / 2 - t.focus.y - d / 2;
            }
          }
          break;
        case 22:
          e ? (D -= d, S += d) : (F -= d, b += d);
          break;
        case 23:
          e ? (D += S - t.width + d, S += d) : (F += b - t.height + d, b += d);
          break;
        case 24:
        case 25:
          e ? o > 1 ? D += L + u / 2 - t.focus.x : D += n[0].focus.x - t.focus.x + n[0].dt.x : o > 1 ? F += L + u / 2 - t.focus.y : F += n[0].focus.y - t.focus.y + n[0].dt.y;
          break;
        case 26:
          e ? D += S + u / 2 - t.focus.x : F += b + u / 2 - t.focus.y;
          break;
        case 27:
          break;
        case 28:
          const R = this.customAlignment(t, D, F, S, b);
          D = R[0], F = R[1], S = R[2], b = R[3];
          break;
      }
      for (let R = 0; R < o; R++) {
        const I = n[R];
        e ? I.X.e(I.X.x + I.dt.x - D, I.X.y + (i > 135 ? (f ? -b : -I.bt.height) + I.dt.y - c : x + c + I.dt.y)) : I.X.e(I.X.x + (i > 135 ? (f ? -S : -I.bt.width) + I.dt.x - c : y + c + I.dt.x), I.X.y + I.dt.y - F);
      }
      e ? (S = this.NA(t, S, D), D < 0 && (D = 0), i > 135 && (F += b + c), b = Math.max(Math.max(b, x), b + x + c)) : (i > 135 && (D += S + c), S = Math.max(Math.max(S, y), S + y + c), b = this.CA(t, b, F), F < 0 && (F = 0)), t.dt.e(D, F), t.bt.e(S, b);
    }
    customAlignment(t, i, e, s, n) {
      return [i, e, s, n];
    }
    KI(t, i, e, s, n, o, r) {
      Debug && U.s(t, TreeVertex2, TreeLayout2, "layoutBusChildrenPosDir:v");
      const l = i.length;
      if (l === 0) return r.e(e, 0, n, o), r;
      if (l === 1) {
        const y = i[0];
        return n = y.bt.width, o = y.bt.height, r.e(e, 0, n, o), r;
      }
      const h = t.nodeSpacing, f = t.rowSpacing, c = this.orthoAngle(t) === 90;
      let u = 0, d = 0, m = 0;
      for (let y = 0; y < l; y++) {
        if (y % 2 !== 0 || l > 1 && y === l - 1) continue;
        const x = i[y], S = x.bt, b = u === 0 ? 0 : f;
        if (c) {
          const k = this.computeBusNodeSpacing(x) - h;
          x.X.e(e - (S.width + k), m + b), n = Math.max(n, S.width + k), o = Math.max(o, m + b + S.height), m += b + S.height;
        } else {
          const k = this.computeBusNodeSpacing(x) - h;
          x.X.e(d + b, e - (S.height + k)), o = Math.max(o, S.height + k), n = Math.max(n, d + b + S.width), d += b + S.width;
        }
        u++;
      }
      u = 0;
      const g = d, p = m;
      c ? (d = e + h, m = 0) : (d = 0, m = e + h);
      for (let y = 0; y < l; y++) {
        if (y % 2 === 0) continue;
        const x = i[y], S = x.bt, b = u === 0 ? 0 : f;
        if (c) {
          const k = this.computeBusNodeSpacing(x) - h;
          x.X.e(d + k, m + b), n = Math.max(n, d + S.width + k), o = Math.max(o, m + b + S.height), m += b + S.height;
        } else {
          const k = this.computeBusNodeSpacing(x) - h;
          x.X.e(d + b, m + k), n = Math.max(n, d + b + S.width), o = Math.max(o, m + S.height + k), d += b + S.width;
        }
        u++;
      }
      if (l > 1 && l % 2 === 1) {
        const y = i[l - 1], x = y.bt, S = this.computeBusLastRowSpacing(y, c ? Math.max(Math.abs(p), Math.abs(m)) : Math.max(Math.abs(g), Math.abs(d)));
        if (c) {
          y.X.e(e + h / 2 - y.focus.x - y.dt.x, o + S);
          const b = e + h / 2 - y.focus.x - y.dt.x;
          n = Math.max(n, b + x.width), b < 0 && (n -= b), o = Math.max(o, Math.max(p, m) + S + x.height), y.X.x < 0 && (e = this.bk(t, y.X.x, false, e, h));
        } else {
          y.X.e(n + S, e + h / 2 - y.focus.y - y.dt.y), n = Math.max(n, Math.max(g, d) + S + x.width);
          const b = e + h / 2 - y.focus.y - y.dt.y;
          o = Math.max(o, b + x.height), b < 0 && (o -= b), y.X.y < 0 && (e = this.bk(t, y.X.y, true, e, h));
        }
      }
      return r.e(e, 0, n, o), r;
    }
    UI(t, i, e, s, n, o, r) {
      Debug && U.s(t, TreeVertex2, TreeLayout2, "layoutBusChildrenNegDir:v");
      const l = i.length;
      if (l === 0) return r.e(e, 0, n, o), r;
      if (l === 1) {
        const y = i[0];
        return n = y.bt.width, o = y.bt.height, r.e(e, 0, n, o), r;
      }
      const h = t.nodeSpacing, f = t.rowSpacing, c = this.orthoAngle(t) === 270;
      let u = 0, d = 0, m = 0;
      for (let y = 0; y < l; y++) {
        if (y % 2 !== 0 || l > 1 && y === l - 1) continue;
        const x = i[y], S = x.bt, b = u === 0 ? 0 : f;
        if (c) {
          const k = this.computeBusNodeSpacing(x) - h;
          m -= b + S.height, x.X.e(e - (S.width + k), m), n = Math.max(n, S.width + k), o = Math.max(o, Math.abs(m));
        } else {
          const k = this.computeBusNodeSpacing(x) - h;
          d -= b + S.width, x.X.e(d, e - (S.height + k)), o = Math.max(o, S.height + k), n = Math.max(n, Math.abs(d));
        }
        u++;
      }
      u = 0;
      const g = d, p = m;
      c ? (d = e + h, m = 0) : (d = 0, m = e + h);
      for (let y = 0; y < l; y++) {
        if (y % 2 === 0) continue;
        const x = i[y], S = x.bt, b = u === 0 ? 0 : f;
        if (c) {
          const k = this.computeBusNodeSpacing(x) - h;
          m -= b + S.height, x.X.e(d + k, m), n = Math.max(n, d + S.width + k), o = Math.max(o, Math.abs(m));
        } else {
          const k = this.computeBusNodeSpacing(x) - h;
          d -= b + S.width, x.X.e(d, m + k), o = Math.max(o, m + S.height + k), n = Math.max(n, Math.abs(d));
        }
        u++;
      }
      if (l > 1 && l % 2 === 1) {
        const y = i[l - 1], x = y.bt, S = this.computeBusLastRowSpacing(y, c ? Math.max(Math.abs(p), Math.abs(m)) : Math.max(Math.abs(g), Math.abs(d)));
        if (c) {
          y.X.e(e + h / 2 - y.focus.x - y.dt.x, -o - x.height - S);
          const b = e + h / 2 - y.focus.x - y.dt.x;
          n = Math.max(n, b + x.width), b < 0 && (n -= b), o = Math.max(o, Math.abs(Math.min(p, m)) + S + x.height), y.X.x < 0 && (e = this.bk(t, y.X.x, false, e, h));
        } else {
          y.X.e(-n - x.width - S, e + h / 2 - y.focus.y - y.dt.y), n = Math.max(n, Math.abs(Math.min(g, d)) + S + x.width);
          const b = e + h / 2 - y.focus.y - y.dt.y;
          o = Math.max(o, b + x.height), b < 0 && (o -= b), y.X.y < 0 && (e = this.bk(t, y.X.y, true, e, h));
        }
      }
      for (let y = 0; y < l; y++) {
        const x = i[y];
        c ? x.X.e(x.X.x, x.X.y + o) : x.X.e(x.X.x + n, x.X.y);
      }
      return r.e(e, 0, n, o), r;
    }
    computeBusNodeSpacing(t) {
      return Debug && U.s(t, TreeVertex2, TreeLayout2, "fixRelativePostions:child"), t.parent === null ? 0 : t.parent.nodeSpacing;
    }
    computeBusLastRowSpacing(t, i) {
      return Debug && U.s(t, TreeVertex2, TreeLayout2, "fixRelativePostions:lastchild"), t.parent === null ? 0 : t.parent.rowSpacing;
    }
    bk(t, i, e, s, n) {
      Debug && U.s(t, TreeVertex2, TreeLayout2, "fixRelativePostions:v");
      const o = t.children, r = o.length;
      for (let h = 0; h < r; h++) e ? o[h].X.e(o[h].X.x, o[h].X.y - i) : o[h].X.e(o[h].X.x - i, o[h].X.y);
      const l = o[r - 1];
      return Math.max(s, e ? l.dt.y + l.focus.y - n / 2 : l.dt.x + l.focus.x - n / 2);
    }
    NA(t, i, e) {
      switch (Debug && U.s(t, TreeVertex2, TreeLayout2, "calculateSubwidth:v"), t.alignment) {
        case 21:
        case 20:
          let s = i;
          return e + t.width > s && (s = e + t.width), e < 0 && (s -= e), s;
        case 22:
          return t.width > i ? t.width : i;
        case 23:
          return t.focus.x * 2 > i ? t.width : i + t.width - t.focus.x * 2;
        case 24:
        case 25:
          const n = Math.min(0, e), o = Math.max(i, e + t.width);
          return Math.max(t.width, o - n);
        case 26:
          return t.width - t.focus.x + t.nodeSpacing / 2 + i;
        case 27:
          return Math.max(t.width, t.focus.x + t.nodeSpacing / 2 + i);
        default:
          return i;
      }
    }
    CA(t, i, e) {
      switch (Debug && U.s(t, TreeVertex2, TreeLayout2, "calculateSubheight:v"), t.alignment) {
        case 21:
        case 20:
          let s = i;
          return e + t.height > s && (s = e + t.height), e < 0 && (s -= e), s;
        case 22:
          return t.height > i ? t.height : i;
        case 23:
          return t.focus.y * 2 > i ? t.height : i + t.height - t.focus.y * 2;
        case 24:
        case 25:
          const n = Math.min(0, e), o = Math.max(i, e + t.height);
          return Math.max(t.height, o - n);
        case 26:
          return t.height - t.focus.y + t.nodeSpacing / 2 + i;
        case 27:
          return Math.max(t.height, t.focus.y + t.nodeSpacing / 2 + i);
        default:
          return i;
      }
    }
    AA(t, i, e) {
      switch (Debug && U.W(t, TreeAlignment2, "TreeAlignment"), t) {
        case 20:
          i /= 2, e /= 2;
          break;
        case 21:
          i /= 2, e /= 2;
          break;
        case 22:
          i = 0, e = 0;
          break;
        case 23:
          break;
        default:
          U.n("Unhandled alignment value " + t.toString());
      }
      return new Point2(i, e);
    }
    Mf(t, i, e, s, n, o) {
      Debug && U.s(t, TreeVertex2, TreeLayout2, "shiftRelPosAlign:v"), Debug && U.W(i, TreeAlignment2, "TreeAlignment");
      const r = this.AA(i, e, s);
      this.Mu(t, r.x, r.y, n, o);
    }
    Mu(t, i, e, s, n) {
      if (Debug && U.s(t, TreeVertex2, TreeLayout2, "shiftRelPos:v"), i === 0 && e === 0) return;
      const o = t.children;
      for (let r = s; r <= n; r++) {
        const h = o[r].X;
        h.x += i, h.y += e;
      }
    }
    xk(t, i, e) {
      Debug && (U.s(t, TreeVertex2, TreeLayout2, "recordMidPoints:v"), U.i(i, "number", TreeLayout2, "recordMidPoints:x"), U.i(e, "number", TreeLayout2, "recordMidPoints:y"));
      const s = t.parent;
      switch (this.ks) {
        case 1: {
          const n = t.sourceEdges;
          for (; n.next(); ) {
            const o = n.value;
            o.fromVertex === s && o.relativePoint.e(i, e);
          }
          break;
        }
        case 2: {
          const n = t.destinationEdges;
          for (; n.next(); ) {
            const o = n.value;
            o.toVertex === s && o.relativePoint.e(i, e);
          }
          break;
        }
        default:
          U.n("Unhandled path value " + this.ks.toString());
      }
    }
    xB(t) {
      if (Debug && U.s(t, TreeVertex2, TreeLayout2, "layoutTreeBlock:v"), t.childrenCount === 0) {
        const z = t.parent;
        let H = false, W = 0, j = 21;
        z !== null && (W = z.angle, j = z.alignment, H = this.isBusAlignment(j));
        const Z = this.MA(t);
        t.X.e(0, 0), t.bt.e(t.width, t.height), t.parent !== null && t.comments !== null && ((W === 180 || W === 270) && !H || Z) ? W === 180 && !H || (W === 90 || W === 270) && Z ? t.dt.e(t.width - t.focus.x * 2, 0) : t.dt.e(0, t.height - t.focus.y * 2) : t.dt.e(0, 0), t.em = null, t.sm = null;
        return;
      }
      const i = this.orthoAngle(t), e = i === 90 || i === 270;
      let s = 0;
      const n = t.children, o = n.length;
      for (let z = 0; z < o; z++) {
        const H = n[z];
        s = Math.max(s, e ? H.bt.width : H.bt.height);
      }
      const r = t.alignment, l = r === 22, h = r === 23, f = this.isBusAlignment(r), a = Math.max(0, t.breadthLimit), c = this.computeLayerSpacing(t), u = t.nodeSpacing, d = this.computeNodeIndent(t), m = t.rowSpacing;
      let g = 0;
      (l || h) && (g = Math.max(0, t.rowIndent));
      const p = t.width, y = t.height;
      let x = 0, S = 0, b = 0, k = null, P = null, A = 0, C = 0, M = 0, N = 0, L = 0, T = 0, D = 0, F = 0, R = 0;
      if (f && !this.Ew(r) && i > 135 && n.reverse(), this.Ew(r)) if (o > 1) for (let z = 0; z < o; z++) z % 2 === 0 && z !== o - 1 ? F = Math.max(F, e ? n[z].bt.width : n[z].bt.height) : z % 2 !== 0 && (R = Math.max(R, e ? n[z].bt.width : n[z].bt.height));
      else o === 1 && (F = e ? n[0].bt.width : n[0].bt.height);
      if (f) {
        switch (r) {
          case 24:
            const z = Rect2.a();
            i < 135 ? this.KI(t, n, F, R, x, S, z) : this.UI(t, n, F, R, x, S, z), F = z.x, x = z.width, S = z.height, Rect2.o(z);
            break;
          case 26:
            for (let H = 0; H < o; H++) {
              const W = n[H], j = W.bt, Z = T === 0 ? 0 : m;
              e ? (W.X.e(s - j.width, N + Z), x = Math.max(x, j.width), S = Math.max(S, N + Z + j.height), N += Z + j.height) : (W.X.e(M + Z, s - j.height), x = Math.max(x, M + Z + j.width), S = Math.max(S, j.height), M += Z + j.width), T++;
            }
            break;
          case 27:
            for (let H = 0; H < o; H++) {
              const W = n[H], j = W.bt, Z = T === 0 ? 0 : m;
              e ? (W.X.e(u / 2 + t.focus.x, N + Z), x = Math.max(x, j.width), S = Math.max(S, N + Z + j.height), N += Z + j.height) : (W.X.e(M + Z, u / 2 + t.focus.y), x = Math.max(x, M + Z + j.width), S = Math.max(S, j.height), M += Z + j.width), T++;
            }
            break;
        }
        k = this.we(2), P = this.we(2), e ? (k[0].e(0, 0), k[1].e(0, S), P[0].e(x, 0), P[1].e(x, S)) : (k[0].e(0, 0), k[1].e(x, 0), P[0].e(0, S), P[1].e(x, S));
      } else for (let z = 0; z < o; z++) {
        const H = n[z], W = H.bt;
        if (e) {
          a > 0 && T > 0 && M + u + W.width > a && (M < s && this.Mf(t, r, s - M, 0, D, z - 1), L++, T = 0, D = z, b = S, M = 0, N = i > 135 ? -S - m : S + m), this.xk(H, 0, N);
          let j = 0;
          if (T === 0) k = H.em, P = H.sm, A = W.width, C = W.height, (k === null || P === null || i !== this.orthoAngle(H)) && (k = this.we(2), P = this.we(2), k[0].e(0, 0), k[1].e(0, C), P[0].e(A, 0), P[1].e(A, C));
          else {
            const Z = U.ft(), V = Rect2.a();
            this.GI(t, H, k, P, A, C, Z, V), j = V.x, k = Z[0], P = Z[1], A = V.width, C = V.height, U.et(Z), M < W.width && j < 0 && (this.Mu(t, -j, 0, D, z - 1), this.Sk(k, -j, 0), this.Sk(P, -j, 0), j = 0), Rect2.o(V);
          }
          H.X.e(j, N), x = Math.max(x, A), S = Math.max(S, b + (L === 0 ? 0 : m) + W.height), M = A;
        } else {
          a > 0 && T > 0 && N + u + W.height > a && (N < s && this.Mf(t, r, 0, s - N, D, z - 1), L++, T = 0, D = z, b = x, N = 0, M = i > 135 ? -x - m : x + m), this.xk(H, M, 0);
          let j = 0;
          if (T === 0) k = H.em, P = H.sm, A = W.width, C = W.height, (k === null || P === null || i !== this.orthoAngle(H)) && (k = this.we(2), P = this.we(2), k[0].e(0, 0), k[1].e(A, 0), P[0].e(0, C), P[1].e(A, C));
          else {
            const Z = U.ft(), V = Rect2.a();
            this.GI(t, H, k, P, A, C, Z, V), j = V.x, k = Z[0], P = Z[1], A = V.width, C = V.height, U.et(Z), N < W.height && j < 0 && (this.Mu(t, 0, -j, D, z - 1), this.Sk(k, 0, -j), this.Sk(P, 0, -j), j = 0), Rect2.o(V);
          }
          H.X.e(M, j), S = Math.max(S, C), x = Math.max(x, b + (L === 0 ? 0 : m) + W.width), N = C;
        }
        T++;
      }
      L > 0 && (e ? (S += Math.max(0, c), M < x && this.Mf(t, r, x - M, 0, D, o - 1), g > 0 && (h || this.Mu(t, g, 0, 0, o - 1), x += g)) : (x += Math.max(0, c), N < S && this.Mf(t, r, 0, S - N, D, o - 1), g > 0 && (h || this.Mu(t, 0, g, 0, o - 1), S += g)));
      let I = 0, O = 0;
      switch (r) {
        case 20:
          e ? I += x / 2 - t.focus.x - d / 2 : O += S / 2 - t.focus.y - d / 2;
          break;
        default:
        case 21:
          if (L > 0) e ? I += x / 2 - t.focus.x - d / 2 : O += S / 2 - t.focus.y - d / 2;
          else {
            const H = o;
            if (e) {
              const W = n[0].X.x + n[0].dt.x, j = n[H - 1].X.x + n[H - 1].dt.x + n[H - 1].focus.x * 2;
              I += W + (j - W) / 2 - t.focus.x - d / 2;
            } else {
              const W = n[0].X.y + n[0].dt.y, j = n[H - 1].X.y + n[H - 1].dt.y + n[H - 1].focus.y * 2;
              O += W + (j - W) / 2 - t.focus.y - d / 2;
            }
          }
          break;
        case 22:
          e ? (I -= d, x += d) : (O -= d, S += d);
          break;
        case 23:
          e ? (I += x - t.width + d, x += d) : (O += S - t.height + d, S += d);
          break;
        case 24:
          e ? o > 1 ? I += F + u / 2 - t.focus.x : I += n[0].focus.x - t.focus.x + n[0].dt.x : o > 1 ? O += F + u / 2 - t.focus.y : O += n[0].focus.y - t.focus.y + n[0].dt.y;
          break;
        case 26:
          e ? I += x + u / 2 - t.focus.x : O += S + u / 2 - t.focus.y;
          break;
        case 27:
          break;
        case 28:
          const z = this.customAlignment(t, I, O, x, S);
          I = z[0], O = z[1], x = z[2], S = z[3];
          break;
      }
      for (let z = 0; z < o; z++) {
        const H = n[z];
        e ? H.X.e(H.X.x + H.dt.x - I, H.X.y + (i > 135 ? (f ? -S : -H.bt.height) + H.dt.y - c : y + c + H.dt.y)) : H.X.e(H.X.x + (i > 135 ? (f ? -x : -H.bt.width) + H.dt.x - c : p + c + H.dt.x), H.X.y + H.dt.y - O);
      }
      let X = 0, K = 0;
      if (f) e ? (x = this.NA(t, x, I), I < 0 && (I = 0), i > 135 && (O += S + c), S += y + c, r === 27 && (X += u / 2 + t.focus.x), K += y + c) : (i > 135 && (I += x + c), x += p + c, S = this.CA(t, S, O), O < 0 && (O = 0), r === 27 && (K += u / 2 + t.focus.y), X += p + c);
      else if (e) {
        if (t.comments === null) {
          if (p > x) {
            const z = this.AA(r, p - x, 0);
            X = z.x, K = z.y, x = p, I = 0;
          }
        } else x = this.NA(t, x, I);
        I < 0 && (X -= I, I = 0), i > 135 && (O += S + c), S = Math.max(Math.max(S, y), S + y + c), K += y + c;
      } else {
        if (i > 135 && (I += x + c), x = Math.max(Math.max(x, p), x + p + c), t.comments === null) {
          if (y > S) {
            const z = this.AA(r, 0, y - S);
            X = z.x, K = z.y, S = y, O = 0;
          }
        } else S = this.CA(t, S, O);
        O < 0 && (K -= O, O = 0), X += p + c;
      }
      let B, Y;
      if (L > 0) B = this.we(4), Y = this.we(4), e ? (B[2].e(0, y + c), B[3].e(B[2].x, S), Y[2].e(x, B[2].y), Y[3].e(Y[2].x, B[3].y)) : (B[2].e(p + c, 0), B[3].e(x, B[2].y), Y[2].e(B[2].x, S), Y[3].e(B[3].x, Y[2].y));
      else {
        B = this.we(k.length + 2), Y = this.we(P.length + 2);
        for (let z = 0; z < k.length; z++) {
          const H = k[z];
          B[z + 2].e(H.x + X, H.y + K);
        }
        for (let z = 0; z < P.length; z++) {
          const H = P[z];
          Y[z + 2].e(H.x + X, H.y + K);
        }
      }
      e ? (B[0].e(I, 0), B[1].e(B[0].x, y), B[2].y < B[1].y && (B[2].x > B[0].x ? B[2].c(B[1]) : B[1].c(B[2])), B[3].y < B[2].y && (B[3].x > B[0].x ? B[3].c(B[2]) : B[2].c(B[3])), Y[0].e(I + p, 0), Y[1].e(Y[0].x, y), Y[2].y < Y[1].y && (Y[2].x < Y[0].x ? Y[2].c(Y[1]) : Y[1].c(Y[2])), Y[3].y < Y[2].y && (Y[3].x < Y[0].x ? Y[3].c(Y[2]) : Y[2].c(Y[3])), B[2].y -= c / 2, Y[2].y -= c / 2) : (B[0].e(0, O), B[1].e(p, B[0].y), B[2].x < B[1].x && (B[2].y > B[0].y ? B[2].c(B[1]) : B[1].c(B[2])), B[3].x < B[2].x && (B[3].y > B[0].y ? B[3].c(B[2]) : B[2].c(B[3])), Y[0].e(0, O + y), Y[1].e(p, Y[0].y), Y[2].x < Y[1].x && (Y[2].y < Y[0].y ? Y[2].c(Y[1]) : Y[1].c(Y[2])), Y[3].x < Y[2].x && (Y[3].y < Y[0].y ? Y[3].c(Y[2]) : Y[2].c(Y[3])), B[2].x -= c / 2, Y[2].x -= c / 2), this.pn(k), this.pn(P), t.em = B, t.sm = Y, t.dt.e(I, O), t.bt.e(x, S);
    }
    Sk(t, i, e) {
      for (let s = 0; s < t.length; s++) {
        const n = t[s];
        n.x += i, n.y += e;
      }
    }
    GI(t, i, e, s, n, o, r, l) {
      Debug && U.s(t, TreeVertex2, TreeLayout2, "mergeFringes:parent"), Debug && U.s(i, TreeVertex2, TreeLayout2, "mergeFringes:child");
      const h = this.orthoAngle(t), f = h === 90 || h === 270, a = t.nodeSpacing, c = e, u = s, d = n, m = o;
      let g = i.em, p = i.sm;
      const y = i.bt, x = f ? Math.max(m, y.height) : Math.max(d, y.width);
      if ((g === null || h !== this.orthoAngle(i)) && (g = this.we(2), p = this.we(2), f ? (g[0].e(0, 0), g[1].e(0, y.height), p[0].e(y.width, 0), p[1].e(p[0].x, g[1].y)) : (g[0].e(0, 0), g[1].e(y.width, 0), p[0].e(0, y.height), p[1].e(g[1].x, p[0].y))), f) {
        const S = d;
        let b = S - this.bB(u, g, S);
        return b += a, e = this.SB(c, g, b), s = this.kB(u, p, b), n = Math.max(0, b) + y.width, o = x, this.pn(c), this.pn(g), this.pn(u), this.pn(p), r[0] = e, r[1] = s, l.e(b, 0, n, o), l;
      } else {
        const S = m;
        let b = S - this.PB(u, g, S);
        return b += a, e = this.MB(c, g, b), s = this.NB(u, p, b), n = x, o = Math.max(0, b) + y.height, this.pn(c), this.pn(g), this.pn(u), this.pn(p), r[0] = e, r[1] = s, l.e(b, 0, n, o), l;
      }
    }
    MB(t, i, e) {
      if (t === null || t.length < 2 || i === null || i.length < 2) return null;
      const s = this.we(t.length + i.length);
      let n = 0, o = 0, r = 0;
      for (; o < i.length && i[o].x < t[0].x; ) {
        const f = i[o++];
        s[r++].e(f.x, f.y + e);
      }
      for (; n < t.length; ) {
        const f = t[n++];
        s[r++].e(f.x, f.y);
      }
      const l = t[t.length - 1].x;
      for (; o < i.length && i[o].x <= l; ) o++;
      for (; o < i.length && i[o].x > l; ) {
        const f = i[o++];
        s[r++].e(f.x, f.y + e);
      }
      const h = this.we(r);
      for (n = 0; n < r; n++) h[n].c(s[n]);
      return this.pn(s), h;
    }
    SB(t, i, e) {
      if (t === null || t.length < 2 || i === null || i.length < 2) return null;
      const s = this.we(t.length + i.length);
      let n = 0, o = 0, r = 0;
      for (; o < i.length && i[o].y < t[0].y; ) {
        const f = i[o++];
        s[r++].e(f.x + e, f.y);
      }
      for (; n < t.length; ) {
        const f = t[n++];
        s[r++].e(f.x, f.y);
      }
      const l = t[t.length - 1].y;
      for (; o < i.length && i[o].y <= l; ) o++;
      for (; o < i.length && i[o].y > l; ) {
        const f = i[o++];
        s[r++].e(f.x + e, f.y);
      }
      const h = this.we(r);
      for (n = 0; n < r; n++) h[n].c(s[n]);
      return this.pn(s), h;
    }
    NB(t, i, e) {
      if (t === null || t.length < 2 || i === null || i.length < 2) return null;
      const s = this.we(t.length + i.length);
      let n = 0, o = 0, r = 0;
      for (; n < t.length && t[n].x < i[0].x; ) {
        const f = t[n++];
        s[r++].e(f.x, f.y);
      }
      for (; o < i.length; ) {
        const f = i[o++];
        s[r++].e(f.x, f.y + e);
      }
      const l = i[i.length - 1].x;
      for (; n < t.length && t[n].x <= l; ) n++;
      for (; n < t.length && t[n].x > l; ) {
        const f = t[n++];
        s[r++].e(f.x, f.y);
      }
      const h = this.we(r);
      for (n = 0; n < r; n++) h[n].c(s[n]);
      return this.pn(s), h;
    }
    kB(t, i, e) {
      if (t === null || t.length < 2 || i === null || i.length < 2) return null;
      const s = this.we(t.length + i.length);
      let n = 0, o = 0, r = 0;
      for (; n < t.length && t[n].y < i[0].y; ) {
        const f = t[n++];
        s[r++].e(f.x, f.y);
      }
      for (; o < i.length; ) {
        const f = i[o++];
        s[r++].e(f.x + e, f.y);
      }
      const l = i[i.length - 1].y;
      for (; n < t.length && t[n].y <= l; ) n++;
      for (; n < t.length && t[n].y > l; ) {
        const f = t[n++];
        s[r++].e(f.x, f.y);
      }
      const h = this.we(r);
      for (n = 0; n < r; n++) h[n].c(s[n]);
      return this.pn(s), h;
    }
    PB(t, i, e) {
      let s = 9999999;
      if (t === null || t.length < 2 || i === null || i.length < 2) return s;
      let n = 0, o = 0;
      for (; n < t.length && o < i.length; ) {
        const r = t[n], l = i[o], h = l.x;
        let f = l.y;
        f += e;
        let a = r;
        n + 1 < t.length && (a = t[n + 1]);
        let c = l, u = c.x, d = c.y;
        o + 1 < i.length && (c = i[o + 1], u = c.x, d = c.y, d += e);
        let m = s;
        r.x === h ? m = f - r.y : r.x > h && r.x < u ? m = f + (r.x - h) / (u - h) * (d - f) - r.y : h > r.x && h < a.x && (m = f - (r.y + (h - r.x) / (a.x - r.x) * (a.y - r.y))), m < s && (s = m), a.x <= r.x ? n++ : u <= h ? o++ : (a.x <= u && n++, u <= a.x && o++);
      }
      return s;
    }
    bB(t, i, e) {
      let s = 9999999;
      if (t === null || t.length < 2 || i === null || i.length < 2) return s;
      let n = 0, o = 0;
      for (; n < t.length && o < i.length; ) {
        const r = t[n], l = i[o];
        let h = l.x;
        const f = l.y;
        h += e;
        let a = r;
        n + 1 < t.length && (a = t[n + 1]);
        let c = l, u = c.x, d = c.y;
        o + 1 < i.length && (c = i[o + 1], u = c.x, d = c.y, u += e);
        let m = s;
        r.y === f ? m = h - r.x : r.y > f && r.y < d ? m = h + (r.y - f) / (d - f) * (u - h) - r.x : f > r.y && f < a.y && (m = h - (r.x + (f - r.y) / (a.y - r.y) * (a.x - r.x))), m < s && (s = m), a.y <= r.y ? n++ : d <= f ? o++ : (a.y <= d && n++, d <= a.y && o++);
      }
      return s;
    }
    we(t) {
      const i = this.wk[t];
      if (i !== void 0) {
        const s = i.pop();
        if (s !== void 0) return s;
      }
      const e = [];
      for (let s = 0; s < t; s++) e[s] = new Point2();
      return e;
    }
    pn(t) {
      if (!t) return;
      const i = t.length;
      let e = this.wk[i];
      e === void 0 && (e = [], this.wk[i] = e), e.push(t);
    }
    arrangeTrees() {
      if (this.Ji === 52) {
        const t = this.Xi.iterator;
        for (; t.next(); ) {
          const i = t.value;
          if (!(i instanceof TreeVertex2)) continue;
          const e = i.node;
          if (e === null) continue;
          const s = e.position;
          let n = s.x, o = s.y;
          isFinite(n) || (n = 0), isFinite(o) || (o = 0), this.TA(i, n, o);
        }
      } else {
        const t = [], i = this.Xi.iterator;
        for (; i.next(); ) {
          const o = i.value;
          o instanceof TreeVertex2 && t.push(o);
        }
        switch (this.sorting) {
          default:
          case 10:
            break;
          case 11:
            t.reverse();
            break;
          case 12:
            t.sort(this.comparer);
            break;
          case 13:
            t.sort(this.comparer), t.reverse();
            break;
        }
        const e = this.arrangementOrigin;
        let s = e.x, n = e.y;
        for (let o = 0; o < t.length; o++) {
          const r = t[o];
          switch (this.TA(r, s + r.dt.x, n + r.dt.y), this.Ji) {
            case 50:
              n += r.bt.height + this.Ks.height;
              break;
            default:
            case 51:
              s += r.bt.width + this.Ks.width;
              break;
          }
        }
      }
    }
    TA(t, i, e) {
      if (t === null) return;
      Debug && U.s(t, TreeVertex2, TreeLayout2, "assignAbsolutePositions:v"), t.x = i, t.y = e;
      const s = t.children, n = s.length;
      for (let o = 0; o < n; o++) {
        const r = s[o];
        this.TA(r, i + r.X.x, e + r.X.y);
      }
    }
    commitLayout() {
      this.Cw(), this.commitNodes(), this.SA(), this.isRouting && this.commitLinks();
    }
    commitNodes() {
      if (this.network === null) return;
      const t = this.network.vertexes.iterator;
      for (; t.next(); ) t.value.commit();
      for (t.reset(); t.next(); ) {
        const i = t.value;
        this.layoutComments(i);
      }
    }
    SA() {
      if (this.network === null || this.layerStyle !== 62) return;
      const t = this.kA, i = [];
      let e;
      const s = this.network.vertexes.iterator;
      for (; s.next(); ) {
        const h = s.value;
        e === void 0 ? e = h.bounds.copy() : e.unionRect(h.bounds);
        let f = i[h.level];
        f === void 0 ? f = this.computeLayerSpacing(h) : f = Math.max(f, this.computeLayerSpacing(h)), i[h.level] = f;
      }
      if (!e) return;
      for (let h = 0; h < i.length; h++) i[h] === void 0 && (i[h] = 0);
      let n;
      this.angle === 90 || this.angle === 270 ? (e.inflate(this.nodeSpacing / 2, this.layerSpacing), n = new Point2(-this.nodeSpacing / 2, -this.layerSpacing / 2)) : (e.inflate(this.layerSpacing, this.nodeSpacing / 2), n = new Point2(-this.layerSpacing / 2, -this.nodeSpacing / 2));
      const o = [], r = this.angle === 90 || this.angle === 270 ? e.width : e.height;
      let l = 0;
      if (this.angle === 180 || this.angle === 270) for (let h = 0; h < t.length; h++) l += t[h] + i[h];
      for (let h = 0; h < t.length; h++) {
        const f = t[h] + i[h];
        this.angle === 270 ? (l -= f, o.push(new Rect2(0, l, r, f))) : this.angle === 90 ? (o.push(new Rect2(0, l, r, f)), l += f) : this.angle === 180 ? (l -= f, o.push(new Rect2(l, 0, f, r))) : (o.push(new Rect2(l, 0, f, r)), l += f);
      }
      this.commitLayers(o, n);
    }
    commitLayers(t, i) {
    }
    commitLinks() {
      if (this.network === null) return;
      const t = this.network.edges.iterator;
      for (; t.next(); ) t.value.commit();
    }
    Cw() {
      const t = this.Xi.iterator;
      for (; t.next(); ) {
        const i = t.value;
        i instanceof TreeVertex2 && this.qI(i);
      }
    }
    qI(t) {
      if (t === null) return;
      Debug && U.s(t, TreeVertex2, TreeLayout2, "setPortSpotsTree:v"), this.setPortSpots(t);
      const i = t.children, e = i.length;
      for (let s = 0; s < e; s++) {
        const n = i[s];
        this.qI(n);
      }
    }
    setPortSpots(t) {
      Debug && U.s(t, TreeVertex2, TreeLayout2, "setPortSpots:v");
      const i = t.alignment;
      if (this.isBusAlignment(i)) this.CB(t, i);
      else {
        const e = this.orthoAngle(t);
        if (this.ks === 1) {
          const s = t.destinationEdges;
          for (; s.next(); ) {
            const o = s.value.link;
            if (o !== null) {
              if (t.setsPortSpot) if (t.portSpot.isDefault()) switch (e) {
                case 0:
                  o.fromSpot = Spot2.MiddleRight;
                  break;
                case 90:
                  o.fromSpot = Spot2.MiddleBottom;
                  break;
                case 180:
                  o.fromSpot = Spot2.MiddleLeft;
                  break;
                default:
                  o.fromSpot = Spot2.MiddleTop;
                  break;
              }
              else o.fromSpot = t.portSpot;
              if (t.setsChildPortSpot) if (t.childPortSpot.isDefault()) switch (e) {
                case 0:
                  o.toSpot = Spot2.MiddleLeft;
                  break;
                case 90:
                  o.toSpot = Spot2.MiddleTop;
                  break;
                case 180:
                  o.toSpot = Spot2.MiddleRight;
                  break;
                default:
                  o.toSpot = Spot2.MiddleBottom;
                  break;
              }
              else o.toSpot = t.childPortSpot;
            }
          }
        } else {
          const s = t.sourceEdges;
          for (; s.next(); ) {
            const o = s.value.link;
            if (o !== null) {
              if (t.setsPortSpot) if (t.portSpot.isDefault()) switch (e) {
                case 0:
                  o.toSpot = Spot2.MiddleRight;
                  break;
                case 90:
                  o.toSpot = Spot2.MiddleBottom;
                  break;
                case 180:
                  o.toSpot = Spot2.MiddleLeft;
                  break;
                default:
                  o.toSpot = Spot2.MiddleTop;
                  break;
              }
              else o.toSpot = t.portSpot;
              if (t.setsChildPortSpot) if (t.childPortSpot.isDefault()) switch (e) {
                case 0:
                  o.fromSpot = Spot2.MiddleLeft;
                  break;
                case 90:
                  o.fromSpot = Spot2.MiddleTop;
                  break;
                case 180:
                  o.fromSpot = Spot2.MiddleRight;
                  break;
                default:
                  o.fromSpot = Spot2.MiddleBottom;
                  break;
              }
              else o.fromSpot = t.childPortSpot;
            }
          }
        }
      }
    }
    CB(t, i) {
      Debug && U.s(t, TreeVertex2, TreeLayout2, "setPortSpotsBus:v"), Debug && U.W(i, TreeAlignment2, "TreeAlignment");
      const e = this.ks === 1, s = this.orthoAngle(t);
      let n;
      switch (s) {
        case 0:
          n = Spot2.MiddleRight;
          break;
        case 90:
          n = Spot2.MiddleBottom;
          break;
        case 180:
          n = Spot2.MiddleLeft;
          break;
        default:
          n = Spot2.MiddleTop;
          break;
      }
      const o = t.children, r = o.length;
      switch (i) {
        case 24:
        case 25: {
          for (let l = 0; l < r; l++) {
            const h = o[l], f = (e ? h.sourceEdges : h.destinationEdges).first();
            if (f === null) continue;
            const a = f.link;
            if (a !== null) {
              let c = s === 90 || s === 270 ? Spot2.MiddleLeft : Spot2.MiddleTop;
              if (r === 1 || l === r - 1 && r % 2 === 1) switch (s) {
                case 0:
                  c = Spot2.MiddleLeft;
                  break;
                case 90:
                  c = Spot2.MiddleTop;
                  break;
                case 180:
                  c = Spot2.MiddleRight;
                  break;
                default:
                  c = Spot2.MiddleBottom;
                  break;
              }
              else l % 2 === 0 && (c = s === 90 || s === 270 ? Spot2.MiddleRight : Spot2.MiddleBottom);
              e ? (t.setsPortSpot && (a.fromSpot = n), t.setsChildPortSpot && (a.toSpot = c)) : (t.setsPortSpot && (a.fromSpot = c), t.setsChildPortSpot && (a.toSpot = n));
            }
          }
          break;
        }
        case 26: {
          const l = s === 90 || s === 270 ? Spot2.MiddleRight : Spot2.MiddleBottom, h = e ? t.destinationEdges : t.sourceEdges;
          for (; h.next(); ) {
            const a = h.value.link;
            a !== null && (e ? (t.setsPortSpot && (a.fromSpot = n), t.setsChildPortSpot && (a.toSpot = l)) : (t.setsPortSpot && (a.fromSpot = l), t.setsChildPortSpot && (a.toSpot = n)));
          }
          break;
        }
        case 27: {
          const l = s === 90 || s === 270 ? Spot2.MiddleLeft : Spot2.MiddleTop, h = e ? t.destinationEdges : t.sourceEdges;
          for (; h.next(); ) {
            const a = h.value.link;
            a !== null && (e ? (t.setsPortSpot && (a.fromSpot = n), t.setsChildPortSpot && (a.toSpot = l)) : (t.setsPortSpot && (a.fromSpot = l), t.setsChildPortSpot && (a.toSpot = n)));
          }
          break;
        }
      }
    }
    orthoAngle(t) {
      const i = t.angle;
      return i <= 45 ? 0 : i <= 135 ? 90 : i <= 225 ? 180 : i <= 315 ? 270 : 0;
    }
    computeLayerSpacing(t) {
      Debug && U.s(t, TreeVertex2, TreeLayout2, "computeLayerSpacing:v");
      const i = this.orthoAngle(t), e = i === 90 || i === 270;
      let s = t.layerSpacing;
      if (t.layerSpacingParentOverlap > 0) {
        const n = Math.min(1, t.layerSpacingParentOverlap);
        s -= e ? t.height * n : t.width * n;
      }
      return s < (e ? -t.height : -t.width) && (s = e ? -t.height : -t.width), s;
    }
    computeNodeIndent(t) {
      Debug && U.s(t, TreeVertex2, TreeLayout2, "computeNodeIndent:v");
      const i = this.orthoAngle(t), e = i === 90 || i === 270;
      let s = t.nodeIndent;
      if (t.nodeIndentPastParent > 0) {
        const n = Math.min(1, t.nodeIndentPastParent);
        s += e ? t.width * n : t.height * n;
      }
      return s = Math.max(0, s), s;
    }
    get roots() {
      return this.Xi;
    }
    set roots(t) {
      this.Xi !== t && (U.s(t, GSet2, TreeLayout2, "roots"), this.Xi = t, this.b());
    }
    get path() {
      return this.Bi;
    }
    set path(t) {
      this.Bi !== t && (U.W(t, TreePath2, "TreePath"), this.Bi = t, this.b());
    }
    get treeStyle() {
      return this.Pu;
    }
    set treeStyle(t) {
      this.Pu !== t && (U.W(t, TreeStyle2, "TreeStyle"), (t === 40 || t === 42 || t === 41 || t === 43) && (this.Pu = t, this.b()));
    }
    get layerStyle() {
      return this.im;
    }
    set layerStyle(t) {
      this.im !== t && (U.W(t, TreeLayerStyle2, "TreeLayerStyle"), (t === 60 || t === 61 || t === 62) && (this.im = t, this.b()));
    }
    get comments() {
      return this.He;
    }
    set comments(t) {
      this.He !== t && (U.i(t, "boolean", TreeLayout2, "comments"), this.He = t, this.b());
    }
    get arrangement() {
      return this.Ji;
    }
    set arrangement(t) {
      this.Ji !== t && (U.W(t, TreeArrangement2, "TreeArrangement"), (t === 50 || t === 51 || t === 52) && (this.Ji = t, this.b()));
    }
    get arrangementSpacing() {
      return this.Ks;
    }
    set arrangementSpacing(t) {
      U.s(t, Size2, TreeLayout2, "arrangementSpacing"), this.Ks.equals(t) || (this.Ks.c(t), this.b());
    }
    get rootDefaults() {
      return this.Y;
    }
    set rootDefaults(t) {
      this.Y !== t && (U.s(t, TreeVertex2, TreeLayout2, "rootDefaults"), this.Y = t, this.b());
    }
    get alternateDefaults() {
      return this.K;
    }
    set alternateDefaults(t) {
      this.K !== t && (U.s(t, TreeVertex2, TreeLayout2, "alternateDefaults"), this.K = t, this.b());
    }
    get sorting() {
      return this.Y.sorting;
    }
    set sorting(t) {
      this.Y.sorting !== t && (U.W(t, TreeSorting2, "TreeSorting"), this.Y.sorting = t, this.b());
    }
    get comparer() {
      return this.Y.comparer;
    }
    set comparer(t) {
      this.Y.comparer !== t && (U.C(t, TreeLayout2, "comparer"), this.Y.comparer = t, this.b());
    }
    get angle() {
      return this.Y.angle;
    }
    set angle(t) {
      this.Y.angle !== t && (U.i(t, "number", TreeLayout2, "angle"), t === 0 || t === 90 || t === 180 || t === 270 ? (this.Y.angle = t, this.b()) : U.n("TreeLayout.angle must be 0, 90, 180, or 270"));
    }
    get alignment() {
      return this.Y.alignment;
    }
    set alignment(t) {
      this.Y.alignment !== t && (U.W(t, TreeAlignment2, "TreeAlignment"), this.Y.alignment = t, this.b());
    }
    get nodeIndent() {
      return this.Y.nodeIndent;
    }
    set nodeIndent(t) {
      this.Y.nodeIndent !== t && (U.i(t, "number", TreeLayout2, "nodeIndent"), t >= 0 && (this.Y.nodeIndent = t, this.b()));
    }
    get nodeIndentPastParent() {
      return this.Y.nodeIndentPastParent;
    }
    set nodeIndentPastParent(t) {
      this.Y.nodeIndentPastParent !== t && (U.i(t, "number", TreeLayout2, "nodeIndentPastParent"), t >= 0 && t <= 1 && (this.Y.nodeIndentPastParent = t, this.b()));
    }
    get nodeSpacing() {
      return this.Y.nodeSpacing;
    }
    set nodeSpacing(t) {
      this.Y.nodeSpacing !== t && (U.i(t, "number", TreeLayout2, "nodeSpacing"), this.Y.nodeSpacing = t, this.b());
    }
    get layerSpacing() {
      return this.Y.layerSpacing;
    }
    set layerSpacing(t) {
      this.Y.layerSpacing !== t && (U.i(t, "number", TreeLayout2, "layerSpacing"), this.Y.layerSpacing = t, this.b());
    }
    get layerSpacingParentOverlap() {
      return this.Y.layerSpacingParentOverlap;
    }
    set layerSpacingParentOverlap(t) {
      this.Y.layerSpacingParentOverlap !== t && (U.i(t, "number", TreeLayout2, "layerSpacingParentOverlap"), t >= 0 && t <= 1 && (this.Y.layerSpacingParentOverlap = t, this.b()));
    }
    get compaction() {
      return this.Y.compaction;
    }
    set compaction(t) {
      this.Y.compaction !== t && (U.W(t, TreeCompaction2, "TreeCompaction"), (t === 30 || t === 31) && (this.Y.compaction = t, this.b()));
    }
    get breadthLimit() {
      return this.Y.breadthLimit;
    }
    set breadthLimit(t) {
      this.Y.breadthLimit !== t && (U.i(t, "number", TreeLayout2, "breadthLimit"), t >= 0 && (this.Y.breadthLimit = t, this.b()));
    }
    get rowSpacing() {
      return this.Y.rowSpacing;
    }
    set rowSpacing(t) {
      this.Y.rowSpacing !== t && (U.i(t, "number", TreeLayout2, "rowSpacing"), this.Y.rowSpacing = t, this.b());
    }
    get rowIndent() {
      return this.Y.rowIndent;
    }
    set rowIndent(t) {
      this.Y.rowIndent !== t && (U.i(t, "number", TreeLayout2, "rowIndent"), t >= 0 && (this.Y.rowIndent = t, this.b()));
    }
    get commentSpacing() {
      return this.Y.commentSpacing;
    }
    set commentSpacing(t) {
      this.Y.commentSpacing !== t && (U.i(t, "number", TreeLayout2, "commentSpacing"), this.Y.commentSpacing = t, this.b());
    }
    get commentMargin() {
      return this.Y.commentMargin;
    }
    set commentMargin(t) {
      this.Y.commentMargin !== t && (U.i(t, "number", TreeLayout2, "commentMargin"), this.Y.commentMargin = t, this.b());
    }
    get setsPortSpot() {
      return this.Y.setsPortSpot;
    }
    set setsPortSpot(t) {
      this.Y.setsPortSpot !== t && (U.i(t, "boolean", TreeLayout2, "setsPortSpot"), this.Y.setsPortSpot = t, this.b());
    }
    get portSpot() {
      return this.Y.portSpot;
    }
    set portSpot(t) {
      U.s(t, Spot2, TreeLayout2, "portSpot"), this.Y.portSpot.equals(t) || (this.Y.portSpot = t, this.b());
    }
    get setsChildPortSpot() {
      return this.Y.setsChildPortSpot;
    }
    set setsChildPortSpot(t) {
      this.Y.setsChildPortSpot !== t && (U.i(t, "boolean", TreeLayout2, "setsChildPortSpot"), this.Y.setsChildPortSpot = t, this.b());
    }
    get childPortSpot() {
      return this.Y.childPortSpot;
    }
    set childPortSpot(t) {
      U.s(t, Spot2, TreeLayout2, "childPortSpot"), this.Y.childPortSpot.equals(t) || (this.Y.childPortSpot = t, this.b());
    }
    get alternateSorting() {
      return this.K.sorting;
    }
    set alternateSorting(t) {
      this.K.sorting !== t && (U.W(t, TreeSorting2, "TreeSorting"), this.K.sorting = t, this.b());
    }
    get alternateComparer() {
      return this.K.comparer;
    }
    set alternateComparer(t) {
      this.K.comparer !== t && (U.C(t, TreeLayout2, "alternateComparer"), this.K.comparer = t, this.b());
    }
    get alternateAngle() {
      return this.K.angle;
    }
    set alternateAngle(t) {
      this.K.angle !== t && (U.i(t, "number", TreeLayout2, "alternateAngle"), (t === 0 || t === 90 || t === 180 || t === 270) && (this.K.angle = t, this.b()));
    }
    get alternateAlignment() {
      return this.K.alignment;
    }
    set alternateAlignment(t) {
      this.K.alignment !== t && (U.W(t, TreeAlignment2, "TreeAlignment"), this.K.alignment = t, this.b());
    }
    get alternateNodeIndent() {
      return this.K.nodeIndent;
    }
    set alternateNodeIndent(t) {
      this.K.nodeIndent !== t && (U.i(t, "number", TreeLayout2, "alternateNodeIndent"), t >= 0 && (this.K.nodeIndent = t, this.b()));
    }
    get alternateNodeIndentPastParent() {
      return this.K.nodeIndentPastParent;
    }
    set alternateNodeIndentPastParent(t) {
      this.K.nodeIndentPastParent !== t && (U.i(t, "number", TreeLayout2, "alternateNodeIndentPastParent"), t >= 0 && t <= 1 && (this.K.nodeIndentPastParent = t, this.b()));
    }
    get alternateNodeSpacing() {
      return this.K.nodeSpacing;
    }
    set alternateNodeSpacing(t) {
      this.K.nodeSpacing !== t && (U.i(t, "number", TreeLayout2, "alternateNodeSpacing"), this.K.nodeSpacing = t, this.b());
    }
    get alternateLayerSpacing() {
      return this.K.layerSpacing;
    }
    set alternateLayerSpacing(t) {
      this.K.layerSpacing !== t && (U.i(t, "number", TreeLayout2, "alternateLayerSpacing"), this.K.layerSpacing = t, this.b());
    }
    get alternateLayerSpacingParentOverlap() {
      return this.K.layerSpacingParentOverlap;
    }
    set alternateLayerSpacingParentOverlap(t) {
      this.K.layerSpacingParentOverlap !== t && (U.i(t, "number", TreeLayout2, "alternateLayerSpacingParentOverlap"), t >= 0 && t <= 1 && (this.K.layerSpacingParentOverlap = t, this.b()));
    }
    get alternateCompaction() {
      return this.K.compaction;
    }
    set alternateCompaction(t) {
      this.K.compaction !== t && (U.W(t, TreeCompaction2, "TreeCompaction"), (t === 30 || t === 31) && (this.K.compaction = t, this.b()));
    }
    get alternateBreadthLimit() {
      return this.K.breadthLimit;
    }
    set alternateBreadthLimit(t) {
      this.K.breadthLimit !== t && (U.i(t, "number", TreeLayout2, "alternateBreadthLimit"), t >= 0 && (this.K.breadthLimit = t, this.b()));
    }
    get alternateRowSpacing() {
      return this.K.rowSpacing;
    }
    set alternateRowSpacing(t) {
      this.K.rowSpacing !== t && (U.i(t, "number", TreeLayout2, "alternateRowSpacing"), this.K.rowSpacing = t, this.b());
    }
    get alternateRowIndent() {
      return this.K.rowIndent;
    }
    set alternateRowIndent(t) {
      this.K.rowIndent !== t && (U.i(t, "number", TreeLayout2, "alternateRowIndent"), t >= 0 && (this.K.rowIndent = t, this.b()));
    }
    get alternateCommentSpacing() {
      return this.K.commentSpacing;
    }
    set alternateCommentSpacing(t) {
      this.K.commentSpacing !== t && (U.i(t, "number", TreeLayout2, "alternateCommentSpacing"), this.K.commentSpacing = t, this.b());
    }
    get alternateCommentMargin() {
      return this.K.commentMargin;
    }
    set alternateCommentMargin(t) {
      this.K.commentMargin !== t && (U.i(t, "number", TreeLayout2, "alternateCommentMargin"), this.K.commentMargin = t, this.b());
    }
    get alternateSetsPortSpot() {
      return this.K.setsPortSpot;
    }
    set alternateSetsPortSpot(t) {
      this.K.setsPortSpot !== t && (U.i(t, "boolean", TreeLayout2, "alternateSetsPortSpot"), this.K.setsPortSpot = t, this.b());
    }
    get alternatePortSpot() {
      return this.K.portSpot;
    }
    set alternatePortSpot(t) {
      U.s(t, Spot2, TreeLayout2, "alternatePortSpot"), this.K.portSpot.equals(t) || (this.K.portSpot = t, this.b());
    }
    get alternateSetsChildPortSpot() {
      return this.K.setsChildPortSpot;
    }
    set alternateSetsChildPortSpot(t) {
      this.K.setsChildPortSpot !== t && (U.i(t, "boolean", TreeLayout2, "alternateSetsChildPortSpot"), this.K.setsChildPortSpot = t, this.b());
    }
    get alternateChildPortSpot() {
      return this.K.childPortSpot;
    }
    set alternateChildPortSpot(t) {
      U.s(t, Spot2, TreeLayout2, "alternateChildPortSpot"), this.K.childPortSpot.equals(t) || (this.K.childPortSpot = t, this.b());
    }
    static PathDefault = 0;
    static PathDestination = 1;
    static PathSource = 2;
    static SortingForwards = 10;
    static SortingReverse = 11;
    static SortingAscending = 12;
    static SortingDescending = 13;
    static AlignmentCenterSubtrees = 20;
    static AlignmentCenterChildren = 21;
    static AlignmentStart = 22;
    static AlignmentEnd = 23;
    static AlignmentBus = 24;
    static AlignmentBusBranching = 25;
    static AlignmentTopLeftBus = 26;
    static AlignmentBottomRightBus = 27;
    static CompactionNone = 30;
    static CompactionBlock = 31;
    static StyleLayered = 40;
    static StyleLastParents = 41;
    static StyleAlternating = 42;
    static StyleRootOnly = 43;
    static ArrangementVertical = 50;
    static ArrangementHorizontal = 51;
    static ArrangementFixedRoots = 52;
    static LayerIndividual = 60;
    static LayerSiblings = 61;
    static LayerUniform = 62;
  }
  class TreeNetwork2 extends LayoutNetwork2 {
    constructor(t) {
      super(t);
    }
    createVertex() {
      return new TreeVertex2(this);
    }
    createEdge() {
      return new TreeEdge2(this);
    }
  }
  class TreeVertex2 extends LayoutVertex2 {
    X;
    bt;
    dt;
    kk;
    Pk;
    Mk;
    Nk;
    Ck;
    Ak;
    Tk;
    He;
    em;
    sm;
    Ce;
    Ae;
    vt;
    pi;
    Bw;
    Vw;
    zw;
    Us;
    Xw;
    Yw;
    Kw;
    Uw;
    Gw;
    qw;
    Hw;
    vw;
    Ww;
    jw;
    Jw;
    constructor(t) {
      super(t), this.kk = false, this.Pk = null, this.Mk = [], this.Nk = 0, this.Ck = 0, this.Ak = 0, this.Tk = 0, this.He = null, this.X = new Point2(0, 0), this.bt = new Size2(0, 0), this.dt = new Point2(0, 0), this.em = null, this.sm = null, this.Ce = 10, this.Ae = LayoutVertex2.standardComparer, this.vt = 0, this.pi = 21, this.Bw = 0, this.Vw = 0, this.zw = 20, this.Us = 50, this.Xw = 0, this.Yw = 31, this.Kw = 0, this.Uw = 25, this.Gw = 10, this.qw = 10, this.Hw = 20, this.vw = true, this.Ww = Spot2.Default, this.jw = true, this.Jw = Spot2.Default;
    }
    copyInheritedPropertiesFrom(t) {
      t !== null && (this.Ce = t.sorting, this.Ae = t.comparer, this.vt = t.angle, this.pi = t.alignment, this.Bw = t.nodeIndent, this.Vw = t.nodeIndentPastParent, this.zw = t.nodeSpacing, this.Us = t.layerSpacing, this.Xw = t.layerSpacingParentOverlap, this.Yw = t.compaction, this.Kw = t.breadthLimit, this.Uw = t.rowSpacing, this.Gw = t.rowIndent, this.qw = t.commentSpacing, this.Hw = t.commentMargin, this.vw = t.setsPortSpot, this.Ww = t.portSpot, this.jw = t.setsChildPortSpot, this.Jw = t.childPortSpot);
    }
    get initialized() {
      return this.kk;
    }
    set initialized(t) {
      this.kk !== t && (U.i(t, "boolean", TreeVertex2, "initialized"), this.kk = t);
    }
    get parent() {
      return this.Pk;
    }
    set parent(t) {
      this.Pk !== t && (Debug && t !== null && U.s(t, TreeVertex2, TreeVertex2, "parent"), this.Pk = t);
    }
    get children() {
      return this.Mk;
    }
    set children(t) {
      if (this.Mk !== t) {
        if (t !== null && !Array.isArray(t) && U.Ti(t, "Array", TreeVertex2, "children:value"), t !== null) {
          const i = t.length;
          for (let e = 0; e < i; e++) {
            const s = t[e];
            Debug && U.s(s, TreeVertex2, TreeVertex2, "children");
          }
        }
        this.Mk = t;
      }
    }
    get level() {
      return this.Nk;
    }
    set level(t) {
      this.Nk !== t && (U.i(t, "number", TreeVertex2, "level"), this.Nk = t);
    }
    get descendantCount() {
      return this.Ck;
    }
    set descendantCount(t) {
      this.Ck !== t && (U.i(t, "number", TreeVertex2, "descendantCount"), this.Ck = t);
    }
    get maxChildrenCount() {
      return this.Ak;
    }
    set maxChildrenCount(t) {
      this.Ak !== t && (U.i(t, "number", TreeVertex2, "maxChildrenCount"), this.Ak = t);
    }
    get maxGenerationCount() {
      return this.Tk;
    }
    set maxGenerationCount(t) {
      this.Tk !== t && (U.i(t, "number", TreeVertex2, "maxGenerationCount"), this.Tk = t);
    }
    get comments() {
      return this.He;
    }
    set comments(t) {
      if (this.He !== t) {
        if (t !== null && !Array.isArray(t) && U.Ti(t, "Array", TreeVertex2, "comments:value"), t !== null) {
          const i = t.length;
          for (let e = 0; e < i; e++) {
            const s = t[e];
            Debug && U.s(s, Node2, TreeVertex2, "comments");
          }
        }
        this.He = t;
      }
    }
    get sorting() {
      return this.Ce;
    }
    set sorting(t) {
      this.Ce !== t && (U.W(t, TreeSorting2, "TreeSorting"), this.Ce = t);
    }
    get comparer() {
      return this.Ae;
    }
    set comparer(t) {
      this.Ae !== t && (U.C(t, TreeVertex2, "comparer"), this.Ae = t);
    }
    get angle() {
      return this.vt;
    }
    set angle(t) {
      this.vt !== t && (U.i(t, "number", TreeVertex2, "angle"), this.vt = t);
    }
    get alignment() {
      return this.pi;
    }
    set alignment(t) {
      this.pi !== t && (U.W(t, TreeAlignment2, "TreeAlignment"), this.pi = t);
    }
    get nodeIndent() {
      return this.Bw;
    }
    set nodeIndent(t) {
      this.Bw !== t && (U.i(t, "number", TreeVertex2, "nodeIndent"), this.Bw = t);
    }
    get nodeIndentPastParent() {
      return this.Vw;
    }
    set nodeIndentPastParent(t) {
      this.Vw !== t && (U.i(t, "number", TreeVertex2, "nodeIndentPastParent"), this.Vw = t);
    }
    get nodeSpacing() {
      return this.zw;
    }
    set nodeSpacing(t) {
      this.zw !== t && (U.i(t, "number", TreeVertex2, "nodeSpacing"), this.zw = t);
    }
    get layerSpacing() {
      return this.Us;
    }
    set layerSpacing(t) {
      this.Us !== t && (U.i(t, "number", TreeVertex2, "layerSpacing"), this.Us = t);
    }
    get layerSpacingParentOverlap() {
      return this.Xw;
    }
    set layerSpacingParentOverlap(t) {
      this.Xw !== t && (U.i(t, "number", TreeVertex2, "layerSpacingParentOverlap"), this.Xw = t);
    }
    get compaction() {
      return this.Yw;
    }
    set compaction(t) {
      this.Yw !== t && (U.W(t, TreeCompaction2, "TreeCompaction"), this.Yw = t);
    }
    get breadthLimit() {
      return this.Kw;
    }
    set breadthLimit(t) {
      this.Kw !== t && (U.i(t, "number", TreeVertex2, "breadthLimit"), this.Kw = t);
    }
    get rowSpacing() {
      return this.Uw;
    }
    set rowSpacing(t) {
      this.Uw !== t && (U.i(t, "number", TreeVertex2, "rowSpacing"), this.Uw = t);
    }
    get rowIndent() {
      return this.Gw;
    }
    set rowIndent(t) {
      this.Gw !== t && (U.i(t, "number", TreeVertex2, "rowIndent"), this.Gw = t);
    }
    get commentSpacing() {
      return this.qw;
    }
    set commentSpacing(t) {
      this.qw !== t && (U.i(t, "number", TreeVertex2, "commentSpacing"), this.qw = t);
    }
    get commentMargin() {
      return this.Hw;
    }
    set commentMargin(t) {
      this.Hw !== t && (U.i(t, "number", TreeVertex2, "commentMargin"), this.Hw = t);
    }
    get setsPortSpot() {
      return this.vw;
    }
    set setsPortSpot(t) {
      this.vw !== t && (U.i(t, "boolean", TreeVertex2, "setsPortSpot"), this.vw = t);
    }
    get portSpot() {
      return this.Ww;
    }
    set portSpot(t) {
      U.s(t, Spot2, TreeVertex2, "portSpot"), this.Ww.equals(t) || (this.Ww = t);
    }
    get setsChildPortSpot() {
      return this.jw;
    }
    set setsChildPortSpot(t) {
      this.jw !== t && (U.i(t, "boolean", TreeVertex2, "setsChildPortSpot"), this.jw = t);
    }
    get childPortSpot() {
      return this.Jw;
    }
    set childPortSpot(t) {
      U.s(t, Spot2, TreeVertex2, "childPortSpot"), this.Jw.equals(t) || (this.Jw = t);
    }
    get childrenCount() {
      return this.children.length;
    }
    get relativePosition() {
      return this.X;
    }
    set relativePosition(t) {
      this.X.set(t);
    }
    get subtreeSize() {
      return this.bt;
    }
    set subtreeSize(t) {
      this.bt.set(t);
    }
    get subtreeOffset() {
      return this.dt;
    }
    set subtreeOffset(t) {
      this.dt.set(t);
    }
  }
  class TreeEdge2 extends LayoutEdge2 {
    Lk;
    constructor(t) {
      super(t), this.Lk = new Point2(0, 0);
    }
    commit() {
      const t = this.link;
      if (t === null || t.isAvoiding) return;
      const i = this.network.layout;
      let e = null, s = null;
      switch (i.ks) {
        case 1:
          e = this.fromVertex, s = this.toVertex;
          break;
        case 2:
          e = this.toVertex, s = this.fromVertex;
          break;
        default:
          U.n("Unhandled path value " + i.ks.toString());
      }
      if (e === null || s === null) return;
      const n = this.Lk;
      if (n.x === 0 && n.y === 0) {
        this.AB(e, s);
        return;
      }
      const o = e.bounds, r = i.orthoAngle(e), l = i.computeLayerSpacing(e), h = e.rowSpacing;
      t.updateRoute();
      const f = t.curve === 9, a = t.isOrthogonal;
      let c = 0, u, d;
      if (t.startRoute(), a || f) {
        for (c = 2; t.pointsCount > 4; ) t.removePoint(2);
        u = t.getPoint(1), d = t.getPoint(2);
      } else {
        for (c = 1; t.pointsCount > 3; ) t.removePoint(1);
        u = t.getPoint(0), d = t.getPoint(t.pointsCount - 1);
      }
      const m = t.getPoint(t.pointsCount - 1);
      let g = 0;
      r === 0 ? (e.alignment === 23 ? (g = o.bottom + n.y, n.y === 0 && u.y > m.y + e.rowIndent && (g = Math.min(g, Math.max(u.y, g - i.computeNodeIndent(e))))) : e.alignment === 22 ? (g = o.top + n.y, n.y === 0 && u.y < m.y - e.rowIndent && (g = Math.max(g, Math.min(u.y, g + i.computeNodeIndent(e))))) : g = o.y + o.height / 2 + n.y, f ? (t.insertPointAt(c, u.x, g), c++, t.insertPointAt(c, o.right + l, g), c++, t.insertPointAt(c, o.right + l + (n.x - h) / 3, g), c++, t.insertPointAt(c, o.right + l + (n.x - h) * 2 / 3, g), c++, t.insertPointAt(c, o.right + l + (n.x - h), g), c++, t.insertPointAt(c, d.x, g), c++) : (a && (t.insertPointAt(c, o.right + l / 2, u.y), c++), t.insertPointAt(c, o.right + l / 2, g), c++, t.insertPointAt(c, o.right + l + n.x - (a ? h / 2 : h), g), c++, a && (t.insertPointAt(c, t.getPoint(c - 1).x, d.y), c++))) : r === 90 ? (e.alignment === 23 ? (g = o.right + n.x, n.x === 0 && u.x > m.x + e.rowIndent && (g = Math.min(g, Math.max(u.x, g - i.computeNodeIndent(e))))) : e.alignment === 22 ? (g = o.left + n.x, n.x === 0 && u.x < m.x - e.rowIndent && (g = Math.max(g, Math.min(u.x, g + i.computeNodeIndent(e))))) : g = o.x + o.width / 2 + n.x, f ? (t.insertPointAt(c, g, u.y), c++, t.insertPointAt(c, g, o.bottom + l), c++, t.insertPointAt(c, g, o.bottom + l + (n.y - h) / 3), c++, t.insertPointAt(c, g, o.bottom + l + (n.y - h) * 2 / 3), c++, t.insertPointAt(c, g, o.bottom + l + (n.y - h)), c++, t.insertPointAt(c, g, d.y), c++) : (a && (t.insertPointAt(c, u.x, o.bottom + l / 2), c++), t.insertPointAt(c, g, o.bottom + l / 2), c++, t.insertPointAt(c, g, o.bottom + l + n.y - (a ? h / 2 : h)), c++, a && (t.insertPointAt(c, d.x, t.getPoint(c - 1).y), c++))) : r === 180 ? (e.alignment === 23 ? (g = o.bottom + n.y, n.y === 0 && u.y > m.y + e.rowIndent && (g = Math.min(g, Math.max(u.y, g - i.computeNodeIndent(e))))) : e.alignment === 22 ? (g = o.top + n.y, n.y === 0 && u.y < m.y - e.rowIndent && (g = Math.max(g, Math.min(u.y, g + i.computeNodeIndent(e))))) : g = o.y + o.height / 2 + n.y, f ? (t.insertPointAt(c, u.x, g), c++, t.insertPointAt(c, o.left - l, g), c++, t.insertPointAt(c, o.left - l + (n.x + h) / 3, g), c++, t.insertPointAt(c, o.left - l + (n.x + h) * 2 / 3, g), c++, t.insertPointAt(c, o.left - l + (n.x + h), g), c++, t.insertPointAt(c, d.x, g), c++) : (a && (t.insertPointAt(c, o.left - l / 2, u.y), c++), t.insertPointAt(c, o.left - l / 2, g), c++, t.insertPointAt(c, o.left - l + n.x + (a ? h / 2 : h), g), c++, a && (t.insertPointAt(c, t.getPoint(c - 1).x, d.y), c++))) : r === 270 ? (e.alignment === 23 ? (g = o.right + n.x, n.x === 0 && u.x > m.x + e.rowIndent && (g = Math.min(g, Math.max(u.x, g - i.computeNodeIndent(e))))) : e.alignment === 22 ? (g = o.left + n.x, n.x === 0 && u.x < m.x - e.rowIndent && (g = Math.max(g, Math.min(u.x, g + i.computeNodeIndent(e))))) : g = o.x + o.width / 2 + n.x, f ? (t.insertPointAt(c, g, u.y), c++, t.insertPointAt(c, g, o.top - l), c++, t.insertPointAt(c, g, o.top - l + (n.y + h) / 3), c++, t.insertPointAt(c, g, o.top - l + (n.y + h) * 2 / 3), c++, t.insertPointAt(c, g, o.top - l + (n.y + h)), c++, t.insertPointAt(c, g, d.y), c++) : (a && (t.insertPointAt(c, u.x, o.top - l / 2), c++), t.insertPointAt(c, g, o.top - l / 2), c++, t.insertPointAt(c, g, o.top - l + n.y + (a ? h / 2 : h)), c++, a && (t.insertPointAt(c, d.x, t.getPoint(c - 1).y), c++))) : U.n("Invalid angle " + r), t.commitRoute();
    }
    AB(t, i) {
      Debug && U.s(t, TreeVertex2, TreeEdge2, "adjustRouteForAngleChange:parent"), Debug && U.s(i, TreeVertex2, TreeEdge2, "adjustRouteForAngleChange:child");
      const e = this.link;
      if (e === null) return;
      const s = this.network.layout, n = s.orthoAngle(t), o = s.orthoAngle(i);
      if (n === o) return;
      const r = s.computeLayerSpacing(t), l = t.bounds, h = i.bounds;
      if (n === 0 && h.left - l.right < r + 1 || n === 90 && h.top - l.bottom < r + 1 || n === 180 && l.left - h.right < r + 1 || n === 270 && l.top - h.bottom < r + 1) return;
      e.updateRoute();
      const f = e.curve === 9, a = e.isOrthogonal, c = this.fromVertex, u = s.isBusAlignment(c.alignment);
      if (e.startRoute(), n === 0) {
        const d = l.right + r / 2;
        if (f) {
          if (e.pointsCount === 4) {
            const m = e.getPoint(3).y;
            e.setPointAt(1, d - 20, e.getPoint(1).y), e.insertPointAt(2, d - 20, m), e.insertPointAt(3, d, m), e.insertPointAt(4, d + 20, m), e.setPointAt(5, e.getPoint(5).x, m);
          }
        } else a ? u ? e.setPointAt(3, e.getPoint(2).x, e.getPoint(4).y) : e.pointsCount === 6 && (e.setPointAt(2, d, e.getPoint(2).y), e.setPointAt(3, d, e.getPoint(3).y)) : e.pointsCount === 4 ? e.insertPointAt(2, d, e.getPoint(2).y) : e.pointsCount === 3 ? e.setPointAt(1, d, e.getPoint(2).y) : e.pointsCount === 2 && e.insertPointAt(1, d, e.getPoint(1).y);
      } else if (n === 90) {
        const d = l.bottom + r / 2;
        if (f) {
          if (e.pointsCount === 4) {
            const m = e.getPoint(3).x;
            e.setPointAt(1, e.getPoint(1).x, d - 20), e.insertPointAt(2, m, d - 20), e.insertPointAt(3, m, d), e.insertPointAt(4, m, d + 20), e.setPointAt(5, m, e.getPoint(5).y);
          }
        } else a ? u ? e.setPointAt(3, e.getPoint(2).x, e.getPoint(4).y) : e.pointsCount === 6 && (e.setPointAt(2, e.getPoint(2).x, d), e.setPointAt(3, e.getPoint(3).x, d)) : e.pointsCount === 4 ? e.insertPointAt(2, e.getPoint(2).x, d) : e.pointsCount === 3 ? e.setPointAt(1, e.getPoint(2).x, d) : e.pointsCount === 2 && e.insertPointAt(1, e.getPoint(1).x, d);
      } else if (n === 180) {
        const d = l.left - r / 2;
        if (f) {
          if (e.pointsCount === 4) {
            const m = e.getPoint(3).y;
            e.setPointAt(1, d + 20, e.getPoint(1).y), e.insertPointAt(2, d + 20, m), e.insertPointAt(3, d, m), e.insertPointAt(4, d - 20, m), e.setPointAt(5, e.getPoint(5).x, m);
          }
        } else a ? u ? e.setPointAt(3, e.getPoint(2).x, e.getPoint(4).y) : e.pointsCount === 6 && (e.setPointAt(2, d, e.getPoint(2).y), e.setPointAt(3, d, e.getPoint(3).y)) : e.pointsCount === 4 ? e.insertPointAt(2, d, e.getPoint(2).y) : e.pointsCount === 3 ? e.setPointAt(1, d, e.getPoint(2).y) : e.pointsCount === 2 && e.insertPointAt(1, d, e.getPoint(1).y);
      } else if (n === 270) {
        const d = l.top - r / 2;
        if (f) {
          if (e.pointsCount === 4) {
            const m = e.getPoint(3).x;
            e.setPointAt(1, e.getPoint(1).x, d + 20), e.insertPointAt(2, m, d + 20), e.insertPointAt(3, m, d), e.insertPointAt(4, m, d - 20), e.setPointAt(5, m, e.getPoint(5).y);
          }
        } else a ? u ? e.setPointAt(3, e.getPoint(2).x, e.getPoint(4).y) : e.pointsCount === 6 && (e.setPointAt(2, e.getPoint(2).x, d), e.setPointAt(3, e.getPoint(3).x, d)) : e.pointsCount === 4 ? e.insertPointAt(2, e.getPoint(2).x, d) : e.pointsCount === 3 ? e.setPointAt(1, e.getPoint(2).x, d) : e.pointsCount === 2 && e.insertPointAt(1, e.getPoint(1).x, d);
      }
      e.commitRoute();
    }
    get fromVertex() {
      return this.ls;
    }
    set fromVertex(t) {
      this.ls !== t && (Debug && t !== null && U.s(t, TreeVertex2, TreeEdge2, "fromVertex"), this.ls = t);
    }
    get toVertex() {
      return this.hs;
    }
    set toVertex(t) {
      this.hs !== t && (Debug && t !== null && U.s(t, TreeVertex2, TreeEdge2, "toVertex"), this.hs = t);
    }
    get relativePoint() {
      return this.Lk;
    }
    set relativePoint(t) {
      this.Lk.set(t);
    }
  }
  class Themes2 {
    constructor() {
    }
    static Light = { colors: { text: "#0a0a0a", comment: "#ca8a04", link: "#0a0a0a", group: "#a3a3a344", outline: "#a3a3a3", selection: "#0ea5e9", div: "#fff", gridMinor: "#e5e5e5", gridMajor: "#a3a3a3", overviewBox: "#c026d3", tempLink: "#2563eb", tempPort: "#c026d3", adornmentFill: "#0ea5e9", adornmentStroke: "#1e40af", dragSelect: "#c026d3" }, fonts: { normal: "10pt sans-serif", bold: "bold 12pt sans-serif" }, numbers: { group: 1, selection: 3 }, margins: { group: new Margin2(5) }, arrowheads: { toArrow: "Standard" } };
    static Dark = { colors: { text: "#f5f5f5", comment: "#facc15", link: "#f5f5f5", group: "#a3a3a388", outline: "#a3a3a3", selection: "#38bdf8", div: "#171717", gridMinor: "#262626", gridMajor: "#404040", overviewBox: "#e879f9", tempLink: "#60a5fa", tempPort: "#e879f9", adornmentFill: "#38bdf8", adornmentStroke: "#2563eb", dragSelect: "#e879f9" }, fonts: { normal: "10pt sans-serif", bold: "bold 12pt sans-serif" }, numbers: { group: 1, selection: 3 }, margins: { group: new Margin2(5) }, arrowheads: { toArrow: "Standard" } };
  }
  class ThemeManager2 {
    ds = /* @__PURE__ */ new Set();
    Nu = new GMap2();
    Dk = "light";
    Fk = "light";
    Ik = false;
    LA = true;
    nm = "light";
    HI = (t) => {
      const i = t.matches ? "dark" : "light";
      i !== this.nm && (this.nm = i, this.Fk === "system" && this.updateDiagrams());
    };
    constructor(t) {
      t && Object.assign(this, t), t?.themeMap || (this.Nu.set("light", { colors: __spreadValues({}, Themes2.Light.colors), fonts: __spreadValues({}, Themes2.Light.fonts), numbers: __spreadValues({}, Themes2.Light.numbers), margins: __spreadValues({}, Themes2.Light.margins), arrowheads: __spreadValues({}, Themes2.Light.arrowheads) }), this.Nu.set("dark", { colors: __spreadValues({}, Themes2.Dark.colors), fonts: __spreadValues({}, Themes2.Dark.fonts), numbers: __spreadValues({}, Themes2.Dark.numbers), margins: __spreadValues({}, Themes2.Dark.margins), arrowheads: __spreadValues({}, Themes2.Dark.arrowheads) })), root.matchMedia && (this.nm = root.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light");
    }
    get themeMap() {
      return this.Nu;
    }
    set themeMap(t) {
      this.Nu !== t && (this.Nu = t, this.updateDiagrams());
    }
    get defaultTheme() {
      return this.Dk;
    }
    set defaultTheme(t) {
      this.Dk !== t && (U.i(t, "string", ThemeManager2, "defaultTheme"), this.Dk = t, this.updateDiagrams());
    }
    get currentTheme() {
      return this.Fk;
    }
    set currentTheme(t) {
      this.Fk !== t && (U.i(t, "string", ThemeManager2, "currentTheme"), this.Fk = t, this.updateDiagrams());
    }
    get changesDivBackground() {
      return this.Ik;
    }
    set changesDivBackground(t) {
      if (this.Ik !== t && (this.Ik = t, t)) for (const e of this.ds) e.setDivBackground(this.findValue("div", "", "fill")), e.F("ThemeChanged", this);
    }
    get readsCssVariables() {
      return this.LA;
    }
    set readsCssVariables(t) {
      this.LA !== t && (this.LA = t, this.updateDiagrams());
    }
    get preferredColorScheme() {
      return this.nm;
    }
    addDiagram(t) {
      return this.ds.add(t), this.DA(t), this;
    }
    removeDiagram(t) {
      return this.ds.delete(t), this.DA(t), this;
    }
    lO() {
      this.ds.size === 0 && root.matchMedia && root.matchMedia("(prefers-color-scheme: dark)")?.addEventListener("change", this.HI);
    }
    hO() {
      this.ds.size === 0 && root.matchMedia && root.matchMedia("(prefers-color-scheme: dark)")?.removeEventListener("change", this.HI);
    }
    set(t, i) {
      t === "" && (t = this.Dk), t === "system" && (t = this.nm);
      let e = this.Nu.get(t);
      return e ? e = this.vI(e, i) : e = i, this.Nu.set(t, e), this.updateDiagrams(), this;
    }
    findValue(t, i, e) {
      return this.getValue(this.findTheme(this.currentTheme), t, i, e) || this.getValue(this.findTheme(this.defaultTheme), t, i, e);
    }
    getValue(t, i, e, s) {
      if (!t) return;
      e == null && (e = "");
      let n = t;
      const o = (l) => {
        if (n === void 0 || l === "") return;
        if (typeof l == "number" || !(Array.isArray(l) || l.includes("."))) return n[l];
        const h = Array.isArray(l) ? l : l.split(".");
        for (let f = 0; f < h.length; f++) {
          const a = h[f];
          if (a !== "" && (n = n[a], n === void 0)) return;
        }
        return n;
      }, r = () => {
        if (!(e !== "" && (n = o(e), n === void 0))) return Array.isArray(n) && typeof i == "number" ? n = n[i % n.length] : n = o(i), n;
      };
      if (n = r(), n === void 0 && typeof s == "string" && s.length > 0) {
        let l = t.targetPropertyMap?.get(s);
        if (l ? n = t[l] : (l = ThemeManager2.TB.get(s), n = l ? t[l] : t.colors), n = r(), n !== void 0) return n;
      }
      return n;
    }
    findTheme(t) {
      return this.themeMap.get(t === "system" ? this.nm : t);
    }
    updateDiagrams() {
      for (const t of this.ds) this.DA(t);
    }
    DA(t) {
      const i = t.skipsUndoManager;
      t.skipsUndoManager = true, t.updateAllThemeBindings(), this.Ik && t.setDivBackground(this.findValue("div", "", "fill")), t.skipsUndoManager = i, t.F("ThemeChanged", this);
    }
    vI(t, i) {
      for (const e in i) if (U.$w(i, e)) try {
        i[e]?.constructor === Object ? t[e] = this.vI(t[e] ?? {}, i[e]) : t[e] = i[e];
      } catch {
        delete t[e];
      }
      return t;
    }
    static TB = /* @__PURE__ */ new Map([["background", "colors"], ["defaultColumnSeparatorStroke", "colors"], ["defaultRowSeparatorStroke", "colors"], ["shadowColor", "colors"], ["fill", "colors"], ["stroke", "colors"], ["font", "fonts"], ["angle", "numbers"], ["fromEndSegmentLength", "numbers"], ["fromShortLength", "numbers"], ["height", "numbers"], ["opacity", "numbers"], ["scale", "numbers"], ["toEndSegmentLength", "numbers"], ["toShortLength", "numbers"], ["width", "numbers"], ["defaultColumnSeparatorStrokeWidth", "numbers"], ["defaultRowSeparatorStrokeWidth", "numbers"], ["shadowBlur", "numbers"], ["corner", "numbers"], ["curviness", "numbers"], ["smoothness", "numbers"], ["parameter1", "numbers"], ["parameter2", "numbers"], ["strokeWidth", "numbers"], ["strokeDashOffset", "numbers"], ["maxLines", "numbers"], ["spacingAbove", "numbers"], ["spacingBelow", "numbers"], ["position", "points"], ["shadowOffset", "points"], ["desiredSize", "sizes"], ["maxSize", "sizes"], ["minSize", "sizes"], ["margin", "margins"], ["defaultSeparatorPadding", "margins"], ["padding", "margins"], ["alignment", "spots"], ["alignmentFocus", "spots"], ["fromSpot", "spots"], ["toSpot", "spots"], ["defaultAlignment", "spots"], ["spot1", "spots"], ["spot2", "spots"], ["verticalAlignment", "spots"], ["imageAlignment", "spots"], ["fromArrow", "arrowheads"], ["toArrow", "arrowheads"]]);
  }
  class Router2 {
    At;
    f;
    Gi;
    Cl;
    constructor() {
      this.f = Diagram2.zm(), this.At = "", this.Gi = true, this.Cl = true;
    }
    get name() {
      return this.At;
    }
    set name(t) {
      this.At = t;
    }
    get isEnabled() {
      return this.Gi;
    }
    set isEnabled(t) {
      this.Gi = t;
    }
    get isRealtime() {
      return this.Cl;
    }
    set isRealtime(t) {
      this.Cl = t;
    }
    get diagram() {
      return this.f;
    }
    set diagram(t) {
      this.f !== t && (this.f = t, t.Bl = true, t.requestUpdate());
    }
    invalidateRouter() {
      this.f !== null && (this.f.Bl = true, this.f.requestUpdate());
    }
    canRoute(t) {
      if (!this.isEnabled) return false;
      const i = this.diagram;
      return !(i && (!this.isRealtime && i.Ku || i.animationManager.isTicking));
    }
    isRoutable(t, i) {
      return true;
    }
    routeLinks(t, i) {
    }
    toString() {
      return this.name !== "" ? this.name + " Router" : U.$n(this.constructor);
    }
  }
  class AvoidsNodesRouter extends Router2 {
    constructor(t) {
      super(), this.name = "AvoidsNodes", t && Object.assign(this, t);
    }
    canRoute(t) {
      return (t instanceof Diagram2 ? t.u0 : t.diagram?.u0) ? super.canRoute(t) : false;
    }
    isRoutable(t, i) {
      return !(!t.isAvoiding || t.containingGroup !== (i instanceof Group2 ? i : null) || t.toNode === null || t.fromNode === null || t.pointsCount < 4);
    }
    routeLinks(t, i) {
      const e = i instanceof Diagram2 ? null : i, s = t.iterator, n = this.diagram.getPositions(true, e, null);
      for (; s.next(); ) {
        const o = s.value;
        if (!this.isRoutable(o, i)) continue;
        o.startRoute();
        const r = o.pointsCount, l = o.getPoint(1), h = o.getPoint(r - 2), f = o.fromNode.actualBounds.copy();
        f.inflate(Link2.Vh, Link2.Vh), f.unionPoint(o.getPoint(0));
        const a = o.toNode.actualBounds.copy();
        a.inflate(Link2.Vh, Link2.Vh), a.unionPoint(o.getPoint(r - 1)), this.LB(o, f, a, n) && this.DB(o, l, o.TC, h, o.LC, f, a, n), o.commitRoute();
      }
    }
    LB(t, i, e, s) {
      const n = t.diagram, o = t.pointsCount;
      if (n === null || !t.fromNode || !t.toNode || t.fromNode === t.toNode || !t.layer || t.layer.isTemporary || i.containsPoint(t.getPoint(o - 1)) && !t.toNode.isMemberOf(t.fromNode) || e.containsPoint(t.getPoint(0)) && !t.fromNode.isMemberOf(t.toNode) || !t.isOrthogonal) return false;
      if (t.segmentIndex === 17) return true;
      const r = t.getPoint(1), l = t.getPoint(o - 2), h = t.getPoint(2);
      if (!s.isUnoccupied(Math.min(r.x, h.x), Math.min(r.y, h.y), Math.abs(r.x - h.x), Math.abs(r.y - h.y))) return true;
      for (let a = 2; a < o - 3; a++) {
        const c = t.getPoint(a), u = t.getPoint(a + 1);
        if (!s.isUnoccupied(Math.min(c.x, u.x), Math.min(c.y, u.y), Math.abs(c.x - u.x), Math.abs(c.y - u.y))) return true;
      }
      const f = t.getPoint(o - 3);
      return !s.isUnoccupied(Math.min(f.x, l.x), Math.min(f.y, l.y), Math.abs(f.x - l.x), Math.abs(f.y - l.y));
    }
    DB(t, i, e, s, n, o, r, l) {
      const h = t.diagram;
      if (h === null) return;
      const f = i, a = s;
      let c = Point2.xn, u = Point2.xn;
      if (h.isVirtualized) {
        const g = l.bounds.copy(), p = t.getPoint(2), y = t.getPoint(t.pointsCount - 3);
        g.inflate(-l.cellWidth, -l.cellHeight);
        const x = Point2.a();
        l.ag(i.x, i.y) || (G.Dl(g.x, g.y, g.x + g.width, g.y + g.height, i.x, i.y, p.x, p.y, x) ? (c = i = x.copy(), e = x.directionPoint(p)) : G.Dl(g.x, g.y, g.x + g.width, g.y + g.height, p.x, p.y, y.x, y.y, x) ? (c = i = x.copy(), e = x.directionPoint(y)) : G.Dl(g.x, g.y, g.x + g.width, g.y + g.height, y.x, y.y, s.x, s.y, x) && (c = i = x.copy(), e = x.directionPoint(s))), l.ag(s.x, s.y) || (G.Dl(g.x, g.y, g.x + g.width, g.y + g.height, s.x, s.y, y.x, y.y, x) ? (u = s = x.copy(), n = y.directionPoint(x)) : G.Dl(g.x, g.y, g.x + g.width, g.y + g.height, y.x, y.y, p.x, p.y, x) ? (u = s = x.copy(), n = p.directionPoint(x)) : G.Dl(g.x, g.y, g.x + g.width, g.y + g.height, p.x, p.y, i.x, i.y, x) && (u = s = x.copy(), n = i.directionPoint(x))), Point2.o(x);
      }
      const d = o.copy().unionRect(r);
      d.inflate(l.cellWidth * l.gc, l.cellHeight * l.gc), l.PF(i, e, s, n, d, true);
      let m = l.Mo(s.x, s.y);
      if (!l.nw && m >= PositionArray.hg && (l.RL(), d.inflate(l.cellWidth * l.K2, l.cellHeight * l.U2), l.PF(i, e, s, n, d, false), m = l.Mo(s.x, s.y)), !l.nw && m < PositionArray.hg && !l.jE(s.x, s.y)) {
        t.points.removeRange(2, t.pointsCount - 3), this.FA(t, l, s.x, s.y, n, true);
        const g = 0, p = 90, y = 180, x = 270, S = t.getPoint(2);
        if (t.pointsCount < 4) e === g || e === y ? (S.x = i.x, S.y = s.y) : (S.x = s.x, S.y = i.y), t.setPointAt(2, S.x, S.y), t.insertPointAt(3, S.x, S.y);
        else {
          const b = t.getPoint(3);
          if (e === g || e === y) if (G.p(S.x, b.x)) {
            const k = e === g ? Math.max(S.x, i.x) : Math.min(S.x, i.x);
            t.setPointAt(2, k, i.y), t.setPointAt(3, k, b.y);
          } else G.p(S.y, b.y) ? (Math.abs(i.y - S.y) <= l.cellHeight / 2 && (t.setPointAt(2, S.x, i.y), t.setPointAt(3, b.x, i.y)), t.insertPointAt(2, S.x, i.y)) : t.setPointAt(2, i.x, S.y);
          else if (e === p || e === x) if (G.p(S.y, b.y)) {
            const k = e === p ? Math.max(S.y, i.y) : Math.min(S.y, i.y);
            t.setPointAt(2, i.x, k), t.setPointAt(3, b.x, k);
          } else G.p(S.x, b.x) ? (Math.abs(i.x - S.x) <= l.cellWidth / 2 && (t.setPointAt(2, i.x, S.y), t.setPointAt(3, i.x, b.y)), t.insertPointAt(2, i.x, S.y)) : t.setPointAt(2, S.x, i.y);
        }
        if (c.isReal()) {
          const b = t.getPoint(1), k = t.getPoint(2);
          b.x !== k.x && b.y !== k.y ? e === g || e === y ? t.insertPointAt(2, b.x, k.y) : t.insertPointAt(2, k.x, b.y) : e === g || e === y ? t.insertPointAt(2, f.x, c.y) : t.insertPointAt(2, c.x, f.y);
        }
        u.isReal() && (n === g || n === y ? t.insertPointAt(t.pointsCount - 2, a.x, u.y) : t.insertPointAt(t.pointsCount - 2, u.x, a.y));
      }
    }
    FA(t, i, e, s, n, o) {
      const a = i.cellWidth, c = i.cellHeight;
      let u = i.Mo(e, s), d = e, m = s, g = d, p = m;
      for (n === 0 ? g += a : n === 90 ? p += c : n === 180 ? g -= a : p -= c, t.EC && u > PositionArray.cf && i.Mo(g, p) !== u - 1 && (i.Mo(d - a, m) === u - 1 ? (n = 180, g = d - a, p = m) : i.Mo(d + a, m) === u - 1 ? (n = 0, g = d + a, p = m) : i.Mo(d, m - c) === u - 1 ? (n = 270, g = d, p = m - c) : i.Mo(d, m + c) === u - 1 && (n = 90, g = d, p = m + c)); u > PositionArray.cf && i.Mo(g, p) === u - 1; ) d = g, m = p, n === 0 ? g += a : n === 90 ? p += c : n === 180 ? g -= a : p -= c, u -= 1;
      if (o ? u > PositionArray.cf && (n === 180 || n === 0 ? d = Math.floor(d / a) * a + a / 2 : (n === 90 || n === 270) && (m = Math.floor(m / c) * c + c / 2)) : (d = Math.floor(d / a) * a + a / 2, m = Math.floor(m / c) * c + c / 2), u > PositionArray.cf) {
        let y = n, x = d, S = m;
        if (n === 0 ? (y = 90, S += c) : n === 90 ? (y = 180, x -= a) : n === 180 ? (y = 270, S -= c) : n === 270 && (y = 0, x += a), i.Mo(x, S) === u - 1) this.FA(t, i, x, S, y, false);
        else {
          let k = d, P = m;
          n === 0 ? (y = 270, P -= c) : n === 90 ? (y = 0, k += a) : n === 180 ? (y = 90, P += c) : n === 270 && (y = 180, k -= a), i.Mo(k, P) === u - 1 && this.FA(t, i, k, P, y, false);
        }
      }
      t.insertPointAt(t.pointsCount - 2, d, m);
    }
  }
  ToolManager2.prototype.initializeStandardTools = function() {
    this.ti("Action", new ActionTool2(), this.mouseDownTools), this.ti("Relinking", new RelinkingTool2(), this.mouseDownTools), this.ti("LinkReshaping", new LinkReshapingTool2(), this.mouseDownTools), this.ti("Rotating", new RotatingTool2(), this.mouseDownTools), this.ti("Resizing", new ResizingTool2(), this.mouseDownTools), this.ti("Linking", new LinkingTool2(), this.mouseMoveTools), this.ti("Dragging", new DraggingTool2(), this.mouseMoveTools), this.ti("DragSelecting", new DragSelectingTool2(), this.mouseMoveTools), this.ti("Panning", new PanningTool2(), this.mouseMoveTools), this.ti("ContextMenu", new ContextMenuTool2(), this.mouseUpTools), this.ti("TextEditing", new TextEditingTool2(), this.mouseUpTools), this.ti("ClickCreating", new ClickCreatingTool2(), this.mouseUpTools), this.ti("ClickSelecting", new ClickSelectingTool2(), this.mouseUpTools);
  }, Diagram2.S2("GraphLinksModel", GraphLinksPartManager), Diagram2.S2("TreeModel", TreePartManager);
  const oldGo = root.go, go2 = { get version() {
    return Diagram2.version;
  }, Group: Group2, List: List2, Set: GSet2, Map: GMap2, Point: Point2, Size: Size2, Rect: Rect2, Margin: Margin2, Spot: Spot2, Geometry: Geometry2, PathFigure: PathFigure2, PathSegment: PathSegment2, InputEvent: InputEvent2, DiagramEvent: DiagramEvent2, ChangedEvent: ChangedEvent2, Model: Model2, GraphLinksModel: GraphLinksModel2, TreeModel: TreeModel2, Binding: Binding2, ThemeBinding: ThemeBinding2, Transaction: Transaction2, UndoManager: UndoManager2, CommandHandler: CommandHandler2, Tool: Tool2, DraggingTool: DraggingTool2, DraggingInfo: DraggingInfo2, DraggingOptions: DraggingOptions2, LinkingBaseTool: LinkingBaseTool2, LinkingTool: LinkingTool2, RelinkingTool: RelinkingTool2, LinkReshapingTool: LinkReshapingTool2, ResizingTool: ResizingTool2, RotatingTool: RotatingTool2, ClickSelectingTool: ClickSelectingTool2, ActionTool: ActionTool2, ClickCreatingTool: ClickCreatingTool2, HTMLInfo: HTMLInfo2, ContextMenuTool: ContextMenuTool2, DragSelectingTool: DragSelectingTool2, PanningTool: PanningTool2, TextEditingTool: TextEditingTool2, ToolManager: ToolManager2, Animation: Animation2, AnimationManager: AnimationManager2, AnimationTrigger: AnimationTrigger2, Layer: Layer2, Diagram: Diagram2, Palette: Palette2, Overview: Overview2, Brush: Brush2, GraphObject: GraphObject2, Panel: Panel2, RowColumnDefinition: RowColumnDefinition2, Shape: Shape2, TextBlock: TextBlock2, Picture: Picture2, Part: Part2, Adornment: Adornment2, Node: Node2, Link: Link2, Placeholder: Placeholder2, Layout: Layout2, LayoutNetwork: LayoutNetwork2, LayoutVertex: LayoutVertex2, LayoutEdge: LayoutEdge2, GridLayout: GridLayout2, PanelLayout: PanelLayout2, CircularLayout: CircularLayout2, CircularNetwork: CircularNetwork2, CircularVertex: CircularVertex2, CircularEdge: CircularEdge2, ForceDirectedLayout: ForceDirectedLayout2, ForceDirectedNetwork: ForceDirectedNetwork2, ForceDirectedVertex: ForceDirectedVertex2, ForceDirectedEdge: ForceDirectedEdge2, LayeredDigraphLayout: LayeredDigraphLayout2, LayeredDigraphNetwork: LayeredDigraphNetwork2, LayeredDigraphVertex: LayeredDigraphVertex2, LayeredDigraphEdge: LayeredDigraphEdge2, TreeLayout: TreeLayout2, TreeNetwork: TreeNetwork2, TreeVertex: TreeVertex2, TreeEdge: TreeEdge2, Themes: Themes2, ThemeManager: ThemeManager2, Router: Router2, AnimationStyle: AnimationStyle2, AutoScale: AutoScale2, CycleMode: CycleMode2, Flip: Flip2, TextFormat: TextFormat2, ImageStretch: ImageStretch2, LayoutConditions: LayoutConditions2, LinkAdjusting: LinkAdjusting2, Curve: Curve2, Routing: Routing2, Orientation: Orientation2, TextOverflow: TextOverflow2, PortSpreading: PortSpreading2, ScrollMode: ScrollMode2, CollapsePolicy: CollapsePolicy2, Sizing: Sizing2, TriggerStart: TriggerStart2, Stretch: Stretch2, ViewboxStretch: ViewboxStretch2, Wrap: Wrap2, BrushType: BrushType2, ColorSpace: ColorSpace2, GeometryStretch: GeometryStretch2, GeometryType: GeometryType2, SegmentType: SegmentType2, BindingMode: BindingMode2, ChangeType: ChangeType2, CircularArrangement: CircularArrangement2, CircularDirection: CircularDirection2, CircularNodeDiameterFormula: CircularNodeDiameterFormula2, CircularSorting: CircularSorting2, GridAlignment: GridAlignment2, GridArrangement: GridArrangement2, GridSorting: GridSorting2, LayeredDigraphAggressive: LayeredDigraphAggressive2, LayeredDigraphAlign: LayeredDigraphAlign2, LayeredDigraphCycleRemove: LayeredDigraphCycleRemove2, LayeredDigraphInit: LayeredDigraphInit2, LayeredDigraphLayering: LayeredDigraphLayering2, LayeredDigraphPack: LayeredDigraphPack2, TreeAlignment: TreeAlignment2, TreeArrangement: TreeArrangement2, TreeCompaction: TreeCompaction2, TreeLayerStyle: TreeLayerStyle2, TreePath: TreePath2, TreeSorting: TreeSorting2, TreeStyle: TreeStyle2, GestureMode: GestureMode2, LinkingDirection: LinkingDirection2, ReshapingBehavior: ReshapingBehavior2, TextEditingAccept: TextEditingAccept2, TextEditingStarting: TextEditingStarting2, TextEditingState: TextEditingState2, WheelMode: WheelMode2 };
  for (const w in go2) {
    const t = go2[w];
    U.at(t) && t !== TextFormat2 && (t.className = w);
  }
  U.it(oldGo) && oldGo.version && U.ot("WARNING: a `go` object on the root object is already defined.  " + ("Debug" in oldGo ? "debug " : "") + "version: " + oldGo.version + ", replaced with version: " + go2.version), Diagram2.prototype.go = go2, root.go = go2, go2.Debug = Debug, Debug.attachReadonlyWarnings(go2);
})();
var go_debug_default = typeof global !== "undefined" ? global.go : self.go;
var go = typeof global !== "undefined" ? global.go : self.go;
var Group = go.Group;
var List = go.List;
var GSet = go.Set;
var GMap = go.Map;
var Point = go.Point;
var Size = go.Size;
var Rect = go.Rect;
var Margin = go.Margin;
var Spot = go.Spot;
var Geometry = go.Geometry;
var PathFigure = go.PathFigure;
var PathSegment = go.PathSegment;
var InputEvent = go.InputEvent;
var DiagramEvent = go.DiagramEvent;
var ChangedEvent = go.ChangedEvent;
var Model = go.Model;
var GraphLinksModel = go.GraphLinksModel;
var TreeModel = go.TreeModel;
var Binding = go.Binding;
var ThemeBinding = go.ThemeBinding;
var Transaction = go.Transaction;
var UndoManager = go.UndoManager;
var CommandHandler = go.CommandHandler;
var Tool = go.Tool;
var DraggingTool = go.DraggingTool;
var DraggingInfo = go.DraggingInfo;
var DraggingOptions = go.DraggingOptions;
var LinkingBaseTool = go.LinkingBaseTool;
var LinkingTool = go.LinkingTool;
var RelinkingTool = go.RelinkingTool;
var LinkReshapingTool = go.LinkReshapingTool;
var ResizingTool = go.ResizingTool;
var RotatingTool = go.RotatingTool;
var ClickSelectingTool = go.ClickSelectingTool;
var ActionTool = go.ActionTool;
var ClickCreatingTool = go.ClickCreatingTool;
var HTMLInfo = go.HTMLInfo;
var ContextMenuTool = go.ContextMenuTool;
var DragSelectingTool = go.DragSelectingTool;
var PanningTool = go.PanningTool;
var TextEditingTool = go.TextEditingTool;
var ToolManager = go.ToolManager;
var Animation = go.Animation;
var AnimationManager = go.AnimationManager;
var AnimationTrigger = go.AnimationTrigger;
var Layer = go.Layer;
var Diagram = go.Diagram;
var Palette = go.Palette;
var Overview = go.Overview;
var Brush = go.Brush;
var GraphObject = go.GraphObject;
var Panel = go.Panel;
var RowColumnDefinition = go.RowColumnDefinition;
var Shape = go.Shape;
var TextBlock = go.TextBlock;
var Picture = go.Picture;
var Part = go.Part;
var Adornment = go.Adornment;
var Node = go.Node;
var Link = go.Link;
var Placeholder = go.Placeholder;
var Layout = go.Layout;
var LayoutNetwork = go.LayoutNetwork;
var LayoutVertex = go.LayoutVertex;
var LayoutEdge = go.LayoutEdge;
var GridLayout = go.GridLayout;
var PanelLayout = go.PanelLayout;
var CircularLayout = go.CircularLayout;
var CircularNetwork = go.CircularNetwork;
var CircularVertex = go.CircularVertex;
var CircularEdge = go.CircularEdge;
var ForceDirectedLayout = go.ForceDirectedLayout;
var ForceDirectedNetwork = go.ForceDirectedNetwork;
var ForceDirectedVertex = go.ForceDirectedVertex;
var ForceDirectedEdge = go.ForceDirectedEdge;
var LayeredDigraphLayout = go.LayeredDigraphLayout;
var LayeredDigraphNetwork = go.LayeredDigraphNetwork;
var LayeredDigraphVertex = go.LayeredDigraphVertex;
var LayeredDigraphEdge = go.LayeredDigraphEdge;
var TreeLayout = go.TreeLayout;
var TreeNetwork = go.TreeNetwork;
var TreeVertex = go.TreeVertex;
var TreeEdge = go.TreeEdge;
var Themes = go.Themes;
var ThemeManager = go.ThemeManager;
var Router = go.Router;
var version = go.version;
var AnimationStyle = go.AnimationStyle;
var AutoScale = go.AutoScale;
var Curve = go.Curve;
var CycleMode = go.CycleMode;
var Flip = go.Flip;
var ImageStretch = go.ImageStretch;
var LayoutConditions = go.LayoutConditions;
var LinkAdjusting = go.LinkAdjusting;
var Orientation = go.Orientation;
var PortSpreading = go.PortSpreading;
var Routing = go.Routing;
var ScrollMode = go.ScrollMode;
var CollapsePolicy = go.CollapsePolicy;
var Sizing = go.Sizing;
var TriggerStart = go.TriggerStart;
var Stretch = go.Stretch;
var TextFormat = go.TextFormat;
var TextOverflow = go.TextOverflow;
var ViewboxStretch = go.ViewboxStretch;
var Wrap = go.Wrap;
var BrushType = go.BrushType;
var ColorSpace = go.ColorSpace;
var GeometryStretch = go.GeometryStretch;
var GeometryType = go.GeometryType;
var SegmentType = go.SegmentType;
var BindingMode = go.BindingMode;
var ChangeType = go.ChangeType;
var CircularArrangement = go.CircularArrangement;
var CircularDirection = go.CircularDirection;
var CircularNodeDiameterFormula = go.CircularNodeDiameterFormula;
var CircularSorting = go.CircularSorting;
var GridAlignment = go.GridAlignment;
var GridArrangement = go.GridArrangement;
var GridSorting = go.GridSorting;
var LayeredDigraphAggressive = go.LayeredDigraphAggressive;
var LayeredDigraphAlign = go.LayeredDigraphAlign;
var LayeredDigraphCycleRemove = go.LayeredDigraphCycleRemove;
var LayeredDigraphInit = go.LayeredDigraphInit;
var LayeredDigraphLayering = go.LayeredDigraphLayering;
var LayeredDigraphPack = go.LayeredDigraphPack;
var TreeAlignment = go.TreeAlignment;
var TreeArrangement = go.TreeArrangement;
var TreeCompaction = go.TreeCompaction;
var TreeLayerStyle = go.TreeLayerStyle;
var TreePath = go.TreePath;
var TreeSorting = go.TreeSorting;
var TreeStyle = go.TreeStyle;
var GestureMode = go.GestureMode;
var LinkingDirection = go.LinkingDirection;
var ReshapingBehavior = go.ReshapingBehavior;
var TextEditingAccept = go.TextEditingAccept;
var TextEditingStarting = go.TextEditingStarting;
var TextEditingState = go.TextEditingState;
var WheelMode = go.WheelMode;
export {
  ActionTool,
  Adornment,
  Animation,
  AnimationManager,
  AnimationStyle,
  AnimationTrigger,
  AutoScale,
  Binding,
  BindingMode,
  Brush,
  BrushType,
  ChangeType,
  ChangedEvent,
  CircularArrangement,
  CircularDirection,
  CircularEdge,
  CircularLayout,
  CircularNetwork,
  CircularNodeDiameterFormula,
  CircularSorting,
  CircularVertex,
  ClickCreatingTool,
  ClickSelectingTool,
  CollapsePolicy,
  ColorSpace,
  CommandHandler,
  ContextMenuTool,
  Curve,
  CycleMode,
  Diagram,
  DiagramEvent,
  DragSelectingTool,
  DraggingInfo,
  DraggingOptions,
  DraggingTool,
  Flip,
  ForceDirectedEdge,
  ForceDirectedLayout,
  ForceDirectedNetwork,
  ForceDirectedVertex,
  Geometry,
  GeometryStretch,
  GeometryType,
  GestureMode,
  GraphLinksModel,
  GraphObject,
  GridAlignment,
  GridArrangement,
  GridLayout,
  GridSorting,
  Group,
  HTMLInfo,
  ImageStretch,
  InputEvent,
  Layer,
  LayeredDigraphAggressive,
  LayeredDigraphAlign,
  LayeredDigraphCycleRemove,
  LayeredDigraphEdge,
  LayeredDigraphInit,
  LayeredDigraphLayering,
  LayeredDigraphLayout,
  LayeredDigraphNetwork,
  LayeredDigraphPack,
  LayeredDigraphVertex,
  Layout,
  LayoutConditions,
  LayoutEdge,
  LayoutNetwork,
  LayoutVertex,
  Link,
  LinkAdjusting,
  LinkReshapingTool,
  LinkingBaseTool,
  LinkingDirection,
  LinkingTool,
  List,
  GMap as Map,
  Margin,
  Model,
  Node,
  Orientation,
  Overview,
  Palette,
  Panel,
  PanelLayout,
  PanningTool,
  Part,
  PathFigure,
  PathSegment,
  Picture,
  Placeholder,
  Point,
  PortSpreading,
  Rect,
  RelinkingTool,
  ReshapingBehavior,
  ResizingTool,
  RotatingTool,
  Router,
  Routing,
  RowColumnDefinition,
  ScrollMode,
  SegmentType,
  GSet as Set,
  Shape,
  Size,
  Sizing,
  Spot,
  Stretch,
  TextBlock,
  TextEditingAccept,
  TextEditingStarting,
  TextEditingState,
  TextEditingTool,
  TextFormat,
  TextOverflow,
  ThemeBinding,
  ThemeManager,
  Themes,
  Tool,
  ToolManager,
  Transaction,
  TreeAlignment,
  TreeArrangement,
  TreeCompaction,
  TreeEdge,
  TreeLayerStyle,
  TreeLayout,
  TreeModel,
  TreeNetwork,
  TreePath,
  TreeSorting,
  TreeStyle,
  TreeVertex,
  TriggerStart,
  UndoManager,
  ViewboxStretch,
  WheelMode,
  Wrap,
  go_debug_default as default,
  go,
  version
};
//# sourceMappingURL=gojs.js.map
